{"ocaml":[{"in":"let sqsum xs = \nlet f a x = a + x * x in\nlet base = 0 in\nList.fold_left f base xs","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n","type":"","out":""},{"in":"let _ = sqsum []","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [];;\n","type":"","out":""},{"in":"let _ = sqsum [1;2;3;4]","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sqsum [(-1); (-2); (-3); (-4)]","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [(-1); (-2); (-3); (-4)];;\n","type":"","out":""},{"in":"let pipe fs = \nlet f a x = (fun x' -> x (a x')) in\nlet base = (fun x -> x) in\nList.fold_left f base fs","min":"\nlet pipe fs =\n  let f a x x' = x (a x') in let base x = x in List.fold_left f base fs;;\n","type":"","out":""},{"in":"let _ = pipe [] 3","min":"\nlet pipe fs =\n  let f a x x' = x (a x') in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n","type":"","out":""},{"in":"let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3","min":"\nlet pipe fs =\n  let f a x x' = x (a x') in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n","type":"","out":""},{"in":"let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3","min":"\nlet pipe fs =\n  let f a x x' = x (a x') in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n","type":"","out":""},{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base = h in\nlet l = t in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n","type":"","out":""},{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"---\" []","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"---\" [];;\n","type":"","out":""},{"in":"let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"\" [\"a\"; \"b\"; \"c\"; \"d\"; \"e\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"X\" [\"hello\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"X\" [\"hello\"];;\n","type":"","out":""},{"in":"let stringOfList f l = \"[\"^(sepConcat \"; \" (List.map f l))^\"]\"","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n","type":"","out":""},{"in":"let _ = stringOfList string_of_int [1;2;3;4;5;6]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n\nlet _ = stringOfList string_of_int [1; 2; 3; 4; 5; 6];;\n","type":"","out":""},{"in":"let _ = stringOfList (fun x -> x) [\"foo\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n\nlet _ = stringOfList (fun x  -> x) [\"foo\"];;\n","type":"","out":""},{"in":"let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n\nlet _ =\n  stringOfList (stringOfList string_of_int) [[1; 2; 3]; [4; 5]; [6]; []];;\n","type":"","out":""},{"in":"let rec clone x n =\nif n < 1 then\n[]\nelse\nx::(clone x (n-1))","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n","type":"","out":""},{"in":"let _ = clone 3 5","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet _ = clone 3 5;;\n","type":"","out":""},{"in":"let _ = clone \"foo\" 2","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet _ = clone \"foo\" 2;;\n","type":"","out":""},{"in":"let _ = clone clone (-3)","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet _ = clone clone (-3);;\n","type":"","out":""},{"in":"let padZero l1 l2 =\nlet s1 = List.length l1 in\nlet s2 = List.length l2 in\nif s1 > s2 then\n(l1, (clone 0 (s1 - s2))@l2)\nelse if s2 > s1 then\n((clone 0 (s2 - s1))@l1, l2)\nelse\n(l1, l2)","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 > s2\n  then (l1, ((clone 0 (s1 - s2)) @ l2))\n  else if s2 > s1 then (((clone 0 (s2 - s1)) @ l1), l2) else (l1, l2);;\n","type":"","out":""},{"in":"let _ = padZero [9;9] [1;0;0;2]","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 > s2\n  then (l1, ((clone 0 (s1 - s2)) @ l2))\n  else if s2 > s1 then (((clone 0 (s2 - s1)) @ l1), l2) else (l1, l2);;\n\nlet _ = padZero [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = padZero [1;0;0;2] [9;9]","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 > s2\n  then (l1, ((clone 0 (s1 - s2)) @ l2))\n  else if s2 > s1 then (((clone 0 (s2 - s1)) @ l1), l2) else (l1, l2);;\n\nlet _ = padZero [1; 0; 0; 2] [9; 9];;\n","type":"","out":""},{"in":"let rec removeZero l = match l with\n| 0::t -> removeZero t\n| _ -> l","min":"\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;1;0;0;2]","min":"\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet _ = removeZero [0; 0; 0; 1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = removeZero [9;9]","min":"\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet _ = removeZero [9; 9];;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;0]","min":"\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet _ = removeZero [0; 0; 0; 0];;\n","type":"","out":""},{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =\nlet (ret, res) = a in\nlet (d1, d2) = x in\nlet sum = ret + d1 + d2 in\nlet newVal = sum mod 10 in\nlet newRet = sum / 10 in\n(newRet, newVal::res)\nin\nlet base = (0, []) in\nlet args =\nlet rec tuplize (a, b) = match a, b with\n| h1::t1, h2::t2 ->\n(tuplize (t1, t2))@[(h1, h2)]\n| _ -> [] in tuplize (0::l1, 0::l2)\nin\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 > s2\n  then (l1, ((clone 0 (s1 - s2)) @ l2))\n  else if s2 > s1 then (((clone 0 (s2 - s1)) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (ret,res) = a in\n      let (d1,d2) = x in\n      let sum = (ret + d1) + d2 in\n      let newVal = sum mod 10 in\n      let newRet = sum / 10 in (newRet, (newVal :: res)) in\n    let base = (0, []) in\n    let args =\n      let rec tuplize (a,b) =\n        match (a, b) with\n        | (h1::t1,h2::t2) -> (tuplize (t1, t2)) @ [(h1, h2)]\n        | _ -> [] in\n      tuplize ((0 :: l1), (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9] [1;0;0;2]","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 > s2\n  then (l1, ((clone 0 (s1 - s2)) @ l2))\n  else if s2 > s1 then (((clone 0 (s2 - s1)) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (ret,res) = a in\n      let (d1,d2) = x in\n      let sum = (ret + d1) + d2 in\n      let newVal = sum mod 10 in\n      let newRet = sum / 10 in (newRet, (newVal :: res)) in\n    let base = (0, []) in\n    let args =\n      let rec tuplize (a,b) =\n        match (a, b) with\n        | (h1::t1,h2::t2) -> (tuplize (t1, t2)) @ [(h1, h2)]\n        | _ -> [] in\n      tuplize ((0 :: l1), (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9;9;9] [9;9;9]","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 > s2\n  then (l1, ((clone 0 (s1 - s2)) @ l2))\n  else if s2 > s1 then (((clone 0 (s2 - s1)) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (ret,res) = a in\n      let (d1,d2) = x in\n      let sum = (ret + d1) + d2 in\n      let newVal = sum mod 10 in\n      let newRet = sum / 10 in (newRet, (newVal :: res)) in\n    let base = (0, []) in\n    let args =\n      let rec tuplize (a,b) =\n        match (a, b) with\n        | (h1::t1,h2::t2) -> (tuplize (t1, t2)) @ [(h1, h2)]\n        | _ -> [] in\n      tuplize ((0 :: l1), (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n","type":"","out":""},{"in":"let rec mulByDigit i l =\nif i < 1 then\n[0]\nelse\nbigAdd l (mulByDigit (i-1) l)","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 > s2\n  then (l1, ((clone 0 (s1 - s2)) @ l2))\n  else if s2 > s1 then (((clone 0 (s2 - s1)) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (ret,res) = a in\n      let (d1,d2) = x in\n      let sum = (ret + d1) + d2 in\n      let newVal = sum mod 10 in\n      let newRet = sum / 10 in (newRet, (newVal :: res)) in\n    let base = (0, []) in\n    let args =\n      let rec tuplize (a,b) =\n        match (a, b) with\n        | (h1::t1,h2::t2) -> (tuplize (t1, t2)) @ [(h1, h2)]\n        | _ -> [] in\n      tuplize ((0 :: l1), (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i < 1 then [0] else bigAdd l (mulByDigit (i - 1) l);;\n","type":"","out":""},{"in":"let _ = mulByDigit 0 [8]","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 > s2\n  then (l1, ((clone 0 (s1 - s2)) @ l2))\n  else if s2 > s1 then (((clone 0 (s2 - s1)) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (ret,res) = a in\n      let (d1,d2) = x in\n      let sum = (ret + d1) + d2 in\n      let newVal = sum mod 10 in\n      let newRet = sum / 10 in (newRet, (newVal :: res)) in\n    let base = (0, []) in\n    let args =\n      let rec tuplize (a,b) =\n        match (a, b) with\n        | (h1::t1,h2::t2) -> (tuplize (t1, t2)) @ [(h1, h2)]\n        | _ -> [] in\n      tuplize ((0 :: l1), (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i < 1 then [0] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet _ = mulByDigit 0 [8];;\n","type":"","out":""},{"in":"let _ = mulByDigit 3 [8]","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 > s2\n  then (l1, ((clone 0 (s1 - s2)) @ l2))\n  else if s2 > s1 then (((clone 0 (s2 - s1)) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (ret,res) = a in\n      let (d1,d2) = x in\n      let sum = (ret + d1) + d2 in\n      let newVal = sum mod 10 in\n      let newRet = sum / 10 in (newRet, (newVal :: res)) in\n    let base = (0, []) in\n    let args =\n      let rec tuplize (a,b) =\n        match (a, b) with\n        | (h1::t1,h2::t2) -> (tuplize (t1, t2)) @ [(h1, h2)]\n        | _ -> [] in\n      tuplize ((0 :: l1), (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i < 1 then [0] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet _ = mulByDigit 3 [8];;\n","type":"","out":""},{"in":"let _ = mulByDigit 9 [9;9;9;9]","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 > s2\n  then (l1, ((clone 0 (s1 - s2)) @ l2))\n  else if s2 > s1 then (((clone 0 (s2 - s1)) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (ret,res) = a in\n      let (d1,d2) = x in\n      let sum = (ret + d1) + d2 in\n      let newVal = sum mod 10 in\n      let newRet = sum / 10 in (newRet, (newVal :: res)) in\n    let base = (0, []) in\n    let args =\n      let rec tuplize (a,b) =\n        match (a, b) with\n        | (h1::t1,h2::t2) -> (tuplize (t1, t2)) @ [(h1, h2)]\n        | _ -> [] in\n      tuplize ((0 :: l1), (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i < 1 then [0] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let bigMul l1 l2 = \nlet f a x =\nlet (pow, res) = a in\nlet prod = mulByDigit x l2 in\nlet prod_padded = prod@(clone 0 pow) in\n(pow+1, bigAdd res prod_padded)\nin\nlet base = (0, [0]) in\nlet args = List.rev l1 in\nlet (_, res) = List.fold_left f base args in\nres","min":"\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 > s2\n  then (l1, ((clone 0 (s1 - s2)) @ l2))\n  else if s2 > s1 then (((clone 0 (s2 - s1)) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (ret,res) = a in\n      let (d1,d2) = x in\n      let sum = (ret + d1) + d2 in\n      let newVal = sum mod 10 in\n      let newRet = sum / 10 in (newRet, (newVal :: res)) in\n    let base = (0, []) in\n    let args =\n      let rec tuplize (a,b) =\n        match (a, b) with\n        | (h1::t1,h2::t2) -> (tuplize (t1, t2)) @ [(h1, h2)]\n        | _ -> [] in\n      tuplize ((0 :: l1), (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  if i < 1 then [0] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (pow,res) = a in\n    let prod = mulByDigit x l2 in\n    let prod_padded = prod @ (clone 0 pow) in\n    ((pow + 1), (bigAdd res prod_padded)) in\n  let base = (0, [0]) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n","type":"","out":""},{"in":"let _ = bigMul [2] [2]","min":"\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 > s2\n  then (l1, ((clone 0 (s1 - s2)) @ l2))\n  else if s2 > s1 then (((clone 0 (s2 - s1)) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (ret,res) = a in\n      let (d1,d2) = x in\n      let sum = (ret + d1) + d2 in\n      let newVal = sum mod 10 in\n      let newRet = sum / 10 in (newRet, (newVal :: res)) in\n    let base = (0, []) in\n    let args =\n      let rec tuplize (a,b) =\n        match (a, b) with\n        | (h1::t1,h2::t2) -> (tuplize (t1, t2)) @ [(h1, h2)]\n        | _ -> [] in\n      tuplize ((0 :: l1), (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  if i < 1 then [0] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (pow,res) = a in\n    let prod = mulByDigit x l2 in\n    let prod_padded = prod @ (clone 0 pow) in\n    ((pow + 1), (bigAdd res prod_padded)) in\n  let base = (0, [0]) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [2] [2];;\n","type":"","out":""},{"in":"let _ = bigMul [2] [9]","min":"\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 > s2\n  then (l1, ((clone 0 (s1 - s2)) @ l2))\n  else if s2 > s1 then (((clone 0 (s2 - s1)) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (ret,res) = a in\n      let (d1,d2) = x in\n      let sum = (ret + d1) + d2 in\n      let newVal = sum mod 10 in\n      let newRet = sum / 10 in (newRet, (newVal :: res)) in\n    let base = (0, []) in\n    let args =\n      let rec tuplize (a,b) =\n        match (a, b) with\n        | (h1::t1,h2::t2) -> (tuplize (t1, t2)) @ [(h1, h2)]\n        | _ -> [] in\n      tuplize ((0 :: l1), (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  if i < 1 then [0] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (pow,res) = a in\n    let prod = mulByDigit x l2 in\n    let prod_padded = prod @ (clone 0 pow) in\n    ((pow + 1), (bigAdd res prod_padded)) in\n  let base = (0, [0]) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [2] [9];;\n","type":"","out":""},{"in":"let _ = bigMul [9] [9]","min":"\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 > s2\n  then (l1, ((clone 0 (s1 - s2)) @ l2))\n  else if s2 > s1 then (((clone 0 (s2 - s1)) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (ret,res) = a in\n      let (d1,d2) = x in\n      let sum = (ret + d1) + d2 in\n      let newVal = sum mod 10 in\n      let newRet = sum / 10 in (newRet, (newVal :: res)) in\n    let base = (0, []) in\n    let args =\n      let rec tuplize (a,b) =\n        match (a, b) with\n        | (h1::t1,h2::t2) -> (tuplize (t1, t2)) @ [(h1, h2)]\n        | _ -> [] in\n      tuplize ((0 :: l1), (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  if i < 1 then [0] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (pow,res) = a in\n    let prod = mulByDigit x l2 in\n    let prod_padded = prod @ (clone 0 pow) in\n    ((pow + 1), (bigAdd res prod_padded)) in\n  let base = (0, [0]) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9] [9];;\n","type":"","out":""},{"in":"let _ = bigMul [8;1] [2]","min":"\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 > s2\n  then (l1, ((clone 0 (s1 - s2)) @ l2))\n  else if s2 > s1 then (((clone 0 (s2 - s1)) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (ret,res) = a in\n      let (d1,d2) = x in\n      let sum = (ret + d1) + d2 in\n      let newVal = sum mod 10 in\n      let newRet = sum / 10 in (newRet, (newVal :: res)) in\n    let base = (0, []) in\n    let args =\n      let rec tuplize (a,b) =\n        match (a, b) with\n        | (h1::t1,h2::t2) -> (tuplize (t1, t2)) @ [(h1, h2)]\n        | _ -> [] in\n      tuplize ((0 :: l1), (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  if i < 1 then [0] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (pow,res) = a in\n    let prod = mulByDigit x l2 in\n    let prod_padded = prod @ (clone 0 pow) in\n    ((pow + 1), (bigAdd res prod_padded)) in\n  let base = (0, [0]) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [8; 1] [2];;\n","type":"","out":""},{"in":"let _ = bigMul [2] [8;1]","min":"\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 > s2\n  then (l1, ((clone 0 (s1 - s2)) @ l2))\n  else if s2 > s1 then (((clone 0 (s2 - s1)) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (ret,res) = a in\n      let (d1,d2) = x in\n      let sum = (ret + d1) + d2 in\n      let newVal = sum mod 10 in\n      let newRet = sum / 10 in (newRet, (newVal :: res)) in\n    let base = (0, []) in\n    let args =\n      let rec tuplize (a,b) =\n        match (a, b) with\n        | (h1::t1,h2::t2) -> (tuplize (t1, t2)) @ [(h1, h2)]\n        | _ -> [] in\n      tuplize ((0 :: l1), (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  if i < 1 then [0] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (pow,res) = a in\n    let prod = mulByDigit x l2 in\n    let prod_padded = prod @ (clone 0 pow) in\n    ((pow + 1), (bigAdd res prod_padded)) in\n  let base = (0, [0]) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [2] [8; 1];;\n","type":"","out":""},{"in":"let _ = bigMul [1;2;3;4;5] [5;4;3;2;1]","min":"\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 > s2\n  then (l1, ((clone 0 (s1 - s2)) @ l2))\n  else if s2 > s1 then (((clone 0 (s2 - s1)) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (ret,res) = a in\n      let (d1,d2) = x in\n      let sum = (ret + d1) + d2 in\n      let newVal = sum mod 10 in\n      let newRet = sum / 10 in (newRet, (newVal :: res)) in\n    let base = (0, []) in\n    let args =\n      let rec tuplize (a,b) =\n        match (a, b) with\n        | (h1::t1,h2::t2) -> (tuplize (t1, t2)) @ [(h1, h2)]\n        | _ -> [] in\n      tuplize ((0 :: l1), (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  if i < 1 then [0] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (pow,res) = a in\n    let prod = mulByDigit x l2 in\n    let prod_padded = prod @ (clone 0 pow) in\n    ((pow + 1), (bigAdd res prod_padded)) in\n  let base = (0, [0]) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1; 2; 3; 4; 5] [5; 4; 3; 2; 1];;\n","type":"","out":""},{"in":"let _ = bigMul [9;9;9;9] [9;9;9;9]","min":"\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 > s2\n  then (l1, ((clone 0 (s1 - s2)) @ l2))\n  else if s2 > s1 then (((clone 0 (s2 - s1)) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (ret,res) = a in\n      let (d1,d2) = x in\n      let sum = (ret + d1) + d2 in\n      let newVal = sum mod 10 in\n      let newRet = sum / 10 in (newRet, (newVal :: res)) in\n    let base = (0, []) in\n    let args =\n      let rec tuplize (a,b) =\n        match (a, b) with\n        | (h1::t1,h2::t2) -> (tuplize (t1, t2)) @ [(h1, h2)]\n        | _ -> [] in\n      tuplize ((0 :: l1), (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  if i < 1 then [0] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (pow,res) = a in\n    let prod = mulByDigit x l2 in\n    let prod_padded = prod @ (clone 0 pow) in\n    ((pow + 1), (bigAdd res prod_padded)) in\n  let base = (0, [0]) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]","min":"\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 > s2\n  then (l1, ((clone 0 (s1 - s2)) @ l2))\n  else if s2 > s1 then (((clone 0 (s2 - s1)) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (ret,res) = a in\n      let (d1,d2) = x in\n      let sum = (ret + d1) + d2 in\n      let newVal = sum mod 10 in\n      let newRet = sum / 10 in (newRet, (newVal :: res)) in\n    let base = (0, []) in\n    let args =\n      let rec tuplize (a,b) =\n        match (a, b) with\n        | (h1::t1,h2::t2) -> (tuplize (t1, t2)) @ [(h1, h2)]\n        | _ -> [] in\n      tuplize ((0 :: l1), (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  if i < 1 then [0] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (pow,res) = a in\n    let prod = mulByDigit x l2 in\n    let prod_padded = prod @ (clone 0 pow) in\n    ((pow + 1), (bigAdd res prod_padded)) in\n  let base = (0, [0]) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9; 9] [9; 9; 9; 9; 9];;\n","type":"","out":""},{"in":"let key = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130 = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ ((Printexc.to_string e) ^ \"\\n\"));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n","type":"","out":""},{"in":"let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","min":"\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n","type":"","out":""},{"in":"let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n\nlet drop_paren s =\n  implode\n    (List.filter (fun c  -> not (List.mem c ['('; ' '; ')'])) (explode s));;\n","type":"","out":""},{"in":"let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","min":"\nlet eq_real p (r1,r2) = ((r1 -. r2) < p) || ((r2 -. r1) < p);;\n","type":"","out":""},{"in":"let wrap_curried_2 f (a,b) = f a b","min":"\nlet wrap_curried_2 f (a,b) = f a b;;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":7566},"type":"eval"},"cursor":0,"time":1.398841630965373e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = (fun x' -> x (a x')) in\n  let base = (fun x -> x) in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a^sep^x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\"^(sepConcat \"; \" (List.map f l))^\"]\"\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n < 1 then\n    []\n  else\n    x::(clone x (n-1))\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n    if s1 > s2 then\n      (l1, (clone 0 (s1 - s2))@l2)\n    else if s2 > s1 then\n      ((clone 0 (s2 - s1))@l1, l2)\n    else\n      (l1, l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x =\n      let (ret, res) = a in\n      let (d1, d2) = x in\n      let sum = ret + d1 + d2 in\n      let newVal = sum mod 10 in\n      let newRet = sum / 10 in\n        (newRet, newVal::res)\n    in\n    let base = (0, []) in\n    let args =\n      let rec tuplize (a, b) = match a, b with\n        | h1::t1, h2::t2 ->\n            (tuplize (t1, t2))@[(h1, h2)]\n        | _ -> [] in tuplize (0::l1, 0::l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\n\n\nlet rec mulByDigit i l =\n  if i < 1 then\n    [0]\n  else\n    bigAdd l (mulByDigit (i-1) l)\n\nlet _ = mulByDigit 0 [8]\nlet _ = mulByDigit 3 [8]\nlet _ = mulByDigit 9 [9;9;9;9]\n\nlet bigMul l1 l2 = \n  let f a x =\n    let (pow, res) = a in\n    let prod = mulByDigit x l2 in\n    let prod_padded = prod@(clone 0 pow) in\n      (pow+1, bigAdd res prod_padded)\n  in\n  let base = (0, [0]) in\n  let args = List.rev l1 in\n  let (_, res) = List.fold_left f base args in\n    res\n\nlet _ = bigMul [2] [2]\nlet _ = bigMul [2] [9]\nlet _ = bigMul [9] [9]\nlet _ = bigMul [8;1] [2]\nlet _ = bigMul [2] [8;1]\nlet _ = bigMul [1;2;3;4;5] [5;4;3;2;1]\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3","min":"\nlet pipe fs =\n  let f a x x' = x (a x') in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n","type":"","out":""},{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base = h in\nlet l = t in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n","type":"","out":""},{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"---\" []","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"---\" [];;\n","type":"","out":""},{"in":"let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"\" [\"a\"; \"b\"; \"c\"; \"d\"; \"e\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"X\" [\"hello\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"X\" [\"hello\"];;\n","type":"","out":""},{"in":"let stringOfList f l = \"[\"^(sepConcat \"; \" (List.map f l))^\"]\"","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n","type":"","out":""},{"in":"let _ = stringOfList string_of_int [1;2;3;4;5;6]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n\nlet _ = stringOfList string_of_int [1; 2; 3; 4; 5; 6];;\n","type":"","out":""},{"in":"let _ = stringOfList (fun x -> x) [\"foo\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n\nlet _ = stringOfList (fun x  -> x) [\"foo\"];;\n","type":"","out":""},{"in":"let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n\nlet _ =\n  stringOfList (stringOfList string_of_int) [[1; 2; 3]; [4; 5]; [6]; []];;\n","type":"","out":""},{"in":"let rec clone x n =\nif n < 1 then\n[]\nelse\nx::(clone x (n-1))","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n","type":"","out":""},{"in":"let _ = clone 3 5","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet _ = clone 3 5;;\n","type":"","out":""},{"in":"let _ = clone \"foo\" 2","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet _ = clone \"foo\" 2;;\n","type":"","out":""},{"in":"let _ = clone clone (-3)","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet _ = clone clone (-3);;\n","type":"","out":""},{"in":"let padZero l1 l2 =\nlet s1 = List.length l1 in\nlet s2 = List.length l2 in\nif s1 > s2 then\n(l1, (clone 0 (s1 - s2))@l2)\nelse if s2 > s1 then\n((clone 0 (s2 - s1))@l1, l2)\nelse\n(l1, l2)","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 > s2\n  then (l1, ((clone 0 (s1 - s2)) @ l2))\n  else if s2 > s1 then (((clone 0 (s2 - s1)) @ l1), l2) else (l1, l2);;\n","type":"","out":""},{"in":"let _ = padZero [9;9] [1;0;0;2]","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 > s2\n  then (l1, ((clone 0 (s1 - s2)) @ l2))\n  else if s2 > s1 then (((clone 0 (s2 - s1)) @ l1), l2) else (l1, l2);;\n\nlet _ = padZero [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = padZero [1;0;0;2] [9;9]","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 > s2\n  then (l1, ((clone 0 (s1 - s2)) @ l2))\n  else if s2 > s1 then (((clone 0 (s2 - s1)) @ l1), l2) else (l1, l2);;\n\nlet _ = padZero [1; 0; 0; 2] [9; 9];;\n","type":"","out":""},{"in":"let rec removeZero l = match l with\n| 0::t -> removeZero t\n| _ -> l","min":"\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;1;0;0;2]","min":"\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet _ = removeZero [0; 0; 0; 1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = removeZero [9;9]","min":"\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet _ = removeZero [9; 9];;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;0]","min":"\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet _ = removeZero [0; 0; 0; 0];;\n","type":"","out":""},{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =\nlet (ret, res) = a in\nlet (d1, d2) = x in\nlet sum = ret + d1 + d2 in\nlet newVal = sum mod 10 in\nlet newRet = sum / 10 in\n(newRet, newVal::res)\nin\nlet base = (0, []) in\nlet args =\nlet rec tuplize (a, b) = match a, b with\n| h1::t1, h2::t2 ->\n(tuplize (t1, t2))@[(h1, h2)]\n| _ -> [] in tuplize (0::l1, 0::l2)\nin\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 > s2\n  then (l1, ((clone 0 (s1 - s2)) @ l2))\n  else if s2 > s1 then (((clone 0 (s2 - s1)) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (ret,res) = a in\n      let (d1,d2) = x in\n      let sum = (ret + d1) + d2 in\n      let newVal = sum mod 10 in\n      let newRet = sum / 10 in (newRet, (newVal :: res)) in\n    let base = (0, []) in\n    let args =\n      let rec tuplize (a,b) =\n        match (a, b) with\n        | (h1::t1,h2::t2) -> (tuplize (t1, t2)) @ [(h1, h2)]\n        | _ -> [] in\n      tuplize ((0 :: l1), (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9] [1;0;0;2]","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 > s2\n  then (l1, ((clone 0 (s1 - s2)) @ l2))\n  else if s2 > s1 then (((clone 0 (s2 - s1)) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (ret,res) = a in\n      let (d1,d2) = x in\n      let sum = (ret + d1) + d2 in\n      let newVal = sum mod 10 in\n      let newRet = sum / 10 in (newRet, (newVal :: res)) in\n    let base = (0, []) in\n    let args =\n      let rec tuplize (a,b) =\n        match (a, b) with\n        | (h1::t1,h2::t2) -> (tuplize (t1, t2)) @ [(h1, h2)]\n        | _ -> [] in\n      tuplize ((0 :: l1), (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9;9;9] [9;9;9]","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 > s2\n  then (l1, ((clone 0 (s1 - s2)) @ l2))\n  else if s2 > s1 then (((clone 0 (s2 - s1)) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (ret,res) = a in\n      let (d1,d2) = x in\n      let sum = (ret + d1) + d2 in\n      let newVal = sum mod 10 in\n      let newRet = sum / 10 in (newRet, (newVal :: res)) in\n    let base = (0, []) in\n    let args =\n      let rec tuplize (a,b) =\n        match (a, b) with\n        | (h1::t1,h2::t2) -> (tuplize (t1, t2)) @ [(h1, h2)]\n        | _ -> [] in\n      tuplize ((0 :: l1), (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n","type":"","out":""},{"in":"let rec mulByDigit i l =\nif i < 1 then\n[0]\nelse\nbigAdd l (mulByDigit (i-1) l)","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 > s2\n  then (l1, ((clone 0 (s1 - s2)) @ l2))\n  else if s2 > s1 then (((clone 0 (s2 - s1)) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (ret,res) = a in\n      let (d1,d2) = x in\n      let sum = (ret + d1) + d2 in\n      let newVal = sum mod 10 in\n      let newRet = sum / 10 in (newRet, (newVal :: res)) in\n    let base = (0, []) in\n    let args =\n      let rec tuplize (a,b) =\n        match (a, b) with\n        | (h1::t1,h2::t2) -> (tuplize (t1, t2)) @ [(h1, h2)]\n        | _ -> [] in\n      tuplize ((0 :: l1), (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i < 1 then [0] else bigAdd l (mulByDigit (i - 1) l);;\n","type":"","out":""},{"in":"let _ = mulByDigit 0 [8]","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 > s2\n  then (l1, ((clone 0 (s1 - s2)) @ l2))\n  else if s2 > s1 then (((clone 0 (s2 - s1)) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (ret,res) = a in\n      let (d1,d2) = x in\n      let sum = (ret + d1) + d2 in\n      let newVal = sum mod 10 in\n      let newRet = sum / 10 in (newRet, (newVal :: res)) in\n    let base = (0, []) in\n    let args =\n      let rec tuplize (a,b) =\n        match (a, b) with\n        | (h1::t1,h2::t2) -> (tuplize (t1, t2)) @ [(h1, h2)]\n        | _ -> [] in\n      tuplize ((0 :: l1), (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i < 1 then [0] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet _ = mulByDigit 0 [8];;\n","type":"","out":""},{"in":"let _ = mulByDigit 3 [8]","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 > s2\n  then (l1, ((clone 0 (s1 - s2)) @ l2))\n  else if s2 > s1 then (((clone 0 (s2 - s1)) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (ret,res) = a in\n      let (d1,d2) = x in\n      let sum = (ret + d1) + d2 in\n      let newVal = sum mod 10 in\n      let newRet = sum / 10 in (newRet, (newVal :: res)) in\n    let base = (0, []) in\n    let args =\n      let rec tuplize (a,b) =\n        match (a, b) with\n        | (h1::t1,h2::t2) -> (tuplize (t1, t2)) @ [(h1, h2)]\n        | _ -> [] in\n      tuplize ((0 :: l1), (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i < 1 then [0] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet _ = mulByDigit 3 [8];;\n","type":"","out":""},{"in":"let _ = mulByDigit 9 [9;9;9;9]","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 > s2\n  then (l1, ((clone 0 (s1 - s2)) @ l2))\n  else if s2 > s1 then (((clone 0 (s2 - s1)) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (ret,res) = a in\n      let (d1,d2) = x in\n      let sum = (ret + d1) + d2 in\n      let newVal = sum mod 10 in\n      let newRet = sum / 10 in (newRet, (newVal :: res)) in\n    let base = (0, []) in\n    let args =\n      let rec tuplize (a,b) =\n        match (a, b) with\n        | (h1::t1,h2::t2) -> (tuplize (t1, t2)) @ [(h1, h2)]\n        | _ -> [] in\n      tuplize ((0 :: l1), (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i < 1 then [0] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let bigMul l1 l2 = \nlet f a x =\nlet (pow, res) = a in\nlet prod = mulByDigit x l2 in\nlet prod_padded = prod@(clone 0 pow) in\n(pow+1, bigAdd res prod_padded)\nin\nlet base = (0, [0]) in\nlet args = List.rev l1 in\nlet (_, res) = List.fold_left f base args in\nres","min":"\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 > s2\n  then (l1, ((clone 0 (s1 - s2)) @ l2))\n  else if s2 > s1 then (((clone 0 (s2 - s1)) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (ret,res) = a in\n      let (d1,d2) = x in\n      let sum = (ret + d1) + d2 in\n      let newVal = sum mod 10 in\n      let newRet = sum / 10 in (newRet, (newVal :: res)) in\n    let base = (0, []) in\n    let args =\n      let rec tuplize (a,b) =\n        match (a, b) with\n        | (h1::t1,h2::t2) -> (tuplize (t1, t2)) @ [(h1, h2)]\n        | _ -> [] in\n      tuplize ((0 :: l1), (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  if i < 1 then [0] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (pow,res) = a in\n    let prod = mulByDigit x l2 in\n    let prod_padded = prod @ (clone 0 pow) in\n    ((pow + 1), (bigAdd res prod_padded)) in\n  let base = (0, [0]) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n","type":"","out":""},{"in":"let _ = bigMul [2] [2]","min":"\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 > s2\n  then (l1, ((clone 0 (s1 - s2)) @ l2))\n  else if s2 > s1 then (((clone 0 (s2 - s1)) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (ret,res) = a in\n      let (d1,d2) = x in\n      let sum = (ret + d1) + d2 in\n      let newVal = sum mod 10 in\n      let newRet = sum / 10 in (newRet, (newVal :: res)) in\n    let base = (0, []) in\n    let args =\n      let rec tuplize (a,b) =\n        match (a, b) with\n        | (h1::t1,h2::t2) -> (tuplize (t1, t2)) @ [(h1, h2)]\n        | _ -> [] in\n      tuplize ((0 :: l1), (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  if i < 1 then [0] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (pow,res) = a in\n    let prod = mulByDigit x l2 in\n    let prod_padded = prod @ (clone 0 pow) in\n    ((pow + 1), (bigAdd res prod_padded)) in\n  let base = (0, [0]) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [2] [2];;\n","type":"","out":""},{"in":"let _ = bigMul [2] [9]","min":"\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 > s2\n  then (l1, ((clone 0 (s1 - s2)) @ l2))\n  else if s2 > s1 then (((clone 0 (s2 - s1)) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (ret,res) = a in\n      let (d1,d2) = x in\n      let sum = (ret + d1) + d2 in\n      let newVal = sum mod 10 in\n      let newRet = sum / 10 in (newRet, (newVal :: res)) in\n    let base = (0, []) in\n    let args =\n      let rec tuplize (a,b) =\n        match (a, b) with\n        | (h1::t1,h2::t2) -> (tuplize (t1, t2)) @ [(h1, h2)]\n        | _ -> [] in\n      tuplize ((0 :: l1), (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  if i < 1 then [0] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (pow,res) = a in\n    let prod = mulByDigit x l2 in\n    let prod_padded = prod @ (clone 0 pow) in\n    ((pow + 1), (bigAdd res prod_padded)) in\n  let base = (0, [0]) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [2] [9];;\n","type":"","out":""},{"in":"let _ = bigMul [9] [9]","min":"\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 > s2\n  then (l1, ((clone 0 (s1 - s2)) @ l2))\n  else if s2 > s1 then (((clone 0 (s2 - s1)) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (ret,res) = a in\n      let (d1,d2) = x in\n      let sum = (ret + d1) + d2 in\n      let newVal = sum mod 10 in\n      let newRet = sum / 10 in (newRet, (newVal :: res)) in\n    let base = (0, []) in\n    let args =\n      let rec tuplize (a,b) =\n        match (a, b) with\n        | (h1::t1,h2::t2) -> (tuplize (t1, t2)) @ [(h1, h2)]\n        | _ -> [] in\n      tuplize ((0 :: l1), (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  if i < 1 then [0] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (pow,res) = a in\n    let prod = mulByDigit x l2 in\n    let prod_padded = prod @ (clone 0 pow) in\n    ((pow + 1), (bigAdd res prod_padded)) in\n  let base = (0, [0]) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9] [9];;\n","type":"","out":""},{"in":"let _ = bigMul [8;1] [2]","min":"\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 > s2\n  then (l1, ((clone 0 (s1 - s2)) @ l2))\n  else if s2 > s1 then (((clone 0 (s2 - s1)) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (ret,res) = a in\n      let (d1,d2) = x in\n      let sum = (ret + d1) + d2 in\n      let newVal = sum mod 10 in\n      let newRet = sum / 10 in (newRet, (newVal :: res)) in\n    let base = (0, []) in\n    let args =\n      let rec tuplize (a,b) =\n        match (a, b) with\n        | (h1::t1,h2::t2) -> (tuplize (t1, t2)) @ [(h1, h2)]\n        | _ -> [] in\n      tuplize ((0 :: l1), (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  if i < 1 then [0] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (pow,res) = a in\n    let prod = mulByDigit x l2 in\n    let prod_padded = prod @ (clone 0 pow) in\n    ((pow + 1), (bigAdd res prod_padded)) in\n  let base = (0, [0]) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [8; 1] [2];;\n","type":"","out":""},{"in":"let _ = bigMul [2] [8;1]","min":"\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 > s2\n  then (l1, ((clone 0 (s1 - s2)) @ l2))\n  else if s2 > s1 then (((clone 0 (s2 - s1)) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (ret,res) = a in\n      let (d1,d2) = x in\n      let sum = (ret + d1) + d2 in\n      let newVal = sum mod 10 in\n      let newRet = sum / 10 in (newRet, (newVal :: res)) in\n    let base = (0, []) in\n    let args =\n      let rec tuplize (a,b) =\n        match (a, b) with\n        | (h1::t1,h2::t2) -> (tuplize (t1, t2)) @ [(h1, h2)]\n        | _ -> [] in\n      tuplize ((0 :: l1), (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  if i < 1 then [0] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (pow,res) = a in\n    let prod = mulByDigit x l2 in\n    let prod_padded = prod @ (clone 0 pow) in\n    ((pow + 1), (bigAdd res prod_padded)) in\n  let base = (0, [0]) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [2] [8; 1];;\n","type":"","out":""},{"in":"let _ = bigMul [1;2;3;4;5] [5;4;3;2;1]","min":"\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 > s2\n  then (l1, ((clone 0 (s1 - s2)) @ l2))\n  else if s2 > s1 then (((clone 0 (s2 - s1)) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (ret,res) = a in\n      let (d1,d2) = x in\n      let sum = (ret + d1) + d2 in\n      let newVal = sum mod 10 in\n      let newRet = sum / 10 in (newRet, (newVal :: res)) in\n    let base = (0, []) in\n    let args =\n      let rec tuplize (a,b) =\n        match (a, b) with\n        | (h1::t1,h2::t2) -> (tuplize (t1, t2)) @ [(h1, h2)]\n        | _ -> [] in\n      tuplize ((0 :: l1), (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  if i < 1 then [0] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (pow,res) = a in\n    let prod = mulByDigit x l2 in\n    let prod_padded = prod @ (clone 0 pow) in\n    ((pow + 1), (bigAdd res prod_padded)) in\n  let base = (0, [0]) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1; 2; 3; 4; 5] [5; 4; 3; 2; 1];;\n","type":"","out":""},{"in":"let _ = bigMul [9;9;9;9] [9;9;9;9]","min":"\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 > s2\n  then (l1, ((clone 0 (s1 - s2)) @ l2))\n  else if s2 > s1 then (((clone 0 (s2 - s1)) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (ret,res) = a in\n      let (d1,d2) = x in\n      let sum = (ret + d1) + d2 in\n      let newVal = sum mod 10 in\n      let newRet = sum / 10 in (newRet, (newVal :: res)) in\n    let base = (0, []) in\n    let args =\n      let rec tuplize (a,b) =\n        match (a, b) with\n        | (h1::t1,h2::t2) -> (tuplize (t1, t2)) @ [(h1, h2)]\n        | _ -> [] in\n      tuplize ((0 :: l1), (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  if i < 1 then [0] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (pow,res) = a in\n    let prod = mulByDigit x l2 in\n    let prod_padded = prod @ (clone 0 pow) in\n    ((pow + 1), (bigAdd res prod_padded)) in\n  let base = (0, [0]) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]","min":"\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 > s2\n  then (l1, ((clone 0 (s1 - s2)) @ l2))\n  else if s2 > s1 then (((clone 0 (s2 - s1)) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (ret,res) = a in\n      let (d1,d2) = x in\n      let sum = (ret + d1) + d2 in\n      let newVal = sum mod 10 in\n      let newRet = sum / 10 in (newRet, (newVal :: res)) in\n    let base = (0, []) in\n    let args =\n      let rec tuplize (a,b) =\n        match (a, b) with\n        | (h1::t1,h2::t2) -> (tuplize (t1, t2)) @ [(h1, h2)]\n        | _ -> [] in\n      tuplize ((0 :: l1), (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  if i < 1 then [0] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (pow,res) = a in\n    let prod = mulByDigit x l2 in\n    let prod_padded = prod @ (clone 0 pow) in\n    ((pow + 1), (bigAdd res prod_padded)) in\n  let base = (0, [0]) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9; 9] [9; 9; 9; 9; 9];;\n","type":"","out":""},{"in":"let key = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130 = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ ((Printexc.to_string e) ^ \"\\n\"));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n","type":"","out":""},{"in":"let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","min":"\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n","type":"","out":""},{"in":"let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n\nlet drop_paren s =\n  implode\n    (List.filter (fun c  -> not (List.mem c ['('; ' '; ')'])) (explode s));;\n","type":"","out":""},{"in":"let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","min":"\nlet eq_real p (r1,r2) = ((r1 -. r2) < p) || ((r2 -. r1) < p);;\n","type":"","out":""},{"in":"let wrap_curried_2 f (a,b) = f a b","min":"\nlet wrap_curried_2 f (a,b) = f a b;;\n","type":"","out":""}],"event":{"region":{"start":1054,"stop":7566},"type":"eval"},"cursor":1104,"time":1.398841692549532e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = (fun x' -> x (a x')) in\n  let base = (fun x -> x) in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a^sep^x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\"^(sepConcat \"; \" (List.map f l))^\"]\"\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n < 1 then\n    []\n  else\n    x::(clone x (n-1))\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n    if s1 > s2 then\n      (l1, (clone 0 (s1 - s2))@l2)\n    else if s2 > s1 then\n      ((clone 0 (s2 - s1))@l1, l2)\n    else\n      (l1, l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x =\n      let (ret, res) = a in\n      let (d1, d2) = x in\n      let sum = ret + d1 + d2 in\n      let newVal = sum mod 10 in\n      let newRet = sum / 10 in\n        (newRet, newVal::res)\n    in\n    let base = (0, []) in\n    let args =\n      let rec tuplize (a, b) = match a, b with\n        | h1::t1, h2::t2 ->\n            (tuplize (t1, t2))@[(h1, h2)]\n        | _ -> [] in tuplize (0::l1, 0::l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\n\n\nlet rec mulByDigit i l =\n  if i < 1 then\n    [0]\n  else\n    bigAdd l (mulByDigit (i-1) l)\n\nlet _ = mulByDigit 0 [8]\nlet _ = mulByDigit 3 [8]\nlet _ = mulByDigit 9 [9;9;9;9]\n\nlet bigMul l1 l2 = \n  let f a x =\n    let (pow, res) = a in\n    let prod = mulByDigit x l2 in\n    let prod_padded = prod@(clone 0 pow) in\n      (pow+1, bigAdd res prod_padded)\n  in\n  let base = (0, [0]) in\n  let args = List.rev l1 in\n  let (_, res) = List.fold_left f base args in\n    res\n\nlet _ = bigMul [2] [2]\nlet _ = bigMul [2] [9]\nlet _ = bigMul [9] [9]\nlet _ = bigMul [8;1] [2]\nlet _ = bigMul [2] [8;1]\nlet _ = bigMul [1;2;3;4;5] [5;4;3;2;1]\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let sqsum xs = \nlet f a x = a + x * x in\nlet base = 0 in\nList.fold_left f base xs","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n","type":"","out":""},{"in":"let _ = sqsum []","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [];;\n","type":"","out":""},{"in":"let _ = sqsum [1;2;3;4]","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sqsum [(-1); (-2); (-3); (-4)]","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [(-1); (-2); (-3); (-4)];;\n","type":"","out":""},{"in":"let pipe fs = \nlet f a x = (fun x' -> x (a x')) in\nlet base = (fun x -> x) in\nList.fold_left f base fs","min":"\nlet pipe fs =\n  let f a x x' = x (a x') in let base x = x in List.fold_left f base fs;;\n","type":"","out":""},{"in":"let _ = pipe [] 3","min":"\nlet pipe fs =\n  let f a x x' = x (a x') in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n","type":"","out":""},{"in":"let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3","min":"\nlet pipe fs =\n  let f a x x' = x (a x') in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n","type":"","out":""},{"in":"let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3","min":"\nlet pipe fs =\n  let f a x x' = x (a x') in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n","type":"","out":""},{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base = h in\nlet l = t in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n","type":"","out":""},{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"---\" []","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"---\" [];;\n","type":"","out":""},{"in":"let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"\" [\"a\"; \"b\"; \"c\"; \"d\"; \"e\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"X\" [\"hello\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"X\" [\"hello\"];;\n","type":"","out":""},{"in":"let stringOfList f l = \"[\"^(sepConcat \"; \" (List.map f l))^\"]\"","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n","type":"","out":""},{"in":"let _ = stringOfList string_of_int [1;2;3;4;5;6]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n\nlet _ = stringOfList string_of_int [1; 2; 3; 4; 5; 6];;\n","type":"","out":""},{"in":"let _ = stringOfList (fun x -> x) [\"foo\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n\nlet _ = stringOfList (fun x  -> x) [\"foo\"];;\n","type":"","out":""},{"in":"let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n\nlet _ =\n  stringOfList (stringOfList string_of_int) [[1; 2; 3]; [4; 5]; [6]; []];;\n","type":"","out":""},{"in":"let rec clone x n =\nif n < 1 then\n[]\nelse\nx::(clone x (n-1))","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n","type":"","out":""},{"in":"let _ = clone 3 5","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet _ = clone 3 5;;\n","type":"","out":""},{"in":"let _ = clone \"foo\" 2","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet _ = clone \"foo\" 2;;\n","type":"","out":""},{"in":"let _ = clone clone (-3)","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet _ = clone clone (-3);;\n","type":"","out":""},{"in":"let padZero l1 l2 =\nlet s1 = List.length l1 in\nlet s2 = List.length l2 in\nif s1 > s2 then\n(l1, (clone 0 (s1 - s2))@l2)\nelse if s2 > s1 then\n((clone 0 (s2 - s1))@l1, l2)\nelse\n(l1, l2)","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 > s2\n  then (l1, ((clone 0 (s1 - s2)) @ l2))\n  else if s2 > s1 then (((clone 0 (s2 - s1)) @ l1), l2) else (l1, l2);;\n","type":"","out":""},{"in":"let _ = padZero [9;9] [1;0;0;2]","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 > s2\n  then (l1, ((clone 0 (s1 - s2)) @ l2))\n  else if s2 > s1 then (((clone 0 (s2 - s1)) @ l1), l2) else (l1, l2);;\n\nlet _ = padZero [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = padZero [1;0;0;2] [9;9]","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 > s2\n  then (l1, ((clone 0 (s1 - s2)) @ l2))\n  else if s2 > s1 then (((clone 0 (s2 - s1)) @ l1), l2) else (l1, l2);;\n\nlet _ = padZero [1; 0; 0; 2] [9; 9];;\n","type":"","out":""},{"in":"let rec removeZero l = match l with\n| 0::t -> removeZero t\n| _ -> l","min":"\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;1;0;0;2]","min":"\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet _ = removeZero [0; 0; 0; 1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = removeZero [9;9]","min":"\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet _ = removeZero [9; 9];;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;0]","min":"\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet _ = removeZero [0; 0; 0; 0];;\n","type":"","out":""},{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =\nlet (ret, res) = a in\nlet (d1, d2) = x in\nlet sum = ret + d1 + d2 in\nlet newVal = sum mod 10 in\nlet newRet = sum / 10 in\n(newRet, newVal::res)\nin\nlet base = (0, []) in\nlet args =\nlet rec tuplize (a, b) = match a, b with\n| h1::t1, h2::t2 ->\n(tuplize (t1, t2))@[(h1, h2)]\n| _ -> [] in tuplize (0::l1, 0::l2)\nin\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 > s2\n  then (l1, ((clone 0 (s1 - s2)) @ l2))\n  else if s2 > s1 then (((clone 0 (s2 - s1)) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (ret,res) = a in\n      let (d1,d2) = x in\n      let sum = (ret + d1) + d2 in\n      let newVal = sum mod 10 in\n      let newRet = sum / 10 in (newRet, (newVal :: res)) in\n    let base = (0, []) in\n    let args =\n      let rec tuplize (a,b) =\n        match (a, b) with\n        | (h1::t1,h2::t2) -> (tuplize (t1, t2)) @ [(h1, h2)]\n        | _ -> [] in\n      tuplize ((0 :: l1), (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9] [1;0;0;2]","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 > s2\n  then (l1, ((clone 0 (s1 - s2)) @ l2))\n  else if s2 > s1 then (((clone 0 (s2 - s1)) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (ret,res) = a in\n      let (d1,d2) = x in\n      let sum = (ret + d1) + d2 in\n      let newVal = sum mod 10 in\n      let newRet = sum / 10 in (newRet, (newVal :: res)) in\n    let base = (0, []) in\n    let args =\n      let rec tuplize (a,b) =\n        match (a, b) with\n        | (h1::t1,h2::t2) -> (tuplize (t1, t2)) @ [(h1, h2)]\n        | _ -> [] in\n      tuplize ((0 :: l1), (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9;9;9] [9;9;9]","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 > s2\n  then (l1, ((clone 0 (s1 - s2)) @ l2))\n  else if s2 > s1 then (((clone 0 (s2 - s1)) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (ret,res) = a in\n      let (d1,d2) = x in\n      let sum = (ret + d1) + d2 in\n      let newVal = sum mod 10 in\n      let newRet = sum / 10 in (newRet, (newVal :: res)) in\n    let base = (0, []) in\n    let args =\n      let rec tuplize (a,b) =\n        match (a, b) with\n        | (h1::t1,h2::t2) -> (tuplize (t1, t2)) @ [(h1, h2)]\n        | _ -> [] in\n      tuplize ((0 :: l1), (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n","type":"","out":""},{"in":"let rec mulByDigit i l =\nif i < 1 then\n[0]\nelse\nbigAdd l (mulByDigit (i-1) l)","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 > s2\n  then (l1, ((clone 0 (s1 - s2)) @ l2))\n  else if s2 > s1 then (((clone 0 (s2 - s1)) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (ret,res) = a in\n      let (d1,d2) = x in\n      let sum = (ret + d1) + d2 in\n      let newVal = sum mod 10 in\n      let newRet = sum / 10 in (newRet, (newVal :: res)) in\n    let base = (0, []) in\n    let args =\n      let rec tuplize (a,b) =\n        match (a, b) with\n        | (h1::t1,h2::t2) -> (tuplize (t1, t2)) @ [(h1, h2)]\n        | _ -> [] in\n      tuplize ((0 :: l1), (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i < 1 then [0] else bigAdd l (mulByDigit (i - 1) l);;\n","type":"","out":""},{"in":"let _ = mulByDigit 0 [8]","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 > s2\n  then (l1, ((clone 0 (s1 - s2)) @ l2))\n  else if s2 > s1 then (((clone 0 (s2 - s1)) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (ret,res) = a in\n      let (d1,d2) = x in\n      let sum = (ret + d1) + d2 in\n      let newVal = sum mod 10 in\n      let newRet = sum / 10 in (newRet, (newVal :: res)) in\n    let base = (0, []) in\n    let args =\n      let rec tuplize (a,b) =\n        match (a, b) with\n        | (h1::t1,h2::t2) -> (tuplize (t1, t2)) @ [(h1, h2)]\n        | _ -> [] in\n      tuplize ((0 :: l1), (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i < 1 then [0] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet _ = mulByDigit 0 [8];;\n","type":"","out":""},{"in":"let _ = mulByDigit 3 [8]","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 > s2\n  then (l1, ((clone 0 (s1 - s2)) @ l2))\n  else if s2 > s1 then (((clone 0 (s2 - s1)) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (ret,res) = a in\n      let (d1,d2) = x in\n      let sum = (ret + d1) + d2 in\n      let newVal = sum mod 10 in\n      let newRet = sum / 10 in (newRet, (newVal :: res)) in\n    let base = (0, []) in\n    let args =\n      let rec tuplize (a,b) =\n        match (a, b) with\n        | (h1::t1,h2::t2) -> (tuplize (t1, t2)) @ [(h1, h2)]\n        | _ -> [] in\n      tuplize ((0 :: l1), (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i < 1 then [0] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet _ = mulByDigit 3 [8];;\n","type":"","out":""},{"in":"let _ = mulByDigit 9 [9;9;9;9]","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 > s2\n  then (l1, ((clone 0 (s1 - s2)) @ l2))\n  else if s2 > s1 then (((clone 0 (s2 - s1)) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (ret,res) = a in\n      let (d1,d2) = x in\n      let sum = (ret + d1) + d2 in\n      let newVal = sum mod 10 in\n      let newRet = sum / 10 in (newRet, (newVal :: res)) in\n    let base = (0, []) in\n    let args =\n      let rec tuplize (a,b) =\n        match (a, b) with\n        | (h1::t1,h2::t2) -> (tuplize (t1, t2)) @ [(h1, h2)]\n        | _ -> [] in\n      tuplize ((0 :: l1), (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i < 1 then [0] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let bigMul l1 l2 = \nlet f a x =\nlet (pow, res) = a in\nlet prod = mulByDigit x l2 in\nlet prod_padded = prod@(clone 0 pow) in\n(pow+1, bigAdd res prod_padded)\nin\nlet base = (0, [0]) in\nlet args = List.rev l1 in\nlet (_, res) = List.fold_left f base args in\nres","min":"\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 > s2\n  then (l1, ((clone 0 (s1 - s2)) @ l2))\n  else if s2 > s1 then (((clone 0 (s2 - s1)) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (ret,res) = a in\n      let (d1,d2) = x in\n      let sum = (ret + d1) + d2 in\n      let newVal = sum mod 10 in\n      let newRet = sum / 10 in (newRet, (newVal :: res)) in\n    let base = (0, []) in\n    let args =\n      let rec tuplize (a,b) =\n        match (a, b) with\n        | (h1::t1,h2::t2) -> (tuplize (t1, t2)) @ [(h1, h2)]\n        | _ -> [] in\n      tuplize ((0 :: l1), (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  if i < 1 then [0] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (pow,res) = a in\n    let prod = mulByDigit x l2 in\n    let prod_padded = prod @ (clone 0 pow) in\n    ((pow + 1), (bigAdd res prod_padded)) in\n  let base = (0, [0]) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n","type":"","out":""},{"in":"let _ = bigMul [2] [2]","min":"\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 > s2\n  then (l1, ((clone 0 (s1 - s2)) @ l2))\n  else if s2 > s1 then (((clone 0 (s2 - s1)) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (ret,res) = a in\n      let (d1,d2) = x in\n      let sum = (ret + d1) + d2 in\n      let newVal = sum mod 10 in\n      let newRet = sum / 10 in (newRet, (newVal :: res)) in\n    let base = (0, []) in\n    let args =\n      let rec tuplize (a,b) =\n        match (a, b) with\n        | (h1::t1,h2::t2) -> (tuplize (t1, t2)) @ [(h1, h2)]\n        | _ -> [] in\n      tuplize ((0 :: l1), (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  if i < 1 then [0] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (pow,res) = a in\n    let prod = mulByDigit x l2 in\n    let prod_padded = prod @ (clone 0 pow) in\n    ((pow + 1), (bigAdd res prod_padded)) in\n  let base = (0, [0]) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [2] [2];;\n","type":"","out":""},{"in":"let _ = bigMul [2] [9]","min":"\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 > s2\n  then (l1, ((clone 0 (s1 - s2)) @ l2))\n  else if s2 > s1 then (((clone 0 (s2 - s1)) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (ret,res) = a in\n      let (d1,d2) = x in\n      let sum = (ret + d1) + d2 in\n      let newVal = sum mod 10 in\n      let newRet = sum / 10 in (newRet, (newVal :: res)) in\n    let base = (0, []) in\n    let args =\n      let rec tuplize (a,b) =\n        match (a, b) with\n        | (h1::t1,h2::t2) -> (tuplize (t1, t2)) @ [(h1, h2)]\n        | _ -> [] in\n      tuplize ((0 :: l1), (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  if i < 1 then [0] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (pow,res) = a in\n    let prod = mulByDigit x l2 in\n    let prod_padded = prod @ (clone 0 pow) in\n    ((pow + 1), (bigAdd res prod_padded)) in\n  let base = (0, [0]) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [2] [9];;\n","type":"","out":""},{"in":"let _ = bigMul [9] [9]","min":"\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 > s2\n  then (l1, ((clone 0 (s1 - s2)) @ l2))\n  else if s2 > s1 then (((clone 0 (s2 - s1)) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (ret,res) = a in\n      let (d1,d2) = x in\n      let sum = (ret + d1) + d2 in\n      let newVal = sum mod 10 in\n      let newRet = sum / 10 in (newRet, (newVal :: res)) in\n    let base = (0, []) in\n    let args =\n      let rec tuplize (a,b) =\n        match (a, b) with\n        | (h1::t1,h2::t2) -> (tuplize (t1, t2)) @ [(h1, h2)]\n        | _ -> [] in\n      tuplize ((0 :: l1), (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  if i < 1 then [0] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (pow,res) = a in\n    let prod = mulByDigit x l2 in\n    let prod_padded = prod @ (clone 0 pow) in\n    ((pow + 1), (bigAdd res prod_padded)) in\n  let base = (0, [0]) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9] [9];;\n","type":"","out":""},{"in":"let _ = bigMul [8;1] [2]","min":"\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 > s2\n  then (l1, ((clone 0 (s1 - s2)) @ l2))\n  else if s2 > s1 then (((clone 0 (s2 - s1)) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (ret,res) = a in\n      let (d1,d2) = x in\n      let sum = (ret + d1) + d2 in\n      let newVal = sum mod 10 in\n      let newRet = sum / 10 in (newRet, (newVal :: res)) in\n    let base = (0, []) in\n    let args =\n      let rec tuplize (a,b) =\n        match (a, b) with\n        | (h1::t1,h2::t2) -> (tuplize (t1, t2)) @ [(h1, h2)]\n        | _ -> [] in\n      tuplize ((0 :: l1), (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  if i < 1 then [0] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (pow,res) = a in\n    let prod = mulByDigit x l2 in\n    let prod_padded = prod @ (clone 0 pow) in\n    ((pow + 1), (bigAdd res prod_padded)) in\n  let base = (0, [0]) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [8; 1] [2];;\n","type":"","out":""},{"in":"let _ = bigMul [2] [8;1]","min":"\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 > s2\n  then (l1, ((clone 0 (s1 - s2)) @ l2))\n  else if s2 > s1 then (((clone 0 (s2 - s1)) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (ret,res) = a in\n      let (d1,d2) = x in\n      let sum = (ret + d1) + d2 in\n      let newVal = sum mod 10 in\n      let newRet = sum / 10 in (newRet, (newVal :: res)) in\n    let base = (0, []) in\n    let args =\n      let rec tuplize (a,b) =\n        match (a, b) with\n        | (h1::t1,h2::t2) -> (tuplize (t1, t2)) @ [(h1, h2)]\n        | _ -> [] in\n      tuplize ((0 :: l1), (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  if i < 1 then [0] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (pow,res) = a in\n    let prod = mulByDigit x l2 in\n    let prod_padded = prod @ (clone 0 pow) in\n    ((pow + 1), (bigAdd res prod_padded)) in\n  let base = (0, [0]) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [2] [8; 1];;\n","type":"","out":""},{"in":"let _ = bigMul [1;2;3;4;5] [5;4;3;2;1]","min":"\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 > s2\n  then (l1, ((clone 0 (s1 - s2)) @ l2))\n  else if s2 > s1 then (((clone 0 (s2 - s1)) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (ret,res) = a in\n      let (d1,d2) = x in\n      let sum = (ret + d1) + d2 in\n      let newVal = sum mod 10 in\n      let newRet = sum / 10 in (newRet, (newVal :: res)) in\n    let base = (0, []) in\n    let args =\n      let rec tuplize (a,b) =\n        match (a, b) with\n        | (h1::t1,h2::t2) -> (tuplize (t1, t2)) @ [(h1, h2)]\n        | _ -> [] in\n      tuplize ((0 :: l1), (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  if i < 1 then [0] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (pow,res) = a in\n    let prod = mulByDigit x l2 in\n    let prod_padded = prod @ (clone 0 pow) in\n    ((pow + 1), (bigAdd res prod_padded)) in\n  let base = (0, [0]) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1; 2; 3; 4; 5] [5; 4; 3; 2; 1];;\n","type":"","out":""},{"in":"let _ = bigMul [9;9;9;9] [9;9;9;9]","min":"\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 > s2\n  then (l1, ((clone 0 (s1 - s2)) @ l2))\n  else if s2 > s1 then (((clone 0 (s2 - s1)) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (ret,res) = a in\n      let (d1,d2) = x in\n      let sum = (ret + d1) + d2 in\n      let newVal = sum mod 10 in\n      let newRet = sum / 10 in (newRet, (newVal :: res)) in\n    let base = (0, []) in\n    let args =\n      let rec tuplize (a,b) =\n        match (a, b) with\n        | (h1::t1,h2::t2) -> (tuplize (t1, t2)) @ [(h1, h2)]\n        | _ -> [] in\n      tuplize ((0 :: l1), (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  if i < 1 then [0] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (pow,res) = a in\n    let prod = mulByDigit x l2 in\n    let prod_padded = prod @ (clone 0 pow) in\n    ((pow + 1), (bigAdd res prod_padded)) in\n  let base = (0, [0]) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]","min":"\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 > s2\n  then (l1, ((clone 0 (s1 - s2)) @ l2))\n  else if s2 > s1 then (((clone 0 (s2 - s1)) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (ret,res) = a in\n      let (d1,d2) = x in\n      let sum = (ret + d1) + d2 in\n      let newVal = sum mod 10 in\n      let newRet = sum / 10 in (newRet, (newVal :: res)) in\n    let base = (0, []) in\n    let args =\n      let rec tuplize (a,b) =\n        match (a, b) with\n        | (h1::t1,h2::t2) -> (tuplize (t1, t2)) @ [(h1, h2)]\n        | _ -> [] in\n      tuplize ((0 :: l1), (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  if i < 1 then [0] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (pow,res) = a in\n    let prod = mulByDigit x l2 in\n    let prod_padded = prod @ (clone 0 pow) in\n    ((pow + 1), (bigAdd res prod_padded)) in\n  let base = (0, [0]) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9; 9] [9; 9; 9; 9; 9];;\n","type":"","out":""},{"in":"let key = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130 = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ ((Printexc.to_string e) ^ \"\\n\"));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n","type":"","out":""},{"in":"let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","min":"\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n","type":"","out":""},{"in":"let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n\nlet drop_paren s =\n  implode\n    (List.filter (fun c  -> not (List.mem c ['('; ' '; ')'])) (explode s));;\n","type":"","out":""},{"in":"let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","min":"\nlet eq_real p (r1,r2) = ((r1 -. r2) < p) || ((r2 -. r1) < p);;\n","type":"","out":""},{"in":"let wrap_curried_2 f (a,b) = f a b","min":"\nlet wrap_curried_2 f (a,b) = f a b;;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":7566},"type":"eval"},"cursor":0,"time":1.398974539392066e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = (fun x' -> x (a x')) in\n  let base = (fun x -> x) in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a^sep^x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\"^(sepConcat \"; \" (List.map f l))^\"]\"\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n < 1 then\n    []\n  else\n    x::(clone x (n-1))\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n    if s1 > s2 then\n      (l1, (clone 0 (s1 - s2))@l2)\n    else if s2 > s1 then\n      ((clone 0 (s2 - s1))@l1, l2)\n    else\n      (l1, l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x =\n      let (ret, res) = a in\n      let (d1, d2) = x in\n      let sum = ret + d1 + d2 in\n      let newVal = sum mod 10 in\n      let newRet = sum / 10 in\n        (newRet, newVal::res)\n    in\n    let base = (0, []) in\n    let args =\n      let rec tuplize (a, b) = match a, b with\n        | h1::t1, h2::t2 ->\n            (tuplize (t1, t2))@[(h1, h2)]\n        | _ -> [] in tuplize (0::l1, 0::l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\n\n\nlet rec mulByDigit i l =\n  if i < 1 then\n    [0]\n  else\n    bigAdd l (mulByDigit (i-1) l)\n\nlet _ = mulByDigit 0 [8]\nlet _ = mulByDigit 3 [8]\nlet _ = mulByDigit 9 [9;9;9;9]\n\nlet bigMul l1 l2 = \n  let f a x =\n    let (pow, res) = a in\n    let prod = mulByDigit x l2 in\n    let prod_padded = prod@(clone 0 pow) in\n      (pow+1, bigAdd res prod_padded)\n  in\n  let base = (0, [0]) in\n  let args = List.rev l1 in\n  let (_, res) = List.fold_left f base args in\n    res\n\nlet _ = bigMul [2] [2]\nlet _ = bigMul [2] [9]\nlet _ = bigMul [9] [9]\nlet _ = bigMul [8;1] [2]\nlet _ = bigMul [2] [8;1]\nlet _ = bigMul [1;2;3;4;5] [5;4;3;2;1]\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
