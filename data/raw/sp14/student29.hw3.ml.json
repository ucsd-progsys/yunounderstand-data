{"ocaml":[{"in":"let sqsum xs = \nlet f a x =  a + x*x in\nlet base = 0 in\nList.fold_left f base xs","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n","type":"","out":""},{"in":"let _ = sqsum []","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [];;\n","type":"","out":""},{"in":"let _ = sqsum [1;2;3;4]","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sqsum [(-1); (-2); (-3); (-4)]","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [(-1); (-2); (-3); (-4)];;\n","type":"","out":""},{"in":"let pipe fs = \nlet f a x = x a in\nlet base =  fun y - > y in\nList.fold_left f base fs","min":"","type":"syntax","out":"Characters 54-55:\n  let base =  fun y - > y in\n                      ^\nError: Syntax error\n"}],"event":{"region":{"start":0,"stop":1004},"type":"eval"},"cursor":1004,"time":1.398547193776895e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y - > y in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let pipe fs = \nlet f a x = x a in\nlet base =  fun y -> y in\nList.fold_left f base fs","min":"\nlet pipe fs = let f a x = x a in let base y = y in List.fold_left f base fs;;\n","type":"","out":""}],"event":{"region":{"start":915,"stop":1003},"type":"eval"},"cursor":1003,"time":1.398547199434092e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y -> y in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let pipe fs = \nlet f a x = x a in\nlet base =  fun y ->  in\nList.fold_left f base fs","min":"","type":"syntax","out":"Characters 56-58:\n  let base =  fun y ->  in\n                        ^^\nError: Syntax error\n"}],"event":{"region":{"start":915,"stop":1002},"type":"eval"},"cursor":1002,"time":1.398547258153307e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let pipe fs = \nlet f a x = x a in\nlet base =  fun y ->  y in\nList.fold_left f base fs","min":"\nlet pipe fs = let f a x = x a in let base y = y in List.fold_left f base fs;;\n","type":"","out":""},{"in":"let _ = pipe [] 3","min":"\nlet pipe fs = let f a x = x a in let base y = y in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n","type":"","out":""},{"in":"let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3","min":"\nlet pipe fs = let f a x = x a in let base y = y in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n","type":"type","out":"Characters 24-25:\n  let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3;;\n                          ^\nError: This expression has type 'a -> 'a\n       but an expression was expected of type int\n"},{"in":"let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3","min":"\nlet pipe fs = let f a x = x a in let base y = y in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n","type":"type","out":"Characters 24-25:\n  let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3;;\n                          ^\nError: This expression has type 'a -> 'a\n       but an expression was expected of type int\n"}],"event":{"region":{"start":915,"stop":1127},"type":"eval"},"cursor":1127,"time":1.398547270835016e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = pipe [(fun x -> x+x); (fun x -> x + 3)]","min":"\nlet pipe fs = let f a x = x a in let base y = y in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)];;\n","type":"type","out":"Characters 24-25:\n  let _ = pipe [(fun x -> x+x); (fun x -> x + 3)];;\n                          ^\nError: This expression has type 'a -> 'a\n       but an expression was expected of type int\n"}],"event":{"region":{"start":1025,"stop":1074},"type":"eval"},"cursor":1074,"time":1.39854732614341e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)]\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3","min":"\nlet pipe fs = let f a x = x a in let base y = y in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n","type":"type","out":"Characters 24-25:\n  let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3;;\n                          ^\nError: This expression has type 'a -> 'a\n       but an expression was expected of type int\n"}],"event":{"region":{"start":1025,"stop":1076},"type":"eval"},"cursor":1076,"time":1.398547332490955e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x  in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = \"\" in let l = t in List.fold_left f base l;;\n","type":"","out":""}],"event":{"region":{"start":1004,"stop":1282},"type":"eval"},"cursor":1282,"time":1.3985476442464e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = \"\" in\n      let l = t in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = \"\" in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"---\" []","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = \"\" in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"---\" [];;\n","type":"","out":""},{"in":"let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = \"\" in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"\" [\"a\"; \"b\"; \"c\"; \"d\"; \"e\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"X\" [\"hello\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = \"\" in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"X\" [\"hello\"];;\n","type":"","out":""}],"event":{"region":{"start":1282,"stop":1431},"type":"eval"},"cursor":1432,"time":1.398547667547833e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = \"\" in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x  in\nlet base = h in\nlet l = t in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n","type":"","out":""}],"event":{"region":{"start":1004,"stop":1281},"type":"eval"},"cursor":1241,"time":1.398547703384407e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"---\" []","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"---\" [];;\n","type":"","out":""},{"in":"let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"\" [\"a\"; \"b\"; \"c\"; \"d\"; \"e\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"X\" [\"hello\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"X\" [\"hello\"];;\n","type":"","out":""}],"event":{"region":{"start":1281,"stop":1430},"type":"eval"},"cursor":1430,"time":1.398547706690745e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let stringOfList f l = \"[\" ^ sepConcat \";\" List.map f l ^ \"]\"","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" List.map f l) ^ \"]\");;\n","type":"type","out":"Characters 29-38:\n  let stringOfList f l = \"[\" ^ sepConcat \";\" List.map f l ^ \"]\";;\n                               ^^^^^^^^^\nError: This function has type string -> string list -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}],"event":{"region":{"start":1430,"stop":1495},"type":"eval"},"cursor":1463,"time":1.398547929585497e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" List.map f l ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n","type":"","out":""}],"event":{"region":{"start":1430,"stop":1497},"type":"eval"},"cursor":1491,"time":1.398547939473115e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = stringOfList string_of_int [1;2;3;4;5;6]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n\nlet _ = stringOfList string_of_int [1; 2; 3; 4; 5; 6];;\n","type":"","out":""},{"in":"let _ = stringOfList (fun x -> x) [\"foo\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n\nlet _ = stringOfList (fun x  -> x) [\"foo\"];;\n","type":"","out":""},{"in":"let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n\nlet _ =\n  stringOfList (stringOfList string_of_int) [[1; 2; 3]; [4; 5]; [6]; []];;\n","type":"","out":""}],"event":{"region":{"start":1497,"stop":1667},"type":"eval"},"cursor":1670,"time":1.398547946485608e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x  in\nlet base = h in\nlet l = t in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n","type":"","out":""}],"event":{"region":{"start":1135,"stop":1281},"type":"eval"},"cursor":1282,"time":1.398548794960618e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let helper a x n in\n    if x <= 0 then []\n    else \n      let a' = x::a in\n        helper a' x (n-1)\nin helper [] x n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"---\" []","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"---\" [];;\n","type":"","out":""},{"in":"let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"\" [\"a\"; \"b\"; \"c\"; \"d\"; \"e\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"X\" [\"hello\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"X\" [\"hello\"];;\n","type":"","out":""},{"in":"let stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n","type":"","out":""},{"in":"let _ = stringOfList string_of_int [1;2;3;4;5;6]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n\nlet _ = stringOfList string_of_int [1; 2; 3; 4; 5; 6];;\n","type":"","out":""},{"in":"let _ = stringOfList (fun x -> x) [\"foo\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n\nlet _ = stringOfList (fun x  -> x) [\"foo\"];;\n","type":"","out":""},{"in":"let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n\nlet _ =\n  stringOfList (stringOfList string_of_int) [[1; 2; 3]; [4; 5]; [6]; []];;\n","type":"","out":""},{"in":"let rec clone x n = \nlet helper a x n in\nif x <= 0 then []\nelse \nlet a' = x::a in\nhelper a' x (n-1)\nin helper [] x n","min":"","type":"syntax","out":"Characters 38-40:\n  let helper a x n in\n                   ^^\nError: Syntax error\n"}],"event":{"region":{"start":1281,"stop":1995},"type":"eval"},"cursor":1997,"time":1.398548797971505e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let helper a x n in\n    if x <= 0 then []\n    else \n      let a' = x::a in\n        helper a' x (n-1)\nin helper [] x n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec clone x n = \nlet helper a x n =\nif x <= 0 then []\nelse \nlet a' = x::a in\nhelper a' x (n-1)\nin helper [] x n","min":"\nlet rec clone x n =\n  let helper a x n =\n    if x <= 0 then [] else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n","type":"scope","out":"Characters 81-87:\n  helper a' x (n-1)\n  ^^^^^^\nError: Unbound value helper\n"}],"event":{"region":{"start":1667,"stop":1994},"type":"eval"},"cursor":1996,"time":1.398548806732197e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let helper a x n =\n    if x <= 0 then []\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec clone x n = \nlet rec helper a x n =\nif x <= 0 then []\nelse \nlet a' = x::a in\nhelper a' x (n-1)\nin helper [] x n","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if x <= 0 then [] else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n","type":"","out":""}],"event":{"region":{"start":1667,"stop":1998},"type":"eval"},"cursor":2000,"time":1.398548813734453e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if x <= 0 then []\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = clone 3 5","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if x <= 0 then [] else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet _ = clone 3 5;;\n","type":"","out":""},{"in":"let _ = clone \"foo\" 2","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if x <= 0 then [] else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet _ = clone \"foo\" 2;;\n","type":"type","out":"Characters 14-19:\n  let _ = clone \"foo\" 2;;\n                ^^^^^\nError: This expression has type string but an expression was expected of type\n         int\n"},{"in":"let _ = clone clone (-3)","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if x <= 0 then [] else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet _ = clone clone (-3);;\n","type":"type","out":"Characters 14-19:\n  let _ = clone clone (-3);;\n                ^^^^^\nError: This expression has type int -> int -> 'a list\n       but an expression was expected of type int\n"}],"event":{"region":{"start":1998,"stop":2072},"type":"eval"},"cursor":2074,"time":1.398548820916325e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if x <= 0 then []\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec clone x n = \nlet rec helper a x n =\nif n <= 0 then []\nelse \nlet a' = x::a in\nhelper a' x (n-1)\nin helper [] x n","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then [] else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n","type":"","out":""}],"event":{"region":{"start":1667,"stop":1998},"type":"eval"},"cursor":2000,"time":1.398548845027067e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then []\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = clone 3 5","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then [] else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet _ = clone 3 5;;\n","type":"","out":""},{"in":"let _ = clone \"foo\" 2","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then [] else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet _ = clone \"foo\" 2;;\n","type":"","out":""},{"in":"let _ = clone clone (-3)","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then [] else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet _ = clone clone (-3);;\n","type":"","out":""}],"event":{"region":{"start":1998,"stop":2072},"type":"eval"},"cursor":2074,"time":1.398548846809658e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then []\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec clone x n = \nlet rec helper a x n =\nif n <= 0 then a\nelse \nlet a' = x::a in\nhelper a' x (n-1)\nin helper [] x n","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n","type":"","out":""}],"event":{"region":{"start":1667,"stop":1997},"type":"eval"},"cursor":1999,"time":1.398548858566511e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = clone 3 5","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet _ = clone 3 5;;\n","type":"","out":""},{"in":"let _ = clone \"foo\" 2","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet _ = clone \"foo\" 2;;\n","type":"","out":""},{"in":"let _ = clone clone (-3)","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet _ = clone clone (-3);;\n","type":"","out":""}],"event":{"region":{"start":1997,"stop":2071},"type":"eval"},"cursor":2073,"time":1.398548860850862e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let padZero l1 l2 = \nlet length1 = List.length l1 in\nlet length2 = List.length l2 in\nif length1 > length2 then \n(l1, List.append (clone 0 (length1 - length2)) l2)\nelse if length2 length1 then (\nList.append (clone 0 (length1 - length2)) l1, l2)\nelse (l1,l2)","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 length1\n    then ((List.append (clone 0 (length1 - length2)) l1), l2)\n    else (l1, l2);;\n","type":"type","out":"Characters 171-178:\n  else if length2 length1 then (\n          ^^^^^^^\nError: This expression has type int\n       This is not a function; it cannot be applied.\n"}],"event":{"region":{"start":2071,"stop":2332},"type":"eval"},"cursor":2332,"time":1.398549187816215e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 length1 then (\n      List.append (clone 0 (length1 - length2)) l1, l2)\n    else (l1,l2)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let padZero l1 l2 = \nlet length1 = List.length l1 in\nlet length2 = List.length l2 in\nif length1 > length2 then \n(l1, List.append (clone 0 (length1 - length2)) l2)\nelse if length2 > length1 then \n(List.append (clone 0 (length1 - length2)) l1, l2)\nelse (l1,l2)","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length1 - length2)) l1), l2)\n    else (l1, l2);;\n","type":"","out":""}],"event":{"region":{"start":2071,"stop":2334},"type":"eval"},"cursor":2334,"time":1.398549204033121e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length1 - length2)) l1, l2)\n    else (l1,l2)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = padZero [9;9] [1;0;0;2]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length1 - length2)) l1), l2)\n    else (l1, l2);;\n\nlet _ = padZero [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = padZero [1;0;0;2] [9;9]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length1 - length2)) l1), l2)\n    else (l1, l2);;\n\nlet _ = padZero [1; 0; 0; 2] [9; 9];;\n","type":"","out":""}],"event":{"region":{"start":2334,"stop":2399},"type":"eval"},"cursor":2401,"time":1.398549212692749e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length1 - length2)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let padZero l1 l2 = \nlet length1 = List.length l1 in\nlet length2 = List.length l2 in\nif length1 > length2 then \n(l1, List.append (clone 0 (length1 - length2)) l2)\nelse if length2 > length1 then \n(List.append (clone 0 (length2 - length1)) l1, l2)\nelse (l1,l2)","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n","type":"","out":""},{"in":"let _ = padZero [9;9] [1;0;0;2]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet _ = padZero [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = padZero [1;0;0;2] [9;9]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet _ = padZero [1; 0; 0; 2] [9; 9];;\n","type":"","out":""}],"event":{"region":{"start":2071,"stop":2399},"type":"eval"},"cursor":2400,"time":1.398549236887122e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec removeZero l = match l with\n| [] -> []\n| h::t if h = 0 then removeZero t else l","min":"","type":"syntax","out":"Characters 54-56:\n  | h::t if h = 0 then removeZero t else l;;\n         ^^\nError: Syntax error: pattern expected.\n"},{"in":"let _ = removeZero [0;0;0;1;0;0;2]","min":"\nlet _ = removeZero [0; 0; 0; 1; 0; 0; 2];;\n","type":"scope","out":"Characters 8-18:\n  let _ = removeZero [0;0;0;1;0;0;2];;\n          ^^^^^^^^^^\nError: Unbound value removeZero\n"},{"in":"let _ = removeZero [9;9]","min":"\nlet _ = removeZero [9; 9];;\n","type":"scope","out":"Characters 8-18:\n  let _ = removeZero [9;9];;\n          ^^^^^^^^^^\nError: Unbound value removeZero\n"},{"in":"let _ = removeZero [0;0;0;0]","min":"\nlet _ = removeZero [0; 0; 0; 0];;\n","type":"scope","out":"Characters 8-18:\n  let _ = removeZero [0;0;0;0];;\n          ^^^^^^^^^^\nError: Unbound value removeZero\n"}],"event":{"region":{"start":2399,"stop":2581},"type":"eval"},"cursor":2581,"time":1.398549360185365e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec removeZero l = match l with\n| [] -> []\n| h::t -> if h = 0 then removeZero t else l","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;1;0;0;2]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet _ = removeZero [0; 0; 0; 1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = removeZero [9;9]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet _ = removeZero [9; 9];;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;0]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet _ = removeZero [0; 0; 0; 0];;\n","type":"","out":""}],"event":{"region":{"start":2399,"stop":2584},"type":"eval"},"cursor":2584,"time":1.398549367004449e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let sqsum xs = \nlet f a x =  a + x*x in\nlet base = 0 in\nList.fold_left f base xs","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n","type":"","out":""},{"in":"let _ = sqsum []","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [];;\n","type":"","out":""},{"in":"let _ = sqsum [1;2;3;4]","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sqsum [(-1); (-2); (-3); (-4)]","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [(-1); (-2); (-3); (-4)];;\n","type":"","out":""},{"in":"let pipe fs = \nlet f a x = x a in\nlet base =  fun y ->  y in\nList.fold_left f base fs","min":"\nlet pipe fs = let f a x = x a in let base y = y in List.fold_left f base fs;;\n","type":"","out":""},{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x  in\nlet base = h in\nlet l = t in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n","type":"","out":""},{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"---\" []","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"---\" [];;\n","type":"","out":""},{"in":"let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"\" [\"a\"; \"b\"; \"c\"; \"d\"; \"e\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"X\" [\"hello\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"X\" [\"hello\"];;\n","type":"","out":""},{"in":"let stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n","type":"","out":""},{"in":"let _ = stringOfList string_of_int [1;2;3;4;5;6]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n\nlet _ = stringOfList string_of_int [1; 2; 3; 4; 5; 6];;\n","type":"","out":""},{"in":"let _ = stringOfList (fun x -> x) [\"foo\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n\nlet _ = stringOfList (fun x  -> x) [\"foo\"];;\n","type":"","out":""},{"in":"let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n\nlet _ =\n  stringOfList (stringOfList string_of_int) [[1; 2; 3]; [4; 5]; [6]; []];;\n","type":"","out":""},{"in":"let rec clone x n = \nlet rec helper a x n =\nif n <= 0 then a\nelse \nlet a' = x::a in\nhelper a' x (n-1)\nin helper [] x n","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n","type":"","out":""},{"in":"let _ = clone 3 5","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet _ = clone 3 5;;\n","type":"","out":""},{"in":"let _ = clone \"foo\" 2","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet _ = clone \"foo\" 2;;\n","type":"","out":""},{"in":"let _ = clone clone (-3)","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet _ = clone clone (-3);;\n","type":"","out":""},{"in":"let padZero l1 l2 = \nlet length1 = List.length l1 in\nlet length2 = List.length l2 in\nif length1 > length2 then \n(l1, List.append (clone 0 (length1 - length2)) l2)\nelse if length2 > length1 then \n(List.append (clone 0 (length2 - length1)) l1, l2)\nelse (l1,l2)","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n","type":"","out":""},{"in":"let _ = padZero [9;9] [1;0;0;2]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet _ = padZero [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = padZero [1;0;0;2] [9;9]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet _ = padZero [1; 0; 0; 2] [9; 9];;\n","type":"","out":""},{"in":"let rec removeZero l = match l with\n| [] -> []\n| h::t -> if h = 0 then removeZero t else l","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;1;0;0;2]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet _ = removeZero [0; 0; 0; 1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = removeZero [9;9]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet _ = removeZero [9; 9];;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;0]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet _ = removeZero [0; 0; 0; 0];;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":2584},"type":"eval"},"cursor":2584,"time":1.398573621819045e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = 0 in\nlet args = \nlet rec pair list1 list2 = match (list1, list2) with\n| (h1::t1, h2::t2) -> (h1,h2)::pair(t1,t2)\n| ([], []) -> []\nin pair l1 l2\nin\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = 0 in\n    let args =\n      let rec pair list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> (h1, h2) :: (pair (t1, t2))\n        | ([],[]) -> [] in\n      pair l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"type","out":"Characters 200-207:\n  | (h1::t1, h2::t2) -> (h1,h2)::pair(t1,t2)\n                                     ^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"}],"event":{"region":{"start":2584,"stop":2913},"type":"eval"},"cursor":2827,"time":1.398574719094653e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = 0 in\n    let args = \n      let rec pair list1 list2 = match (list1, list2) with\n        | (h1::t1, h2::t2) -> (h1,h2)::pair(t1,t2)\n        | ([], []) -> []\n      in pair l1 l2\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = 0 in\nlet args = \nlet rec pair list1 list2 = match (list1, list2) with\n| (h1::t1, h2::t2) -> (h1,h2)::pair t1 t2\n| ([], []) -> []\nin pair l1 l2\nin\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = 0 in\n    let args =\n      let rec pair list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> (h1, h2) :: (pair t1 t2)\n        | ([],[]) -> [] in\n      pair l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"type","out":"Characters 256-282:\n  let (_, res) = List.fold_left f base args in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a * 'b\n"}],"event":{"region":{"start":2584,"stop":2912},"type":"eval"},"cursor":2823,"time":1.398574738377935e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = 0 in\n    let args = \n      let rec pair list1 list2 = match (list1, list2) with\n        | (h1::t1, h2::t2) -> (h1,h2)::pair t1 t2\n        | ([], []) -> []\n      in pair l1 l2\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = 0 in\nlet args = \nlet rec pair list1 list2 = match (list1, list2) with\n| (h1::t1, h2::t2) -> (h1,h2)::pair t1 t2\n| (_ , _) -> []\nin pair l1 l2\nin\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = 0 in\n    let args =\n      let rec pair list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> (h1, h2) :: (pair t1 t2)\n        | (_,_) -> [] in\n      pair l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"type","out":"Characters 255-281:\n  let (_, res) = List.fold_left f base args in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a * 'b\n"}],"event":{"region":{"start":2584,"stop":2911},"type":"eval"},"cursor":2822,"time":1.398574749749266e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = 0 in\n    let args = \n      let rec pair list1 list2 = match (list1, list2) with\n        | (h1::t1, h2::t2) -> (h1,h2)::pair t1 t2\n        | (_ , _) -> []\n      in pair l1 l2\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(x1, x2) -> \nmatch a with\n(o , z)if o + x1 + x2 > 9 \nthen (1, ((o + x1 + x2) mod 10)::z )\nelse (0, (o + x1 + x2)::z)\nin\nlet base = (0, []) in\nlet args = \nlet rec pair list1 list2 = \nmatch (List.rev list1, List.rev list2) with\n| (h1::t1, h2::t2) -> (h1,h2)::pair t1 t2\n| (_ , _) -> []\nin pair l1 l2\nin\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"","type":"syntax","out":"Characters 98-100:\n  (o , z)if o + x1 + x2 > 9 \n         ^^\nError: Syntax error\n"}],"event":{"region":{"start":2584,"stop":3037},"type":"eval"},"cursor":3000,"time":1.398575154161979e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z)if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair list1 list2 = \n        match (List.rev list1, List.rev list2) with\n          | (h1::t1, h2::t2) -> (h1,h2)::pair t1 t2\n          | (_ , _) -> []\n      in pair l1 l2\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(x1, x2) -> \nmatch a with\n(o , z) -> if o + x1 + x2 > 9 \nthen (1, ((o + x1 + x2) mod 10)::z )\nelse (0, (o + x1 + x2)::z)\nin\nlet base = (0, []) in\nlet args = \nlet rec pair list1 list2 = \nmatch (List.rev list1, List.rev list2) with\n| (h1::t1, h2::t2) -> (h1,h2)::pair t1 t2\n| (_ , _) -> []\nin pair l1 l2\nin\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair list1 list2 =\n        match ((List.rev list1), (List.rev list2)) with\n        | (h1::t1,h2::t2) -> (h1, h2) :: (pair t1 t2)\n        | (_,_) -> [] in\n      pair l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"","out":""}],"event":{"region":{"start":2584,"stop":3041},"type":"eval"},"cursor":3020,"time":1.398575163103661e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair list1 list2 = \n        match (List.rev list1, List.rev list2) with\n          | (h1::t1, h2::t2) -> (h1,h2)::pair t1 t2\n          | (_ , _) -> []\n      in pair l1 l2\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = bigAdd [9;9] [1;0;0;2]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair list1 list2 =\n        match ((List.rev list1), (List.rev list2)) with\n        | (h1::t1,h2::t2) -> (h1, h2) :: (pair t1 t2)\n        | (_,_) -> [] in\n      pair l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9;9;9] [9;9;9]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair list1 list2 =\n        match ((List.rev list1), (List.rev list2)) with\n        | (h1::t1,h2::t2) -> (h1, h2) :: (pair t1 t2)\n        | (_,_) -> [] in\n      pair l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n","type":"","out":""}],"event":{"region":{"start":3041,"stop":3109},"type":"eval"},"cursor":3113,"time":1.398575171197931e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair list1 list2 = \n        match (List.rev list1, List.rev list2) with\n          | (h1::t1, h2::t2) -> (h1,h2)::pair t1 t2\n          | (_ , _) -> []\n      in pair l1 l2\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(x1, x2) -> \nmatch a with\n(o , z) -> if o + x1 + x2 > 9 \nthen (1, ((o + x1 + x2) mod 10)::z )\nelse (0, (o + x1 + x2)::z)\nin\nlet base = (0, []) in\nlet args = \nlet rec pair list1 list2 = \nmatch (List.rev list1, List.rev list2) with\n| (h1::t1, h2::t2) -> (h1,h2)::pair t1 t2\n| (_ , _) -> []\nin pair l1 l2\nin\nlet (_, res) = List.fold_left f base args in\nargs\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair list1 list2 =\n        match ((List.rev list1), (List.rev list2)) with\n        | (h1::t1,h2::t2) -> (h1, h2) :: (pair t1 t2)\n        | (_,_) -> [] in\n      pair l1 l2 in\n    let (_,res) = List.fold_left f base args in args in\n  removeZero (add (padZero l1 l2));;\n","type":"type","out":"Characters 435-456:\n  removeZero (add (padZero l1 l2));;\n             ^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type (int * int) list\n       but an expression was expected of type int list\n       Type int * int is not compatible with type int \n"}],"event":{"region":{"start":2584,"stop":3042},"type":"eval"},"cursor":3005,"time":1.398575254807873e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair list1 list2 = \n        match (List.rev list1, List.rev list2) with\n          | (h1::t1, h2::t2) -> (h1,h2)::pair t1 t2\n          | (_ , _) -> []\n      in pair l1 l2\n    in\n    let (_, res) = List.fold_left f base args in\n      args\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(x1, x2) -> \nmatch a with\n(o , z) -> if o + x1 + x2 > 9 \nthen (1, ((o + x1 + x2) mod 10)::z )\nelse (0, (o + x1 + x2)::z)\nin\nlet base = (0, []) in\nlet args = \nlet rec pair list1 list2 = \nmatch (List.rev list1, List.rev list2) with\n| (h1::t1, h2::t2) -> (h1,h2)::pair t1 t2\n| (_ , _) -> []\nin pair l1 l2\nin\nlet (_, res) = List.fold_left f base args in\nargs\nin \nadd (padZero l1 l2)","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair list1 list2 =\n        match ((List.rev list1), (List.rev list2)) with\n        | (h1::t1,h2::t2) -> (h1, h2) :: (pair t1 t2)\n        | (_,_) -> [] in\n      pair l1 l2 in\n    let (_,res) = List.fold_left f base args in args in\n  add (padZero l1 l2);;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9] [1;0;0;2]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair list1 list2 =\n        match ((List.rev list1), (List.rev list2)) with\n        | (h1::t1,h2::t2) -> (h1, h2) :: (pair t1 t2)\n        | (_,_) -> [] in\n      pair l1 l2 in\n    let (_,res) = List.fold_left f base args in args in\n  add (padZero l1 l2);;\n\nlet _ = bigAdd [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9;9;9] [9;9;9]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair list1 list2 =\n        match ((List.rev list1), (List.rev list2)) with\n        | (h1::t1,h2::t2) -> (h1, h2) :: (pair t1 t2)\n        | (_,_) -> [] in\n      pair l1 l2 in\n    let (_,res) = List.fold_left f base args in args in\n  add (padZero l1 l2);;\n\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n","type":"","out":""}],"event":{"region":{"start":2584,"stop":3097},"type":"eval"},"cursor":3100,"time":1.398575266381269e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair list1 list2 = \n        match (List.rev list1, List.rev list2) with\n          | (h1::t1, h2::t2) -> (h1,h2)::pair t1 t2\n          | (_ , _) -> []\n      in pair l1 l2\n    in\n    let (_, res) = List.fold_left f base args in\n      args\n  in \n    add (padZero l1 l2)\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(x1, x2) -> \nmatch a with\n(o , z) -> if o + x1 + x2 > 9 \nthen (1, ((o + x1 + x2) mod 10)::z )\nelse (0, (o + x1 + x2)::z)\nin\nlet base = (0, []) in\nlet args = \nlet rec pair list1 list2 = \nmatch (list1, list2) with\n| (h1::t1, h2::t2) -> (h1,h2)::pair t1 t2\n| (_ , _) -> []\nin pair List.rev l1 List.rev l2\nin\nlet (_, res) = List.fold_left f base args in\nargs\nin \nadd (padZero l1 l2)","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> (h1, h2) :: (pair t1 t2)\n        | (_,_) -> [] in\n      pair List.rev l1 List.rev l2 in\n    let (_,res) = List.fold_left f base args in args in\n  add (padZero l1 l2);;\n","type":"type","out":"Characters 338-342:\n  in pair List.rev l1 List.rev l2\n     ^^^^\nError: This function has type 'a list -> 'b list -> ('a * 'b) list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"},{"in":"let _ = bigAdd [9;9] [1;0;0;2]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair list1 list2 =\n        match ((List.rev list1), (List.rev list2)) with\n        | (h1::t1,h2::t2) -> (h1, h2) :: (pair t1 t2)\n        | (_,_) -> [] in\n      pair l1 l2 in\n    let (_,res) = List.fold_left f base args in args in\n  add (padZero l1 l2);;\n\nlet _ = bigAdd [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9;9;9] [9;9;9]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair list1 list2 =\n        match ((List.rev list1), (List.rev list2)) with\n        | (h1::t1,h2::t2) -> (h1, h2) :: (pair t1 t2)\n        | (_,_) -> [] in\n      pair l1 l2 in\n    let (_,res) = List.fold_left f base args in args in\n  add (padZero l1 l2);;\n\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n","type":"","out":""}],"event":{"region":{"start":2584,"stop":3097},"type":"eval"},"cursor":3100,"time":1.398575350189095e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> (h1,h2)::pair t1 t2\n          | (_ , _) -> []\n      in pair List.rev l1 List.rev l2\n    in\n    let (_, res) = List.fold_left f base args in\n      args\n  in \n    add (padZero l1 l2)\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(x1, x2) -> \nmatch a with\n(o , z) -> if o + x1 + x2 > 9 \nthen (1, ((o + x1 + x2) mod 10)::z )\nelse (0, (o + x1 + x2)::z)\nin\nlet base = (0, []) in\nlet args = \nlet rec pair list1 list2 = \nmatch (list1, list2) with\n| (h1::t1, h2::t2) -> (h1,h2)::pair t1 t2\n| (_ , _) -> []\nin pair (List.rev l1) (List.rev l2)\nin\nlet (_, res) = List.fold_left f base args in\nargs\nin \nadd (padZero l1 l2)","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> (h1, h2) :: (pair t1 t2)\n        | (_,_) -> [] in\n      pair (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in args in\n  add (padZero l1 l2);;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9] [1;0;0;2]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> (h1, h2) :: (pair t1 t2)\n        | (_,_) -> [] in\n      pair (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in args in\n  add (padZero l1 l2);;\n\nlet _ = bigAdd [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9;9;9] [9;9;9]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> (h1, h2) :: (pair t1 t2)\n        | (_,_) -> [] in\n      pair (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in args in\n  add (padZero l1 l2);;\n\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n","type":"","out":""}],"event":{"region":{"start":2584,"stop":3101},"type":"eval"},"cursor":3104,"time":1.398575362861099e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> (h1,h2)::pair t1 t2\n          | (_ , _) -> []\n      in pair (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      args\n  in \n    add (padZero l1 l2)\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(x1, x2) -> \nmatch a with\n(o , z) -> if o + x1 + x2 > 9 \nthen (1, ((o + x1 + x2) mod 10)::z )\nelse (0, (o + x1 + x2)::z)\nin\nlet base = (0, []) in\nlet args = \nlet rec pair list1 list2 = \nmatch (list1, list2) with\n| (h1::t1, h2::t2) -> (h1,h2)::pair t1 t2\n| (_ , _) -> []\nin pair (List.rev l1) (List.rev l2)\nin\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> (h1, h2) :: (pair t1 t2)\n        | (_,_) -> [] in\n      pair (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9] [1;0;0;2]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> (h1, h2) :: (pair t1 t2)\n        | (_,_) -> [] in\n      pair (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9;9;9] [9;9;9]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> (h1, h2) :: (pair t1 t2)\n        | (_,_) -> [] in\n      pair (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n","type":"","out":""}],"event":{"region":{"start":2584,"stop":3113},"type":"eval"},"cursor":3116,"time":1.398575376827885e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> (h1,h2)::pair t1 t2\n          | (_ , _) -> []\n      in pair (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(x1, x2) -> \nmatch a with\n(o , z) -> if o + x1 + x2 > 9 \nthen (1, ((o + x1 + x2) mod 10)::z )\nelse (0, (o + x1 + x2)::z)\nin\nlet base = (0, []) in\nlet args = \nlet rec pair list1 list2 = \nmatch (list1, list2) with\n| (h1::t1, h2::t2) -> (h1,h2)::pair t1 t2\n| (_ , _) -> (0,0)\nin pair (List.rev l1) (List.rev l2)\nin\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> (h1, h2) :: (pair t1 t2)\n        | (_,_) -> (0, 0) in\n      pair (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"type","out":"Characters 332-337:\n  | (_ , _) -> (0,0)\n               ^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type ('c * 'd) list\n"},{"in":"let _ = bigAdd [9;9] [1;0;0;2]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> (h1, h2) :: (pair t1 t2)\n        | (_,_) -> [] in\n      pair (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9;9;9] [9;9;9]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> (h1, h2) :: (pair t1 t2)\n        | (_,_) -> [] in\n      pair (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n","type":"","out":""}],"event":{"region":{"start":2584,"stop":3116},"type":"eval"},"cursor":3119,"time":1.398575571113426e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> (h1,h2)::pair t1 t2\n          | (_ , _) -> (0,0)\n      in pair (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(x1, x2) -> \nmatch a with\n(o , z) -> if o + x1 + x2 > 9 \nthen (1, ((o + x1 + x2) mod 10)::z )\nelse (0, (o + x1 + x2)::z)\nin\nlet base = (0, []) in\nlet args = \nlet rec pair list1 list2 = \nmatch (list1, list2) with\n| (h1::t1, h2::t2) -> (h1,h2)::pair t1 t2\n| (_ , _) -> [(0,0)]\nin pair (List.rev l1) (List.rev l2)\nin\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> (h1, h2) :: (pair t1 t2)\n        | (_,_) -> [(0, 0)] in\n      pair (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9] [1;0;0;2]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> (h1, h2) :: (pair t1 t2)\n        | (_,_) -> [(0, 0)] in\n      pair (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9;9;9] [9;9;9]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> (h1, h2) :: (pair t1 t2)\n        | (_,_) -> [(0, 0)] in\n      pair (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n","type":"","out":""}],"event":{"region":{"start":2584,"stop":3118},"type":"eval"},"cursor":3121,"time":1.398575580721787e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> (h1,h2)::pair t1 t2\n          | (_ , _) -> [(0,0)]\n      in pair (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec mulByDigit i l =\nlet helper a i l = match l with\n| [] -> a\n| h::t -> let a' = h*i::a in\nhelper a' i t\nin helper [] i l","min":"\nlet rec mulByDigit i l =\n  let helper a i l =\n    match l with | [] -> a | h::t -> let a' = (h * i) :: a in helper a' i t in\n  helper [] i l;;\n","type":"scope","out":"Characters 96-102:\n  helper a' i t\n  ^^^^^^\nError: Unbound value helper\n"}],"event":{"region":{"start":3118,"stop":3251},"type":"eval"},"cursor":3251,"time":1.398576020845708e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> (h1,h2)::pair t1 t2\n          | (_ , _) -> [(0,0)]\n      in pair (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\n\nlet rec mulByDigit i l =\n  let helper a i l = match l with\n    | [] -> a\n    | h::t -> let a' = h*i::a in\n          helper a' i t\n  in helper [] i l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec mulByDigit i l =\nlet rec helper a i l = match l with\n| [] -> a\n| h::t -> let a' = h*i::a in\nhelper a' i t\nin helper [] i l","min":"\nlet rec mulByDigit i l =\n  let rec helper a i l =\n    match l with | [] -> a | h::t -> let a' = (h * i) :: a in helper a' i t in\n  helper [] i l;;\n","type":"","out":""}],"event":{"region":{"start":3118,"stop":3255},"type":"eval"},"cursor":3255,"time":1.39857602772532e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> (h1,h2)::pair t1 t2\n          | (_ , _) -> [(0,0)]\n      in pair (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\n\nlet rec mulByDigit i l =\n  let rec helper a i l = match l with\n    | [] -> a\n    | h::t -> let a' = h*i::a in\n          helper a' i t\n  in helper [] i l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = mulByDigit 9 [9;9;9;9]","min":"\nlet rec mulByDigit i l =\n  let rec helper a i l =\n    match l with | [] -> a | h::t -> let a' = (h * i) :: a in helper a' i t in\n  helper [] i l;;\n\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n","type":"","out":""}],"event":{"region":{"start":3255,"stop":3288},"type":"eval"},"cursor":3288,"time":1.398576036198106e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> (h1,h2)::pair t1 t2\n          | (_ , _) -> [(0,0)]\n      in pair (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\n\nlet rec mulByDigit i l =\n  let rec helper a i l = match l with\n    | [] -> a\n    | h::t -> let a' = h*i::a in\n          helper a' i t\n  in helper [] i l\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec mulByDigit i l =\nlet rec helper a c i l = match l with\n| [] -> a\n| h::t -> let x = (h*i + c) in \nlet n = if x > 9 then x mod 10 else x in\nlet c' = if x > 9 then x - 10 else 0 in\nlet a' = n::a in\nhelper a' c' i t\nin helper [] 0 i l","min":"\nlet rec mulByDigit i l =\n  let rec helper a c i l =\n    match l with\n    | [] -> a\n    | h::t ->\n        let x = (h * i) + c in\n        let n = if x > 9 then x mod 10 else x in\n        let c' = if x > 9 then x - 10 else 0 in\n        let a' = n :: a in helper a' c' i t in\n  helper [] 0 i l;;\n","type":"","out":""},{"in":"let _ = mulByDigit 9 [9;9;9;9]","min":"\nlet rec mulByDigit i l =\n  let rec helper a c i l =\n    match l with\n    | [] -> a\n    | h::t ->\n        let x = (h * i) + c in\n        let n = if x > 9 then x mod 10 else x in\n        let c' = if x > 9 then x - 10 else 0 in\n        let a' = n :: a in helper a' c' i t in\n  helper [] 0 i l;;\n\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n","type":"","out":""}],"event":{"region":{"start":3118,"stop":3396},"type":"eval"},"cursor":3396,"time":1.398576276811194e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> (h1,h2)::pair t1 t2\n          | (_ , _) -> [(0,0)]\n      in pair (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\n\nlet rec mulByDigit i l =\n  let rec helper a c i l = match l with\n    | [] -> a\n    | h::t -> let x = (h*i + c) in \n        let n = if x > 9 then x mod 10 else x in\n        let c' = if x > 9 then x - 10 else 0 in\n        let a' = n::a in\n          helper a' c' i t\n  in helper [] 0 i l\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec mulByDigit i l =\nlet rec helper acc carry i l = match l with\n| [] -> acc\n| h::t -> let x = (h*i + carry) in \nlet n = if x > 9 then x mod 10 else x in\nlet c' = if x > 9 then x - 10 else 0 in\nlet a' = n::a in\nhelper a' c' i t\nin helper [] 0 i (List.rev l)","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> acc\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let c' = if x > 9 then x - 10 else 0 in\n        let a' = n :: a in helper a' c' i t in\n  helper [] 0 i (List.rev l);;\n","type":"scope","out":"Characters 210-211:\n  let a' = n::a in\n              ^\nError: Unbound value a\n"}],"event":{"region":{"start":3118,"stop":3386},"type":"eval"},"cursor":3386,"time":1.398576377783196e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> (h1,h2)::pair t1 t2\n          | (_ , _) -> [(0,0)]\n      in pair (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> acc\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let c' = if x > 9 then x - 10 else 0 in\n        let a' = n::a in\n          helper a' c' i t\n  in helper [] 0 i (List.rev l)\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec mulByDigit i l =\nlet rec helper acc carry i l = match l with\n| [] -> acc\n| h::t -> let x = (h*i + carry) in \nlet n = if x > 9 then x mod 10 else x in\nlet carry' = if x > 9 then x - 10 else 0 in\nlet acc' = n::acc in\nhelper acc' carry' i t\nin helper [] 0 i (List.rev l)","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> acc\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x - 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev l);;\n","type":"","out":""}],"event":{"region":{"start":3118,"stop":3400},"type":"eval"},"cursor":3400,"time":1.398576392906515e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> (h1,h2)::pair t1 t2\n          | (_ , _) -> [(0,0)]\n      in pair (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> acc\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x - 10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev l)\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = mulByDigit 9 [9;9;9;9]","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> acc\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x - 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev l);;\n\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n","type":"","out":""}],"event":{"region":{"start":3400,"stop":3433},"type":"eval"},"cursor":3433,"time":1.398576395617249e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> (h1,h2)::pair t1 t2\n          | (_ , _) -> [(0,0)]\n      in pair (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> acc\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x - 10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev l)\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec mulByDigit i l =\nlet rec helper acc carry i l = match l with\n| [] -> acc\n| h::t -> let x = (h*i + carry) in \nlet n = if x > 9 then x mod 10 else x in\nlet carry' = if x > 9 then x/10 else 0 in\nlet acc' = n::acc in\nhelper acc' carry' i t\nin helper [] 0 i (List.rev l)","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> acc\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev l);;\n","type":"","out":""}],"event":{"region":{"start":3118,"stop":3398},"type":"eval"},"cursor":3398,"time":1.398576497417465e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> (h1,h2)::pair t1 t2\n          | (_ , _) -> [(0,0)]\n      in pair (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> acc\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev l)\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = mulByDigit 9 [9;9;9;9]","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> acc\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev l);;\n\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n","type":"","out":""}],"event":{"region":{"start":3398,"stop":3431},"type":"eval"},"cursor":3431,"time":1.398576500799421e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> (h1,h2)::pair t1 t2\n          | (_ , _) -> [(0,0)]\n      in pair (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> acc\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev l)\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[],"event":{"region":{"start":3118,"stop":7775},"type":"eval"},"cursor":3402,"time":1.398576529934559e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> (h1,h2)::pair t1 t2\n          | (_ , _) -> [(0,0)]\n      in pair (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> acc\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l)\n\n\n                    let _ = mulByDigit 9 [9;9;9;9]\n\n                    let bigMul l1 l2 = \n                      let f a x = failwith \"to be implemented\" in\n                      let base = failwith \"to be implemented\" in\n                      let args = failwith \"to be implemented\" in\n                      let (_, res) = List.fold_left f base args in\n                        res\n\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n                    let key = \"\" (*XXXXXXXX*)\n                    let prefix130 = \"130\" (*XXXXXXXX*)\n                    let print130 s = print_string (prefix130^\">>\"^s)\n\n                    exception ErrorCode of string\n\n                    type result = Pass | Fail | ErrorCode of string\n\n                    let score = ref 0\n                    let max = ref 0\n                    let timeout = 300\n\n                    let runWTimeout (f,arg,out,time) = \n                      try if compare (f arg) out = 0 then Pass else Fail\n                      with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\n                    exception TestException\n                    let testTest () =\n                      let testGood x = 1 in\n                      let testBad x = 0 in \n                      let testException x = raise TestException in\n                      let rec testTimeout x = testTimeout x in\n                        runWTimeout(testGood,0,1,5) = Pass &&  \n                        runWTimeout(testBad,0,1,5) = Fail &&  \n                        runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n                        runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\n                    let runTest (f,arg,out,points,name) =\n                      let _ = max := !max + points in\n                      let outs = \n                        match runWTimeout(f,arg,out,timeout) with \n                            Pass -> (score := !score + points; \"[pass]\")\n                          | Fail -> \"[fail]\"\n                          | ErrorCode e -> \"[error: \"^e^\"]\"  in\n                        name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let explode s = \n                      let rec _exp i = \n                        if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n                        _exp 0\n\n                    let implode cs = \n                      String.concat \"\" (List.map (String.make 1) cs)\n\n                    let drop_paren s = \n                      implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\n                    let eq_real p (r1,r2) = \n                      (r1 -. r2) < p || (r2 -. r1) < p\n\n                    let wrap_curried_2 f (a,b) = f a b\n\n                    let runAllTests () =\n                      let _ = (score := 0; max := 0) in\n                      let report = \n                        [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n                         runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n                         runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n                         runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n                         runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n                         runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n                         runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n                         runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n                         runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n                         runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n                         runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n                         runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n                         runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n                         runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n                         runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n                         runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n                         runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n                         runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n                         runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n                         runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n                         runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n                         runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n                         runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n                         runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n                         runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n                        ] in\n                      let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n                      let _ = List.iter print130 (report@([s])) in\n                        (!score,!max)\n\n                    let _ = runAllTests ()\n\n                    let _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec mulByDigit i l =\nlet rec helper acc carry i l = match l with\n| [] -> acc\n| h::t -> let x = (h*i + carry) in \nlet n = if x > 9 then x mod 10 else x in\nlet carry' = if x > 9 then x/10 else 0 in\nlet acc' = n::acc in\nhelper acc' carry' i t\nin helper [] 0 i (List.rev (0::l))","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> acc\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n","type":"","out":""}],"event":{"region":{"start":3118,"stop":3403},"type":"eval"},"cursor":3403,"time":1.398576538376656e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> (h1,h2)::pair t1 t2\n          | (_ , _) -> [(0,0)]\n      in pair (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> acc\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = mulByDigit 9 [9;9;9;9]","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> acc\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n","type":"","out":""}],"event":{"region":{"start":3403,"stop":3436},"type":"eval"},"cursor":3436,"time":1.398576540818683e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> (h1,h2)::pair t1 t2\n          | (_ , _) -> [(0,0)]\n      in pair (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> acc\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let sqsum xs = \nlet f a x =  a + x*x in\nlet base = 0 in\nList.fold_left f base xs","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n","type":"","out":""},{"in":"let _ = sqsum []","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [];;\n","type":"","out":""},{"in":"let _ = sqsum [1;2;3;4]","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sqsum [(-1); (-2); (-3); (-4)]","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [(-1); (-2); (-3); (-4)];;\n","type":"","out":""},{"in":"let pipe fs = \nlet f a x = x a in\nlet base =  fun y ->  y in\nList.fold_left f base fs","min":"\nlet pipe fs = let f a x = x a in let base y = y in List.fold_left f base fs;;\n","type":"","out":""},{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x  in\nlet base = h in\nlet l = t in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n","type":"","out":""},{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"---\" []","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"---\" [];;\n","type":"","out":""},{"in":"let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"\" [\"a\"; \"b\"; \"c\"; \"d\"; \"e\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"X\" [\"hello\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"X\" [\"hello\"];;\n","type":"","out":""},{"in":"let stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n","type":"","out":""},{"in":"let _ = stringOfList string_of_int [1;2;3;4;5;6]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n\nlet _ = stringOfList string_of_int [1; 2; 3; 4; 5; 6];;\n","type":"","out":""},{"in":"let _ = stringOfList (fun x -> x) [\"foo\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n\nlet _ = stringOfList (fun x  -> x) [\"foo\"];;\n","type":"","out":""},{"in":"let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n\nlet _ =\n  stringOfList (stringOfList string_of_int) [[1; 2; 3]; [4; 5]; [6]; []];;\n","type":"","out":""},{"in":"let rec clone x n = \nlet rec helper a x n =\nif n <= 0 then a\nelse \nlet a' = x::a in\nhelper a' x (n-1)\nin helper [] x n","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n","type":"","out":""},{"in":"let _ = clone 3 5","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet _ = clone 3 5;;\n","type":"","out":""},{"in":"let _ = clone \"foo\" 2","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet _ = clone \"foo\" 2;;\n","type":"","out":""},{"in":"let _ = clone clone (-3)","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet _ = clone clone (-3);;\n","type":"","out":""},{"in":"let padZero l1 l2 = \nlet length1 = List.length l1 in\nlet length2 = List.length l2 in\nif length1 > length2 then \n(l1, List.append (clone 0 (length1 - length2)) l2)\nelse if length2 > length1 then \n(List.append (clone 0 (length2 - length1)) l1, l2)\nelse (l1,l2)","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n","type":"","out":""},{"in":"let _ = padZero [9;9] [1;0;0;2]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet _ = padZero [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = padZero [1;0;0;2] [9;9]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet _ = padZero [1; 0; 0; 2] [9; 9];;\n","type":"","out":""},{"in":"let rec removeZero l = match l with\n| [] -> []\n| h::t -> if h = 0 then removeZero t else l","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;1;0;0;2]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet _ = removeZero [0; 0; 0; 1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = removeZero [9;9]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet _ = removeZero [9; 9];;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;0]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet _ = removeZero [0; 0; 0; 0];;\n","type":"","out":""},{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(x1, x2) -> \nmatch a with\n(o , z) -> if o + x1 + x2 > 9 \nthen (1, ((o + x1 + x2) mod 10)::z )\nelse (0, (o + x1 + x2)::z)\nin\nlet base = (0, []) in\nlet args = \nlet rec pair acc list1 list2 = \nmatch (list1, list2) with\n| (h1::t1, h2::t2) -> pair (h1,h2)::acc t1 t2\n| (_ , _) -> acc\nin pair [(0,0)] (List.rev l1) (List.rev l2)\nin\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> (pair (h1, h2)) :: (acc t1 t2)\n        | (_,_) -> acc in\n      pair [(0, 0)] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"type","out":"Characters 303-315:\n  | (h1::t1, h2::t2) -> pair (h1,h2)::acc t1 t2\n                        ^^^^^^^^^^^^\nError: This expression has type 'a list -> 'b list -> 'c list\n       but an expression was expected of type 'c\n       The type variable 'c occurs inside 'a list -> 'b list -> 'c list\n"}],"event":{"region":{"start":0,"stop":3062},"type":"eval"},"cursor":3061,"time":1.398639639472048e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair acc list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> pair (h1,h2)::acc t1 t2\n          | (_ , _) -> acc\n      in pair [(0,0)] (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> acc\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\nlet bigMul l1 l2 = \n  let f a x =  in\n  let base = failwith \"to be implemented\" in\n  let args = \n    let rec digitProducts in\n    let (_, res) = List.fold_left f base args in\n      res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(x1, x2) -> \nmatch a with\n(o , z) -> if o + x1 + x2 > 9 \nthen (1, ((o + x1 + x2) mod 10)::z )\nelse (0, (o + x1 + x2)::z)\nin\nlet base = (0, []) in\nlet args = \nlet rec pair acc list1 list2 = \nmatch (list1, list2) with\n| (h1::t1, h2::t2) -> pair ((h1,h2)::acc) t1 t2\n| (_ , _) -> acc\nin pair [(0,0)] (List.rev l1) (List.rev l2)\nin\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair ((h1, h2) :: acc) t1 t2\n        | (_,_) -> acc in\n      pair [(0, 0)] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"","out":""}],"event":{"region":{"start":2584,"stop":3064},"type":"eval"},"cursor":3064,"time":1.398639656940755e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair acc list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> pair ((h1,h2)::acc) t1 t2\n          | (_ , _) -> acc\n      in pair [(0,0)] (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> acc\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\nlet bigMul l1 l2 = \n  let f a x =  in\n  let base = failwith \"to be implemented\" in\n  let args = \n    let rec digitProducts in\n    let (_, res) = List.fold_left f base args in\n      res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = bigAdd [9;9] [1;0;0;2]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair ((h1, h2) :: acc) t1 t2\n        | (_,_) -> acc in\n      pair [(0, 0)] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9;9;9] [9;9;9]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair ((h1, h2) :: acc) t1 t2\n        | (_,_) -> acc in\n      pair [(0, 0)] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n","type":"","out":""}],"event":{"region":{"start":3064,"stop":3132},"type":"eval"},"cursor":3135,"time":1.398639660063596e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair acc list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> pair ((h1,h2)::acc) t1 t2\n          | (_ , _) -> acc\n      in pair [(0,0)] (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> acc\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\nlet bigMul l1 l2 = \n  let f a x =  in\n  let base = failwith \"to be implemented\" in\n  let args = \n    let rec digitProducts in\n    let (_, res) = List.fold_left f base args in\n      res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(x1, x2) -> \nmatch a with\n(o , z) -> if o + x1 + x2 > 9 \nthen (1, ((o + x1 + x2) mod 10)::z )\nelse (0, (o + x1 + x2)::z)\nin\nlet base = (0, []) in\nlet args = \nlet rec pair acc list1 list2 = \nmatch (list1, list2) with\n| (h1::t1, h2::t2) -> pair (List.append acc (h1,h2)) t1 t2\n| (_ , _) -> acc\nin pair [(0,0)] (List.rev l1) (List.rev l2)\nin\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc (h1, h2)) t1 t2\n        | (_,_) -> acc in\n      pair [(0, 0)] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"type","out":"Characters 325-332:\n  | (h1::t1, h2::t2) -> pair (List.append acc (h1,h2)) t1 t2\n                                              ^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"},{"in":"let _ = bigAdd [9;9] [1;0;0;2]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair ((h1, h2) :: acc) t1 t2\n        | (_,_) -> acc in\n      pair [(0, 0)] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9;9;9] [9;9;9]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair ((h1, h2) :: acc) t1 t2\n        | (_,_) -> acc in\n      pair [(0, 0)] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n","type":"","out":""}],"event":{"region":{"start":2584,"stop":3143},"type":"eval"},"cursor":3146,"time":1.398639719107216e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair acc list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> pair (List.append acc (h1,h2)) t1 t2\n          | (_ , _) -> acc\n      in pair [(0,0)] (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> acc\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\nlet bigMul l1 l2 = \n  let f a x =  in\n  let base = failwith \"to be implemented\" in\n  let args = \n    let rec digitProducts in\n    let (_, res) = List.fold_left f base args in\n      res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(x1, x2) -> \nmatch a with\n(o , z) -> if o + x1 + x2 > 9 \nthen (1, ((o + x1 + x2) mod 10)::z )\nelse (0, (o + x1 + x2)::z)\nin\nlet base = (0, []) in\nlet args = \nlet rec pair acc list1 list2 = \nmatch (list1, list2) with\n| (h1::t1, h2::t2) -> pair (List.append acc [(h1,h2)]) t1 t2\n| (_ , _) -> acc\nin pair [(0,0)] (List.rev l1) (List.rev l2)\nin\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> acc in\n      pair [(0, 0)] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9] [1;0;0;2]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> acc in\n      pair [(0, 0)] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9;9;9] [9;9;9]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> acc in\n      pair [(0, 0)] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n","type":"","out":""}],"event":{"region":{"start":2584,"stop":3145},"type":"eval"},"cursor":3148,"time":1.398639727672865e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair acc list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> pair (List.append acc [(h1,h2)]) t1 t2\n          | (_ , _) -> acc\n      in pair [(0,0)] (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> acc\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\nlet bigMul l1 l2 = \n  let f a x =  in\n  let base = failwith \"to be implemented\" in\n  let args = \n    let rec digitProducts in\n    let (_, res) = List.fold_left f base args in\n      res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(x1, x2) -> \nmatch a with\n(o , z) -> if o + x1 + x2 > 9 \nthen (1, ((o + x1 + x2) mod 10)::z )\nelse (0, (o + x1 + x2)::z)\nin\nlet base = (0, []) in\nlet args = \nlet rec pair acc list1 list2 = \nmatch (list1, list2) with\n| (h1::t1, h2::t2) -> pair (List.append acc [(h1,h2)]) t1 t2\n| (_ , _) -> (0,0)::acc\nin pair [] (List.rev l1) (List.rev l2)\nin\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> (0, 0) :: acc in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9] [1;0;0;2]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> (0, 0) :: acc in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9;9;9] [9;9;9]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> (0, 0) :: acc in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n","type":"","out":""}],"event":{"region":{"start":2584,"stop":3147},"type":"eval"},"cursor":3150,"time":1.398639834976095e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair acc list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> pair (List.append acc [(h1,h2)]) t1 t2\n          | (_ , _) -> (0,0)::acc\n      in pair [] (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> acc\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\nlet bigMul l1 l2 = \n  let f a x =  in\n  let base = failwith \"to be implemented\" in\n  let args = \n    let rec digitProducts in\n    let (_, res) = List.fold_left f base args in\n      res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(x1, x2) -> \nmatch a with\n(o , z) -> if o + x1 + x2 > 9 \nthen (1, ((o + x1 + x2) mod 10)::z )\nelse (0, (o + x1 + x2)::z)\nin\nlet base = (0, []) in\nlet args = \nlet rec pair acc list1 list2 = \nmatch (list1, list2) with\n| (h1::t1, h2::t2) -> pair (List.append acc (h1,h2)) t1 t2\n| (_ , _) -> List.append acc (0,0)\nin pair [] (List.rev l1) (List.rev l2)\nin\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc (h1, h2)) t1 t2\n        | (_,_) -> List.append acc (0, 0) in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"type","out":"Characters 325-332:\n  | (h1::t1, h2::t2) -> pair (List.append acc (h1,h2)) t1 t2\n                                              ^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"},{"in":"let _ = bigAdd [9;9] [1;0;0;2]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> (0, 0) :: acc in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9;9;9] [9;9;9]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> (0, 0) :: acc in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n","type":"","out":""}],"event":{"region":{"start":2584,"stop":3156},"type":"eval"},"cursor":3159,"time":1.398640062583245e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair acc list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> pair (List.append acc (h1,h2)) t1 t2\n          | (_ , _) -> List.append acc (0,0)\n      in pair [] (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> acc\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\nlet bigMul l1 l2 = \n  let f a x =  in\n  let base = failwith \"to be implemented\" in\n  let args = \n    let rec digitProducts in\n    let (_, res) = List.fold_left f base args in\n      res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(x1, x2) -> \nmatch a with\n(o , z) -> if o + x1 + x2 > 9 \nthen (1, ((o + x1 + x2) mod 10)::z )\nelse (0, (o + x1 + x2)::z)\nin\nlet base = (0, []) in\nlet args = \nlet rec pair acc list1 list2 = \nmatch (list1, list2) with\n| (h1::t1, h2::t2) -> pair (List.append acc [(h1,h2)]) t1 t2\n| (_ , _) -> List.append acc [(0,0)]\nin pair [] (List.rev l1) (List.rev l2)\nin\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"","out":""}],"event":{"region":{"start":2584,"stop":3092},"type":"eval"},"cursor":2958,"time":1.398640085024387e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair acc list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> pair (List.append acc [(h1,h2)]) t1 t2\n          | (_ , _) -> List.append acc [(0,0)]\n      in pair [] (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> acc\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\nlet bigMul l1 l2 = \n  let f a x =  in\n  let base = failwith \"to be implemented\" in\n  let args = \n    let rec digitProducts in\n    let (_, res) = List.fold_left f base args in\n      res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = bigAdd [9;9] [1;0;0;2]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9;9;9] [9;9;9]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n","type":"","out":""}],"event":{"region":{"start":3092,"stop":3160},"type":"eval"},"cursor":3163,"time":1.398640089092029e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair acc list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> pair (List.append acc [(h1,h2)]) t1 t2\n          | (_ , _) -> List.append acc [(0,0)]\n      in pair [] (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> acc\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\nlet bigMul l1 l2 = \n  let f a x =  in\n  let base = failwith \"to be implemented\" in\n  let args = \n    let rec digitProducts in\n    let (_, res) = List.fold_left f base args in\n      res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = sepConcat \"a\" []","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"a\" [];;\n","type":"","out":""},{"in":"let _ = sepConcat \"a\" [\"b\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"a\" [\"b\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"\" []","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"\" [];;\n","type":"","out":""},{"in":"let _ = sepConcat \"\" [\"bc\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"\" [\"bc\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"z\" [\"\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"z\" [\"\"];;\n","type":"","out":""}],"event":{"region":{"start":1430,"stop":1562},"type":"eval"},"cursor":1562,"time":1.398640208106599e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair acc list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> pair (List.append acc [(h1,h2)]) t1 t2\n          | (_ , _) -> List.append acc [(0,0)]\n      in pair [] (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> acc\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\nlet bigMul l1 l2 = \n  let f a x =  in\n  let base = failwith \"to be implemented\" in\n  let args = \n    let rec digitProducts in\n    let (_, res) = List.fold_left f base args in\n      res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n","type":"","out":""},{"in":"let _ = stringOfList string_of_int [1;2;3;4;5;6]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n\nlet _ = stringOfList string_of_int [1; 2; 3; 4; 5; 6];;\n","type":"","out":""},{"in":"let _ = stringOfList (fun x -> x) [\"foo\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n\nlet _ = stringOfList (fun x  -> x) [\"foo\"];;\n","type":"","out":""},{"in":"let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n\nlet _ =\n  stringOfList (stringOfList string_of_int) [[1; 2; 3]; [4; 5]; [6]; []];;\n","type":"","out":""}],"event":{"region":{"start":1562,"stop":1799},"type":"eval"},"cursor":1801,"time":1.398640238877349e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair acc list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> pair (List.append acc [(h1,h2)]) t1 t2\n          | (_ , _) -> List.append acc [(0,0)]\n      in pair [] (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> acc\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\nlet bigMul l1 l2 = \n  let f a x =  in\n  let base = failwith \"to be implemented\" in\n  let args = \n    let rec digitProducts in\n    let (_, res) = List.fold_left f base args in\n      res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec clone x n = \nlet rec helper a x n =\nif n <= 0 then a\nelse \nlet a' = x::a in\nhelper a' x (n-1)\nin helper [] x n","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n","type":"","out":""},{"in":"let _ = clone 3 5","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet _ = clone 3 5;;\n","type":"","out":""},{"in":"let _ = clone \"foo\" 2","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet _ = clone \"foo\" 2;;\n","type":"","out":""},{"in":"let _ = clone clone (-3)","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet _ = clone clone (-3);;\n","type":"","out":""},{"in":"let padZero l1 l2 = \nlet length1 = List.length l1 in\nlet length2 = List.length l2 in\nif length1 > length2 then \n(l1, List.append (clone 0 (length1 - length2)) l2)\nelse if length2 > length1 then \n(List.append (clone 0 (length2 - length1)) l1, l2)\nelse (l1,l2)","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n","type":"","out":""},{"in":"let _ = padZero [9;9] [1;0;0;2]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet _ = padZero [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = padZero [1;0;0;2] [9;9]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet _ = padZero [1; 0; 0; 2] [9; 9];;\n","type":"","out":""},{"in":"let _ = padZero [1;0;0;2] []","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet _ = padZero [1; 0; 0; 2] [];;\n","type":"","out":""},{"in":"let _ = padZero [77] [9;9;4;5;6;7;8;9;0]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet _ = padZero [77] [9; 9; 4; 5; 6; 7; 8; 9; 0];;\n","type":"","out":""}],"event":{"region":{"start":1799,"stop":2601},"type":"eval"},"cursor":2601,"time":1.398640746958549e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]\nlet _ = padZero [1;0;0;2] []\nlet _ = padZero [77] [9;9;4;5;6;7;8;9;0]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair acc list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> pair (List.append acc [(h1,h2)]) t1 t2\n          | (_ , _) -> List.append acc [(0,0)]\n      in pair [] (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> acc\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\nlet bigMul l1 l2 = \n  let f a x =  in\n  let base = failwith \"to be implemented\" in\n  let args = \n    let rec digitProducts acc =\n\n      let (_, res) = List.fold_left f base args in\n        res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = padZero [] []","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet _ = padZero [] [];;\n","type":"","out":""}],"event":{"region":{"start":2601,"stop":2623},"type":"eval"},"cursor":2623,"time":1.398640778126455e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]\nlet _ = padZero [1;0;0;2] []\nlet _ = padZero [77] [9;9;4;5;6;7;8;9;0]\nlet _ = padZero [] []\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair acc list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> pair (List.append acc [(h1,h2)]) t1 t2\n          | (_ , _) -> List.append acc [(0,0)]\n      in pair [] (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> acc\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\nlet bigMul l1 l2 = \n  let f a x =  in\n  let base = failwith \"to be implemented\" in\n  let args = \n    let rec digitProducts acc =\n\n      let (_, res) = List.fold_left f base args in\n        res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = padZero [] [9]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet _ = padZero [] [9];;\n","type":"","out":""}],"event":{"region":{"start":2623,"stop":2646},"type":"eval"},"cursor":2641,"time":1.398640786621335e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]\nlet _ = padZero [1;0;0;2] []\nlet _ = padZero [77] [9;9;4;5;6;7;8;9;0]\nlet _ = padZero [] []\nlet _ = padZero [] [9]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair acc list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> pair (List.append acc [(h1,h2)]) t1 t2\n          | (_ , _) -> List.append acc [(0,0)]\n      in pair [] (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> acc\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\nlet bigMul l1 l2 = \n  let f a x =  in\n  let base = failwith \"to be implemented\" in\n  let args = \n    let rec digitProducts acc =\n\n      let (_, res) = List.fold_left f base args in\n        res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = padZero [0;0] [1;0;1]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet _ = padZero [0; 0] [1; 0; 1];;\n","type":"","out":""}],"event":{"region":{"start":2646,"stop":2676},"type":"eval"},"cursor":2664,"time":1.398640799665391e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]\nlet _ = padZero [1;0;0;2] []\nlet _ = padZero [77] [9;9;4;5;6;7;8;9;0]\nlet _ = padZero [] []\nlet _ = padZero [] [9]\nlet _ = padZero [0;0] [1;0;1]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair acc list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> pair (List.append acc [(h1,h2)]) t1 t2\n          | (_ , _) -> List.append acc [(0,0)]\n      in pair [] (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> acc\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\nlet bigMul l1 l2 = \n  let f a x =  in\n  let base = failwith \"to be implemented\" in\n  let args = \n    let rec digitProducts acc =\n\n      let (_, res) = List.fold_left f base args in\n        res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = padZero [0;0] [0;1]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet _ = padZero [0; 0] [0; 1];;\n","type":"","out":""}],"event":{"region":{"start":2646,"stop":2674},"type":"eval"},"cursor":2670,"time":1.398640805442187e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]\nlet _ = padZero [1;0;0;2] []\nlet _ = padZero [77] [9;9;4;5;6;7;8;9;0]\nlet _ = padZero [] []\nlet _ = padZero [] [9]\nlet _ = padZero [0;0] [0;1]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair acc list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> pair (List.append acc [(h1,h2)]) t1 t2\n          | (_ , _) -> List.append acc [(0,0)]\n      in pair [] (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> acc\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\nlet bigMul l1 l2 = \n  let f a x =  in\n  let base = failwith \"to be implemented\" in\n  let args = \n    let rec digitProducts acc =\n\n      let (_, res) = List.fold_left f base args in\n        res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = padZero [0;0] [1]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet _ = padZero [0; 0] [1];;\n","type":"","out":""}],"event":{"region":{"start":2646,"stop":2672},"type":"eval"},"cursor":2670,"time":1.39864081773036e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]\nlet _ = padZero [1;0;0;2] []\nlet _ = padZero [77] [9;9;4;5;6;7;8;9;0]\nlet _ = padZero [] []\nlet _ = padZero [] [9]\nlet _ = padZero [0;0] [1]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair acc list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> pair (List.append acc [(h1,h2)]) t1 t2\n          | (_ , _) -> List.append acc [(0,0)]\n      in pair [] (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> acc\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\nlet bigMul l1 l2 = \n  let f a x =  in\n  let base = failwith \"to be implemented\" in\n  let args = \n    let rec digitProducts acc =\n\n      let (_, res) = List.fold_left f base args in\n        res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec removeZero l = match l with\n| [] -> []\n| h::t -> if h = 0 then removeZero t else l","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;1;0;0;2]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet _ = removeZero [0; 0; 0; 1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = removeZero [9;9]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet _ = removeZero [9; 9];;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;0]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet _ = removeZero [0; 0; 0; 0];;\n","type":"","out":""},{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(x1, x2) -> \nmatch a with\n(o , z) -> if o + x1 + x2 > 9 \nthen (1, ((o + x1 + x2) mod 10)::z )\nelse (0, (o + x1 + x2)::z)\nin\nlet base = (0, []) in\nlet args = \nlet rec pair acc list1 list2 = \nmatch (list1, list2) with\n| (h1::t1, h2::t2) -> pair (List.append acc [(h1,h2)]) t1 t2\n| (_ , _) -> List.append acc [(0,0)]\nin pair [] (List.rev l1) (List.rev l2)\nin\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9] [1;0;0;2]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9;9;9] [9;9;9]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigAdd [1;2;3] []","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [1; 2; 3] [];;\n","type":"","out":""},{"in":"let _ = bigAdd [] []","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [] [];;\n","type":"","out":""},{"in":"let _ = bigAdd [] [3;4;5]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [] [3; 4; 5];;\n","type":"","out":""},{"in":"let _ = bigAdd [1] [9;9;9]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [1] [9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigAdd [0;0;0] [9;9;9]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [0; 0; 0] [9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigAdd [0;0;0;0] [9;9;9]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [0; 0; 0; 0] [9; 9; 9];;\n","type":"","out":""}],"event":{"region":{"start":2672,"stop":3609},"type":"eval"},"cursor":3611,"time":1.398640915423294e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]\nlet _ = padZero [1;0;0;2] []\nlet _ = padZero [77] [9;9;4;5;6;7;8;9;0]\nlet _ = padZero [] []\nlet _ = padZero [] [9]\nlet _ = padZero [0;0] [1]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair acc list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> pair (List.append acc [(h1,h2)]) t1 t2\n          | (_ , _) -> List.append acc [(0,0)]\n      in pair [] (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [1;2;3] [];;\nlet _ = bigAdd [] [];;\nlet _ = bigAdd [] [3;4;5];;\nlet _ = bigAdd [1] [9;9;9];;\nlet _ = bigAdd [0;0;0] [9;9;9];;\nlet _ = bigAdd [0;0;0;0] [9;9;9];;\n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> acc\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\nlet bigMul l1 l2 = \n  let f a x =  in\n  let base = failwith \"to be implemented\" in\n  let args = \n    let rec digitProducts acc =\n\n      let (_, res) = List.fold_left f base args in\n        res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = bigAdd [0] []","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [0] [];;\n","type":"","out":""},{"in":"let _ = bigAdd [3] []","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [3] [];;\n","type":"","out":""},{"in":"let _ = bigAdd [0] [0]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [0] [0];;\n","type":"","out":""}],"event":{"region":{"start":3609,"stop":3682},"type":"eval"},"cursor":3684,"time":1.398641038324256e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]\nlet _ = padZero [1;0;0;2] []\nlet _ = padZero [77] [9;9;4;5;6;7;8;9;0]\nlet _ = padZero [] []\nlet _ = padZero [] [9]\nlet _ = padZero [0;0] [1]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair acc list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> pair (List.append acc [(h1,h2)]) t1 t2\n          | (_ , _) -> List.append acc [(0,0)]\n      in pair [] (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [1;2;3] [];;\nlet _ = bigAdd [] [];;\nlet _ = bigAdd [] [3;4;5];;\nlet _ = bigAdd [1] [9;9;9];;\nlet _ = bigAdd [0;0;0] [9;9;9];;\nlet _ = bigAdd [0;0;0;0] [9;9;9];;\nlet _ = bigAdd [0] [];;\nlet _ = bigAdd [3] [];;\nlet _ = bigAdd [0] [0];;\n\n\n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> acc\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\nlet bigMul l1 l2 = \n  let f a x =  in\n  let base = failwith \"to be implemented\" in\n  let args = \n    let rec digitProducts acc =\n\n      let (_, res) = List.fold_left f base args in\n        res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec mulByDigit i l =\nlet rec helper acc carry i l = match l with\n| [] -> acc\n| h::t -> let x = (h*i + carry) in \nlet n = if x > 9 then x mod 10 else x in\nlet carry' = if x > 9 then x/10 else 0 in\nlet acc' = n::acc in\nhelper acc' carry' i t\nin helper [] 0 i (List.rev (0::l))","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> acc\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n","type":"","out":""},{"in":"let _ = mulByDigit 9 [9;9;9;9]","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> acc\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n","type":"","out":""}],"event":{"region":{"start":3682,"stop":4001},"type":"eval"},"cursor":4001,"time":1.398641126177454e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]\nlet _ = padZero [1;0;0;2] []\nlet _ = padZero [77] [9;9;4;5;6;7;8;9;0]\nlet _ = padZero [] []\nlet _ = padZero [] [9]\nlet _ = padZero [0;0] [1]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair acc list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> pair (List.append acc [(h1,h2)]) t1 t2\n          | (_ , _) -> List.append acc [(0,0)]\n      in pair [] (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [1;2;3] [];;\nlet _ = bigAdd [] [];;\nlet _ = bigAdd [] [3;4;5];;\nlet _ = bigAdd [1] [9;9;9];;\nlet _ = bigAdd [0;0;0] [9;9;9];;\nlet _ = bigAdd [0;0;0;0] [9;9;9];;\nlet _ = bigAdd [0] [];;\nlet _ = bigAdd [3] [];;\nlet _ = bigAdd [0] [0];;\n\n\n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> acc\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\nlet bigMul l1 l2 = \n  let f a x =  in\n  let base = failwith \"to be implemented\" in\n  let args = \n    let rec digitProducts acc =\n\n      let (_, res) = List.fold_left f base args in\n        res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let sqsum xs = \nlet f a x =  a + x*x in\nlet base = 0 in\nList.fold_left f base xs","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n","type":"","out":""},{"in":"let _ = sqsum []","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [];;\n","type":"","out":""},{"in":"let _ = sqsum [1;2;3;4]","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sqsum [(-1); (-2); (-3); (-4)]","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [(-1); (-2); (-3); (-4)];;\n","type":"","out":""},{"in":"let pipe fs = \nlet f a x = x a in\nlet base =  fun y ->  y in\nList.fold_left f base fs","min":"\nlet pipe fs = let f a x = x a in let base y = y in List.fold_left f base fs;;\n","type":"","out":""},{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x  in\nlet base = h in\nlet l = t in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n","type":"","out":""},{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"---\" []","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"---\" [];;\n","type":"","out":""},{"in":"let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"\" [\"a\"; \"b\"; \"c\"; \"d\"; \"e\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"X\" [\"hello\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"X\" [\"hello\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"a\" []","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"a\" [];;\n","type":"","out":""},{"in":"let _ = sepConcat \"a\" [\"b\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"a\" [\"b\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"\" []","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"\" [];;\n","type":"","out":""},{"in":"let _ = sepConcat \"\" [\"bc\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"\" [\"bc\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"z\" [\"\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"z\" [\"\"];;\n","type":"","out":""},{"in":"let stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n","type":"","out":""},{"in":"let _ = stringOfList string_of_int [1;2;3;4;5;6]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n\nlet _ = stringOfList string_of_int [1; 2; 3; 4; 5; 6];;\n","type":"","out":""},{"in":"let _ = stringOfList (fun x -> x) [\"foo\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n\nlet _ = stringOfList (fun x  -> x) [\"foo\"];;\n","type":"","out":""},{"in":"let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n\nlet _ =\n  stringOfList (stringOfList string_of_int) [[1; 2; 3]; [4; 5]; [6]; []];;\n","type":"","out":""},{"in":"let rec clone x n = \nlet rec helper a x n =\nif n <= 0 then a\nelse \nlet a' = x::a in\nhelper a' x (n-1)\nin helper [] x n","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n","type":"","out":""},{"in":"let _ = clone 3 5","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet _ = clone 3 5;;\n","type":"","out":""},{"in":"let _ = clone \"foo\" 2","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet _ = clone \"foo\" 2;;\n","type":"","out":""},{"in":"let _ = clone clone (-3)","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet _ = clone clone (-3);;\n","type":"","out":""},{"in":"let padZero l1 l2 = \nlet length1 = List.length l1 in\nlet length2 = List.length l2 in\nif length1 > length2 then \n(l1, List.append (clone 0 (length1 - length2)) l2)\nelse if length2 > length1 then \n(List.append (clone 0 (length2 - length1)) l1, l2)\nelse (l1,l2)","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n","type":"","out":""},{"in":"let _ = padZero [9;9] [1;0;0;2]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet _ = padZero [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = padZero [1;0;0;2] [9;9]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet _ = padZero [1; 0; 0; 2] [9; 9];;\n","type":"","out":""},{"in":"let _ = padZero [1;0;0;2] []","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet _ = padZero [1; 0; 0; 2] [];;\n","type":"","out":""},{"in":"let _ = padZero [77] [9;9;4;5;6;7;8;9;0]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet _ = padZero [77] [9; 9; 4; 5; 6; 7; 8; 9; 0];;\n","type":"","out":""},{"in":"let _ = padZero [] []","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet _ = padZero [] [];;\n","type":"","out":""},{"in":"let _ = padZero [] [9]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet _ = padZero [] [9];;\n","type":"","out":""},{"in":"let _ = padZero [0;0] [1]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet _ = padZero [0; 0] [1];;\n","type":"","out":""},{"in":"let rec removeZero l = match l with\n| [] -> []\n| h::t -> if h = 0 then removeZero t else l","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;1;0;0;2]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet _ = removeZero [0; 0; 0; 1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = removeZero [9;9]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet _ = removeZero [9; 9];;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;0]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet _ = removeZero [0; 0; 0; 0];;\n","type":"","out":""},{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(x1, x2) -> \nmatch a with\n(o , z) -> if o + x1 + x2 > 9 \nthen (1, ((o + x1 + x2) mod 10)::z )\nelse (0, (o + x1 + x2)::z)\nin\nlet base = (0, []) in\nlet args = \nlet rec pair acc list1 list2 = \nmatch (list1, list2) with\n| (h1::t1, h2::t2) -> pair (List.append acc [(h1,h2)]) t1 t2\n| (_ , _) -> List.append acc [(0,0)]\nin pair [] (List.rev l1) (List.rev l2)\nin\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9] [1;0;0;2]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9;9;9] [9;9;9]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigAdd [1;2;3] []","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [1; 2; 3] [];;\n","type":"","out":""},{"in":"let _ = bigAdd [] []","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [] [];;\n","type":"","out":""},{"in":"let _ = bigAdd [] [3;4;5]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [] [3; 4; 5];;\n","type":"","out":""},{"in":"let _ = bigAdd [1] [9;9;9]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [1] [9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigAdd [0;0;0] [9;9;9]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [0; 0; 0] [9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigAdd [0;0;0;0] [9;9;9]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [0; 0; 0; 0] [9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigAdd [0] []","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [0] [];;\n","type":"","out":""},{"in":"let _ = bigAdd [3] []","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [3] [];;\n","type":"","out":""},{"in":"let _ = bigAdd [0] [0]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [0] [0];;\n","type":"","out":""},{"in":"let rec mulByDigit i l =\nlet rec helper acc carry i l = match l with\n| [] -> acc\n| h::t -> let x = (h*i + carry) in \nlet n = if x > 9 then x mod 10 else x in\nlet carry' = if x > 9 then x/10 else 0 in\nlet acc' = n::acc in\nhelper acc' carry' i t\nin helper [] 0 i (List.rev (0::l))","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> acc\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n","type":"","out":""},{"in":"let _ = mulByDigit 9 [9;9;9;9]","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> acc\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let _ = mulByDigit -9 [1;2;3]","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> acc\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit - (9 [1; 2; 3]);;\n","type":"type","out":"Characters 8-18:\n  let _ = mulByDigit -9 [1;2;3];;\n          ^^^^^^^^^^\nError: This expression has type int -> int list -> int list\n       but an expression was expected of type int\n"},{"in":"let _ = mulByDigit 0 [1;2;3]","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> acc\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 0 [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = mulByDigit 1 [1;2;3]","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> acc\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 1 [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = mulByDigit 10 [1;2;3]","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> acc\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 10 [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = mulByDigit 5 [0;0;0]","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> acc\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 5 [0; 0; 0];;\n","type":"","out":""},{"in":"let _ = mulByDigit -5 [0;0;0]","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> acc\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit - (5 [0; 0; 0]);;\n","type":"type","out":"Characters 8-18:\n  let _ = mulByDigit -5 [0;0;0];;\n          ^^^^^^^^^^\nError: This expression has type int -> int list -> int list\n       but an expression was expected of type int\n"},{"in":"let _ = mulByDigit 9 []","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> acc\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 9 [];;\n","type":"","out":""},{"in":"let _ = mulByDigit -9 []","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> acc\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit - (9 []);;\n","type":"type","out":"Characters 8-18:\n  let _ = mulByDigit -9 [];;\n          ^^^^^^^^^^\nError: This expression has type int -> int list -> int list\n       but an expression was expected of type int\n"},{"in":"let _ = mulByDigit 0 []","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> acc\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 0 [];;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":4251},"type":"eval"},"cursor":4251,"time":1.398641291745959e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]\nlet _ = padZero [1;0;0;2] []\nlet _ = padZero [77] [9;9;4;5;6;7;8;9;0]\nlet _ = padZero [] []\nlet _ = padZero [] [9]\nlet _ = padZero [0;0] [1]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair acc list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> pair (List.append acc [(h1,h2)]) t1 t2\n          | (_ , _) -> List.append acc [(0,0)]\n      in pair [] (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [1;2;3] [];;\nlet _ = bigAdd [] [];;\nlet _ = bigAdd [] [3;4;5];;\nlet _ = bigAdd [1] [9;9;9];;\nlet _ = bigAdd [0;0;0] [9;9;9];;\nlet _ = bigAdd [0;0;0;0] [9;9;9];;\nlet _ = bigAdd [0] [];;\nlet _ = bigAdd [3] [];;\nlet _ = bigAdd [0] [0];;\n\n\n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> acc\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\nlet _ = mulByDigit -9 [1;2;3]\nlet _ = mulByDigit 0 [1;2;3]\nlet _ = mulByDigit 1 [1;2;3]\nlet _ = mulByDigit 10 [1;2;3]\nlet _ = mulByDigit 5 [0;0;0]\nlet _ = mulByDigit -5 [0;0;0]\nlet _ = mulByDigit 9 []\nlet _ = mulByDigit -9 []\nlet _ = mulByDigit 0 []\n\n\nlet bigMul l1 l2 = \n  let f a x =  in\n  let base = failwith \"to be implemented\" in\n  let args = \n    let rec digitProducts acc =\n\n      let (_, res) = List.fold_left f base args in\n        res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = mulByDigit (-)9 [1;2;3]","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> acc\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit (-) 9 [1; 2; 3];;\n","type":"type","out":"Characters 8-18:\n  let _ = mulByDigit (-)9 [1;2;3];;\n          ^^^^^^^^^^\nError: This function has type int -> int list -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"},{"in":"let _ = mulByDigit 0 [1;2;3]","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> acc\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 0 [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = mulByDigit 1 [1;2;3]","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> acc\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 1 [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = mulByDigit 10 [1;2;3]","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> acc\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 10 [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = mulByDigit 5 [0;0;0]","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> acc\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 5 [0; 0; 0];;\n","type":"","out":""},{"in":"let _ = mulByDigit -5 [0;0;0]","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> acc\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit - (5 [0; 0; 0]);;\n","type":"type","out":"Characters 8-18:\n  let _ = mulByDigit -5 [0;0;0];;\n          ^^^^^^^^^^\nError: This expression has type int -> int list -> int list\n       but an expression was expected of type int\n"},{"in":"let _ = mulByDigit 9 []","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> acc\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 9 [];;\n","type":"","out":""},{"in":"let _ = mulByDigit -9 []","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> acc\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit - (9 []);;\n","type":"type","out":"Characters 8-18:\n  let _ = mulByDigit -9 [];;\n          ^^^^^^^^^^\nError: This expression has type int -> int list -> int list\n       but an expression was expected of type int\n"},{"in":"let _ = mulByDigit 0 []","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> acc\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 0 [];;\n","type":"","out":""}],"event":{"region":{"start":4001,"stop":4253},"type":"eval"},"cursor":4253,"time":1.398641329059917e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]\nlet _ = padZero [1;0;0;2] []\nlet _ = padZero [77] [9;9;4;5;6;7;8;9;0]\nlet _ = padZero [] []\nlet _ = padZero [] [9]\nlet _ = padZero [0;0] [1]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair acc list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> pair (List.append acc [(h1,h2)]) t1 t2\n          | (_ , _) -> List.append acc [(0,0)]\n      in pair [] (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [1;2;3] [];;\nlet _ = bigAdd [] [];;\nlet _ = bigAdd [] [3;4;5];;\nlet _ = bigAdd [1] [9;9;9];;\nlet _ = bigAdd [0;0;0] [9;9;9];;\nlet _ = bigAdd [0;0;0;0] [9;9;9];;\nlet _ = bigAdd [0] [];;\nlet _ = bigAdd [3] [];;\nlet _ = bigAdd [0] [0];;\n\n\n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> acc\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\nlet _ = mulByDigit (-)9 [1;2;3]\nlet _ = mulByDigit 0 [1;2;3]\nlet _ = mulByDigit 1 [1;2;3]\nlet _ = mulByDigit 10 [1;2;3]\nlet _ = mulByDigit 5 [0;0;0]\nlet _ = mulByDigit -5 [0;0;0]\nlet _ = mulByDigit 9 []\nlet _ = mulByDigit -9 []\nlet _ = mulByDigit 0 []\n\n\nlet bigMul l1 l2 = \n  let f a x =  in\n  let base = failwith \"to be implemented\" in\n  let args = \n    let rec digitProducts acc =\n\n      let (_, res) = List.fold_left f base args in\n        res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = let x = 0 - 9 in\nmulByDigit x [1;2;3]","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> acc\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = let x = 0 - 9 in mulByDigit x [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = mulByDigit 0 [1;2;3]","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> acc\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 0 [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = mulByDigit 1 [1;2;3]","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> acc\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 1 [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = mulByDigit 10 [1;2;3]","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> acc\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 10 [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = let x = 0 - 5 in\nmulByDigit x [0;0;0]","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> acc\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = let x = 0 - 5 in mulByDigit x [0; 0; 0];;\n","type":"","out":""},{"in":"let _ = mulByDigit 5 [0;0;0]","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> acc\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 5 [0; 0; 0];;\n","type":"","out":""},{"in":"let _ = mulByDigit 9 []","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> acc\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 9 [];;\n","type":"","out":""},{"in":"let _ = let x = 0 - 9 in\nmulByDigit x []","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> acc\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = let x = 0 - 9 in mulByDigit x [];;\n","type":"","out":""},{"in":"let _ = mulByDigit 0 []","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> acc\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 0 [];;\n","type":"","out":""}],"event":{"region":{"start":4001,"stop":4299},"type":"eval"},"cursor":4299,"time":1.398641383948306e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]\nlet _ = padZero [1;0;0;2] []\nlet _ = padZero [77] [9;9;4;5;6;7;8;9;0]\nlet _ = padZero [] []\nlet _ = padZero [] [9]\nlet _ = padZero [0;0] [1]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair acc list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> pair (List.append acc [(h1,h2)]) t1 t2\n          | (_ , _) -> List.append acc [(0,0)]\n      in pair [] (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [1;2;3] [];;\nlet _ = bigAdd [] [];;\nlet _ = bigAdd [] [3;4;5];;\nlet _ = bigAdd [1] [9;9;9];;\nlet _ = bigAdd [0;0;0] [9;9;9];;\nlet _ = bigAdd [0;0;0;0] [9;9;9];;\nlet _ = bigAdd [0] [];;\nlet _ = bigAdd [3] [];;\nlet _ = bigAdd [0] [0];;\n\n\n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> acc\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\nlet _ = let x = 0 - 9 in\n    mulByDigit x [1;2;3]\nlet _ = mulByDigit 0 [1;2;3]\nlet _ = mulByDigit 1 [1;2;3]\nlet _ = mulByDigit 10 [1;2;3]\nlet _ = let x = 0 - 5 in\n    mulByDigit x [0;0;0]\nlet _ = mulByDigit 5 [0;0;0]\nlet _ = mulByDigit 9 []\nlet _ = let x = 0 - 9 in\n    mulByDigit x []\nlet _ = mulByDigit 0 []\n\n\nlet bigMul l1 l2 = \n  let f a x =  in\n  let base = failwith \"to be implemented\" in\n  let args = \n    let rec digitProducts acc =\n\n      let (_, res) = List.fold_left f base args in\n        res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec mulByDigit i l =\nlet rec helper acc carry i l = match l with\n| [] -> acc\n| h::t -> let x = (h*i + carry) in \nlet n = if x > 9 then x mod 10 else x in\nlet carry' = if x > 9 then x/10 else 0 in\nlet acc' = n::acc in\nhelper acc' carry' i t\nin helper [] 0 i (List.rev (0::l))","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> acc\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n","type":"","out":""}],"event":{"region":{"start":3690,"stop":3968},"type":"eval"},"cursor":3968,"time":1.398641412614691e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]\nlet _ = padZero [1;0;0;2] []\nlet _ = padZero [77] [9;9;4;5;6;7;8;9;0]\nlet _ = padZero [] []\nlet _ = padZero [] [9]\nlet _ = padZero [0;0] [1]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair acc list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> pair (List.append acc [(h1,h2)]) t1 t2\n          | (_ , _) -> List.append acc [(0,0)]\n      in pair [] (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [1;2;3] [];;\nlet _ = bigAdd [] [];;\nlet _ = bigAdd [] [3;4;5];;\nlet _ = bigAdd [1] [9;9;9];;\nlet _ = bigAdd [0;0;0] [9;9;9];;\nlet _ = bigAdd [0;0;0;0] [9;9;9];;\nlet _ = bigAdd [0] [];;\nlet _ = bigAdd [3] [];;\nlet _ = bigAdd [0] [0];;\n\n\n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> acc\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\nlet _ = let x = 0 - 9 in\n    mulByDigit x [1;2;3]\nlet _ = mulByDigit 0 [1;2;3]\nlet _ = mulByDigit 1 [1;2;3]\nlet _ = mulByDigit 10 [1;2;3]\nlet _ = let x = 0 - 5 in\n    mulByDigit x [0;0;0]\nlet _ = mulByDigit 5 [0;0;0]\nlet _ = mulByDigit 9 []\nlet _ = let x = 0 - 9 in\n    mulByDigit x []\nlet _ = mulByDigit 0 []\n\n\nlet bigMul l1 l2 = \n  let f a x =  in\n  let base = failwith \"to be implemented\" in\n  let args = \n    let rec digitProducts acc =\n\n      let (_, res) = List.fold_left f base args in\n        res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = mulByDigit 9 [9;9;9;9]","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> acc\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let _ = let x = 0 - 9 in\nmulByDigit x [1;2;3]","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> acc\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = let x = 0 - 9 in mulByDigit x [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = mulByDigit 0 [1;2;3]","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> acc\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 0 [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = mulByDigit 1 [1;2;3]","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> acc\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 1 [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = mulByDigit 10 [1;2;3]","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> acc\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 10 [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = let x = 0 - 5 in\nmulByDigit x [0;0;0]","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> acc\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = let x = 0 - 5 in mulByDigit x [0; 0; 0];;\n","type":"","out":""},{"in":"let _ = mulByDigit 5 [0;0;0]","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> acc\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 5 [0; 0; 0];;\n","type":"","out":""},{"in":"let _ = mulByDigit 9 []","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> acc\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 9 [];;\n","type":"","out":""},{"in":"let _ = let x = 0 - 9 in\nmulByDigit x []","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> acc\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = let x = 0 - 9 in mulByDigit x [];;\n","type":"","out":""},{"in":"let _ = mulByDigit 0 []","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> acc\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 0 [];;\n","type":"","out":""}],"event":{"region":{"start":3968,"stop":4299},"type":"eval"},"cursor":4299,"time":1.398641414783292e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]\nlet _ = padZero [1;0;0;2] []\nlet _ = padZero [77] [9;9;4;5;6;7;8;9;0]\nlet _ = padZero [] []\nlet _ = padZero [] [9]\nlet _ = padZero [0;0] [1]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair acc list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> pair (List.append acc [(h1,h2)]) t1 t2\n          | (_ , _) -> List.append acc [(0,0)]\n      in pair [] (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [1;2;3] [];;\nlet _ = bigAdd [] [];;\nlet _ = bigAdd [] [3;4;5];;\nlet _ = bigAdd [1] [9;9;9];;\nlet _ = bigAdd [0;0;0] [9;9;9];;\nlet _ = bigAdd [0;0;0;0] [9;9;9];;\nlet _ = bigAdd [0] [];;\nlet _ = bigAdd [3] [];;\nlet _ = bigAdd [0] [0];;\n\n\n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> acc\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\nlet _ = let x = 0 - 9 in\n    mulByDigit x [1;2;3]\nlet _ = mulByDigit 0 [1;2;3]\nlet _ = mulByDigit 1 [1;2;3]\nlet _ = mulByDigit 10 [1;2;3]\nlet _ = let x = 0 - 5 in\n    mulByDigit x [0;0;0]\nlet _ = mulByDigit 5 [0;0;0]\nlet _ = mulByDigit 9 []\nlet _ = let x = 0 - 9 in\n    mulByDigit x []\nlet _ = mulByDigit 0 []\n\n\nlet bigMul l1 l2 = \n  let f a x =  in\n  let base = failwith \"to be implemented\" in\n  let args = \n    let rec digitProducts acc =\n\n      let (_, res) = List.fold_left f base args in\n        res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec mulByDigit i l =\nlet rec helper acc carry i l = match l with\n| [] -> acc\n| h::t -> let x = (h*i + carry) in \nlet n = if x > 9 then x mod 10 else x in\nlet carry' = if x > 9 then x/10 else 0 in\nlet acc' = n::acc in\nhelper acc' carry' i t\nin removeZero (helper [] 0 i (List.rev (0::l)))","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> acc\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  removeZero (helper [] 0 i (List.rev (0 :: l)));;\n","type":"","out":""},{"in":"let _ = mulByDigit 9 [9;9;9;9]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> acc\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  removeZero (helper [] 0 i (List.rev (0 :: l)));;\n\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let _ = let x = 0 - 9 in\nmulByDigit x [1;2;3]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> acc\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  removeZero (helper [] 0 i (List.rev (0 :: l)));;\n\nlet _ = let x = 0 - 9 in mulByDigit x [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = mulByDigit 0 [1;2;3]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> acc\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  removeZero (helper [] 0 i (List.rev (0 :: l)));;\n\nlet _ = mulByDigit 0 [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = mulByDigit 1 [1;2;3]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> acc\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  removeZero (helper [] 0 i (List.rev (0 :: l)));;\n\nlet _ = mulByDigit 1 [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = mulByDigit 10 [1;2;3]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> acc\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  removeZero (helper [] 0 i (List.rev (0 :: l)));;\n\nlet _ = mulByDigit 10 [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = let x = 0 - 5 in\nmulByDigit x [0;0;0]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> acc\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  removeZero (helper [] 0 i (List.rev (0 :: l)));;\n\nlet _ = let x = 0 - 5 in mulByDigit x [0; 0; 0];;\n","type":"","out":""},{"in":"let _ = mulByDigit 5 [0;0;0]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> acc\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  removeZero (helper [] 0 i (List.rev (0 :: l)));;\n\nlet _ = mulByDigit 5 [0; 0; 0];;\n","type":"","out":""},{"in":"let _ = mulByDigit 9 []","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> acc\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  removeZero (helper [] 0 i (List.rev (0 :: l)));;\n\nlet _ = mulByDigit 9 [];;\n","type":"","out":""},{"in":"let _ = let x = 0 - 9 in\nmulByDigit x []","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> acc\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  removeZero (helper [] 0 i (List.rev (0 :: l)));;\n\nlet _ = let x = 0 - 9 in mulByDigit x [];;\n","type":"","out":""},{"in":"let _ = mulByDigit 0 []","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> acc\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  removeZero (helper [] 0 i (List.rev (0 :: l)));;\n\nlet _ = mulByDigit 0 [];;\n","type":"","out":""}],"event":{"region":{"start":3682,"stop":4312},"type":"eval"},"cursor":4312,"time":1.398641439130734e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]\nlet _ = padZero [1;0;0;2] []\nlet _ = padZero [77] [9;9;4;5;6;7;8;9;0]\nlet _ = padZero [] []\nlet _ = padZero [] [9]\nlet _ = padZero [0;0] [1]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair acc list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> pair (List.append acc [(h1,h2)]) t1 t2\n          | (_ , _) -> List.append acc [(0,0)]\n      in pair [] (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [1;2;3] [];;\nlet _ = bigAdd [] [];;\nlet _ = bigAdd [] [3;4;5];;\nlet _ = bigAdd [1] [9;9;9];;\nlet _ = bigAdd [0;0;0] [9;9;9];;\nlet _ = bigAdd [0;0;0;0] [9;9;9];;\nlet _ = bigAdd [0] [];;\nlet _ = bigAdd [3] [];;\nlet _ = bigAdd [0] [0];;\n\n\n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> acc\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in removeZero (helper [] 0 i (List.rev (0::l)))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\nlet _ = let x = 0 - 9 in\n    mulByDigit x [1;2;3]\nlet _ = mulByDigit 0 [1;2;3]\nlet _ = mulByDigit 1 [1;2;3]\nlet _ = mulByDigit 10 [1;2;3]\nlet _ = let x = 0 - 5 in\n    mulByDigit x [0;0;0]\nlet _ = mulByDigit 5 [0;0;0]\nlet _ = mulByDigit 9 []\nlet _ = let x = 0 - 9 in\n    mulByDigit x []\nlet _ = mulByDigit 0 []\n\n\nlet bigMul l1 l2 = \n  let f a x =  in\n  let base = failwith \"to be implemented\" in\n  let args = \n    let rec digitProducts acc =\n\n      let (_, res) = List.fold_left f base args in\n        res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec mulByDigit i l =\nlet rec helper acc carry i l = match l with\n| [] -> acc\n| h::t -> let x = (h*i + carry) in \nlet n = if x > 9 then x mod 10 else x in\nlet carry' = if x > 9 then x/10 else 0 in\nlet acc' = n::acc in\nhelper acc' carry' i t\nin helper [] 0 i (List.rev (0::l))","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> acc\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n","type":"","out":""},{"in":"let _ = mulByDigit 9 [9;9;9;9]","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> acc\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let _ = let x = 0 - 9 in\nmulByDigit x [1;2;3]","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> acc\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = let x = 0 - 9 in mulByDigit x [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = mulByDigit 0 [1;2;3]","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> acc\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 0 [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = mulByDigit 1 [1;2;3]","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> acc\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 1 [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = mulByDigit 10 [1;2;3]","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> acc\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 10 [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = let x = 0 - 5 in\nmulByDigit x [0;0;0]","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> acc\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = let x = 0 - 5 in mulByDigit x [0; 0; 0];;\n","type":"","out":""},{"in":"let _ = mulByDigit 5 [0;0;0]","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> acc\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 5 [0; 0; 0];;\n","type":"","out":""},{"in":"let _ = mulByDigit 9 []","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> acc\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 9 [];;\n","type":"","out":""},{"in":"let _ = let x = 0 - 9 in\nmulByDigit x []","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> acc\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = let x = 0 - 9 in mulByDigit x [];;\n","type":"","out":""},{"in":"let _ = mulByDigit 0 []","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> acc\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 0 [];;\n","type":"","out":""}],"event":{"region":{"start":3682,"stop":4299},"type":"eval"},"cursor":4299,"time":1.398641471788594e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]\nlet _ = padZero [1;0;0;2] []\nlet _ = padZero [77] [9;9;4;5;6;7;8;9;0]\nlet _ = padZero [] []\nlet _ = padZero [] [9]\nlet _ = padZero [0;0] [1]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair acc list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> pair (List.append acc [(h1,h2)]) t1 t2\n          | (_ , _) -> List.append acc [(0,0)]\n      in pair [] (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [1;2;3] [];;\nlet _ = bigAdd [] [];;\nlet _ = bigAdd [] [3;4;5];;\nlet _ = bigAdd [1] [9;9;9];;\nlet _ = bigAdd [0;0;0] [9;9;9];;\nlet _ = bigAdd [0;0;0;0] [9;9;9];;\nlet _ = bigAdd [0] [];;\nlet _ = bigAdd [3] [];;\nlet _ = bigAdd [0] [0];;\n\n\n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> acc\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\nlet _ = let x = 0 - 9 in\n    mulByDigit x [1;2;3]\nlet _ = mulByDigit 0 [1;2;3]\nlet _ = mulByDigit 1 [1;2;3]\nlet _ = mulByDigit 10 [1;2;3]\nlet _ = let x = 0 - 5 in\n    mulByDigit x [0;0;0]\nlet _ = mulByDigit 5 [0;0;0]\nlet _ = mulByDigit 9 []\nlet _ = let x = 0 - 9 in\n    mulByDigit x []\nlet _ = mulByDigit 0 []\n\n\nlet bigMul l1 l2 = \n  let f a x =  in\n  let base = failwith \"to be implemented\" in\n  let args = \n    let rec digitProducts acc =\n\n      let (_, res) = List.fold_left f base args in\n        res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec mulByDigit i l =\nlet rec helper acc carry i l = match l with\n| [] -> (match acc with\n| [] -> []\n| h::t -> if h = 0 then t else acc)\n| h::t -> let x = (h*i + carry) in \nlet n = if x > 9 then x mod 10 else x in\nlet carry' = if x > 9 then x/10 else 0 in\nlet acc' = n::acc in\nhelper acc' carry' i t\nin helper [] 0 i (List.rev (0::l))","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n","type":"","out":""},{"in":"let _ = mulByDigit 9 [9;9;9;9]","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let _ = let x = 0 - 9 in\nmulByDigit x [1;2;3]","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = let x = 0 - 9 in mulByDigit x [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = mulByDigit 0 [1;2;3]","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 0 [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = mulByDigit 1 [1;2;3]","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 1 [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = mulByDigit 10 [1;2;3]","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 10 [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = let x = 0 - 5 in\nmulByDigit x [0;0;0]","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = let x = 0 - 5 in mulByDigit x [0; 0; 0];;\n","type":"","out":""},{"in":"let _ = mulByDigit 5 [0;0;0]","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 5 [0; 0; 0];;\n","type":"","out":""},{"in":"let _ = mulByDigit 9 []","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 9 [];;\n","type":"","out":""},{"in":"let _ = let x = 0 - 9 in\nmulByDigit x []","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = let x = 0 - 9 in mulByDigit x [];;\n","type":"","out":""},{"in":"let _ = mulByDigit 0 []","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 0 [];;\n","type":"","out":""}],"event":{"region":{"start":3682,"stop":4358},"type":"eval"},"cursor":4358,"time":1.39864162467874e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]\nlet _ = padZero [1;0;0;2] []\nlet _ = padZero [77] [9;9;4;5;6;7;8;9;0]\nlet _ = padZero [] []\nlet _ = padZero [] [9]\nlet _ = padZero [0;0] [1]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair acc list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> pair (List.append acc [(h1,h2)]) t1 t2\n          | (_ , _) -> List.append acc [(0,0)]\n      in pair [] (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [1;2;3] [];;\nlet _ = bigAdd [] [];;\nlet _ = bigAdd [] [3;4;5];;\nlet _ = bigAdd [1] [9;9;9];;\nlet _ = bigAdd [0;0;0] [9;9;9];;\nlet _ = bigAdd [0;0;0;0] [9;9;9];;\nlet _ = bigAdd [0] [];;\nlet _ = bigAdd [3] [];;\nlet _ = bigAdd [0] [0];;\n\n\n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> (match acc with\n              | [] -> []\n              | h::t -> if h = 0 then t else acc)\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\nlet _ = let x = 0 - 9 in\n    mulByDigit x [1;2;3]\nlet _ = mulByDigit 0 [1;2;3]\nlet _ = mulByDigit 1 [1;2;3]\nlet _ = mulByDigit 10 [1;2;3]\nlet _ = let x = 0 - 5 in\n    mulByDigit x [0;0;0]\nlet _ = mulByDigit 5 [0;0;0]\nlet _ = mulByDigit 9 []\nlet _ = let x = 0 - 9 in\n    mulByDigit x []\nlet _ = mulByDigit 0 []\n\n\nlet bigMul l1 l2 = \n  let f a x =  in\n  let base = failwith \"to be implemented\" in\n  let args = \n    let rec digitProducts acc =\n\n      let (_, res) = List.fold_left f base args in\n        res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = mulByDigit 0 [1;2;3]","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 0 [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = mulByDigit 1 [1;2;3]","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 1 [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = mulByDigit 10 [1;2;3]","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 10 [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = mulByDigit 5 [0;0;0]","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 5 [0; 0; 0];;\n","type":"","out":""},{"in":"let _ = mulByDigit 9 []","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 9 [];;\n","type":"","out":""},{"in":"let _ = mulByDigit 0 []","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 0 [];;\n","type":"","out":""}],"event":{"region":{"start":4060,"stop":4370},"type":"eval"},"cursor":4370,"time":1.398642438665745e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]\nlet _ = padZero [1;0;0;2] []\nlet _ = padZero [77] [9;9;4;5;6;7;8;9;0]\nlet _ = padZero [] []\nlet _ = padZero [] [9]\nlet _ = padZero [0;0] [1]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair acc list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> pair (List.append acc [(h1,h2)]) t1 t2\n          | (_ , _) -> List.append acc [(0,0)]\n      in pair [] (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [1;2;3] [];;\nlet _ = bigAdd [] [];;\nlet _ = bigAdd [] [3;4;5];;\nlet _ = bigAdd [1] [9;9;9];;\nlet _ = bigAdd [0;0;0] [9;9;9];;\nlet _ = bigAdd [0;0;0;0] [9;9;9];;\nlet _ = bigAdd [0] [];;\nlet _ = bigAdd [3] [];;\nlet _ = bigAdd [0] [0];;\n\n\n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> (match acc with\n              | [] -> []\n              | h::t -> if h = 0 then t else acc)\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 [1;2;3]\nlet _ = mulByDigit 1 [1;2;3]\nlet _ = mulByDigit 10 [1;2;3]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 5 [0;0;0]\nlet _ = mulByDigit 9 []\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 []\n\n\nlet bigMul l1 l2 = \n  let f a x =  in\n  let base = failwith \"to be implemented\" in\n  let args = \n    let rec digitProducts acc =\n\n      let (_, res) = List.fold_left f base args in\n        res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigMul l1 l2 = \nlet f a x =  in\nlet base = failwith \"to be implemented\" in\nlet args = \nlet rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \nlet rec buildZeros a places = \n(if places = 0 then a else buildZeros (0::a) (places-1)) in\nhelper [] place in \nlet acc' = List.append (mulByDigit h l2) placeHolders in\ndigitProducts acc' (place+1) t l2","min":"","type":"syntax","out":"Characters 33-35:\n  let f a x =  in\n               ^^\nError: Syntax error\n"},{"in":"let (_, res) = List.fold_left f base args in\nres","min":"\nlet _ = let (_,res) = List.fold_left f base args in res;;\n","type":"scope","out":"Characters 30-31:\n  let (_, res) = List.fold_left f base args in\n                                ^\nError: Unbound value f\n"}],"event":{"region":{"start":4370,"stop":4811},"type":"eval"},"cursor":4811,"time":1.398644184847988e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]\nlet _ = padZero [1;0;0;2] []\nlet _ = padZero [77] [9;9;4;5;6;7;8;9;0]\nlet _ = padZero [] []\nlet _ = padZero [] [9]\nlet _ = padZero [0;0] [1]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair acc list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> pair (List.append acc [(h1,h2)]) t1 t2\n          | (_ , _) -> List.append acc [(0,0)]\n      in pair [] (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [1;2;3] [];;\nlet _ = bigAdd [] [];;\nlet _ = bigAdd [] [3;4;5];;\nlet _ = bigAdd [1] [9;9;9];;\nlet _ = bigAdd [0;0;0] [9;9;9];;\nlet _ = bigAdd [0;0;0;0] [9;9;9];;\nlet _ = bigAdd [0] [];;\nlet _ = bigAdd [3] [];;\nlet _ = bigAdd [0] [0];;\n\n\n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> (match acc with\n              | [] -> []\n              | h::t -> if h = 0 then t else acc)\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 [1;2;3]\nlet _ = mulByDigit 1 [1;2;3]\nlet _ = mulByDigit 10 [1;2;3]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 5 [0;0;0]\nlet _ = mulByDigit 9 []\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 []\n\n\nlet bigMul l1 l2 = \n  let f a x =  in\n  let base = failwith \"to be implemented\" in\n  let args = \n    let rec digitProducts acc place l1 l2 = match l1 with\n      | [] -> acc\n      | h::t -> \n          let placeHolders = \n            let rec buildZeros a places = \n              (if places = 0 then a else buildZeros (0::a) (places-1)) in\n              helper [] place in \n          let acc' = List.append (mulByDigit h l2) placeHolders in\n            digitProducts acc' (place+1) t l2\nlet (_, res) = List.fold_left f base args in\n  res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigMul l1 l2 = \nlet f a x = a in\nlet base = failwith \"to be implemented\" in\nlet args = \nlet rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> let placeHolders = \nlet rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in\nbuildZeros [] place in \nlet acc' = List.append (mulByDigit h l2) placeHolders in\ndigitProducts acc' (place+1) t l2 in\nlet (_, res) = List.fold_left f base args in\nres","min":"","type":"syntax","out":"Characters 443-445:\n  res;;\n     ^^\nError: Syntax error\n"}],"event":{"region":{"start":4370,"stop":4816},"type":"eval"},"cursor":4816,"time":1.398644250045049e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]\nlet _ = padZero [1;0;0;2] []\nlet _ = padZero [77] [9;9;4;5;6;7;8;9;0]\nlet _ = padZero [] []\nlet _ = padZero [] [9]\nlet _ = padZero [0;0] [1]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair acc list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> pair (List.append acc [(h1,h2)]) t1 t2\n          | (_ , _) -> List.append acc [(0,0)]\n      in pair [] (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [1;2;3] [];;\nlet _ = bigAdd [] [];;\nlet _ = bigAdd [] [3;4;5];;\nlet _ = bigAdd [1] [9;9;9];;\nlet _ = bigAdd [0;0;0] [9;9;9];;\nlet _ = bigAdd [0;0;0;0] [9;9;9];;\nlet _ = bigAdd [0] [];;\nlet _ = bigAdd [3] [];;\nlet _ = bigAdd [0] [0];;\n\n\n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> (match acc with\n              | [] -> []\n              | h::t -> if h = 0 then t else acc)\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 [1;2;3]\nlet _ = mulByDigit 1 [1;2;3]\nlet _ = mulByDigit 10 [1;2;3]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 5 [0;0;0]\nlet _ = mulByDigit 9 []\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 []\n\n\nlet bigMul l1 l2 = \n  let f a x = a in\n  let base = failwith \"to be implemented\" in\n  let args = \n    let rec digitProducts acc place l1 l2 = match l1 with\n      | [] -> acc\n      | h::t -> let placeHolders = \n        let rec buildZeros a places = \n          if places = 0 then a else buildZeros (0::a) (places-1) in\n          buildZeros [] place in \n          let acc' = List.append (mulByDigit h l2) placeHolders in\n            digitProducts acc' (place+1) t l2 in\n    let (_, res) = List.fold_left f base args in\n      res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigMul l1 l2 = \nlet f a x = a in\nlet base = failwith \"to be implemented\" in\nlet args = \n(let rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> let placeHolders = \nlet rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in\nbuildZeros [] place in \nlet acc' = List.append (mulByDigit h l2) placeHolders in\ndigitProducts acc' (place+1) t l2) in\nlet (_, res) = List.fold_left f base args in\nres","min":"","type":"syntax","out":"Characters 392-393:\n  digitProducts acc' (place+1) t l2) in\n                                   ^\nError: Syntax error: operator expected.\n"}],"event":{"region":{"start":4370,"stop":4818},"type":"eval"},"cursor":4818,"time":1.398644361545695e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]\nlet _ = padZero [1;0;0;2] []\nlet _ = padZero [77] [9;9;4;5;6;7;8;9;0]\nlet _ = padZero [] []\nlet _ = padZero [] [9]\nlet _ = padZero [0;0] [1]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair acc list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> pair (List.append acc [(h1,h2)]) t1 t2\n          | (_ , _) -> List.append acc [(0,0)]\n      in pair [] (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [1;2;3] [];;\nlet _ = bigAdd [] [];;\nlet _ = bigAdd [] [3;4;5];;\nlet _ = bigAdd [1] [9;9;9];;\nlet _ = bigAdd [0;0;0] [9;9;9];;\nlet _ = bigAdd [0;0;0;0] [9;9;9];;\nlet _ = bigAdd [0] [];;\nlet _ = bigAdd [3] [];;\nlet _ = bigAdd [0] [0];;\n\n\n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> (match acc with\n              | [] -> []\n              | h::t -> if h = 0 then t else acc)\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 [1;2;3]\nlet _ = mulByDigit 1 [1;2;3]\nlet _ = mulByDigit 10 [1;2;3]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 5 [0;0;0]\nlet _ = mulByDigit 9 []\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 []\n\n\nlet bigMul l1 l2 = \n  let f a x = a in\n  let base = failwith \"to be implemented\" in\n  let args = \n    (let rec digitProducts acc place l1 l2 = match l1 with\n       | [] -> acc\n       | h::t -> let placeHolders = \n         let rec buildZeros a places = \n           if places = 0 then a else buildZeros (0::a) (places-1) in\n           buildZeros [] place in \n           let acc' = List.append (mulByDigit h l2) placeHolders in\n             digitProducts acc' (place+1) t l2) in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigMul l1 l2 = \nlet f a x = a in\nlet base = failwith \"to be implemented\" in\nlet args = \n(let rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> let placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in\nbuildZeros [] place in \nlet acc' = List.append (mulByDigit h l2) placeHolders in\ndigitProducts acc' (place+1) t l2)","min":"","type":"syntax","out":"Characters 189-190:\n  (let rec buildZeros a places = \n  ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n"},{"in":") in\nlet (_, res) = List.fold_left f base args in\nres","min":"","type":"syntax","out":"Characters 0-1:\n  ) in\n  ^\nError: Syntax error\n"}],"event":{"region":{"start":4370,"stop":4820},"type":"eval"},"cursor":4820,"time":1.398644384618914e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]\nlet _ = padZero [1;0;0;2] []\nlet _ = padZero [77] [9;9;4;5;6;7;8;9;0]\nlet _ = padZero [] []\nlet _ = padZero [] [9]\nlet _ = padZero [0;0] [1]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair acc list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> pair (List.append acc [(h1,h2)]) t1 t2\n          | (_ , _) -> List.append acc [(0,0)]\n      in pair [] (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [1;2;3] [];;\nlet _ = bigAdd [] [];;\nlet _ = bigAdd [] [3;4;5];;\nlet _ = bigAdd [1] [9;9;9];;\nlet _ = bigAdd [0;0;0] [9;9;9];;\nlet _ = bigAdd [0;0;0;0] [9;9;9];;\nlet _ = bigAdd [0] [];;\nlet _ = bigAdd [3] [];;\nlet _ = bigAdd [0] [0];;\n\n\n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> (match acc with\n              | [] -> []\n              | h::t -> if h = 0 then t else acc)\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 [1;2;3]\nlet _ = mulByDigit 1 [1;2;3]\nlet _ = mulByDigit 10 [1;2;3]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 5 [0;0;0]\nlet _ = mulByDigit 9 []\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 []\n\n\nlet bigMul l1 l2 = \n  let f a x = a in\n  let base = failwith \"to be implemented\" in\n  let args = \n    (let rec digitProducts acc place l1 l2 = match l1 with\n       | [] -> acc\n       | h::t -> let placeHolders = \n         (let rec buildZeros a places = \n           if places = 0 then a else buildZeros (0::a) (places-1) in\n            buildZeros [] place in \n           let acc' = List.append (mulByDigit h l2) placeHolders in\n             digitProducts acc' (place+1) t l2)) in\nlet (_, res) = List.fold_left f base args in\n  res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigMul l1 l2 = \nlet f a x = a in\nlet base = failwith \"to be implemented\" in\nlet args = \nlet rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> let placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in\nbuildZeros [] place in \nlet acc' = List.append (mulByDigit h l2) placeHolders in\ndigitProducts acc' (place+1) t l2","min":"","type":"syntax","out":"Characters 188-189:\n  (let rec buildZeros a places = \n  ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n"},{"in":") in\nlet (_, res) = List.fold_left f base args in\nres","min":"","type":"syntax","out":"Characters 0-1:\n  ) in\n  ^\nError: Syntax error\n"}],"event":{"region":{"start":4370,"stop":4818},"type":"eval"},"cursor":4766,"time":1.398644398314584e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]\nlet _ = padZero [1;0;0;2] []\nlet _ = padZero [77] [9;9;4;5;6;7;8;9;0]\nlet _ = padZero [] []\nlet _ = padZero [] [9]\nlet _ = padZero [0;0] [1]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair acc list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> pair (List.append acc [(h1,h2)]) t1 t2\n          | (_ , _) -> List.append acc [(0,0)]\n      in pair [] (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [1;2;3] [];;\nlet _ = bigAdd [] [];;\nlet _ = bigAdd [] [3;4;5];;\nlet _ = bigAdd [1] [9;9;9];;\nlet _ = bigAdd [0;0;0] [9;9;9];;\nlet _ = bigAdd [0;0;0;0] [9;9;9];;\nlet _ = bigAdd [0] [];;\nlet _ = bigAdd [3] [];;\nlet _ = bigAdd [0] [0];;\n\n\n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> (match acc with\n              | [] -> []\n              | h::t -> if h = 0 then t else acc)\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 [1;2;3]\nlet _ = mulByDigit 1 [1;2;3]\nlet _ = mulByDigit 10 [1;2;3]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 5 [0;0;0]\nlet _ = mulByDigit 9 []\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 []\n\n\nlet bigMul l1 l2 = \n  let f a x = a in\n  let base = failwith \"to be implemented\" in\n  let args = \n    let rec digitProducts acc place l1 l2 = match l1 with\n      | [] -> acc\n      | h::t -> let placeHolders = \n        (let rec buildZeros a places = \n          if places = 0 then a else buildZeros (0::a) (places-1) in\n           buildZeros [] place in \n          let acc' = List.append (mulByDigit h l2) placeHolders in\n            digitProducts acc' (place+1) t l2) in\nlet (_, res) = List.fold_left f base args in\n  res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigMul l1 l2 = \nlet f a x = a in\nlet base = failwith \"to be implemented\" in\nlet args = \n(let rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> let placeHolders = \nlet rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in\nbuildZeros [] place in \nlet acc' = List.append (mulByDigit h l2) placeHolders in\ndigitProducts acc' (place+1) t l2) in\nlet (_, res) = List.fold_left f base args in\nres","min":"","type":"syntax","out":"Characters 392-393:\n  digitProducts acc' (place+1) t l2) in\n                                   ^\nError: Syntax error: operator expected.\n"}],"event":{"region":{"start":4370,"stop":4818},"type":"eval"},"cursor":4466,"time":1.398644406713379e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]\nlet _ = padZero [1;0;0;2] []\nlet _ = padZero [77] [9;9;4;5;6;7;8;9;0]\nlet _ = padZero [] []\nlet _ = padZero [] [9]\nlet _ = padZero [0;0] [1]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair acc list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> pair (List.append acc [(h1,h2)]) t1 t2\n          | (_ , _) -> List.append acc [(0,0)]\n      in pair [] (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [1;2;3] [];;\nlet _ = bigAdd [] [];;\nlet _ = bigAdd [] [3;4;5];;\nlet _ = bigAdd [1] [9;9;9];;\nlet _ = bigAdd [0;0;0] [9;9;9];;\nlet _ = bigAdd [0;0;0;0] [9;9;9];;\nlet _ = bigAdd [0] [];;\nlet _ = bigAdd [3] [];;\nlet _ = bigAdd [0] [0];;\n\n\n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> (match acc with\n              | [] -> []\n              | h::t -> if h = 0 then t else acc)\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 [1;2;3]\nlet _ = mulByDigit 1 [1;2;3]\nlet _ = mulByDigit 10 [1;2;3]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 5 [0;0;0]\nlet _ = mulByDigit 9 []\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 []\n\n\nlet bigMul l1 l2 = \n  let f a x = a in\n  let base = failwith \"to be implemented\" in\n  let args = \n    (let rec digitProducts acc place l1 l2 = match l1 with\n       | [] -> acc\n       | h::t -> let placeHolders = \n         let rec buildZeros a places = \n           if places = 0 then a else buildZeros (0::a) (places-1) in\n           buildZeros [] place in \n           let acc' = List.append (mulByDigit h l2) placeHolders in\n             digitProducts acc' (place+1) t l2) in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigMul l1 l2 = \nlet f a x = a in\nlet base = failwith \"to be implemented\" in\nlet args = \n(let rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> let placeHolders = \nlet rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in\nbuildZeros [] place\nlet acc' = List.append (mulByDigit h l2) placeHolders in\ndigitProducts acc' (place+1) t l2) in\nlet (_, res) = List.fold_left f base args in\nres","min":"","type":"syntax","out":"Characters 298-301:\n  let acc' = List.append (mulByDigit h l2) placeHolders in\n  ^^^\nError: Syntax error: operator expected.\n"}],"event":{"region":{"start":4370,"stop":4814},"type":"eval"},"cursor":4811,"time":1.398644446636161e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]\nlet _ = padZero [1;0;0;2] []\nlet _ = padZero [77] [9;9;4;5;6;7;8;9;0]\nlet _ = padZero [] []\nlet _ = padZero [] [9]\nlet _ = padZero [0;0] [1]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair acc list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> pair (List.append acc [(h1,h2)]) t1 t2\n          | (_ , _) -> List.append acc [(0,0)]\n      in pair [] (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [1;2;3] [];;\nlet _ = bigAdd [] [];;\nlet _ = bigAdd [] [3;4;5];;\nlet _ = bigAdd [1] [9;9;9];;\nlet _ = bigAdd [0;0;0] [9;9;9];;\nlet _ = bigAdd [0;0;0;0] [9;9;9];;\nlet _ = bigAdd [0] [];;\nlet _ = bigAdd [3] [];;\nlet _ = bigAdd [0] [0];;\n\n\n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> (match acc with\n              | [] -> []\n              | h::t -> if h = 0 then t else acc)\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 [1;2;3]\nlet _ = mulByDigit 1 [1;2;3]\nlet _ = mulByDigit 10 [1;2;3]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 5 [0;0;0]\nlet _ = mulByDigit 9 []\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 []\n\n\nlet bigMul l1 l2 = \n  let f a x = a in\n  let base = failwith \"to be implemented\" in\n  let args = \n    (let rec digitProducts acc place l1 l2 = match l1 with\n       | [] -> acc\n       | h::t -> let placeHolders = \n         let rec buildZeros a places = \n           if places = 0 then a else buildZeros (0::a) (places-1) in\n           buildZeros [] place\n     let acc' = List.append (mulByDigit h l2) placeHolders in\n       digitProducts acc' (place+1) t l2) in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigMul l1 l2 = \nlet f a x = a in\nlet base = failwith \"to be implemented\" in\nlet args = \n(let rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> let placeHolders = \nlet rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in\nbuildZeros [] place in \nlet acc' = List.append (mulByDigit h l2) placeHolders in\ndigitProducts acc' (place+1) t l2) in\nlet (_, res) = List.fold_left f base args in\nres","min":"","type":"syntax","out":"Characters 392-393:\n  digitProducts acc' (place+1) t l2) in\n                                   ^\nError: Syntax error: operator expected.\n"}],"event":{"region":{"start":4370,"stop":4818},"type":"eval"},"cursor":4769,"time":1.398644465119271e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]\nlet _ = padZero [1;0;0;2] []\nlet _ = padZero [77] [9;9;4;5;6;7;8;9;0]\nlet _ = padZero [] []\nlet _ = padZero [] [9]\nlet _ = padZero [0;0] [1]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair acc list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> pair (List.append acc [(h1,h2)]) t1 t2\n          | (_ , _) -> List.append acc [(0,0)]\n      in pair [] (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [1;2;3] [];;\nlet _ = bigAdd [] [];;\nlet _ = bigAdd [] [3;4;5];;\nlet _ = bigAdd [1] [9;9;9];;\nlet _ = bigAdd [0;0;0] [9;9;9];;\nlet _ = bigAdd [0;0;0;0] [9;9;9];;\nlet _ = bigAdd [0] [];;\nlet _ = bigAdd [3] [];;\nlet _ = bigAdd [0] [0];;\n\n\n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> (match acc with\n              | [] -> []\n              | h::t -> if h = 0 then t else acc)\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 [1;2;3]\nlet _ = mulByDigit 1 [1;2;3]\nlet _ = mulByDigit 10 [1;2;3]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 5 [0;0;0]\nlet _ = mulByDigit 9 []\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 []\n\n\nlet bigMul l1 l2 = \n  let f a x = a in\n  let base = failwith \"to be implemented\" in\n  let args = \n    (let rec digitProducts acc place l1 l2 = match l1 with\n       | [] -> acc\n       | h::t -> let placeHolders = \n         let rec buildZeros a places = \n           if places = 0 then a else buildZeros (0::a) (places-1) in\n           buildZeros [] place in \n           let acc' = List.append (mulByDigit h l2) placeHolders in\n             digitProducts acc' (place+1) t l2) in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigMul l1 l2 = \nlet f a x = a in\nlet base = failwith \"to be implemented\" in\nlet args = \nlet rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> let placeHolders = \nlet rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in\nbuildZeros [] place in \nlet acc' = List.append (mulByDigit h l2) placeHolders in\ndigitProducts acc' (place+1) t l2 in\nlet (_, res) = List.fold_left f base args in\nres","min":"","type":"syntax","out":"Characters 443-445:\n  res;;\n     ^^\nError: Syntax error\n"}],"event":{"region":{"start":4370,"stop":4816},"type":"eval"},"cursor":4816,"time":1.398644480316978e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]\nlet _ = padZero [1;0;0;2] []\nlet _ = padZero [77] [9;9;4;5;6;7;8;9;0]\nlet _ = padZero [] []\nlet _ = padZero [] [9]\nlet _ = padZero [0;0] [1]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair acc list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> pair (List.append acc [(h1,h2)]) t1 t2\n          | (_ , _) -> List.append acc [(0,0)]\n      in pair [] (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [1;2;3] [];;\nlet _ = bigAdd [] [];;\nlet _ = bigAdd [] [3;4;5];;\nlet _ = bigAdd [1] [9;9;9];;\nlet _ = bigAdd [0;0;0] [9;9;9];;\nlet _ = bigAdd [0;0;0;0] [9;9;9];;\nlet _ = bigAdd [0] [];;\nlet _ = bigAdd [3] [];;\nlet _ = bigAdd [0] [0];;\n\n\n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> (match acc with\n              | [] -> []\n              | h::t -> if h = 0 then t else acc)\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 [1;2;3]\nlet _ = mulByDigit 1 [1;2;3]\nlet _ = mulByDigit 10 [1;2;3]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 5 [0;0;0]\nlet _ = mulByDigit 9 []\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 []\n\n\nlet bigMul l1 l2 = \n  let f a x = a in\n  let base = failwith \"to be implemented\" in\n  let args = \n    let rec digitProducts acc place l1 l2 = match l1 with\n      | [] -> acc\n      | h::t -> let placeHolders = \n        let rec buildZeros a places = \n          if places = 0 then a else buildZeros (0::a) (places-1) in\n          buildZeros [] place in \n          let acc' = List.append (mulByDigit h l2) placeHolders in\n            digitProducts acc' (place+1) t l2 in\n    let (_, res) = List.fold_left f base args in\n      res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigMul l1 l2 = \nlet f a x = a in\nlet base = failwith \"to be implemented\" in\nlet args = \nlet rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> let placeHolders = \nlet rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in\nbuildZeros [] place in \nlet acc' = List.append (mulByDigit h l2) placeHolders in\ndigitProducts acc' (place+1) t l2 in\nlet (_, res) = List.fold_left f base args in\nres","min":"","type":"syntax","out":"Characters 443-445:\n  res;;\n     ^^\nError: Syntax error\n"}],"event":{"region":{"start":4370,"stop":4816},"type":"eval"},"cursor":4816,"time":1.398644487954172e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]\nlet _ = padZero [1;0;0;2] []\nlet _ = padZero [77] [9;9;4;5;6;7;8;9;0]\nlet _ = padZero [] []\nlet _ = padZero [] [9]\nlet _ = padZero [0;0] [1]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair acc list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> pair (List.append acc [(h1,h2)]) t1 t2\n          | (_ , _) -> List.append acc [(0,0)]\n      in pair [] (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [1;2;3] [];;\nlet _ = bigAdd [] [];;\nlet _ = bigAdd [] [3;4;5];;\nlet _ = bigAdd [1] [9;9;9];;\nlet _ = bigAdd [0;0;0] [9;9;9];;\nlet _ = bigAdd [0;0;0;0] [9;9;9];;\nlet _ = bigAdd [0] [];;\nlet _ = bigAdd [3] [];;\nlet _ = bigAdd [0] [0];;\n\n\n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> (match acc with\n              | [] -> []\n              | h::t -> if h = 0 then t else acc)\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 [1;2;3]\nlet _ = mulByDigit 1 [1;2;3]\nlet _ = mulByDigit 10 [1;2;3]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 5 [0;0;0]\nlet _ = mulByDigit 9 []\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 []\n\n\nlet bigMul l1 l2 = \n  let f a x = a in\n  let base = failwith \"to be implemented\" in\n  let args = \n    let rec digitProducts acc place l1 l2 = match l1 with\n      | [] -> acc\n      | h::t -> let placeHolders = \n        let rec buildZeros a places = \n          if places = 0 then a else buildZeros (0::a) (places-1) in\n          buildZeros [] place in \n          let acc' = List.append (mulByDigit h l2) placeHolders in\n            digitProducts acc' (place+1) t l2 in\n    let (_, res) = List.fold_left f base args in\n      res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigMul l1 l2 = \nlet f a x = a in\nlet base = failwith \"to be implemented\" in\nlet args = let rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \nlet rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in\nbuildZeros [] place in \nlet acc' = List.append (mulByDigit h l2) placeHolders in\ndigitProducts acc' (place+1) t l2 in\nlet (_, res) = List.fold_left f base args in\nres","min":"","type":"syntax","out":"Characters 443-445:\n  res;;\n     ^^\nError: Syntax error\n"}],"event":{"region":{"start":4370,"stop":4816},"type":"eval"},"cursor":4767,"time":1.398644580045951e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]\nlet _ = padZero [1;0;0;2] []\nlet _ = padZero [77] [9;9;4;5;6;7;8;9;0]\nlet _ = padZero [] []\nlet _ = padZero [] [9]\nlet _ = padZero [0;0] [1]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair acc list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> pair (List.append acc [(h1,h2)]) t1 t2\n          | (_ , _) -> List.append acc [(0,0)]\n      in pair [] (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [1;2;3] [];;\nlet _ = bigAdd [] [];;\nlet _ = bigAdd [] [3;4;5];;\nlet _ = bigAdd [1] [9;9;9];;\nlet _ = bigAdd [0;0;0] [9;9;9];;\nlet _ = bigAdd [0;0;0;0] [9;9;9];;\nlet _ = bigAdd [0] [];;\nlet _ = bigAdd [3] [];;\nlet _ = bigAdd [0] [0];;\n\n\n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> (match acc with\n              | [] -> []\n              | h::t -> if h = 0 then t else acc)\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 [1;2;3]\nlet _ = mulByDigit 1 [1;2;3]\nlet _ = mulByDigit 10 [1;2;3]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 5 [0;0;0]\nlet _ = mulByDigit 9 []\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 []\n\n\nlet bigMul l1 l2 = \n  let f a x = a in\n  let base = failwith \"to be implemented\" in\n  let args = let rec digitProducts acc place l1 l2 = match l1 with\n    | [] -> acc\n    | h::t -> \n        let placeHolders = \n          let rec buildZeros a places = \n            if places = 0 then a else buildZeros (0::a) (places-1) in\n            buildZeros [] place in \n        let acc' = List.append (mulByDigit h l2) placeHolders in\n          digitProducts acc' (place+1) t l2 in\n    let (_, res) = List.fold_left f base args in\n      res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigMul l1 l2 = \nlet f a x = a in\nlet base = failwith \"to be implemented\" in\nlet args = let rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \nlet rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in\nbuildZeros [] place in \nlet acc' = List.append (mulByDigit h l2) placeHolders in\ndigitProducts acc' (place+1) t l2 in\nlet (_, res) = List.fold_left f base args in\nres","min":"","type":"syntax","out":"Characters 443-445:\n  res;;\n     ^^\nError: Syntax error\n"}],"event":{"region":{"start":4370,"stop":4816},"type":"eval"},"cursor":4816,"time":1.398644582937912e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]\nlet _ = padZero [1;0;0;2] []\nlet _ = padZero [77] [9;9;4;5;6;7;8;9;0]\nlet _ = padZero [] []\nlet _ = padZero [] [9]\nlet _ = padZero [0;0] [1]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair acc list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> pair (List.append acc [(h1,h2)]) t1 t2\n          | (_ , _) -> List.append acc [(0,0)]\n      in pair [] (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [1;2;3] [];;\nlet _ = bigAdd [] [];;\nlet _ = bigAdd [] [3;4;5];;\nlet _ = bigAdd [1] [9;9;9];;\nlet _ = bigAdd [0;0;0] [9;9;9];;\nlet _ = bigAdd [0;0;0;0] [9;9;9];;\nlet _ = bigAdd [0] [];;\nlet _ = bigAdd [3] [];;\nlet _ = bigAdd [0] [0];;\n\n\n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> (match acc with\n              | [] -> []\n              | h::t -> if h = 0 then t else acc)\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 [1;2;3]\nlet _ = mulByDigit 1 [1;2;3]\nlet _ = mulByDigit 10 [1;2;3]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 5 [0;0;0]\nlet _ = mulByDigit 9 []\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 []\n\n\nlet bigMul l1 l2 = \n  let f a x = a in\n  let base = failwith \"to be implemented\" in\n  let args = let rec digitProducts acc place l1 l2 = match l1 with\n    | [] -> acc\n    | h::t -> \n        let placeHolders = \n          let rec buildZeros a places = \n            if places = 0 then a else buildZeros (0::a) (places-1) in\n            buildZeros [] place in \n        let acc' = List.append (mulByDigit h l2) placeHolders in\n          digitProducts acc' (place+1) t l2 in\n    let (_, res) = List.fold_left f base args in\n      res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigMul l1 l2 = \nlet f a x = a in\nlet base = failwith \"to be implemented\" in\nlet args = let rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \nlet rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in\nbuildZeros [] place in \nlet acc' = List.append (mulByDigit h l2) placeHolders in\ndigitProducts acc' (place+1) t l2 in\nlet (_, res) = List.fold_left f base args in\nres","min":"","type":"syntax","out":"Characters 443-445:\n  res;;\n     ^^\nError: Syntax error\n"}],"event":{"region":{"start":4370,"stop":4816},"type":"eval"},"cursor":4816,"time":1.398645167680985e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]\nlet _ = padZero [1;0;0;2] []\nlet _ = padZero [77] [9;9;4;5;6;7;8;9;0]\nlet _ = padZero [] []\nlet _ = padZero [] [9]\nlet _ = padZero [0;0] [1]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair acc list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> pair (List.append acc [(h1,h2)]) t1 t2\n          | (_ , _) -> List.append acc [(0,0)]\n      in pair [] (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [1;2;3] [];;\nlet _ = bigAdd [] [];;\nlet _ = bigAdd [] [3;4;5];;\nlet _ = bigAdd [1] [9;9;9];;\nlet _ = bigAdd [0;0;0] [9;9;9];;\nlet _ = bigAdd [0;0;0;0] [9;9;9];;\nlet _ = bigAdd [0] [];;\nlet _ = bigAdd [3] [];;\nlet _ = bigAdd [0] [0];;\n\n\n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> (match acc with\n              | [] -> []\n              | h::t -> if h = 0 then t else acc)\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 [1;2;3]\nlet _ = mulByDigit 1 [1;2;3]\nlet _ = mulByDigit 10 [1;2;3]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 5 [0;0;0]\nlet _ = mulByDigit 9 []\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 []\n\n\nlet bigMul l1 l2 = \n  let f a x = a in\n  let base = failwith \"to be implemented\" in\n  let args = let rec digitProducts acc place l1 l2 = match l1 with\n    | [] -> acc\n    | h::t -> \n        let placeHolders = \n          let rec buildZeros a places = \n            if places = 0 then a else buildZeros (0::a) (places-1) in\n            buildZeros [] place in \n        let acc' = List.append (mulByDigit h l2) placeHolders in\n          digitProducts acc' (place+1) t l2 in\n    let (_, res) = List.fold_left f base args in\n      res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigMul l1 l2 = \nlet f a x = a in\nlet base = failwith \"to be implemented\" in\nlet args = let rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \nlet rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in\nbuildZeros [] place in \nlet acc' = List.append (mulByDigit h l2) placeHolders in\ndigitProducts acc' (place+1) t l2 in\nlet (_, res) = List.fold_left f base args in\nres","min":"","type":"syntax","out":"Characters 443-445:\n  res;;\n     ^^\nError: Syntax error\n"}],"event":{"region":{"start":4370,"stop":4816},"type":"eval"},"cursor":4392,"time":1.398645173437578e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]\nlet _ = padZero [1;0;0;2] []\nlet _ = padZero [77] [9;9;4;5;6;7;8;9;0]\nlet _ = padZero [] []\nlet _ = padZero [] [9]\nlet _ = padZero [0;0] [1]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair acc list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> pair (List.append acc [(h1,h2)]) t1 t2\n          | (_ , _) -> List.append acc [(0,0)]\n      in pair [] (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [1;2;3] [];;\nlet _ = bigAdd [] [];;\nlet _ = bigAdd [] [3;4;5];;\nlet _ = bigAdd [1] [9;9;9];;\nlet _ = bigAdd [0;0;0] [9;9;9];;\nlet _ = bigAdd [0;0;0;0] [9;9;9];;\nlet _ = bigAdd [0] [];;\nlet _ = bigAdd [3] [];;\nlet _ = bigAdd [0] [0];;\n\n\n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> (match acc with\n              | [] -> []\n              | h::t -> if h = 0 then t else acc)\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 [1;2;3]\nlet _ = mulByDigit 1 [1;2;3]\nlet _ = mulByDigit 10 [1;2;3]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 5 [0;0;0]\nlet _ = mulByDigit 9 []\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 []\n\n\nlet bigMul l1 l2 = \n  let f a x = a in\n  let base = failwith \"to be implemented\" in\n  let args = let rec digitProducts acc place l1 l2 = match l1 with\n    | [] -> acc\n    | h::t -> \n        let placeHolders = \n          let rec buildZeros a places = \n            if places = 0 then a else buildZeros (0::a) (places-1) in\n            buildZeros [] place in \n        let acc' = List.append (mulByDigit h l2) placeHolders in\n          digitProducts acc' (place+1) t l2 in\n    let (_, res) = List.fold_left f base args in\n      res;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = mulByDigit 0 []","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 0 [];;\n","type":"","out":""}],"event":{"region":{"start":4347,"stop":4370},"type":"eval"},"cursor":4370,"time":1.398645176386531e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]\nlet _ = padZero [1;0;0;2] []\nlet _ = padZero [77] [9;9;4;5;6;7;8;9;0]\nlet _ = padZero [] []\nlet _ = padZero [] [9]\nlet _ = padZero [0;0] [1]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair acc list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> pair (List.append acc [(h1,h2)]) t1 t2\n          | (_ , _) -> List.append acc [(0,0)]\n      in pair [] (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [1;2;3] [];;\nlet _ = bigAdd [] [];;\nlet _ = bigAdd [] [3;4;5];;\nlet _ = bigAdd [1] [9;9;9];;\nlet _ = bigAdd [0;0;0] [9;9;9];;\nlet _ = bigAdd [0;0;0;0] [9;9;9];;\nlet _ = bigAdd [0] [];;\nlet _ = bigAdd [3] [];;\nlet _ = bigAdd [0] [0];;\n\n\n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> (match acc with\n              | [] -> []\n              | h::t -> if h = 0 then t else acc)\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 [1;2;3]\nlet _ = mulByDigit 1 [1;2;3]\nlet _ = mulByDigit 10 [1;2;3]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 5 [0;0;0]\nlet _ = mulByDigit 9 []\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 []\n\n\nlet bigMul l1 l2 = \n  let f a x = a in\n  let base = failwith \"to be implemented\" in\n  let args = let rec digitProducts acc place l1 l2 = match l1 with\n    | [] -> acc\n    | h::t -> \n        let placeHolders = \n          let rec buildZeros a places = \n            if places = 0 then a else buildZeros (0::a) (places-1) in\n            buildZeros [] place in \n        let acc' = List.append (mulByDigit h l2) placeHolders in\n          digitProducts acc' (place+1) t l2 in\n    let (_, res) = List.fold_left f base args in\n      res;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigMul l1 l2 = \nlet f a x = a in\nlet base = failwith \"to be implemented\" in\nlet args = \n(let rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \nlet rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in\nbuildZeros [] place in \nlet acc' = List.append (mulByDigit h l2) placeHolders in\ndigitProducts acc' (place+1) t l2)in\nlet (_, res) = List.fold_left f base args in\nres","min":"","type":"syntax","out":"Characters 393-394:\n  digitProducts acc' (place+1) t l2)in\n                                   ^\nError: Syntax error: operator expected.\n"}],"event":{"region":{"start":4370,"stop":4818},"type":"eval"},"cursor":4820,"time":1.398645202881078e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]\nlet _ = padZero [1;0;0;2] []\nlet _ = padZero [77] [9;9;4;5;6;7;8;9;0]\nlet _ = padZero [] []\nlet _ = padZero [] [9]\nlet _ = padZero [0;0] [1]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair acc list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> pair (List.append acc [(h1,h2)]) t1 t2\n          | (_ , _) -> List.append acc [(0,0)]\n      in pair [] (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [1;2;3] [];;\nlet _ = bigAdd [] [];;\nlet _ = bigAdd [] [3;4;5];;\nlet _ = bigAdd [1] [9;9;9];;\nlet _ = bigAdd [0;0;0] [9;9;9];;\nlet _ = bigAdd [0;0;0;0] [9;9;9];;\nlet _ = bigAdd [0] [];;\nlet _ = bigAdd [3] [];;\nlet _ = bigAdd [0] [0];;\n\n\n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> (match acc with\n              | [] -> []\n              | h::t -> if h = 0 then t else acc)\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 [1;2;3]\nlet _ = mulByDigit 1 [1;2;3]\nlet _ = mulByDigit 10 [1;2;3]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 5 [0;0;0]\nlet _ = mulByDigit 9 []\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 []\n\n\nlet bigMul l1 l2 = \n  let f a x = a in\n  let base = failwith \"to be implemented\" in\n  let args = \n    (let rec digitProducts acc place l1 l2 = match l1 with\n       | [] -> acc\n       | h::t -> \n           let placeHolders = \n             let rec buildZeros a places = \n               if places = 0 then a else buildZeros (0::a) (places-1) in\n               buildZeros [] place in \n           let acc' = List.append (mulByDigit h l2) placeHolders in\n             digitProducts acc' (place+1) t l2)in\n  let (_, res) = List.fold_left f base args in\n    res;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigMul l1 l2 = \nlet f a x = a in\nlet base = failwith \"to be implemented\" in\nlet args = \n(let rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \nlet rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in\nbuildZeros [] place in \nlet acc' = List.append (mulByDigit h l2) placeHolders in\ndigitProducts acc' (place+1) t l2) in\nlet (_, res) = List.fold_left f base args in\nres","min":"","type":"syntax","out":"Characters 393-394:\n  digitProducts acc' (place+1) t l2) in\n                                   ^\nError: Syntax error: operator expected.\n"}],"event":{"region":{"start":4370,"stop":4819},"type":"eval"},"cursor":4821,"time":1.3986452082757e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]\nlet _ = padZero [1;0;0;2] []\nlet _ = padZero [77] [9;9;4;5;6;7;8;9;0]\nlet _ = padZero [] []\nlet _ = padZero [] [9]\nlet _ = padZero [0;0] [1]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair acc list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> pair (List.append acc [(h1,h2)]) t1 t2\n          | (_ , _) -> List.append acc [(0,0)]\n      in pair [] (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [1;2;3] [];;\nlet _ = bigAdd [] [];;\nlet _ = bigAdd [] [3;4;5];;\nlet _ = bigAdd [1] [9;9;9];;\nlet _ = bigAdd [0;0;0] [9;9;9];;\nlet _ = bigAdd [0;0;0;0] [9;9;9];;\nlet _ = bigAdd [0] [];;\nlet _ = bigAdd [3] [];;\nlet _ = bigAdd [0] [0];;\n\n\n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> (match acc with\n              | [] -> []\n              | h::t -> if h = 0 then t else acc)\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 [1;2;3]\nlet _ = mulByDigit 1 [1;2;3]\nlet _ = mulByDigit 10 [1;2;3]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 5 [0;0;0]\nlet _ = mulByDigit 9 []\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 []\n\n\nlet bigMul l1 l2 = \n  let f a x = a in\n  let base = failwith \"to be implemented\" in\n  let args = \n    (let rec digitProducts acc place l1 l2 = match l1 with\n       | [] -> acc\n       | h::t -> \n           let placeHolders = \n             let rec buildZeros a places = \n               if places = 0 then a else buildZeros (0::a) (places-1) in\n               buildZeros [] place in \n           let acc' = List.append (mulByDigit h l2) placeHolders in\n             digitProducts acc' (place+1) t l2) in\n  let (_, res) = List.fold_left f base args in\n    res;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec mulByDigit i l =\nlet rec helper acc carry i l = match l with\n| [] -> (match acc with\n| [] -> []\n| h::t -> if h = 0 then t else acc)\n| h::t -> let x = (h*i + carry) in \nlet n = if x > 9 then x mod 10 else x in\nlet carry' = if x > 9 then x/10 else 0 in\nlet acc' = n::acc in\nhelper acc' carry' i t\nin helper [] 0 i (List.rev (0::l))","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n","type":"","out":""}],"event":{"region":{"start":3690,"stop":4027},"type":"eval"},"cursor":3969,"time":1.398645267530028e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]\nlet _ = padZero [1;0;0;2] []\nlet _ = padZero [77] [9;9;4;5;6;7;8;9;0]\nlet _ = padZero [] []\nlet _ = padZero [] [9]\nlet _ = padZero [0;0] [1]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair acc list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> pair (List.append acc [(h1,h2)]) t1 t2\n          | (_ , _) -> List.append acc [(0,0)]\n      in pair [] (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [1;2;3] [];;\nlet _ = bigAdd [] [];;\nlet _ = bigAdd [] [3;4;5];;\nlet _ = bigAdd [1] [9;9;9];;\nlet _ = bigAdd [0;0;0] [9;9;9];;\nlet _ = bigAdd [0;0;0;0] [9;9;9];;\nlet _ = bigAdd [0] [];;\nlet _ = bigAdd [3] [];;\nlet _ = bigAdd [0] [0];;\n\n\n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> (match acc with\n              | [] -> []\n              | h::t -> if h = 0 then t else acc)\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 [1;2;3]\nlet _ = mulByDigit 1 [1;2;3]\nlet _ = mulByDigit 10 [1;2;3]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 5 [0;0;0]\nlet _ = mulByDigit 9 []\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 []\n\n\nlet bigMul l1 l2 = \n  let f a x = a in\n  let base = failwith \"to be implemented\" in\n  let args = \n    (let rec digitProducts acc place l1 l2 = match l1 with\n       | [] -> acc\n       | h::t -> \n           (let placeHolders = \n             let rec buildZeros a places = \n               if places = 0 then a else buildZeros (0::a) (places-1) in\n               buildZeros [] place in \n            let acc' = List.append (mulByDigit h l2) placeHolders) in\n       digitProducts acc' (place+1) t l2) in\n  let (_, res) = List.fold_left f base args in\n    res;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = mulByDigit 9 [9;9;9;9]","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let _ = mulByDigit 0 [1;2;3]","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 0 [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = mulByDigit 1 [1;2;3]","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 1 [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = mulByDigit 10 [1;2;3]","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 10 [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = mulByDigit 5 [0;0;0]","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 5 [0; 0; 0];;\n","type":"","out":""},{"in":"let _ = mulByDigit 9 []","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 9 [];;\n","type":"","out":""},{"in":"let _ = mulByDigit 0 []","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 0 [];;\n","type":"","out":""},{"in":"let bigMul l1 l2 = \nlet f a x = a in\nlet base = failwith \"to be implemented\" in\nlet args = \n(let rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \n(let placeHolders = \nlet rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in\nbuildZeros [] place in \nlet acc' = List.append (mulByDigit h l2) placeHolders) in\ndigitProducts acc' (place+1) t l2) in\nlet (_, res) = List.fold_left f base args in\nres","min":"","type":"syntax","out":"Characters 357-358:\n  let acc' = List.append (mulByDigit h l2) placeHolders) in\n                                                       ^\nError: Syntax error: operator expected.\n"}],"event":{"region":{"start":4027,"stop":4821},"type":"eval"},"cursor":4817,"time":1.398645270490475e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]\nlet _ = padZero [1;0;0;2] []\nlet _ = padZero [77] [9;9;4;5;6;7;8;9;0]\nlet _ = padZero [] []\nlet _ = padZero [] [9]\nlet _ = padZero [0;0] [1]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair acc list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> pair (List.append acc [(h1,h2)]) t1 t2\n          | (_ , _) -> List.append acc [(0,0)]\n      in pair [] (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [1;2;3] [];;\nlet _ = bigAdd [] [];;\nlet _ = bigAdd [] [3;4;5];;\nlet _ = bigAdd [1] [9;9;9];;\nlet _ = bigAdd [0;0;0] [9;9;9];;\nlet _ = bigAdd [0;0;0;0] [9;9;9];;\nlet _ = bigAdd [0] [];;\nlet _ = bigAdd [3] [];;\nlet _ = bigAdd [0] [0];;\n\n\n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> (match acc with\n              | [] -> []\n              | h::t -> if h = 0 then t else acc)\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 [1;2;3]\nlet _ = mulByDigit 1 [1;2;3]\nlet _ = mulByDigit 10 [1;2;3]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 5 [0;0;0]\nlet _ = mulByDigit 9 []\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 []\n\n\nlet bigMul l1 l2 = \n  let f a x = a in\n  let base = failwith \"to be implemented\" in\n  let args = \n    (let rec digitProducts acc place l1 l2 = match l1 with\n       | [] -> acc\n       | h::t -> \n           (let placeHolders = \n             let rec buildZeros a places = \n               if places = 0 then a else buildZeros (0::a) (places-1) in\n               buildZeros [] place in \n            let acc' = List.append (mulByDigit h l2) placeHolders) in\n       digitProducts acc' (place+1) t l2) in\n  let (_, res) = List.fold_left f base args in\n    res;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigMul l1 l2 = \nlet f a x = a in\nlet base = failwith \"to be implemented\" in\nlet args = \n(let rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \n(let placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1)) in\nbuildZeros [] place in \nlet acc' = List.append (mulByDigit h l2) placeHolders) in\ndigitProducts acc' (place+1) t l2","min":"","type":"syntax","out":"Characters 277-278:\n  if places = 0 then a else buildZeros (0::a) (places-1)) in\n                                                        ^\nError: Syntax error: operator expected.\n"},{"in":") in\nlet (_, res) = List.fold_left f base args in\nres","min":"","type":"syntax","out":"Characters 0-1:\n  ) in\n  ^\nError: Syntax error\n"}],"event":{"region":{"start":4370,"stop":4823},"type":"eval"},"cursor":4825,"time":1.398645287132791e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]\nlet _ = padZero [1;0;0;2] []\nlet _ = padZero [77] [9;9;4;5;6;7;8;9;0]\nlet _ = padZero [] []\nlet _ = padZero [] [9]\nlet _ = padZero [0;0] [1]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair acc list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> pair (List.append acc [(h1,h2)]) t1 t2\n          | (_ , _) -> List.append acc [(0,0)]\n      in pair [] (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [1;2;3] [];;\nlet _ = bigAdd [] [];;\nlet _ = bigAdd [] [3;4;5];;\nlet _ = bigAdd [1] [9;9;9];;\nlet _ = bigAdd [0;0;0] [9;9;9];;\nlet _ = bigAdd [0;0;0;0] [9;9;9];;\nlet _ = bigAdd [0] [];;\nlet _ = bigAdd [3] [];;\nlet _ = bigAdd [0] [0];;\n\n\n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> (match acc with\n              | [] -> []\n              | h::t -> if h = 0 then t else acc)\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 [1;2;3]\nlet _ = mulByDigit 1 [1;2;3]\nlet _ = mulByDigit 10 [1;2;3]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 5 [0;0;0]\nlet _ = mulByDigit 9 []\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 []\n\n\nlet bigMul l1 l2 = \n  let f a x = a in\n  let base = failwith \"to be implemented\" in\n  let args = \n    (let rec digitProducts acc place l1 l2 = match l1 with\n       | [] -> acc\n       | h::t -> \n           (let placeHolders = \n             (let rec buildZeros a places = \n               if places = 0 then a else buildZeros (0::a) (places-1)) in\n              buildZeros [] place in \n     let acc' = List.append (mulByDigit h l2) placeHolders) in\n    digitProducts acc' (place+1) t l2) in\nlet (_, res) = List.fold_left f base args in\n  res;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigMul l1 l2 = \nlet f a x = a in\nlet base = failwith \"to be implemented\" in\nlet args = \n(let rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \n(let placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in\nbuildZeros [] place) in \nlet acc' = List.append (mulByDigit h l2) placeHolders) in\ndigitProducts acc' (place+1) t l2) in\nlet (_, res) = List.fold_left f base args in\nres","min":"","type":"syntax","out":"Characters 359-360:\n  let acc' = List.append (mulByDigit h l2) placeHolders) in\n                                                       ^\nError: Syntax error: operator expected.\n"}],"event":{"region":{"start":4370,"stop":4823},"type":"eval"},"cursor":4825,"time":1.398645305903207e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]\nlet _ = padZero [1;0;0;2] []\nlet _ = padZero [77] [9;9;4;5;6;7;8;9;0]\nlet _ = padZero [] []\nlet _ = padZero [] [9]\nlet _ = padZero [0;0] [1]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair acc list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> pair (List.append acc [(h1,h2)]) t1 t2\n          | (_ , _) -> List.append acc [(0,0)]\n      in pair [] (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [1;2;3] [];;\nlet _ = bigAdd [] [];;\nlet _ = bigAdd [] [3;4;5];;\nlet _ = bigAdd [1] [9;9;9];;\nlet _ = bigAdd [0;0;0] [9;9;9];;\nlet _ = bigAdd [0;0;0;0] [9;9;9];;\nlet _ = bigAdd [0] [];;\nlet _ = bigAdd [3] [];;\nlet _ = bigAdd [0] [0];;\n\n\n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> (match acc with\n              | [] -> []\n              | h::t -> if h = 0 then t else acc)\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 [1;2;3]\nlet _ = mulByDigit 1 [1;2;3]\nlet _ = mulByDigit 10 [1;2;3]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 5 [0;0;0]\nlet _ = mulByDigit 9 []\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 []\n\n\nlet bigMul l1 l2 = \n  let f a x = a in\n  let base = failwith \"to be implemented\" in\n  let args = \n    (let rec digitProducts acc place l1 l2 = match l1 with\n       | [] -> acc\n       | h::t -> \n           (let placeHolders = \n             (let rec buildZeros a places = \n               if places = 0 then a else buildZeros (0::a) (places-1) in\n                buildZeros [] place) in \n            let acc' = List.append (mulByDigit h l2) placeHolders) in\n       digitProducts acc' (place+1) t l2) in\n  let (_, res) = List.fold_left f base args in\n    res;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigMul l1 l2 = \nlet f a x = a in\nlet base = failwith \"to be implemented\" in\nlet args = \n(let rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \n(let placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in\nbuildZeros [] place) in \nlet acc' = List.append (mulByDigit h l2) placeHolders in\ndigitProducts acc' (place+1) t l2)) in\nlet (_, res) = List.fold_left f base args in\nres","min":"","type":"syntax","out":"Characters 397-398:\n  digitProducts acc' (place+1) t l2)) in\n                                    ^\nError: Syntax error: operator expected.\n"}],"event":{"region":{"start":4370,"stop":4823},"type":"eval"},"cursor":4825,"time":1.398645335551302e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]\nlet _ = padZero [1;0;0;2] []\nlet _ = padZero [77] [9;9;4;5;6;7;8;9;0]\nlet _ = padZero [] []\nlet _ = padZero [] [9]\nlet _ = padZero [0;0] [1]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair acc list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> pair (List.append acc [(h1,h2)]) t1 t2\n          | (_ , _) -> List.append acc [(0,0)]\n      in pair [] (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [1;2;3] [];;\nlet _ = bigAdd [] [];;\nlet _ = bigAdd [] [3;4;5];;\nlet _ = bigAdd [1] [9;9;9];;\nlet _ = bigAdd [0;0;0] [9;9;9];;\nlet _ = bigAdd [0;0;0;0] [9;9;9];;\nlet _ = bigAdd [0] [];;\nlet _ = bigAdd [3] [];;\nlet _ = bigAdd [0] [0];;\n\n\n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> (match acc with\n              | [] -> []\n              | h::t -> if h = 0 then t else acc)\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 [1;2;3]\nlet _ = mulByDigit 1 [1;2;3]\nlet _ = mulByDigit 10 [1;2;3]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 5 [0;0;0]\nlet _ = mulByDigit 9 []\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 []\n\n\nlet bigMul l1 l2 = \n  let f a x = a in\n  let base = failwith \"to be implemented\" in\n  let args = \n    (let rec digitProducts acc place l1 l2 = match l1 with\n       | [] -> acc\n       | h::t -> \n           (let placeHolders = \n             (let rec buildZeros a places = \n               if places = 0 then a else buildZeros (0::a) (places-1) in\n                buildZeros [] place) in \n            let acc' = List.append (mulByDigit h l2) placeHolders in\n              digitProducts acc' (place+1) t l2)) in\n  let (_, res) = List.fold_left f base args in\n    res;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigMul l1 l2 = \nlet f a x = a in\nlet base = failwith \"to be implemented\" in\nlet args = \n(let rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \n(let placeHolders = \n(let rec buildZeros a places = if places = 0 then a else buildZeros (0::a) (places-1) in buildZeros [] place) in \nlet acc' = List.append (mulByDigit h l2) placeHolders in\ndigitProducts acc' (place+1) t l2)) in\nlet (_, res) = List.fold_left f base args in\nres","min":"","type":"syntax","out":"Characters 396-397:\n  digitProducts acc' (place+1) t l2)) in\n                                    ^\nError: Syntax error: operator expected.\n"}],"event":{"region":{"start":4370,"stop":4822},"type":"eval"},"cursor":4818,"time":1.398645395393272e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]\nlet _ = padZero [1;0;0;2] []\nlet _ = padZero [77] [9;9;4;5;6;7;8;9;0]\nlet _ = padZero [] []\nlet _ = padZero [] [9]\nlet _ = padZero [0;0] [1]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair acc list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> pair (List.append acc [(h1,h2)]) t1 t2\n          | (_ , _) -> List.append acc [(0,0)]\n      in pair [] (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [1;2;3] [];;\nlet _ = bigAdd [] [];;\nlet _ = bigAdd [] [3;4;5];;\nlet _ = bigAdd [1] [9;9;9];;\nlet _ = bigAdd [0;0;0] [9;9;9];;\nlet _ = bigAdd [0;0;0;0] [9;9;9];;\nlet _ = bigAdd [0] [];;\nlet _ = bigAdd [3] [];;\nlet _ = bigAdd [0] [0];;\n\n\n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> (match acc with\n              | [] -> []\n              | h::t -> if h = 0 then t else acc)\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 [1;2;3]\nlet _ = mulByDigit 1 [1;2;3]\nlet _ = mulByDigit 10 [1;2;3]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 5 [0;0;0]\nlet _ = mulByDigit 9 []\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 []\n\n\nlet bigMul l1 l2 = \n  let f a x = a in\n  let base = failwith \"to be implemented\" in\n  let args = \n    (let rec digitProducts acc place l1 l2 = match l1 with\n       | [] -> acc\n       | h::t -> \n           (let placeHolders = \n             (let rec buildZeros a places = if places = 0 then a else buildZeros (0::a) (places-1) in buildZeros [] place) in \n            let acc' = List.append (mulByDigit h l2) placeHolders in\n              digitProducts acc' (place+1) t l2)) in\n  let (_, res) = List.fold_left f base args in\n    res;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigMul l1 l2 = \nlet f a x = a in\nlet base = failwith \"to be implemented\" in\nlet args = \n(let rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet acc' = List.append (mulByDigit h l2) placeHolders in\ndigitProducts acc' (place+1) t l2) in\nlet (_, res) = List.fold_left f base args in\nres","min":"","type":"syntax","out":"Characters 396-397:\n  digitProducts acc' (place+1) t l2) in\n                                   ^\nError: Syntax error: operator expected.\n"}],"event":{"region":{"start":4370,"stop":4822},"type":"eval"},"cursor":4824,"time":1.398645442278225e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]\nlet _ = padZero [1;0;0;2] []\nlet _ = padZero [77] [9;9;4;5;6;7;8;9;0]\nlet _ = padZero [] []\nlet _ = padZero [] [9]\nlet _ = padZero [0;0] [1]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair acc list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> pair (List.append acc [(h1,h2)]) t1 t2\n          | (_ , _) -> List.append acc [(0,0)]\n      in pair [] (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [1;2;3] [];;\nlet _ = bigAdd [] [];;\nlet _ = bigAdd [] [3;4;5];;\nlet _ = bigAdd [1] [9;9;9];;\nlet _ = bigAdd [0;0;0] [9;9;9];;\nlet _ = bigAdd [0;0;0;0] [9;9;9];;\nlet _ = bigAdd [0] [];;\nlet _ = bigAdd [3] [];;\nlet _ = bigAdd [0] [0];;\n\n\n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> (match acc with\n              | [] -> []\n              | h::t -> if h = 0 then t else acc)\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 [1;2;3]\nlet _ = mulByDigit 1 [1;2;3]\nlet _ = mulByDigit 10 [1;2;3]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 5 [0;0;0]\nlet _ = mulByDigit 9 []\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 []\n\n\nlet bigMul l1 l2 = \n  let f a x = a in\n  let base = failwith \"to be implemented\" in\n  let args = \n    (let rec digitProducts acc place l1 l2 = match l1 with\n       | [] -> acc\n       | h::t -> \n           let placeHolders = \n             (let rec buildZeros a places = \n               if places = 0 then a else buildZeros (0::a) (places-1) in \n                buildZeros [] place) in \n           let acc' = List.append (mulByDigit h l2) placeHolders in\n             digitProducts acc' (place+1) t l2) in\n  let (_, res) = List.fold_left f base args in\n    res;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigMul l1 l2 = \nlet f a x = a in\nlet base = failwith \"to be implemented\" in\nlet args = \n(let rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = List.append (mulByDigit h l2) placeHolders in\ndigitProducts a::acc (place+1) t l2) in\nlet (_, res) = List.fold_left f base args in\nres","min":"","type":"syntax","out":"Characters 395-396:\n  digitProducts a::acc (place+1) t l2) in\n                                     ^\nError: Syntax error: operator expected.\n"}],"event":{"region":{"start":4370,"stop":4821},"type":"eval"},"cursor":4823,"time":1.398645524838849e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]\nlet _ = padZero [1;0;0;2] []\nlet _ = padZero [77] [9;9;4;5;6;7;8;9;0]\nlet _ = padZero [] []\nlet _ = padZero [] [9]\nlet _ = padZero [0;0] [1]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair acc list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> pair (List.append acc [(h1,h2)]) t1 t2\n          | (_ , _) -> List.append acc [(0,0)]\n      in pair [] (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [1;2;3] [];;\nlet _ = bigAdd [] [];;\nlet _ = bigAdd [] [3;4;5];;\nlet _ = bigAdd [1] [9;9;9];;\nlet _ = bigAdd [0;0;0] [9;9;9];;\nlet _ = bigAdd [0;0;0;0] [9;9;9];;\nlet _ = bigAdd [0] [];;\nlet _ = bigAdd [3] [];;\nlet _ = bigAdd [0] [0];;\n\n\n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> (match acc with\n              | [] -> []\n              | h::t -> if h = 0 then t else acc)\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 [1;2;3]\nlet _ = mulByDigit 1 [1;2;3]\nlet _ = mulByDigit 10 [1;2;3]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 5 [0;0;0]\nlet _ = mulByDigit 9 []\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 []\n\n\nlet bigMul l1 l2 = \n  let f a x = a in\n  let base = failwith \"to be implemented\" in\n  let args = \n    (let rec digitProducts acc place l1 l2 = match l1 with\n       | [] -> acc\n       | h::t -> \n           let placeHolders = \n             (let rec buildZeros a places = \n               if places = 0 then a else buildZeros (0::a) (places-1) in \n                buildZeros [] place) in \n           let a = List.append (mulByDigit h l2) placeHolders in\n             digitProducts a::acc (place+1) t l2) in\n  let (_, res) = List.fold_left f base args in\n    res;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigMul l1 l2 = \nlet f a x = a in\nlet base = failwith \"to be implemented\" in\nlet args = \n(let rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = List.append (mulByDigit h l2) placeHolders in\ndigitProducts a::acc (place+1) t l2+) in\nlet (_, res) = List.fold_left f base args in\nres","min":"","type":"syntax","out":"Characters 396-397:\n  digitProducts a::acc (place+1) t l2+) in\n                                      ^\nError: Syntax error: operator expected.\n"}],"event":{"region":{"start":4370,"stop":4822},"type":"eval"},"cursor":4769,"time":1.398645531150105e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]\nlet _ = padZero [1;0;0;2] []\nlet _ = padZero [77] [9;9;4;5;6;7;8;9;0]\nlet _ = padZero [] []\nlet _ = padZero [] [9]\nlet _ = padZero [0;0] [1]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair acc list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> pair (List.append acc [(h1,h2)]) t1 t2\n          | (_ , _) -> List.append acc [(0,0)]\n      in pair [] (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [1;2;3] [];;\nlet _ = bigAdd [] [];;\nlet _ = bigAdd [] [3;4;5];;\nlet _ = bigAdd [1] [9;9;9];;\nlet _ = bigAdd [0;0;0] [9;9;9];;\nlet _ = bigAdd [0;0;0;0] [9;9;9];;\nlet _ = bigAdd [0] [];;\nlet _ = bigAdd [3] [];;\nlet _ = bigAdd [0] [0];;\n\n\n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> (match acc with\n              | [] -> []\n              | h::t -> if h = 0 then t else acc)\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 [1;2;3]\nlet _ = mulByDigit 1 [1;2;3]\nlet _ = mulByDigit 10 [1;2;3]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 5 [0;0;0]\nlet _ = mulByDigit 9 []\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 []\n\n\nlet bigMul l1 l2 = \n  let f a x = a in\n  let base = failwith \"to be implemented\" in\n  let args = \n    (let rec digitProducts acc place l1 l2 = match l1 with\n       | [] -> acc\n       | h::t -> \n           let placeHolders = \n             (let rec buildZeros a places = \n               if places = 0 then a else buildZeros (0::a) (places-1) in \n                buildZeros [] place) in \n           let a = List.append (mulByDigit h l2) placeHolders in\n             digitProducts a::acc (place+1) t l2+) in\n  let (_, res) = List.fold_left f base args in\n    res;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigMul l1 l2 = \nlet f a x = a in\nlet base = failwith \"to be implemented\" in\nlet args = \n(let rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = List.append (mulByDigit h l2) placeHolders in\ndigitProducts a::acc (place+1) t l2) \nin\nlet (_, res) = List.fold_left f base args in\nres","min":"","type":"syntax","out":"Characters 395-396:\n  digitProducts a::acc (place+1) t l2) \n                                     ^\nError: Syntax error: operator expected.\n"}],"event":{"region":{"start":4370,"stop":4822},"type":"eval"},"cursor":4824,"time":1.398645560344651e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]\nlet _ = padZero [1;0;0;2] []\nlet _ = padZero [77] [9;9;4;5;6;7;8;9;0]\nlet _ = padZero [] []\nlet _ = padZero [] [9]\nlet _ = padZero [0;0] [1]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair acc list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> pair (List.append acc [(h1,h2)]) t1 t2\n          | (_ , _) -> List.append acc [(0,0)]\n      in pair [] (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [1;2;3] [];;\nlet _ = bigAdd [] [];;\nlet _ = bigAdd [] [3;4;5];;\nlet _ = bigAdd [1] [9;9;9];;\nlet _ = bigAdd [0;0;0] [9;9;9];;\nlet _ = bigAdd [0;0;0;0] [9;9;9];;\nlet _ = bigAdd [0] [];;\nlet _ = bigAdd [3] [];;\nlet _ = bigAdd [0] [0];;\n\n\n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> (match acc with\n              | [] -> []\n              | h::t -> if h = 0 then t else acc)\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 [1;2;3]\nlet _ = mulByDigit 1 [1;2;3]\nlet _ = mulByDigit 10 [1;2;3]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 5 [0;0;0]\nlet _ = mulByDigit 9 []\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 []\n\n\nlet bigMul l1 l2 = \n  let f a x = a in\n  let base = failwith \"to be implemented\" in\n  let args = \n    (let rec digitProducts acc place l1 l2 = match l1 with\n       | [] -> acc\n       | h::t -> \n           let placeHolders = \n             (let rec buildZeros a places = \n               if places = 0 then a else buildZeros (0::a) (places-1) in \n                buildZeros [] place) in \n           let a = List.append (mulByDigit h l2) placeHolders in\n             digitProducts a::acc (place+1) t l2) \n  in\n  let (_, res) = List.fold_left f base args in\n    res;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigMul l1 l2 = \nlet f a x = a in\nlet base = failwith \"to be implemented\" in\nlet args = \n(let rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = List.append (mulByDigit h l2) placeHolders in\ndigitProducts a::acc (place+1) t l2","min":"","type":"syntax","out":"Characters 395-397:\n  digitProducts a::acc (place+1) t l2;;\n                                     ^^\nError: Syntax error: operator expected.\n"},{"in":") \nin\nlet (_, res) = List.fold_left f base args in\nres","min":"","type":"syntax","out":"Characters 0-1:\n  ) \n  ^\nError: Syntax error\n"}],"event":{"region":{"start":4370,"stop":4824},"type":"eval"},"cursor":4770,"time":1.398645566096379e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]\nlet _ = padZero [1;0;0;2] []\nlet _ = padZero [77] [9;9;4;5;6;7;8;9;0]\nlet _ = padZero [] []\nlet _ = padZero [] [9]\nlet _ = padZero [0;0] [1]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair acc list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> pair (List.append acc [(h1,h2)]) t1 t2\n          | (_ , _) -> List.append acc [(0,0)]\n      in pair [] (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [1;2;3] [];;\nlet _ = bigAdd [] [];;\nlet _ = bigAdd [] [3;4;5];;\nlet _ = bigAdd [1] [9;9;9];;\nlet _ = bigAdd [0;0;0] [9;9;9];;\nlet _ = bigAdd [0;0;0;0] [9;9;9];;\nlet _ = bigAdd [0] [];;\nlet _ = bigAdd [3] [];;\nlet _ = bigAdd [0] [0];;\n\n\n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> (match acc with\n              | [] -> []\n              | h::t -> if h = 0 then t else acc)\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 [1;2;3]\nlet _ = mulByDigit 1 [1;2;3]\nlet _ = mulByDigit 10 [1;2;3]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 5 [0;0;0]\nlet _ = mulByDigit 9 []\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 []\n\n\nlet bigMul l1 l2 = \n  let f a x = a in\n  let base = failwith \"to be implemented\" in\n  let args = \n    (let rec digitProducts acc place l1 l2 = match l1 with\n       | [] -> acc\n       | h::t -> \n           let placeHolders = \n             (let rec buildZeros a places = \n               if places = 0 then a else buildZeros (0::a) (places-1) in \n                buildZeros [] place) in \n           let a = List.append (mulByDigit h l2) placeHolders in\n             digitProducts a::acc (place+1) t l2;;) \n  in\n  let (_, res) = List.fold_left f base args in\n    res;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigMul l1 l2 = \nlet f a x = a in\nlet base = failwith \"to be implemented\" in\nlet args = \n(let rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = List.append (mulByDigit h l2) placeHolders in\ndigitProducts a::acc (place+1) t) \nin\nlet (_, res) = List.fold_left f base args in\nres","min":"","type":"syntax","out":"Characters 392-393:\n  digitProducts a::acc (place+1) t) \n                                  ^\nError: Syntax error: operator expected.\n"}],"event":{"region":{"start":4370,"stop":4819},"type":"eval"},"cursor":4765,"time":1.398645573136803e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]\nlet _ = padZero [1;0;0;2] []\nlet _ = padZero [77] [9;9;4;5;6;7;8;9;0]\nlet _ = padZero [] []\nlet _ = padZero [] [9]\nlet _ = padZero [0;0] [1]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair acc list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> pair (List.append acc [(h1,h2)]) t1 t2\n          | (_ , _) -> List.append acc [(0,0)]\n      in pair [] (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [1;2;3] [];;\nlet _ = bigAdd [] [];;\nlet _ = bigAdd [] [3;4;5];;\nlet _ = bigAdd [1] [9;9;9];;\nlet _ = bigAdd [0;0;0] [9;9;9];;\nlet _ = bigAdd [0;0;0;0] [9;9;9];;\nlet _ = bigAdd [0] [];;\nlet _ = bigAdd [3] [];;\nlet _ = bigAdd [0] [0];;\n\n\n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> (match acc with\n              | [] -> []\n              | h::t -> if h = 0 then t else acc)\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 [1;2;3]\nlet _ = mulByDigit 1 [1;2;3]\nlet _ = mulByDigit 10 [1;2;3]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 5 [0;0;0]\nlet _ = mulByDigit 9 []\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 []\n\n\nlet bigMul l1 l2 = \n  let f a x = a in\n  let base = failwith \"to be implemented\" in\n  let args = \n    (let rec digitProducts acc place l1 l2 = match l1 with\n       | [] -> acc\n       | h::t -> \n           let placeHolders = \n             (let rec buildZeros a places = \n               if places = 0 then a else buildZeros (0::a) (places-1) in \n                buildZeros [] place) in \n           let a = List.append (mulByDigit h l2) placeHolders in\n             digitProducts a::acc (place+1) t) \n  in\n  let (_, res) = List.fold_left f base args in\n    res;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigMul l1 l2 = \nlet f a x = a in\nlet base = failwith \"to be implemented\" in\nlet args = \n(let rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = \n(List.append (mulByDigit h l2) placeHolders) in\ndigitProducts a::acc (place+1) t l2) \nin\nlet (_, res) = List.fold_left f base args in\nres","min":"","type":"syntax","out":"Characters 398-399:\n  digitProducts a::acc (place+1) t l2) \n                                     ^\nError: Syntax error: operator expected.\n"}],"event":{"region":{"start":4370,"stop":4825},"type":"eval"},"cursor":4773,"time":1.398645610109525e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]\nlet _ = padZero [1;0;0;2] []\nlet _ = padZero [77] [9;9;4;5;6;7;8;9;0]\nlet _ = padZero [] []\nlet _ = padZero [] [9]\nlet _ = padZero [0;0] [1]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair acc list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> pair (List.append acc [(h1,h2)]) t1 t2\n          | (_ , _) -> List.append acc [(0,0)]\n      in pair [] (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [1;2;3] [];;\nlet _ = bigAdd [] [];;\nlet _ = bigAdd [] [3;4;5];;\nlet _ = bigAdd [1] [9;9;9];;\nlet _ = bigAdd [0;0;0] [9;9;9];;\nlet _ = bigAdd [0;0;0;0] [9;9;9];;\nlet _ = bigAdd [0] [];;\nlet _ = bigAdd [3] [];;\nlet _ = bigAdd [0] [0];;\n\n\n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> (match acc with\n              | [] -> []\n              | h::t -> if h = 0 then t else acc)\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 [1;2;3]\nlet _ = mulByDigit 1 [1;2;3]\nlet _ = mulByDigit 10 [1;2;3]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 5 [0;0;0]\nlet _ = mulByDigit 9 []\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 []\n\n\nlet bigMul l1 l2 = \n  let f a x = a in\n  let base = failwith \"to be implemented\" in\n  let args = \n    (let rec digitProducts acc place l1 l2 = match l1 with\n       | [] -> acc\n       | h::t -> \n           let placeHolders = \n             (let rec buildZeros a places = \n               if places = 0 then a else buildZeros (0::a) (places-1) in \n                buildZeros [] place) in \n           let a = \n             (List.append (mulByDigit h l2) placeHolders) in\n             digitProducts a::acc (place+1) t l2) \n  in\n  let (_, res) = List.fold_left f base args in\n    res;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigMul l1 l2 = \nlet f a x = a in\nlet base = failwith \"to be implemented\" in\nlet args = \nlet rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = \n(List.append (mulByDigit h l2) placeHolders) in\ndigitProducts a::acc (place+1) t l2 in\ndigitsProducts [] 0 l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = a in\n  let base = failwith \"to be implemented\" in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          (digitProducts a) :: (acc (place + 1) t l2) in\n    digitsProducts [] 0 l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n","type":"type","out":"Characters 362-377:\n  digitProducts a::acc (place+1) t l2 in\n  ^^^^^^^^^^^^^^^\nError: This expression has type int -> int list -> int list -> int list\n       but an expression was expected of type int\n"}],"event":{"region":{"start":4370,"stop":4851},"type":"eval"},"cursor":4853,"time":1.398645787100004e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]\nlet _ = padZero [1;0;0;2] []\nlet _ = padZero [77] [9;9;4;5;6;7;8;9;0]\nlet _ = padZero [] []\nlet _ = padZero [] [9]\nlet _ = padZero [0;0] [1]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair acc list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> pair (List.append acc [(h1,h2)]) t1 t2\n          | (_ , _) -> List.append acc [(0,0)]\n      in pair [] (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [1;2;3] [];;\nlet _ = bigAdd [] [];;\nlet _ = bigAdd [] [3;4;5];;\nlet _ = bigAdd [1] [9;9;9];;\nlet _ = bigAdd [0;0;0] [9;9;9];;\nlet _ = bigAdd [0;0;0;0] [9;9;9];;\nlet _ = bigAdd [0] [];;\nlet _ = bigAdd [3] [];;\nlet _ = bigAdd [0] [0];;\n\n\n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> (match acc with\n              | [] -> []\n              | h::t -> if h = 0 then t else acc)\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 [1;2;3]\nlet _ = mulByDigit 1 [1;2;3]\nlet _ = mulByDigit 10 [1;2;3]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 5 [0;0;0]\nlet _ = mulByDigit 9 []\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 []\n\n\nlet bigMul l1 l2 = \n  let f a x = a in\n  let base = failwith \"to be implemented\" in\n  let args = \n    let rec digitProducts acc place l1 l2 = match l1 with\n      | [] -> acc\n      | h::t -> \n          let placeHolders = \n            (let rec buildZeros a places = \n              if places = 0 then a else buildZeros (0::a) (places-1) in \n               buildZeros [] place) in \n          let a = \n            (List.append (mulByDigit h l2) placeHolders) in\n            digitProducts a::acc (place+1) t l2 in\n      digitsProducts [] 0 l1 l2 in\n  let (_, res) = List.fold_left f base args in\n    res;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigMul l1 l2 = \nlet f a x = a in\nlet base = failwith \"to be implemented\" in\nlet args = \nlet rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = \n(List.append (mulByDigit h l2) placeHolders) in\ndigitProducts (a::acc) (place+1) t l2 in\ndigitsProducts [] 0 l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = a in\n  let base = failwith \"to be implemented\" in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitsProducts [] 0 l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n","type":"scope","out":"Characters 403-417:\n  digitsProducts [] 0 l1 l2 in\n  ^^^^^^^^^^^^^^\nError: Unbound value digitsProducts\n"}],"event":{"region":{"start":4370,"stop":4853},"type":"eval"},"cursor":4855,"time":1.398645821274133e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]\nlet _ = padZero [1;0;0;2] []\nlet _ = padZero [77] [9;9;4;5;6;7;8;9;0]\nlet _ = padZero [] []\nlet _ = padZero [] [9]\nlet _ = padZero [0;0] [1]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair acc list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> pair (List.append acc [(h1,h2)]) t1 t2\n          | (_ , _) -> List.append acc [(0,0)]\n      in pair [] (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [1;2;3] [];;\nlet _ = bigAdd [] [];;\nlet _ = bigAdd [] [3;4;5];;\nlet _ = bigAdd [1] [9;9;9];;\nlet _ = bigAdd [0;0;0] [9;9;9];;\nlet _ = bigAdd [0;0;0;0] [9;9;9];;\nlet _ = bigAdd [0] [];;\nlet _ = bigAdd [3] [];;\nlet _ = bigAdd [0] [0];;\n\n\n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> (match acc with\n              | [] -> []\n              | h::t -> if h = 0 then t else acc)\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 [1;2;3]\nlet _ = mulByDigit 1 [1;2;3]\nlet _ = mulByDigit 10 [1;2;3]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 5 [0;0;0]\nlet _ = mulByDigit 9 []\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 []\n\n\nlet bigMul l1 l2 = \n  let f a x = a in\n  let base = failwith \"to be implemented\" in\n  let args = \n    let rec digitProducts acc place l1 l2 = match l1 with\n      | [] -> acc\n      | h::t -> \n          let placeHolders = \n            (let rec buildZeros a places = \n              if places = 0 then a else buildZeros (0::a) (places-1) in \n               buildZeros [] place) in \n          let a = \n            (List.append (mulByDigit h l2) placeHolders) in\n            digitProducts (a::acc) (place+1) t l2 in\n      digitsProducts [] 0 l1 l2 in\n  let (_, res) = List.fold_left f base args in\n    res;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigMul l1 l2 = \nlet f a x = a in\nlet base = failwith \"to be implemented\" in\nlet args = \nlet rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = \n(List.append (mulByDigit h l2) placeHolders) in\ndigitProducts (a::acc) (place+1) t l2 in\ndigitProducts [] 0 l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = a in\n  let base = failwith \"to be implemented\" in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n","type":"","out":""}],"event":{"region":{"start":4370,"stop":4852},"type":"eval"},"cursor":4854,"time":1.398645829377308e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]\nlet _ = padZero [1;0;0;2] []\nlet _ = padZero [77] [9;9;4;5;6;7;8;9;0]\nlet _ = padZero [] []\nlet _ = padZero [] [9]\nlet _ = padZero [0;0] [1]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair acc list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> pair (List.append acc [(h1,h2)]) t1 t2\n          | (_ , _) -> List.append acc [(0,0)]\n      in pair [] (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [1;2;3] [];;\nlet _ = bigAdd [] [];;\nlet _ = bigAdd [] [3;4;5];;\nlet _ = bigAdd [1] [9;9;9];;\nlet _ = bigAdd [0;0;0] [9;9;9];;\nlet _ = bigAdd [0;0;0;0] [9;9;9];;\nlet _ = bigAdd [0] [];;\nlet _ = bigAdd [3] [];;\nlet _ = bigAdd [0] [0];;\n\n\n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> (match acc with\n              | [] -> []\n              | h::t -> if h = 0 then t else acc)\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 [1;2;3]\nlet _ = mulByDigit 1 [1;2;3]\nlet _ = mulByDigit 10 [1;2;3]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 5 [0;0;0]\nlet _ = mulByDigit 9 []\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 []\n\n\nlet bigMul l1 l2 = \n  let f a x = a in\n  let base = failwith \"to be implemented\" in\n  let args = \n    let rec digitProducts acc place l1 l2 = match l1 with\n      | [] -> acc\n      | h::t -> \n          let placeHolders = \n            (let rec buildZeros a places = \n              if places = 0 then a else buildZeros (0::a) (places-1) in \n               buildZeros [] place) in \n          let a = \n            (List.append (mulByDigit h l2) placeHolders) in\n            digitProducts (a::acc) (place+1) t l2 in\n      digitProducts [] 0 l1 l2 in\n  let (_, res) = List.fold_left f base args in\n    res;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigMul l1 l2 = \nlet f a x =  bigAdd a x in\nlet base = [] in\nlet args = \nlet rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = \n(List.append (mulByDigit h l2) placeHolders) in\ndigitProducts (a::acc) (place+1) t l2 in\ndigitProducts [] 0 l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = bigAdd a x in\n  let base = [] in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n","type":"type","out":"Characters 430-456:\n  let (_, res) = List.fold_left f base args in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type 'a * 'b\n"}],"event":{"region":{"start":4370,"stop":4836},"type":"eval"},"cursor":4838,"time":1.398645884442071e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]\nlet _ = padZero [1;0;0;2] []\nlet _ = padZero [77] [9;9;4;5;6;7;8;9;0]\nlet _ = padZero [] []\nlet _ = padZero [] [9]\nlet _ = padZero [0;0] [1]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair acc list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> pair (List.append acc [(h1,h2)]) t1 t2\n          | (_ , _) -> List.append acc [(0,0)]\n      in pair [] (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [1;2;3] [];;\nlet _ = bigAdd [] [];;\nlet _ = bigAdd [] [3;4;5];;\nlet _ = bigAdd [1] [9;9;9];;\nlet _ = bigAdd [0;0;0] [9;9;9];;\nlet _ = bigAdd [0;0;0;0] [9;9;9];;\nlet _ = bigAdd [0] [];;\nlet _ = bigAdd [3] [];;\nlet _ = bigAdd [0] [0];;\n\n\n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> (match acc with\n              | [] -> []\n              | h::t -> if h = 0 then t else acc)\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 [1;2;3]\nlet _ = mulByDigit 1 [1;2;3]\nlet _ = mulByDigit 10 [1;2;3]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 5 [0;0;0]\nlet _ = mulByDigit 9 []\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 []\n\n\nlet bigMul l1 l2 = \n  let f a x =  bigAdd a x in\n  let base = [] in\n  let args = \n    let rec digitProducts acc place l1 l2 = match l1 with\n      | [] -> acc\n      | h::t -> \n          let placeHolders = \n            (let rec buildZeros a places = \n              if places = 0 then a else buildZeros (0::a) (places-1) in \n               buildZeros [] place) in \n          let a = \n            (List.append (mulByDigit h l2) placeHolders) in\n            digitProducts (a::acc) (place+1) t l2 in\n      digitProducts [] 0 l1 l2 in\n  let (_, res) = List.fold_left f base args in\n    res;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigMul l1 l2 = \nlet f a x =  match a with \n| (_, z) -> (0, bigAdd z x)\n| _ -> (0, 0) in\nlet base = [] in\nlet args = \nlet rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = \n(List.append (mulByDigit h l2) placeHolders) in\ndigitProducts (a::acc) (place+1) t l2 in\ndigitProducts [] 0 l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) | _ -> (0, 0) in\n  let base = [] in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n","type":"type","out":"Characters 86-87:\n  | _ -> (0, 0) in\n             ^\nError: This expression has type int but an expression was expected of type\n         int list\n"}],"event":{"region":{"start":4370,"stop":4881},"type":"eval"},"cursor":4883,"time":1.3986460133537e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]\nlet _ = padZero [1;0;0;2] []\nlet _ = padZero [77] [9;9;4;5;6;7;8;9;0]\nlet _ = padZero [] []\nlet _ = padZero [] [9]\nlet _ = padZero [0;0] [1]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair acc list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> pair (List.append acc [(h1,h2)]) t1 t2\n          | (_ , _) -> List.append acc [(0,0)]\n      in pair [] (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [1;2;3] [];;\nlet _ = bigAdd [] [];;\nlet _ = bigAdd [] [3;4;5];;\nlet _ = bigAdd [1] [9;9;9];;\nlet _ = bigAdd [0;0;0] [9;9;9];;\nlet _ = bigAdd [0;0;0;0] [9;9;9];;\nlet _ = bigAdd [0] [];;\nlet _ = bigAdd [3] [];;\nlet _ = bigAdd [0] [0];;\n\n\n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> (match acc with\n              | [] -> []\n              | h::t -> if h = 0 then t else acc)\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 [1;2;3]\nlet _ = mulByDigit 1 [1;2;3]\nlet _ = mulByDigit 10 [1;2;3]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 5 [0;0;0]\nlet _ = mulByDigit 9 []\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 []\n\n\nlet bigMul l1 l2 = \n  let f a x =  match a with \n    | (_, z) -> (0, bigAdd z x)\n    | _ -> (0, 0) in\n  let base = [] in\n  let args = \n    let rec digitProducts acc place l1 l2 = match l1 with\n      | [] -> acc\n      | h::t -> \n          let placeHolders = \n            (let rec buildZeros a places = \n              if places = 0 then a else buildZeros (0::a) (places-1) in \n               buildZeros [] place) in \n          let a = \n            (List.append (mulByDigit h l2) placeHolders) in\n            digitProducts (a::acc) (place+1) t l2 in\n      digitProducts [] 0 l1 l2 in\n  let (_, res) = List.fold_left f base args in\n    res;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigMul l1 l2 = \nlet f a x =  match a with \n| (_, z) -> (0, bigAdd z x)\n| _ -> (0, []) in\nlet base = [] in\nlet args = \nlet rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = \n(List.append (mulByDigit h l2) placeHolders) in\ndigitProducts (a::acc) (place+1) t l2 in\ndigitProducts [] 0 l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) | _ -> (0, []) in\n  let base = [] in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n","type":"type","out":"Characters 493-497:\n  let (_, res) = List.fold_left f base args in\n                                  ^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int * int list\n"}],"event":{"region":{"start":4370,"stop":4882},"type":"eval"},"cursor":4884,"time":1.398646024623452e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]\nlet _ = padZero [1;0;0;2] []\nlet _ = padZero [77] [9;9;4;5;6;7;8;9;0]\nlet _ = padZero [] []\nlet _ = padZero [] [9]\nlet _ = padZero [0;0] [1]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair acc list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> pair (List.append acc [(h1,h2)]) t1 t2\n          | (_ , _) -> List.append acc [(0,0)]\n      in pair [] (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [1;2;3] [];;\nlet _ = bigAdd [] [];;\nlet _ = bigAdd [] [3;4;5];;\nlet _ = bigAdd [1] [9;9;9];;\nlet _ = bigAdd [0;0;0] [9;9;9];;\nlet _ = bigAdd [0;0;0;0] [9;9;9];;\nlet _ = bigAdd [0] [];;\nlet _ = bigAdd [3] [];;\nlet _ = bigAdd [0] [0];;\n\n\n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> (match acc with\n              | [] -> []\n              | h::t -> if h = 0 then t else acc)\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 [1;2;3]\nlet _ = mulByDigit 1 [1;2;3]\nlet _ = mulByDigit 10 [1;2;3]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 5 [0;0;0]\nlet _ = mulByDigit 9 []\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 []\n\n\nlet bigMul l1 l2 = \n  let f a x =  match a with \n    | (_, z) -> (0, bigAdd z x)\n    | _ -> (0, []) in\n  let base = [] in\n  let args = \n    let rec digitProducts acc place l1 l2 = match l1 with\n      | [] -> acc\n      | h::t -> \n          let placeHolders = \n            (let rec buildZeros a places = \n              if places = 0 then a else buildZeros (0::a) (places-1) in \n               buildZeros [] place) in \n          let a = \n            (List.append (mulByDigit h l2) placeHolders) in\n            digitProducts (a::acc) (place+1) t l2 in\n      digitProducts [] 0 l1 l2 in\n  let (_, res) = List.fold_left f base args in\n    res;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigMul l1 l2 = \nlet f a x =  match a with \n| (_, z) -> (0, bigAdd z x)\n| _ -> (0, []) in\nlet base = (0, []) in\nlet args = \nlet rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = \n(List.append (mulByDigit h l2) placeHolders) in\ndigitProducts (a::acc) (place+1) t l2 in\ndigitProducts [] 0 l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) | _ -> (0, []) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n","type":"","out":""}],"event":{"region":{"start":4370,"stop":4887},"type":"eval"},"cursor":4889,"time":1.398646045124901e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]\nlet _ = padZero [1;0;0;2] []\nlet _ = padZero [77] [9;9;4;5;6;7;8;9;0]\nlet _ = padZero [] []\nlet _ = padZero [] [9]\nlet _ = padZero [0;0] [1]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair acc list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> pair (List.append acc [(h1,h2)]) t1 t2\n          | (_ , _) -> List.append acc [(0,0)]\n      in pair [] (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [1;2;3] [];;\nlet _ = bigAdd [] [];;\nlet _ = bigAdd [] [3;4;5];;\nlet _ = bigAdd [1] [9;9;9];;\nlet _ = bigAdd [0;0;0] [9;9;9];;\nlet _ = bigAdd [0;0;0;0] [9;9;9];;\nlet _ = bigAdd [0] [];;\nlet _ = bigAdd [3] [];;\nlet _ = bigAdd [0] [0];;\n\n\n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> (match acc with\n              | [] -> []\n              | h::t -> if h = 0 then t else acc)\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 [1;2;3]\nlet _ = mulByDigit 1 [1;2;3]\nlet _ = mulByDigit 10 [1;2;3]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 5 [0;0;0]\nlet _ = mulByDigit 9 []\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 []\n\n\nlet bigMul l1 l2 = \n  let f a x =  match a with \n    | (_, z) -> (0, bigAdd z x)\n    | _ -> (0, []) in\n  let base = (0, []) in\n  let args = \n    let rec digitProducts acc place l1 l2 = match l1 with\n      | [] -> acc\n      | h::t -> \n          let placeHolders = \n            (let rec buildZeros a places = \n              if places = 0 then a else buildZeros (0::a) (places-1) in \n               buildZeros [] place) in \n          let a = \n            (List.append (mulByDigit h l2) placeHolders) in\n            digitProducts (a::acc) (place+1) t l2 in\n      digitProducts [] 0 l1 l2 in\n  let (_, res) = List.fold_left f base args in\n    res;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigMul l1 l2 = \nlet f a x =  match a with \n| (_, z) -> (0, bigAdd z x) in\nlet base = (0, []) in\nlet args = \nlet rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = \n(List.append (mulByDigit h l2) placeHolders) in\ndigitProducts (a::acc) (place+1) t l2 in\ndigitProducts [] 0 l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n","type":"","out":""}],"event":{"region":{"start":4370,"stop":4872},"type":"eval"},"cursor":4874,"time":1.398646057704419e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]\nlet _ = padZero [1;0;0;2] []\nlet _ = padZero [77] [9;9;4;5;6;7;8;9;0]\nlet _ = padZero [] []\nlet _ = padZero [] [9]\nlet _ = padZero [0;0] [1]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair acc list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> pair (List.append acc [(h1,h2)]) t1 t2\n          | (_ , _) -> List.append acc [(0,0)]\n      in pair [] (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [1;2;3] [];;\nlet _ = bigAdd [] [];;\nlet _ = bigAdd [] [3;4;5];;\nlet _ = bigAdd [1] [9;9;9];;\nlet _ = bigAdd [0;0;0] [9;9;9];;\nlet _ = bigAdd [0;0;0;0] [9;9;9];;\nlet _ = bigAdd [0] [];;\nlet _ = bigAdd [3] [];;\nlet _ = bigAdd [0] [0];;\n\n\n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> (match acc with\n              | [] -> []\n              | h::t -> if h = 0 then t else acc)\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 [1;2;3]\nlet _ = mulByDigit 1 [1;2;3]\nlet _ = mulByDigit 10 [1;2;3]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 5 [0;0;0]\nlet _ = mulByDigit 9 []\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 []\n\n\nlet bigMul l1 l2 = \n  let f a x =  match a with \n    | (_, z) -> (0, bigAdd z x) in\n  let base = (0, []) in\n  let args = \n    let rec digitProducts acc place l1 l2 = match l1 with\n      | [] -> acc\n      | h::t -> \n          let placeHolders = \n            (let rec buildZeros a places = \n              if places = 0 then a else buildZeros (0::a) (places-1) in \n               buildZeros [] place) in \n          let a = \n            (List.append (mulByDigit h l2) placeHolders) in\n            digitProducts (a::acc) (place+1) t l2 in\n      digitProducts [] 0 l1 l2 in\n  let (_, res) = List.fold_left f base args in\n    res;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = bigMul [9;9;9;9] [9;9;9;9]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9; 9] [9; 9; 9; 9; 9];;\n","type":"","out":""}],"event":{"region":{"start":4872,"stop":4950},"type":"eval"},"cursor":4952,"time":1.398646064060881e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]\nlet _ = padZero [1;0;0;2] []\nlet _ = padZero [77] [9;9;4;5;6;7;8;9;0]\nlet _ = padZero [] []\nlet _ = padZero [] [9]\nlet _ = padZero [0;0] [1]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair acc list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> pair (List.append acc [(h1,h2)]) t1 t2\n          | (_ , _) -> List.append acc [(0,0)]\n      in pair [] (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [1;2;3] [];;\nlet _ = bigAdd [] [];;\nlet _ = bigAdd [] [3;4;5];;\nlet _ = bigAdd [1] [9;9;9];;\nlet _ = bigAdd [0;0;0] [9;9;9];;\nlet _ = bigAdd [0;0;0;0] [9;9;9];;\nlet _ = bigAdd [0] [];;\nlet _ = bigAdd [3] [];;\nlet _ = bigAdd [0] [0];;\n\n\n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> (match acc with\n              | [] -> []\n              | h::t -> if h = 0 then t else acc)\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 [1;2;3]\nlet _ = mulByDigit 1 [1;2;3]\nlet _ = mulByDigit 10 [1;2;3]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 5 [0;0;0]\nlet _ = mulByDigit 9 []\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 []\n\n\nlet bigMul l1 l2 = \n  let f a x =  match a with \n    | (_, z) -> (0, bigAdd z x) in\n  let base = (0, []) in\n  let args = \n    let rec digitProducts acc place l1 l2 = match l1 with\n      | [] -> acc\n      | h::t -> \n          let placeHolders = \n            (let rec buildZeros a places = \n              if places = 0 then a else buildZeros (0::a) (places-1) in \n               buildZeros [] place) in \n          let a = \n            (List.append (mulByDigit h l2) placeHolders) in\n            digitProducts (a::acc) (place+1) t l2 in\n      digitProducts [] 0 l1 l2 in\n  let (_, res) = List.fold_left f base args in\n    res;;\n\n\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = bigMul [] []","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [] [];;\n","type":"","out":""},{"in":"let _ = bigMul [] [0]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [] [0];;\n","type":"","out":""},{"in":"let _ = bigMul [0] []","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [0] [];;\n","type":"","out":""},{"in":"let _ = bigMul [] [1;2;3]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [] [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = bigMul [1;2;3] []","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1; 2; 3] [];;\n","type":"","out":""},{"in":"let _ = bigMul [0] [1;2;3]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [0] [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = bigMul [1;2;3] [0]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1; 2; 3] [0];;\n","type":"","out":""},{"in":"let _ = bigMul [1] [1;2;3]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1] [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = bigMul [1;2;3] [1]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1; 2; 3] [1];;\n","type":"","out":""},{"in":"let _ = bigMul [1;2;3] [5]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1; 2; 3] [5];;\n","type":"","out":""},{"in":"let _ = bigMul [5] [1;2;3]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [5] [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = bigMul [1;2;3] [5;6]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1; 2; 3] [5; 6];;\n","type":"","out":""},{"in":"let _ = bigMul [5;6] [1;2;3]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [5; 6] [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = bigMul [1;0;0] [5]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1; 0; 0] [5];;\n","type":"","out":""},{"in":"let _ = bigMul [5;2;1] [0;0]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [5; 2; 1] [0; 0];;\n","type":"","out":""},{"in":"let _ = bigMul [1;2;3;3] [0;0;0]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1; 2; 3; 3] [0; 0; 0];;\n","type":"","out":""}],"event":{"region":{"start":4950,"stop":5377},"type":"eval"},"cursor":5377,"time":1.398646169677252e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]\nlet _ = padZero [1;0;0;2] []\nlet _ = padZero [77] [9;9;4;5;6;7;8;9;0]\nlet _ = padZero [] []\nlet _ = padZero [] [9]\nlet _ = padZero [0;0] [1]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair acc list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> pair (List.append acc [(h1,h2)]) t1 t2\n          | (_ , _) -> List.append acc [(0,0)]\n      in pair [] (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [1;2;3] [];;\nlet _ = bigAdd [] [];;\nlet _ = bigAdd [] [3;4;5];;\nlet _ = bigAdd [1] [9;9;9];;\nlet _ = bigAdd [0;0;0] [9;9;9];;\nlet _ = bigAdd [0;0;0;0] [9;9;9];;\nlet _ = bigAdd [0] [];;\nlet _ = bigAdd [3] [];;\nlet _ = bigAdd [0] [0];;\n\n\n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> (match acc with\n              | [] -> []\n              | h::t -> if h = 0 then t else acc)\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 [1;2;3]\nlet _ = mulByDigit 1 [1;2;3]\nlet _ = mulByDigit 10 [1;2;3]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 5 [0;0;0]\nlet _ = mulByDigit 9 []\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 []\n\n\nlet bigMul l1 l2 = \n  let f a x =  match a with \n    | (_, z) -> (0, bigAdd z x) in\n  let base = (0, []) in\n  let args = \n    let rec digitProducts acc place l1 l2 = match l1 with\n      | [] -> acc\n      | h::t -> \n          let placeHolders = \n            (let rec buildZeros a places = \n              if places = 0 then a else buildZeros (0::a) (places-1) in \n               buildZeros [] place) in \n          let a = \n            (List.append (mulByDigit h l2) placeHolders) in\n            digitProducts (a::acc) (place+1) t l2 in\n      digitProducts [] 0 l1 l2 in\n  let (_, res) = List.fold_left f base args in\n    res;;\n\n\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \nlet _ = bigMul [] []\nlet _ = bigMul [] [0]\nlet _ = bigMul [0] []\nlet _ = bigMul [] [1;2;3]\nlet _ = bigMul [1;2;3] []\nlet _ = bigMul [0] [1;2;3]\nlet _ = bigMul [1;2;3] [0]\nlet _ = bigMul [1] [1;2;3]\nlet _ = bigMul [1;2;3] [1]\nlet _ = bigMul [1;2;3] [5]\nlet _ = bigMul [5] [1;2;3]\nlet _ = bigMul [1;2;3] [5;6]\nlet _ = bigMul [5;6] [1;2;3]\nlet _ = bigMul [1;0;0] [5]\nlet _ = bigMul [5;2;1] [0;0]\nlet _ = bigMul [1;2;3;3] [0;0;0]\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigMul l1 l2 = \nlet f a x =  match a with \n| (_, z) -> (0, bigAdd z x) in\nlet base = (0, []) in\nlet args = \nlet rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = \n(List.append (mulByDigit h l2) placeHolders) in\ndigitProducts (a::acc) (place+1) t l2 in\ndigitProducts [] 0 (List.rev l1) l2 in\nlet (_, res) = List.fold_left f base args in\nres","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n","type":"","out":""},{"in":"let _ = bigMul [9;9;9;9] [9;9;9;9]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9; 9] [9; 9; 9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigMul [] []","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [] [];;\n","type":"","out":""},{"in":"let _ = bigMul [] [0]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [] [0];;\n","type":"","out":""},{"in":"let _ = bigMul [0] []","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [0] [];;\n","type":"","out":""},{"in":"let _ = bigMul [] [1;2;3]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [] [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = bigMul [1;2;3] []","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1; 2; 3] [];;\n","type":"","out":""},{"in":"let _ = bigMul [0] [1;2;3]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [0] [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = bigMul [1;2;3] [0]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1; 2; 3] [0];;\n","type":"","out":""},{"in":"let _ = bigMul [1] [1;2;3]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1] [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = bigMul [1;2;3] [1]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1; 2; 3] [1];;\n","type":"","out":""},{"in":"let _ = bigMul [1;2;3] [5]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1; 2; 3] [5];;\n","type":"","out":""},{"in":"let _ = bigMul [5] [1;2;3]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [5] [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = bigMul [1;2;3] [5;6]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1; 2; 3] [5; 6];;\n","type":"","out":""},{"in":"let _ = bigMul [5;6] [1;2;3]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [5; 6] [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = bigMul [1;0;0] [5]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1; 0; 0] [5];;\n","type":"","out":""},{"in":"let _ = bigMul [5;2;1] [0;0]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [5; 2; 1] [0; 0];;\n","type":"","out":""},{"in":"let _ = bigMul [1;2;3;3] [0;0;0]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1; 2; 3; 3] [0; 0; 0];;\n","type":"","out":""}],"event":{"region":{"start":4370,"stop":5388},"type":"eval"},"cursor":5388,"time":1.398646327067239e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]\nlet _ = padZero [1;0;0;2] []\nlet _ = padZero [77] [9;9;4;5;6;7;8;9;0]\nlet _ = padZero [] []\nlet _ = padZero [] [9]\nlet _ = padZero [0;0] [1]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair acc list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> pair (List.append acc [(h1,h2)]) t1 t2\n          | (_ , _) -> List.append acc [(0,0)]\n      in pair [] (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [1;2;3] [];;\nlet _ = bigAdd [] [];;\nlet _ = bigAdd [] [3;4;5];;\nlet _ = bigAdd [1] [9;9;9];;\nlet _ = bigAdd [0;0;0] [9;9;9];;\nlet _ = bigAdd [0;0;0;0] [9;9;9];;\nlet _ = bigAdd [0] [];;\nlet _ = bigAdd [3] [];;\nlet _ = bigAdd [0] [0];;\n\n\n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> (match acc with\n              | [] -> []\n              | h::t -> if h = 0 then t else acc)\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 [1;2;3]\nlet _ = mulByDigit 1 [1;2;3]\nlet _ = mulByDigit 10 [1;2;3]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 5 [0;0;0]\nlet _ = mulByDigit 9 []\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 []\n\n\nlet bigMul l1 l2 = \n  let f a x =  match a with \n    | (_, z) -> (0, bigAdd z x) in\n  let base = (0, []) in\n  let args = \n    let rec digitProducts acc place l1 l2 = match l1 with\n      | [] -> acc\n      | h::t -> \n          let placeHolders = \n            (let rec buildZeros a places = \n              if places = 0 then a else buildZeros (0::a) (places-1) in \n               buildZeros [] place) in \n          let a = \n            (List.append (mulByDigit h l2) placeHolders) in\n            digitProducts (a::acc) (place+1) t l2 in\n      digitProducts [] 0 (List.rev l1) l2 in\n  let (_, res) = List.fold_left f base args in\n    res;;\n\n\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \nlet _ = bigMul [] []\nlet _ = bigMul [] [0]\nlet _ = bigMul [0] []\nlet _ = bigMul [] [1;2;3]\nlet _ = bigMul [1;2;3] []\nlet _ = bigMul [0] [1;2;3]\nlet _ = bigMul [1;2;3] [0]\nlet _ = bigMul [1] [1;2;3]\nlet _ = bigMul [1;2;3] [1]\nlet _ = bigMul [1;2;3] [5]\nlet _ = bigMul [5] [1;2;3]\nlet _ = bigMul [1;2;3] [5;6]\nlet _ = bigMul [5;6] [1;2;3]\nlet _ = bigMul [1;0;0] [5]\nlet _ = bigMul [5;2;1] [0;0]\nlet _ = bigMul [1;2;3;3] [0;0;0]\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = bigMul [1;2;3;3] [0;0;0]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1; 2; 3; 3] [0; 0; 0];;\n","type":"","out":""}],"event":{"region":{"start":5355,"stop":5388},"type":"eval"},"cursor":5388,"time":1.398646364119355e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]\nlet _ = padZero [1;0;0;2] []\nlet _ = padZero [77] [9;9;4;5;6;7;8;9;0]\nlet _ = padZero [] []\nlet _ = padZero [] [9]\nlet _ = padZero [0;0] [1]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair acc list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> pair (List.append acc [(h1,h2)]) t1 t2\n          | (_ , _) -> List.append acc [(0,0)]\n      in pair [] (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [1;2;3] [];;\nlet _ = bigAdd [] [];;\nlet _ = bigAdd [] [3;4;5];;\nlet _ = bigAdd [1] [9;9;9];;\nlet _ = bigAdd [0;0;0] [9;9;9];;\nlet _ = bigAdd [0;0;0;0] [9;9;9];;\nlet _ = bigAdd [0] [];;\nlet _ = bigAdd [3] [];;\nlet _ = bigAdd [0] [0];;\n\n\n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> (match acc with\n              | [] -> []\n              | h::t -> if h = 0 then t else acc)\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 [1;2;3]\nlet _ = mulByDigit 1 [1;2;3]\nlet _ = mulByDigit 10 [1;2;3]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 5 [0;0;0]\nlet _ = mulByDigit 9 []\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 []\n\n\nlet bigMul l1 l2 = \n  let f a x =  match a with \n    | (_, z) -> (0, bigAdd z x) in\n  let base = (0, []) in\n  let args = \n    let rec digitProducts acc place l1 l2 = match l1 with\n      | [] -> acc\n      | h::t -> \n          let placeHolders = \n            (let rec buildZeros a places = \n              if places = 0 then a else buildZeros (0::a) (places-1) in \n               buildZeros [] place) in \n          let a = \n            (List.append (mulByDigit h l2) placeHolders) in\n            digitProducts (a::acc) (place+1) t l2 in\n      digitProducts [] 0 (List.rev l1) l2 in\n  let (_, res) = List.fold_left f base args in\n    res;;\n\n\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \nlet _ = bigMul [] []\nlet _ = bigMul [] [0]\nlet _ = bigMul [0] []\nlet _ = bigMul [] [1;2;3]\nlet _ = bigMul [1;2;3] []\nlet _ = bigMul [0] [1;2;3]\nlet _ = bigMul [1;2;3] [0]\nlet _ = bigMul [1] [1;2;3]\nlet _ = bigMul [1;2;3] [1]\nlet _ = bigMul [1;2;3] [5]\nlet _ = bigMul [5] [1;2;3]\nlet _ = bigMul [1;2;3] [5;6]\nlet _ = bigMul [5;6] [1;2;3]\nlet _ = bigMul [1;0;0] [5]\nlet _ = bigMul [5;2;1] [0;0]\nlet _ = bigMul [1;2;3;3] [0;0;0]\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = bigMul [0] [0]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [0] [0];;\n","type":"","out":""},{"in":"let _ = bigMul [] [0]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [] [0];;\n","type":"","out":""},{"in":"let _ = bigMul [0] []","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [0] [];;\n","type":"","out":""},{"in":"let _ = bigMul [] [1;2;3]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [] [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = bigMul [1;2;3] []","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1; 2; 3] [];;\n","type":"","out":""},{"in":"let _ = bigMul [0] [1;2;3]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [0] [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = bigMul [1;2;3] [0]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1; 2; 3] [0];;\n","type":"","out":""},{"in":"let _ = bigMul [1] [1;2;3]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1] [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = bigMul [1;2;3] [1]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1; 2; 3] [1];;\n","type":"","out":""},{"in":"let _ = bigMul [1;2;3] [5]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1; 2; 3] [5];;\n","type":"","out":""},{"in":"let _ = bigMul [5] [1;2;3]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [5] [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = bigMul [1;2;3] [5;6]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1; 2; 3] [5; 6];;\n","type":"","out":""},{"in":"let _ = bigMul [5;6] [1;2;3]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [5; 6] [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = bigMul [1;0;0] [5]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1; 0; 0] [5];;\n","type":"","out":""},{"in":"let _ = bigMul [5;2;1] [0;0]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [5; 2; 1] [0; 0];;\n","type":"","out":""},{"in":"let _ = bigMul [1;2;3;3] [0;0;0]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1; 2; 3; 3] [0; 0; 0];;\n","type":"","out":""},{"in":"let _ = bigMul [5] [5]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [5] [5];;\n","type":"","out":""}],"event":{"region":{"start":4983,"stop":5434},"type":"eval"},"cursor":5434,"time":1.398646394857029e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]\nlet _ = padZero [1;0;0;2] []\nlet _ = padZero [77] [9;9;4;5;6;7;8;9;0]\nlet _ = padZero [] []\nlet _ = padZero [] [9]\nlet _ = padZero [0;0] [1]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair acc list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> pair (List.append acc [(h1,h2)]) t1 t2\n          | (_ , _) -> List.append acc [(0,0)]\n      in pair [] (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [1;2;3] [];;\nlet _ = bigAdd [] [];;\nlet _ = bigAdd [] [3;4;5];;\nlet _ = bigAdd [1] [9;9;9];;\nlet _ = bigAdd [0;0;0] [9;9;9];;\nlet _ = bigAdd [0;0;0;0] [9;9;9];;\nlet _ = bigAdd [0] [];;\nlet _ = bigAdd [3] [];;\nlet _ = bigAdd [0] [0];;\n\n\n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> (match acc with\n              | [] -> []\n              | h::t -> if h = 0 then t else acc)\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 [1;2;3]\nlet _ = mulByDigit 1 [1;2;3]\nlet _ = mulByDigit 10 [1;2;3]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 5 [0;0;0]\nlet _ = mulByDigit 9 []\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 []\n\n\nlet bigMul l1 l2 = \n  let f a x =  match a with \n    | (_, z) -> (0, bigAdd z x) in\n  let base = (0, []) in\n  let args = \n    let rec digitProducts acc place l1 l2 = match l1 with\n      | [] -> acc\n      | h::t -> \n          let placeHolders = \n            (let rec buildZeros a places = \n              if places = 0 then a else buildZeros (0::a) (places-1) in \n               buildZeros [] place) in \n          let a = \n            (List.append (mulByDigit h l2) placeHolders) in\n            digitProducts (a::acc) (place+1) t l2 in\n      digitProducts [] 0 (List.rev l1) l2 in\n  let (_, res) = List.fold_left f base args in\n    res;;\n\n\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \nlet _ = bigMul [] []\nlet _ = bigMul [0] [0]\nlet _ = bigMul [] [0]\nlet _ = bigMul [0] []\nlet _ = bigMul [] [1;2;3]\nlet _ = bigMul [1;2;3] []\nlet _ = bigMul [0] [1;2;3]\nlet _ = bigMul [1;2;3] [0]\nlet _ = bigMul [1] [1;2;3]\nlet _ = bigMul [1;2;3] [1]\nlet _ = bigMul [1;2;3] [5]\nlet _ = bigMul [5] [1;2;3]\nlet _ = bigMul [1;2;3] [5;6]\nlet _ = bigMul [5;6] [1;2;3]\nlet _ = bigMul [1;0;0] [5]\nlet _ = bigMul [5;2;1] [0;0]\nlet _ = bigMul [1;2;3;3] [0;0;0]\nlet _ = bigMul [5] [5]\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let pipe fs = \nlet f a x = x a in\nlet base =  fun y ->  y in\nList.fold_left f base fs","min":"\nlet pipe fs = let f a x = x a in let base y = y in List.fold_left f base fs;;\n","type":"","out":""}],"event":{"region":{"start":919,"stop":1004},"type":"eval"},"cursor":976,"time":1.398652021391701e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base =  fun y ->  y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]\nlet _ = padZero [1;0;0;2] []\nlet _ = padZero [77] [9;9;4;5;6;7;8;9;0]\nlet _ = padZero [] []\nlet _ = padZero [] [9]\nlet _ = padZero [0;0] [1]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair acc list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> pair (List.append acc [(h1,h2)]) t1 t2\n          | (_ , _) -> List.append acc [(0,0)]\n      in pair [] (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [1;2;3] [];;\nlet _ = bigAdd [] [];;\nlet _ = bigAdd [] [3;4;5];;\nlet _ = bigAdd [1] [9;9;9];;\nlet _ = bigAdd [0;0;0] [9;9;9];;\nlet _ = bigAdd [0;0;0;0] [9;9;9];;\nlet _ = bigAdd [0] [];;\nlet _ = bigAdd [3] [];;\nlet _ = bigAdd [0] [0];;\n\n\n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> (match acc with\n              | [] -> []\n              | h::t -> if h = 0 then t else acc)\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 [1;2;3]\nlet _ = mulByDigit 1 [1;2;3]\nlet _ = mulByDigit 10 [1;2;3]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 5 [0;0;0]\nlet _ = mulByDigit 9 []\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 []\n\n\nlet bigMul l1 l2 = \n  let f a x =  match a with \n    | (_, z) -> (0, bigAdd z x) in\n  let base = (0, []) in\n  let args = \n    let rec digitProducts acc place l1 l2 = match l1 with\n      | [] -> acc\n      | h::t -> \n          let placeHolders = \n            (let rec buildZeros a places = \n              if places = 0 then a else buildZeros (0::a) (places-1) in \n               buildZeros [] place) in \n          let a = \n            (List.append (mulByDigit h l2) placeHolders) in\n            digitProducts (a::acc) (place+1) t l2 in\n      digitProducts [] 0 (List.rev l1) l2 in\n  let (_, res) = List.fold_left f base args in\n    res;;\n\n\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \nlet _ = bigMul [] []\nlet _ = bigMul [0] [0]\nlet _ = bigMul [] [0]\nlet _ = bigMul [0] []\nlet _ = bigMul [] [1;2;3]\nlet _ = bigMul [1;2;3] []\nlet _ = bigMul [0] [1;2;3]\nlet _ = bigMul [1;2;3] [0]\nlet _ = bigMul [1] [1;2;3]\nlet _ = bigMul [1;2;3] [1]\nlet _ = bigMul [1;2;3] [5]\nlet _ = bigMul [5] [1;2;3]\nlet _ = bigMul [1;2;3] [5;6]\nlet _ = bigMul [5;6] [1;2;3]\nlet _ = bigMul [1;0;0] [5]\nlet _ = bigMul [5;2;1] [0;0]\nlet _ = bigMul [1;2;3;3] [0;0;0]\nlet _ = bigMul [5] [5]\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let sqsum xs = \nlet f a x =  a + x*x in\nlet base = 0 in\nList.fold_left f base xs","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n","type":"","out":""}],"event":{"region":{"start":753,"stop":833},"type":"eval"},"cursor":833,"time":1.398652046534456e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base = function f -> y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]\nlet _ = padZero [1;0;0;2] []\nlet _ = padZero [77] [9;9;4;5;6;7;8;9;0]\nlet _ = padZero [] []\nlet _ = padZero [] [9]\nlet _ = padZero [0;0] [1]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair acc list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> pair (List.append acc [(h1,h2)]) t1 t2\n          | (_ , _) -> List.append acc [(0,0)]\n      in pair [] (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [1;2;3] [];;\nlet _ = bigAdd [] [];;\nlet _ = bigAdd [] [3;4;5];;\nlet _ = bigAdd [1] [9;9;9];;\nlet _ = bigAdd [0;0;0] [9;9;9];;\nlet _ = bigAdd [0;0;0;0] [9;9;9];;\nlet _ = bigAdd [0] [];;\nlet _ = bigAdd [3] [];;\nlet _ = bigAdd [0] [0];;\n\n\n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> (match acc with\n              | [] -> []\n              | h::t -> if h = 0 then t else acc)\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 [1;2;3]\nlet _ = mulByDigit 1 [1;2;3]\nlet _ = mulByDigit 10 [1;2;3]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 5 [0;0;0]\nlet _ = mulByDigit 9 []\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 []\n\n\nlet bigMul l1 l2 = \n  let f a x =  match a with \n    | (_, z) -> (0, bigAdd z x) in\n  let base = (0, []) in\n  let args = \n    let rec digitProducts acc place l1 l2 = match l1 with\n      | [] -> acc\n      | h::t -> \n          let placeHolders = \n            (let rec buildZeros a places = \n              if places = 0 then a else buildZeros (0::a) (places-1) in \n               buildZeros [] place) in \n          let a = \n            (List.append (mulByDigit h l2) placeHolders) in\n            digitProducts (a::acc) (place+1) t l2 in\n      digitProducts [] 0 (List.rev l1) l2 in\n  let (_, res) = List.fold_left f base args in\n    res;;\n\n\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \nlet _ = bigMul [] []\nlet _ = bigMul [0] [0]\nlet _ = bigMul [] [0]\nlet _ = bigMul [0] []\nlet _ = bigMul [] [1;2;3]\nlet _ = bigMul [1;2;3] []\nlet _ = bigMul [0] [1;2;3]\nlet _ = bigMul [1;2;3] [0]\nlet _ = bigMul [1] [1;2;3]\nlet _ = bigMul [1;2;3] [1]\nlet _ = bigMul [1;2;3] [5]\nlet _ = bigMul [5] [1;2;3]\nlet _ = bigMul [1;2;3] [5;6]\nlet _ = bigMul [5;6] [1;2;3]\nlet _ = bigMul [1;0;0] [5]\nlet _ = bigMul [5;2;1] [0;0]\nlet _ = bigMul [1;2;3;3] [0;0;0]\nlet _ = bigMul [5] [5]\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = sqsum []","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [];;\n","type":"","out":""},{"in":"let _ = sqsum [1;2;3;4]","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sqsum [(-1); (-2); (-3); (-4)]","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [(-1); (-2); (-3); (-4)];;\n","type":"","out":""},{"in":"let pipe fs = \nlet f a x = x a in\nlet base = function f -> y in\nList.fold_left f base fs","min":"\nlet pipe fs =\n  let f a x = x a in let base = function | f -> y in List.fold_left f base fs;;\n","type":"scope","out":"Characters 59-60:\n  let base = function f -> y in\n                           ^\nError: Unbound value y\n"}],"event":{"region":{"start":833,"stop":1007},"type":"eval"},"cursor":1007,"time":1.398652049351764e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base = function f -> y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]\nlet _ = padZero [1;0;0;2] []\nlet _ = padZero [77] [9;9;4;5;6;7;8;9;0]\nlet _ = padZero [] []\nlet _ = padZero [] [9]\nlet _ = padZero [0;0] [1]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair acc list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> pair (List.append acc [(h1,h2)]) t1 t2\n          | (_ , _) -> List.append acc [(0,0)]\n      in pair [] (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [1;2;3] [];;\nlet _ = bigAdd [] [];;\nlet _ = bigAdd [] [3;4;5];;\nlet _ = bigAdd [1] [9;9;9];;\nlet _ = bigAdd [0;0;0] [9;9;9];;\nlet _ = bigAdd [0;0;0;0] [9;9;9];;\nlet _ = bigAdd [0] [];;\nlet _ = bigAdd [3] [];;\nlet _ = bigAdd [0] [0];;\n\n\n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> (match acc with\n              | [] -> []\n              | h::t -> if h = 0 then t else acc)\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 [1;2;3]\nlet _ = mulByDigit 1 [1;2;3]\nlet _ = mulByDigit 10 [1;2;3]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 5 [0;0;0]\nlet _ = mulByDigit 9 []\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 []\n\n\nlet bigMul l1 l2 = \n  let f a x =  match a with \n    | (_, z) -> (0, bigAdd z x) in\n  let base = (0, []) in\n  let args = \n    let rec digitProducts acc place l1 l2 = match l1 with\n      | [] -> acc\n      | h::t -> \n          let placeHolders = \n            (let rec buildZeros a places = \n              if places = 0 then a else buildZeros (0::a) (places-1) in \n               buildZeros [] place) in \n          let a = \n            (List.append (mulByDigit h l2) placeHolders) in\n            digitProducts (a::acc) (place+1) t l2 in\n      digitProducts [] 0 (List.rev l1) l2 in\n  let (_, res) = List.fold_left f base args in\n    res;;\n\n\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \nlet _ = bigMul [] []\nlet _ = bigMul [0] [0]\nlet _ = bigMul [] [0]\nlet _ = bigMul [0] []\nlet _ = bigMul [] [1;2;3]\nlet _ = bigMul [1;2;3] []\nlet _ = bigMul [0] [1;2;3]\nlet _ = bigMul [1;2;3] [0]\nlet _ = bigMul [1] [1;2;3]\nlet _ = bigMul [1;2;3] [1]\nlet _ = bigMul [1;2;3] [5]\nlet _ = bigMul [5] [1;2;3]\nlet _ = bigMul [1;2;3] [5;6]\nlet _ = bigMul [5;6] [1;2;3]\nlet _ = bigMul [1;0;0] [5]\nlet _ = bigMul [5;2;1] [0;0]\nlet _ = bigMul [1;2;3;3] [0;0;0]\nlet _ = bigMul [5] [5]\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let pipe fs = \nlet f a x = x a in\nlet base = function y -> y in\nList.fold_left f base fs","min":"\nlet pipe fs =\n  let f a x = x a in let base = function | y -> y in List.fold_left f base fs;;\n","type":"","out":""}],"event":{"region":{"start":915,"stop":1007},"type":"eval"},"cursor":1007,"time":1.398652054665541e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base = function y -> y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]\nlet _ = padZero [1;0;0;2] []\nlet _ = padZero [77] [9;9;4;5;6;7;8;9;0]\nlet _ = padZero [] []\nlet _ = padZero [] [9]\nlet _ = padZero [0;0] [1]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair acc list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> pair (List.append acc [(h1,h2)]) t1 t2\n          | (_ , _) -> List.append acc [(0,0)]\n      in pair [] (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [1;2;3] [];;\nlet _ = bigAdd [] [];;\nlet _ = bigAdd [] [3;4;5];;\nlet _ = bigAdd [1] [9;9;9];;\nlet _ = bigAdd [0;0;0] [9;9;9];;\nlet _ = bigAdd [0;0;0;0] [9;9;9];;\nlet _ = bigAdd [0] [];;\nlet _ = bigAdd [3] [];;\nlet _ = bigAdd [0] [0];;\n\n\n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> (match acc with\n              | [] -> []\n              | h::t -> if h = 0 then t else acc)\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 [1;2;3]\nlet _ = mulByDigit 1 [1;2;3]\nlet _ = mulByDigit 10 [1;2;3]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 5 [0;0;0]\nlet _ = mulByDigit 9 []\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 []\n\n\nlet bigMul l1 l2 = \n  let f a x =  match a with \n    | (_, z) -> (0, bigAdd z x) in\n  let base = (0, []) in\n  let args = \n    let rec digitProducts acc place l1 l2 = match l1 with\n      | [] -> acc\n      | h::t -> \n          let placeHolders = \n            (let rec buildZeros a places = \n              if places = 0 then a else buildZeros (0::a) (places-1) in \n               buildZeros [] place) in \n          let a = \n            (List.append (mulByDigit h l2) placeHolders) in\n            digitProducts (a::acc) (place+1) t l2 in\n      digitProducts [] 0 (List.rev l1) l2 in\n  let (_, res) = List.fold_left f base args in\n    res;;\n\n\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \nlet _ = bigMul [] []\nlet _ = bigMul [0] [0]\nlet _ = bigMul [] [0]\nlet _ = bigMul [0] []\nlet _ = bigMul [] [1;2;3]\nlet _ = bigMul [1;2;3] []\nlet _ = bigMul [0] [1;2;3]\nlet _ = bigMul [1;2;3] [0]\nlet _ = bigMul [1] [1;2;3]\nlet _ = bigMul [1;2;3] [1]\nlet _ = bigMul [1;2;3] [5]\nlet _ = bigMul [5] [1;2;3]\nlet _ = bigMul [1;2;3] [5;6]\nlet _ = bigMul [5;6] [1;2;3]\nlet _ = bigMul [1;0;0] [5]\nlet _ = bigMul [5;2;1] [0;0]\nlet _ = bigMul [1;2;3;3] [0;0;0]\nlet _ = bigMul [5] [5]\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let pipe fs = \nlet f a x = x a in\nlet base = let ass y -> y in\nass y in\nList.fold_left f base fs","min":"","type":"syntax","out":"Characters 55-57:\n  let base = let ass y -> y in\n                       ^^\nError: Syntax error\n"}],"event":{"region":{"start":915,"stop":1015},"type":"eval"},"cursor":1015,"time":1.398652084568055e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base = let ass y -> y in\n      ass y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]\nlet _ = padZero [1;0;0;2] []\nlet _ = padZero [77] [9;9;4;5;6;7;8;9;0]\nlet _ = padZero [] []\nlet _ = padZero [] [9]\nlet _ = padZero [0;0] [1]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair acc list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> pair (List.append acc [(h1,h2)]) t1 t2\n          | (_ , _) -> List.append acc [(0,0)]\n      in pair [] (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [1;2;3] [];;\nlet _ = bigAdd [] [];;\nlet _ = bigAdd [] [3;4;5];;\nlet _ = bigAdd [1] [9;9;9];;\nlet _ = bigAdd [0;0;0] [9;9;9];;\nlet _ = bigAdd [0;0;0;0] [9;9;9];;\nlet _ = bigAdd [0] [];;\nlet _ = bigAdd [3] [];;\nlet _ = bigAdd [0] [0];;\n\n\n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> (match acc with\n              | [] -> []\n              | h::t -> if h = 0 then t else acc)\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 [1;2;3]\nlet _ = mulByDigit 1 [1;2;3]\nlet _ = mulByDigit 10 [1;2;3]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 5 [0;0;0]\nlet _ = mulByDigit 9 []\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 []\n\n\nlet bigMul l1 l2 = \n  let f a x =  match a with \n    | (_, z) -> (0, bigAdd z x) in\n  let base = (0, []) in\n  let args = \n    let rec digitProducts acc place l1 l2 = match l1 with\n      | [] -> acc\n      | h::t -> \n          let placeHolders = \n            (let rec buildZeros a places = \n              if places = 0 then a else buildZeros (0::a) (places-1) in \n               buildZeros [] place) in \n          let a = \n            (List.append (mulByDigit h l2) placeHolders) in\n            digitProducts (a::acc) (place+1) t l2 in\n      digitProducts [] 0 (List.rev l1) l2 in\n  let (_, res) = List.fold_left f base args in\n    res;;\n\n\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \nlet _ = bigMul [] []\nlet _ = bigMul [0] [0]\nlet _ = bigMul [] [0]\nlet _ = bigMul [0] []\nlet _ = bigMul [] [1;2;3]\nlet _ = bigMul [1;2;3] []\nlet _ = bigMul [0] [1;2;3]\nlet _ = bigMul [1;2;3] [0]\nlet _ = bigMul [1] [1;2;3]\nlet _ = bigMul [1;2;3] [1]\nlet _ = bigMul [1;2;3] [5]\nlet _ = bigMul [5] [1;2;3]\nlet _ = bigMul [1;2;3] [5;6]\nlet _ = bigMul [5;6] [1;2;3]\nlet _ = bigMul [1;0;0] [5]\nlet _ = bigMul [5;2;1] [0;0]\nlet _ = bigMul [1;2;3;3] [0;0;0]\nlet _ = bigMul [5] [5]\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let pipe fs = \nlet f a x = x a in\nlet base = let ass y -> y in\nList.fold_left f base fs","min":"","type":"syntax","out":"Characters 55-57:\n  let base = let ass y -> y in\n                       ^^\nError: Syntax error\n"}],"event":{"region":{"start":915,"stop":1006},"type":"eval"},"cursor":1006,"time":1.39865211383427e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base = let ass y -> y in\n      List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]\nlet _ = padZero [1;0;0;2] []\nlet _ = padZero [77] [9;9;4;5;6;7;8;9;0]\nlet _ = padZero [] []\nlet _ = padZero [] [9]\nlet _ = padZero [0;0] [1]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair acc list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> pair (List.append acc [(h1,h2)]) t1 t2\n          | (_ , _) -> List.append acc [(0,0)]\n      in pair [] (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [1;2;3] [];;\nlet _ = bigAdd [] [];;\nlet _ = bigAdd [] [3;4;5];;\nlet _ = bigAdd [1] [9;9;9];;\nlet _ = bigAdd [0;0;0] [9;9;9];;\nlet _ = bigAdd [0;0;0;0] [9;9;9];;\nlet _ = bigAdd [0] [];;\nlet _ = bigAdd [3] [];;\nlet _ = bigAdd [0] [0];;\n\n\n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> (match acc with\n              | [] -> []\n              | h::t -> if h = 0 then t else acc)\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 [1;2;3]\nlet _ = mulByDigit 1 [1;2;3]\nlet _ = mulByDigit 10 [1;2;3]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 5 [0;0;0]\nlet _ = mulByDigit 9 []\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 []\n\n\nlet bigMul l1 l2 = \n  let f a x =  match a with \n    | (_, z) -> (0, bigAdd z x) in\n  let base = (0, []) in\n  let args = \n    let rec digitProducts acc place l1 l2 = match l1 with\n      | [] -> acc\n      | h::t -> \n          let placeHolders = \n            (let rec buildZeros a places = \n              if places = 0 then a else buildZeros (0::a) (places-1) in \n               buildZeros [] place) in \n          let a = \n            (List.append (mulByDigit h l2) placeHolders) in\n            digitProducts (a::acc) (place+1) t l2 in\n      digitProducts [] 0 (List.rev l1) l2 in\n  let (_, res) = List.fold_left f base args in\n    res;;\n\n\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \nlet _ = bigMul [] []\nlet _ = bigMul [0] [0]\nlet _ = bigMul [] [0]\nlet _ = bigMul [0] []\nlet _ = bigMul [] [1;2;3]\nlet _ = bigMul [1;2;3] []\nlet _ = bigMul [0] [1;2;3]\nlet _ = bigMul [1;2;3] [0]\nlet _ = bigMul [1] [1;2;3]\nlet _ = bigMul [1;2;3] [1]\nlet _ = bigMul [1;2;3] [5]\nlet _ = bigMul [5] [1;2;3]\nlet _ = bigMul [1;2;3] [5;6]\nlet _ = bigMul [5;6] [1;2;3]\nlet _ = bigMul [1;0;0] [5]\nlet _ = bigMul [5;2;1] [0;0]\nlet _ = bigMul [1;2;3;3] [0;0;0]\nlet _ = bigMul [5] [5]\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let pipe fs = \nlet f a x = x a in\nlet base = fun y -> y in\nList.fold_left f base fs","min":"\nlet pipe fs = let f a x = x a in let base y = y in List.fold_left f base fs;;\n","type":"","out":""}],"event":{"region":{"start":915,"stop":1002},"type":"eval"},"cursor":1002,"time":1.398652129223664e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base = fun y -> y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]\nlet _ = padZero [1;0;0;2] []\nlet _ = padZero [77] [9;9;4;5;6;7;8;9;0]\nlet _ = padZero [] []\nlet _ = padZero [] [9]\nlet _ = padZero [0;0] [1]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair acc list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> pair (List.append acc [(h1,h2)]) t1 t2\n          | (_ , _) -> List.append acc [(0,0)]\n      in pair [] (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [1;2;3] [];;\nlet _ = bigAdd [] [];;\nlet _ = bigAdd [] [3;4;5];;\nlet _ = bigAdd [1] [9;9;9];;\nlet _ = bigAdd [0;0;0] [9;9;9];;\nlet _ = bigAdd [0;0;0;0] [9;9;9];;\nlet _ = bigAdd [0] [];;\nlet _ = bigAdd [3] [];;\nlet _ = bigAdd [0] [0];;\n\n\n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> (match acc with\n              | [] -> []\n              | h::t -> if h = 0 then t else acc)\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 [1;2;3]\nlet _ = mulByDigit 1 [1;2;3]\nlet _ = mulByDigit 10 [1;2;3]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 5 [0;0;0]\nlet _ = mulByDigit 9 []\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 []\n\n\nlet bigMul l1 l2 = \n  let f a x =  match a with \n    | (_, z) -> (0, bigAdd z x) in\n  let base = (0, []) in\n  let args = \n    let rec digitProducts acc place l1 l2 = match l1 with\n      | [] -> acc\n      | h::t -> \n          let placeHolders = \n            (let rec buildZeros a places = \n              if places = 0 then a else buildZeros (0::a) (places-1) in \n               buildZeros [] place) in \n          let a = \n            (List.append (mulByDigit h l2) placeHolders) in\n            digitProducts (a::acc) (place+1) t l2 in\n      digitProducts [] 0 (List.rev l1) l2 in\n  let (_, res) = List.fold_left f base args in\n    res;;\n\n\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \nlet _ = bigMul [] []\nlet _ = bigMul [0] [0]\nlet _ = bigMul [] [0]\nlet _ = bigMul [0] []\nlet _ = bigMul [] [1;2;3]\nlet _ = bigMul [1;2;3] []\nlet _ = bigMul [0] [1;2;3]\nlet _ = bigMul [1;2;3] [0]\nlet _ = bigMul [1] [1;2;3]\nlet _ = bigMul [1;2;3] [1]\nlet _ = bigMul [1;2;3] [5]\nlet _ = bigMul [5] [1;2;3]\nlet _ = bigMul [1;2;3] [5;6]\nlet _ = bigMul [5;6] [1;2;3]\nlet _ = bigMul [1;0;0] [5]\nlet _ = bigMul [5;2;1] [0;0]\nlet _ = bigMul [1;2;3;3] [0;0;0]\nlet _ = bigMul [5] [5]\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let pipe fs = \nlet f a x = x a in\nlet base = fun y -> y in\nList.fold_left f base fs","min":"\nlet pipe fs = let f a x = x a in let base y = y in List.fold_left f base fs;;\n","type":"","out":""},{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x  in\nlet base = h in\nlet l = t in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n","type":"","out":""},{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"---\" []","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"---\" [];;\n","type":"","out":""},{"in":"let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"\" [\"a\"; \"b\"; \"c\"; \"d\"; \"e\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"X\" [\"hello\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"X\" [\"hello\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"a\" []","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"a\" [];;\n","type":"","out":""},{"in":"let _ = sepConcat \"a\" [\"b\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"a\" [\"b\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"\" []","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"\" [];;\n","type":"","out":""},{"in":"let _ = sepConcat \"\" [\"bc\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"\" [\"bc\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"z\" [\"\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"z\" [\"\"];;\n","type":"","out":""},{"in":"let stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n","type":"","out":""},{"in":"let _ = stringOfList string_of_int [1;2;3;4;5;6]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n\nlet _ = stringOfList string_of_int [1; 2; 3; 4; 5; 6];;\n","type":"","out":""},{"in":"let _ = stringOfList (fun x -> x) [\"foo\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n\nlet _ = stringOfList (fun x  -> x) [\"foo\"];;\n","type":"","out":""},{"in":"let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n\nlet _ =\n  stringOfList (stringOfList string_of_int) [[1; 2; 3]; [4; 5]; [6]; []];;\n","type":"","out":""},{"in":"let rec clone x n = \nlet rec helper a x n =\nif n <= 0 then a\nelse \nlet a' = x::a in\nhelper a' x (n-1)\nin helper [] x n","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n","type":"","out":""},{"in":"let _ = clone 3 5","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet _ = clone 3 5;;\n","type":"","out":""},{"in":"let _ = clone \"foo\" 2","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet _ = clone \"foo\" 2;;\n","type":"","out":""},{"in":"let _ = clone clone (-3)","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet _ = clone clone (-3);;\n","type":"","out":""},{"in":"let padZero l1 l2 = \nlet length1 = List.length l1 in\nlet length2 = List.length l2 in\nif length1 > length2 then \n(l1, List.append (clone 0 (length1 - length2)) l2)\nelse if length2 > length1 then \n(List.append (clone 0 (length2 - length1)) l1, l2)\nelse (l1,l2)","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n","type":"","out":""},{"in":"let _ = padZero [9;9] [1;0;0;2]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet _ = padZero [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = padZero [1;0;0;2] [9;9]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet _ = padZero [1; 0; 0; 2] [9; 9];;\n","type":"","out":""},{"in":"let _ = padZero [1;0;0;2] []","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet _ = padZero [1; 0; 0; 2] [];;\n","type":"","out":""},{"in":"let _ = padZero [77] [9;9;4;5;6;7;8;9;0]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet _ = padZero [77] [9; 9; 4; 5; 6; 7; 8; 9; 0];;\n","type":"","out":""},{"in":"let _ = padZero [] []","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet _ = padZero [] [];;\n","type":"","out":""},{"in":"let _ = padZero [] [9]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet _ = padZero [] [9];;\n","type":"","out":""},{"in":"let _ = padZero [0;0] [1]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet _ = padZero [0; 0] [1];;\n","type":"","out":""},{"in":"let rec removeZero l = match l with\n| [] -> []\n| h::t -> if h = 0 then removeZero t else l","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;1;0;0;2]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet _ = removeZero [0; 0; 0; 1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = removeZero [9;9]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet _ = removeZero [9; 9];;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;0]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet _ = removeZero [0; 0; 0; 0];;\n","type":"","out":""},{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(x1, x2) -> \nmatch a with\n(o , z) -> if o + x1 + x2 > 9 \nthen (1, ((o + x1 + x2) mod 10)::z )\nelse (0, (o + x1 + x2)::z)\nin\nlet base = (0, []) in\nlet args = \nlet rec pair acc list1 list2 = \nmatch (list1, list2) with\n| (h1::t1, h2::t2) -> pair (List.append acc [(h1,h2)]) t1 t2\n| (_ , _) -> List.append acc [(0,0)]\nin pair [] (List.rev l1) (List.rev l2)\nin\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9] [1;0;0;2]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9;9;9] [9;9;9]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigAdd [1;2;3] []","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [1; 2; 3] [];;\n","type":"","out":""},{"in":"let _ = bigAdd [] []","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [] [];;\n","type":"","out":""},{"in":"let _ = bigAdd [] [3;4;5]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [] [3; 4; 5];;\n","type":"","out":""},{"in":"let _ = bigAdd [1] [9;9;9]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [1] [9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigAdd [0;0;0] [9;9;9]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [0; 0; 0] [9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigAdd [0;0;0;0] [9;9;9]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [0; 0; 0; 0] [9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigAdd [0] []","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [0] [];;\n","type":"","out":""},{"in":"let _ = bigAdd [3] []","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [3] [];;\n","type":"","out":""},{"in":"let _ = bigAdd [0] [0]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [0] [0];;\n","type":"","out":""},{"in":"let rec mulByDigit i l =\nlet rec helper acc carry i l = match l with\n| [] -> (match acc with\n| [] -> []\n| h::t -> if h = 0 then t else acc)\n| h::t -> let x = (h*i + carry) in \nlet n = if x > 9 then x mod 10 else x in\nlet carry' = if x > 9 then x/10 else 0 in\nlet acc' = n::acc in\nhelper acc' carry' i t\nin helper [] 0 i (List.rev (0::l))","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n","type":"","out":""},{"in":"let _ = mulByDigit 9 [9;9;9;9]","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let _ = mulByDigit 0 [1;2;3]","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 0 [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = mulByDigit 1 [1;2;3]","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 1 [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = mulByDigit 10 [1;2;3]","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 10 [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = mulByDigit 5 [0;0;0]","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 5 [0; 0; 0];;\n","type":"","out":""},{"in":"let _ = mulByDigit 9 []","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 9 [];;\n","type":"","out":""},{"in":"let _ = mulByDigit 0 []","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 0 [];;\n","type":"","out":""},{"in":"let bigMul l1 l2 = \nlet f a x =  match a with \n| (_, z) -> (0, bigAdd z x) in\nlet base = (0, []) in\nlet args = \nlet rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = \n(List.append (mulByDigit h l2) placeHolders) in\ndigitProducts (a::acc) (place+1) t l2 in\ndigitProducts [] 0 (List.rev l1) l2 in\nlet (_, res) = List.fold_left f base args in\nres","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n","type":"","out":""},{"in":"let _ = bigMul [9;9;9;9] [9;9;9;9]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9; 9] [9; 9; 9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigMul [] []","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [] [];;\n","type":"","out":""},{"in":"let _ = bigMul [0] [0]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [0] [0];;\n","type":"","out":""},{"in":"let _ = bigMul [] [0]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [] [0];;\n","type":"","out":""},{"in":"let _ = bigMul [0] []","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [0] [];;\n","type":"","out":""},{"in":"let _ = bigMul [] [1;2;3]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [] [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = bigMul [1;2;3] []","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1; 2; 3] [];;\n","type":"","out":""},{"in":"let _ = bigMul [0] [1;2;3]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [0] [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = bigMul [1;2;3] [0]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1; 2; 3] [0];;\n","type":"","out":""},{"in":"let _ = bigMul [1] [1;2;3]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1] [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = bigMul [1;2;3] [1]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1; 2; 3] [1];;\n","type":"","out":""},{"in":"let _ = bigMul [1;2;3] [5]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1; 2; 3] [5];;\n","type":"","out":""},{"in":"let _ = bigMul [5] [1;2;3]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [5] [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = bigMul [1;2;3] [5;6]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1; 2; 3] [5; 6];;\n","type":"","out":""},{"in":"let _ = bigMul [5;6] [1;2;3]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [5; 6] [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = bigMul [1;0;0] [5]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1; 0; 0] [5];;\n","type":"","out":""},{"in":"let _ = bigMul [5;2;1] [0;0]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [5; 2; 1] [0; 0];;\n","type":"","out":""},{"in":"let _ = bigMul [1;2;3;3] [0;0;0]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1; 2; 3; 3] [0; 0; 0];;\n","type":"","out":""},{"in":"let _ = bigMul [5] [5]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [5] [5];;\n","type":"","out":""},{"in":"let key = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130 = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ ((Printexc.to_string e) ^ \"\\n\"));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n","type":"","out":""},{"in":"let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","min":"\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n","type":"","out":""},{"in":"let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n\nlet drop_paren s =\n  implode\n    (List.filter (fun c  -> not (List.mem c ['('; ' '; ')'])) (explode s));;\n","type":"","out":""},{"in":"let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","min":"\nlet eq_real p (r1,r2) = ((r1 -. r2) < p) || ((r2 -. r1) < p);;\n","type":"","out":""},{"in":"let wrap_curried_2 f (a,b) = f a b","min":"\nlet wrap_curried_2 f (a,b) = f a b;;\n","type":"","out":""}],"event":{"region":{"start":919,"stop":9450},"type":"eval"},"cursor":1002,"time":1.398653650004866e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base = fun y -> y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]\nlet _ = padZero [1;0;0;2] []\nlet _ = padZero [77] [9;9;4;5;6;7;8;9;0]\nlet _ = padZero [] []\nlet _ = padZero [] [9]\nlet _ = padZero [0;0] [1]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair acc list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> pair (List.append acc [(h1,h2)]) t1 t2\n          | (_ , _) -> List.append acc [(0,0)]\n      in pair [] (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [1;2;3] [];;\nlet _ = bigAdd [] [];;\nlet _ = bigAdd [] [3;4;5];;\nlet _ = bigAdd [1] [9;9;9];;\nlet _ = bigAdd [0;0;0] [9;9;9];;\nlet _ = bigAdd [0;0;0;0] [9;9;9];;\nlet _ = bigAdd [0] [];;\nlet _ = bigAdd [3] [];;\nlet _ = bigAdd [0] [0];;\n\n\n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> (match acc with\n              | [] -> []\n              | h::t -> if h = 0 then t else acc)\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 [1;2;3]\nlet _ = mulByDigit 1 [1;2;3]\nlet _ = mulByDigit 10 [1;2;3]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 5 [0;0;0]\nlet _ = mulByDigit 9 []\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 []\n\n\nlet bigMul l1 l2 = \n  let f a x =  match a with \n    | (_, z) -> (0, bigAdd z x) in\n  let base = (0, []) in\n  let args = \n    let rec digitProducts acc place l1 l2 = match l1 with\n      | [] -> acc\n      | h::t -> \n          let placeHolders = \n            (let rec buildZeros a places = \n              if places = 0 then a else buildZeros (0::a) (places-1) in \n               buildZeros [] place) in \n          let a = \n            (List.append (mulByDigit h l2) placeHolders) in\n            digitProducts (a::acc) (place+1) t l2 in\n      digitProducts [] 0 (List.rev l1) l2 in\n  let (_, res) = List.fold_left f base args in\n    res;;\n\n\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \nlet _ = bigMul [] []\nlet _ = bigMul [0] [0]\nlet _ = bigMul [] [0]\nlet _ = bigMul [0] []\nlet _ = bigMul [] [1;2;3]\nlet _ = bigMul [1;2;3] []\nlet _ = bigMul [0] [1;2;3]\nlet _ = bigMul [1;2;3] [0]\nlet _ = bigMul [1] [1;2;3]\nlet _ = bigMul [1;2;3] [1]\nlet _ = bigMul [1;2;3] [5]\nlet _ = bigMul [5] [1;2;3]\nlet _ = bigMul [1;2;3] [5;6]\nlet _ = bigMul [5;6] [1;2;3]\nlet _ = bigMul [1;0;0] [5]\nlet _ = bigMul [5;2;1] [0;0]\nlet _ = bigMul [1;2;3;3] [0;0;0]\nlet _ = bigMul [5] [5]\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let pipe fs = \nlet f a x = x a in\nlet base = fun y -> y in\nList.fold_left f base fs","min":"\nlet pipe fs = let f a x = x a in let base y = y in List.fold_left f base fs;;\n","type":"","out":""}],"event":{"region":{"start":919,"stop":1002},"type":"eval"},"cursor":1002,"time":1.398653679957979e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base = fun y -> y in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]\nlet _ = padZero [1;0;0;2] []\nlet _ = padZero [77] [9;9;4;5;6;7;8;9;0]\nlet _ = padZero [] []\nlet _ = padZero [] [9]\nlet _ = padZero [0;0] [1]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair acc list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> pair (List.append acc [(h1,h2)]) t1 t2\n          | (_ , _) -> List.append acc [(0,0)]\n      in pair [] (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [1;2;3] [];;\nlet _ = bigAdd [] [];;\nlet _ = bigAdd [] [3;4;5];;\nlet _ = bigAdd [1] [9;9;9];;\nlet _ = bigAdd [0;0;0] [9;9;9];;\nlet _ = bigAdd [0;0;0;0] [9;9;9];;\nlet _ = bigAdd [0] [];;\nlet _ = bigAdd [3] [];;\nlet _ = bigAdd [0] [0];;\n\n\n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> (match acc with\n              | [] -> []\n              | h::t -> if h = 0 then t else acc)\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 [1;2;3]\nlet _ = mulByDigit 1 [1;2;3]\nlet _ = mulByDigit 10 [1;2;3]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 5 [0;0;0]\nlet _ = mulByDigit 9 []\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 []\n\n\nlet bigMul l1 l2 = \n  let f a x =  match a with \n    | (_, z) -> (0, bigAdd z x) in\n  let base = (0, []) in\n  let args = \n    let rec digitProducts acc place l1 l2 = match l1 with\n      | [] -> acc\n      | h::t -> \n          let placeHolders = \n            (let rec buildZeros a places = \n              if places = 0 then a else buildZeros (0::a) (places-1) in \n               buildZeros [] place) in \n          let a = \n            (List.append (mulByDigit h l2) placeHolders) in\n            digitProducts (a::acc) (place+1) t l2 in\n      digitProducts [] 0 (List.rev l1) l2 in\n  let (_, res) = List.fold_left f base args in\n    res;;\n\n\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \nlet _ = bigMul [] []\nlet _ = bigMul [0] [0]\nlet _ = bigMul [] [0]\nlet _ = bigMul [0] []\nlet _ = bigMul [] [1;2;3]\nlet _ = bigMul [1;2;3] []\nlet _ = bigMul [0] [1;2;3]\nlet _ = bigMul [1;2;3] [0]\nlet _ = bigMul [1] [1;2;3]\nlet _ = bigMul [1;2;3] [1]\nlet _ = bigMul [1;2;3] [5]\nlet _ = bigMul [5] [1;2;3]\nlet _ = bigMul [1;2;3] [5;6]\nlet _ = bigMul [5;6] [1;2;3]\nlet _ = bigMul [1;0;0] [5]\nlet _ = bigMul [5;2;1] [0;0]\nlet _ = bigMul [1;2;3;3] [0;0;0]\nlet _ = bigMul [5] [5]\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = pipe [] 3","min":"\nlet pipe fs = let f a x = x a in let base y = y in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n","type":"","out":""},{"in":"let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3","min":"\nlet pipe fs = let f a x = x a in let base y = y in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n","type":"type","out":"Characters 24-25:\n  let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3;;\n                          ^\nError: This expression has type 'a -> 'a\n       but an expression was expected of type int\n"},{"in":"let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3","min":"\nlet pipe fs = let f a x = x a in let base y = y in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n","type":"type","out":"Characters 24-25:\n  let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3;;\n                          ^\nError: This expression has type 'a -> 'a\n       but an expression was expected of type int\n"}],"event":{"region":{"start":1002,"stop":1125},"type":"eval"},"cursor":1125,"time":1.398653682008478e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base = fun y -> y in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]\nlet _ = padZero [1;0;0;2] []\nlet _ = padZero [77] [9;9;4;5;6;7;8;9;0]\nlet _ = padZero [] []\nlet _ = padZero [] [9]\nlet _ = padZero [0;0] [1]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = \n      let rec pair acc list1 list2 = \n        match (list1, list2) with\n          | (h1::t1, h2::t2) -> pair (List.append acc [(h1,h2)]) t1 t2\n          | (_ , _) -> List.append acc [(0,0)]\n      in pair [] (List.rev l1) (List.rev l2)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [1;2;3] [];;\nlet _ = bigAdd [] [];;\nlet _ = bigAdd [] [3;4;5];;\nlet _ = bigAdd [1] [9;9;9];;\nlet _ = bigAdd [0;0;0] [9;9;9];;\nlet _ = bigAdd [0;0;0;0] [9;9;9];;\nlet _ = bigAdd [0] [];;\nlet _ = bigAdd [3] [];;\nlet _ = bigAdd [0] [0];;\n\n\n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> (match acc with\n              | [] -> []\n              | h::t -> if h = 0 then t else acc)\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 [1;2;3]\nlet _ = mulByDigit 1 [1;2;3]\nlet _ = mulByDigit 10 [1;2;3]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 5 [0;0;0]\nlet _ = mulByDigit 9 []\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 []\n\n\nlet bigMul l1 l2 = \n  let f a x =  match a with \n    | (_, z) -> (0, bigAdd z x) in\n  let base = (0, []) in\n  let args = \n    let rec digitProducts acc place l1 l2 = match l1 with\n      | [] -> acc\n      | h::t -> \n          let placeHolders = \n            (let rec buildZeros a places = \n              if places = 0 then a else buildZeros (0::a) (places-1) in \n               buildZeros [] place) in \n          let a = \n            (List.append (mulByDigit h l2) placeHolders) in\n            digitProducts (a::acc) (place+1) t l2 in\n      digitProducts [] 0 (List.rev l1) l2 in\n  let (_, res) = List.fold_left f base args in\n    res;;\n\n\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \nlet _ = bigMul [] []\nlet _ = bigMul [0] [0]\nlet _ = bigMul [] [0]\nlet _ = bigMul [0] []\nlet _ = bigMul [] [1;2;3]\nlet _ = bigMul [1;2;3] []\nlet _ = bigMul [0] [1;2;3]\nlet _ = bigMul [1;2;3] [0]\nlet _ = bigMul [1] [1;2;3]\nlet _ = bigMul [1;2;3] [1]\nlet _ = bigMul [1;2;3] [5]\nlet _ = bigMul [5] [1;2;3]\nlet _ = bigMul [1;2;3] [5;6]\nlet _ = bigMul [5;6] [1;2;3]\nlet _ = bigMul [1;0;0] [5]\nlet _ = bigMul [5;2;1] [0;0]\nlet _ = bigMul [1;2;3;3] [0;0;0]\nlet _ = bigMul [5] [5]\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let sqsum xs = \nlet f a x =  a + x*x in\nlet base = 0 in\nList.fold_left f base xs","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n","type":"","out":""},{"in":"let _ = sqsum []","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [];;\n","type":"","out":""},{"in":"let _ = sqsum [1;2;3;4]","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sqsum [(-1); (-2); (-3); (-4)]","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [(-1); (-2); (-3); (-4)];;\n","type":"","out":""},{"in":"let pipe fs = \nlet f a x = x a in\nlet base = fun y -> y in\nList.fold_left f base fs","min":"\nlet pipe fs = let f a x = x a in let base y = y in List.fold_left f base fs;;\n","type":"","out":""},{"in":"let _ = pipe [] 3","min":"\nlet pipe fs = let f a x = x a in let base y = y in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n","type":"","out":""},{"in":"let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3","min":"\nlet pipe fs = let f a x = x a in let base y = y in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n","type":"type","out":"Characters 24-25:\n  let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3;;\n                          ^\nError: This expression has type 'a -> 'a\n       but an expression was expected of type int\n"},{"in":"let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3","min":"\nlet pipe fs = let f a x = x a in let base y = y in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n","type":"type","out":"Characters 24-25:\n  let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3;;\n                          ^\nError: This expression has type 'a -> 'a\n       but an expression was expected of type int\n"},{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x  in\nlet base = h in\nlet l = t in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n","type":"","out":""},{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"---\" []","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"---\" [];;\n","type":"","out":""},{"in":"let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"\" [\"a\"; \"b\"; \"c\"; \"d\"; \"e\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"X\" [\"hello\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"X\" [\"hello\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"a\" []","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"a\" [];;\n","type":"","out":""},{"in":"let _ = sepConcat \"a\" [\"b\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"a\" [\"b\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"\" []","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"\" [];;\n","type":"","out":""},{"in":"let _ = sepConcat \"\" [\"bc\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"\" [\"bc\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"z\" [\"\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"z\" [\"\"];;\n","type":"","out":""},{"in":"let stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n","type":"","out":""},{"in":"let _ = stringOfList string_of_int [1;2;3;4;5;6]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n\nlet _ = stringOfList string_of_int [1; 2; 3; 4; 5; 6];;\n","type":"","out":""},{"in":"let _ = stringOfList (fun x -> x) [\"foo\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n\nlet _ = stringOfList (fun x  -> x) [\"foo\"];;\n","type":"","out":""},{"in":"let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n\nlet _ =\n  stringOfList (stringOfList string_of_int) [[1; 2; 3]; [4; 5]; [6]; []];;\n","type":"","out":""},{"in":"let rec clone x n = \nlet rec helper a x n =\nif n <= 0 then a\nelse \nlet a' = x::a in\nhelper a' x (n-1)\nin helper [] x n","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n","type":"","out":""},{"in":"let _ = clone 3 5","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet _ = clone 3 5;;\n","type":"","out":""},{"in":"let _ = clone \"foo\" 2","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet _ = clone \"foo\" 2;;\n","type":"","out":""},{"in":"let _ = clone clone (-3)","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet _ = clone clone (-3);;\n","type":"","out":""},{"in":"let padZero l1 l2 = \nlet length1 = List.length l1 in\nlet length2 = List.length l2 in\nif length1 > length2 then \n(l1, List.append (clone 0 (length1 - length2)) l2)\nelse if length2 > length1 then \n(List.append (clone 0 (length2 - length1)) l1, l2)\nelse (l1,l2)","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n","type":"","out":""},{"in":"let _ = padZero [9;9] [1;0;0;2]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet _ = padZero [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = padZero [1;0;0;2] [9;9]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet _ = padZero [1; 0; 0; 2] [9; 9];;\n","type":"","out":""},{"in":"let _ = padZero [1;0;0;2] []","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet _ = padZero [1; 0; 0; 2] [];;\n","type":"","out":""},{"in":"let _ = padZero [77] [9;9;4;5;6;7;8;9;0]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet _ = padZero [77] [9; 9; 4; 5; 6; 7; 8; 9; 0];;\n","type":"","out":""},{"in":"let _ = padZero [] []","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet _ = padZero [] [];;\n","type":"","out":""},{"in":"let _ = padZero [] [9]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet _ = padZero [] [9];;\n","type":"","out":""},{"in":"let _ = padZero [0;0] [1]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet _ = padZero [0; 0] [1];;\n","type":"","out":""},{"in":"let rec removeZero l = match l with\n| [] -> []\n| h::t -> if h = 0 then removeZero t else l","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;1;0;0;2]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet _ = removeZero [0; 0; 0; 1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = removeZero [9;9]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet _ = removeZero [9; 9];;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;0]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet _ = removeZero [0; 0; 0; 0];;\n","type":"","out":""},{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(x1, x2) -> \nmatch a with\n(o , z) -> if o + x1 + x2 > 9 \nthen (1, ((o + x1 + x2) mod 10)::z )\nelse (0, (o + x1 + x2)::z)\nin\nlet base = (0, []) in\nlet args = List.append (List.combine (List.rev l1) (List.rev l2)) [(0,0)]\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nin\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":3427},"type":"eval"},"cursor":3427,"time":1.398658981613886e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base = fun y -> y in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]\nlet _ = padZero [1;0;0;2] []\nlet _ = padZero [77] [9;9;4;5;6;7;8;9;0]\nlet _ = padZero [] []\nlet _ = padZero [] [9]\nlet _ = padZero [0;0] [1]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = List.append (List.combine (List.rev l1) (List.rev l2)) [(0,0)]\n    (*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [1;2;3] [];;\nlet _ = bigAdd [] [];;\nlet _ = bigAdd [] [3;4;5];;\nlet _ = bigAdd [1] [9;9;9];;\nlet _ = bigAdd [0;0;0] [9;9;9];;\nlet _ = bigAdd [0;0;0;0] [9;9;9];;\nlet _ = bigAdd [0] [];;\nlet _ = bigAdd [3] [];;\nlet _ = bigAdd [0] [0];;\n\n\n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> (match acc with\n              | [] -> []\n              | h::t -> if h = 0 then t else acc)\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 [1;2;3]\nlet _ = mulByDigit 1 [1;2;3]\nlet _ = mulByDigit 10 [1;2;3]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 5 [0;0;0]\nlet _ = mulByDigit 9 []\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 []\n\n\nlet bigMul l1 l2 = \n  let f a x =  match a with \n    | (_, z) -> (0, bigAdd z x) in\n  let base = (0, []) in\n  let args = \n    let rec digitProducts acc place l1 l2 = match l1 with\n      | [] -> acc\n      | h::t -> \n          let placeHolders = \n            (let rec buildZeros a places = \n              if places = 0 then a else buildZeros (0::a) (places-1) in \n               buildZeros [] place) in \n          let a = \n            (List.append (mulByDigit h l2) placeHolders) in\n            digitProducts (a::acc) (place+1) t l2 in\n      digitProducts [] 0 (List.rev l1) l2 in\n  let (_, res) = List.fold_left f base args in\n    res;;\n\n\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \nlet _ = bigMul [] []\nlet _ = bigMul [0] [0]\nlet _ = bigMul [] [0]\nlet _ = bigMul [0] []\nlet _ = bigMul [] [1;2;3]\nlet _ = bigMul [1;2;3] []\nlet _ = bigMul [0] [1;2;3]\nlet _ = bigMul [1;2;3] [0]\nlet _ = bigMul [1] [1;2;3]\nlet _ = bigMul [1;2;3] [1]\nlet _ = bigMul [1;2;3] [5]\nlet _ = bigMul [5] [1;2;3]\nlet _ = bigMul [1;2;3] [5;6]\nlet _ = bigMul [5;6] [1;2;3]\nlet _ = bigMul [1;0;0] [5]\nlet _ = bigMul [5;2;1] [0;0]\nlet _ = bigMul [1;2;3;3] [0;0;0]\nlet _ = bigMul [5] [5]\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x  in\nlet base = h in\nlet l = t in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n","type":"","out":""},{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"---\" []","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"---\" [];;\n","type":"","out":""},{"in":"let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"\" [\"a\"; \"b\"; \"c\"; \"d\"; \"e\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"X\" [\"hello\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"X\" [\"hello\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"a\" []","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"a\" [];;\n","type":"","out":""},{"in":"let _ = sepConcat \"a\" [\"b\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"a\" [\"b\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"\" []","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"\" [];;\n","type":"","out":""},{"in":"let _ = sepConcat \"\" [\"bc\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"\" [\"bc\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"z\" [\"\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"z\" [\"\"];;\n","type":"","out":""},{"in":"let stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n","type":"","out":""},{"in":"let _ = stringOfList string_of_int [1;2;3;4;5;6]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n\nlet _ = stringOfList string_of_int [1; 2; 3; 4; 5; 6];;\n","type":"","out":""},{"in":"let _ = stringOfList (fun x -> x) [\"foo\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n\nlet _ = stringOfList (fun x  -> x) [\"foo\"];;\n","type":"","out":""},{"in":"let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n\nlet _ =\n  stringOfList (stringOfList string_of_int) [[1; 2; 3]; [4; 5]; [6]; []];;\n","type":"","out":""},{"in":"let rec clone x n = \nlet rec helper a x n =\nif n <= 0 then a\nelse \nlet a' = x::a in\nhelper a' x (n-1)\nin helper [] x n","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n","type":"","out":""},{"in":"let _ = clone 3 5","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet _ = clone 3 5;;\n","type":"","out":""},{"in":"let _ = clone \"foo\" 2","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet _ = clone \"foo\" 2;;\n","type":"","out":""},{"in":"let _ = clone clone (-3)","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet _ = clone clone (-3);;\n","type":"","out":""},{"in":"let padZero l1 l2 = \nlet length1 = List.length l1 in\nlet length2 = List.length l2 in\nif length1 > length2 then \n(l1, List.append (clone 0 (length1 - length2)) l2)\nelse if length2 > length1 then \n(List.append (clone 0 (length2 - length1)) l1, l2)\nelse (l1,l2)","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n","type":"","out":""},{"in":"let _ = padZero [9;9] [1;0;0;2]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet _ = padZero [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = padZero [1;0;0;2] [9;9]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet _ = padZero [1; 0; 0; 2] [9; 9];;\n","type":"","out":""},{"in":"let _ = padZero [1;0;0;2] []","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet _ = padZero [1; 0; 0; 2] [];;\n","type":"","out":""},{"in":"let _ = padZero [77] [9;9;4;5;6;7;8;9;0]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet _ = padZero [77] [9; 9; 4; 5; 6; 7; 8; 9; 0];;\n","type":"","out":""},{"in":"let _ = padZero [] []","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet _ = padZero [] [];;\n","type":"","out":""},{"in":"let _ = padZero [] [9]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet _ = padZero [] [9];;\n","type":"","out":""},{"in":"let _ = padZero [0;0] [1]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet _ = padZero [0; 0] [1];;\n","type":"","out":""},{"in":"let rec removeZero l = match l with\n| [] -> []\n| h::t -> if h = 0 then removeZero t else l","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;1;0;0;2]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet _ = removeZero [0; 0; 0; 1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = removeZero [9;9]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet _ = removeZero [9; 9];;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;0]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet _ = removeZero [0; 0; 0; 0];;\n","type":"","out":""},{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(x1, x2) -> \nmatch a with\n(o , z) -> if o + x1 + x2 > 9 \nthen (1, ((o + x1 + x2) mod 10)::z )\nelse (0, (o + x1 + x2)::z)\nin\nlet base = (0, []) in\nlet args = List.append (List.combine (List.rev l1) (List.rev l2)) [(0,0)]\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nin\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"","out":""}],"event":{"region":{"start":1002,"stop":3431},"type":"eval"},"cursor":3431,"time":1.398659003952417e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base = fun y -> y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]\nlet _ = padZero [1;0;0;2] []\nlet _ = padZero [77] [9;9;4;5;6;7;8;9;0]\nlet _ = padZero [] []\nlet _ = padZero [] [9]\nlet _ = padZero [0;0] [1]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = List.append (List.combine (List.rev l1) (List.rev l2)) [(0,0)]\n    (*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [1;2;3] [];;\nlet _ = bigAdd [] [];;\nlet _ = bigAdd [] [3;4;5];;\nlet _ = bigAdd [1] [9;9;9];;\nlet _ = bigAdd [0;0;0] [9;9;9];;\nlet _ = bigAdd [0;0;0;0] [9;9;9];;\nlet _ = bigAdd [0] [];;\nlet _ = bigAdd [3] [];;\nlet _ = bigAdd [0] [0];;\n\n\n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> (match acc with\n              | [] -> []\n              | h::t -> if h = 0 then t else acc)\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 [1;2;3]\nlet _ = mulByDigit 1 [1;2;3]\nlet _ = mulByDigit 10 [1;2;3]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 5 [0;0;0]\nlet _ = mulByDigit 9 []\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 []\n\n\nlet bigMul l1 l2 = \n  let f a x =  match a with \n    | (_, z) -> (0, bigAdd z x) in\n  let base = (0, []) in\n  let args = \n    let rec digitProducts acc place l1 l2 = match l1 with\n      | [] -> acc\n      | h::t -> \n          let placeHolders = \n            (let rec buildZeros a places = \n              if places = 0 then a else buildZeros (0::a) (places-1) in \n               buildZeros [] place) in \n          let a = \n            (List.append (mulByDigit h l2) placeHolders) in\n            digitProducts (a::acc) (place+1) t l2 in\n      digitProducts [] 0 (List.rev l1) l2 in\n  let (_, res) = List.fold_left f base args in\n    res;;\n\n\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \nlet _ = bigMul [] []\nlet _ = bigMul [0] [0]\nlet _ = bigMul [] [0]\nlet _ = bigMul [0] []\nlet _ = bigMul [] [1;2;3]\nlet _ = bigMul [1;2;3] []\nlet _ = bigMul [0] [1;2;3]\nlet _ = bigMul [1;2;3] [0]\nlet _ = bigMul [1] [1;2;3]\nlet _ = bigMul [1;2;3] [1]\nlet _ = bigMul [1;2;3] [5]\nlet _ = bigMul [5] [1;2;3]\nlet _ = bigMul [1;2;3] [5;6]\nlet _ = bigMul [5;6] [1;2;3]\nlet _ = bigMul [1;0;0] [5]\nlet _ = bigMul [5;2;1] [0;0]\nlet _ = bigMul [1;2;3;3] [0;0;0]\nlet _ = bigMul [5] [5]\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = bigAdd [9;9] [1;0;0;2]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9;9;9] [9;9;9]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigAdd [1;2;3] []","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [1; 2; 3] [];;\n","type":"","out":""},{"in":"let _ = bigAdd [] []","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [] [];;\n","type":"","out":""},{"in":"let _ = bigAdd [] [3;4;5]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [] [3; 4; 5];;\n","type":"","out":""},{"in":"let _ = bigAdd [1] [9;9;9]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [1] [9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigAdd [0;0;0] [9;9;9]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [0; 0; 0] [9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigAdd [0;0;0;0] [9;9;9]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [0; 0; 0; 0] [9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigAdd [0] []","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [0] [];;\n","type":"","out":""},{"in":"let _ = bigAdd [3] []","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [3] [];;\n","type":"","out":""},{"in":"let _ = bigAdd [0] [0]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [0] [0];;\n","type":"","out":""}],"event":{"region":{"start":3431,"stop":3749},"type":"eval"},"cursor":3751,"time":1.398659012199991e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base = fun y -> y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]\nlet _ = padZero [1;0;0;2] []\nlet _ = padZero [77] [9;9;4;5;6;7;8;9;0]\nlet _ = padZero [] []\nlet _ = padZero [] [9]\nlet _ = padZero [0;0] [1]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = List.append (List.combine (List.rev l1) (List.rev l2)) [(0,0)]\n    (*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [1;2;3] [];;\nlet _ = bigAdd [] [];;\nlet _ = bigAdd [] [3;4;5];;\nlet _ = bigAdd [1] [9;9;9];;\nlet _ = bigAdd [0;0;0] [9;9;9];;\nlet _ = bigAdd [0;0;0;0] [9;9;9];;\nlet _ = bigAdd [0] [];;\nlet _ = bigAdd [3] [];;\nlet _ = bigAdd [0] [0];;\n\n\n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> (match acc with\n              | [] -> []\n              | h::t -> if h = 0 then t else acc)\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 [1;2;3]\nlet _ = mulByDigit 1 [1;2;3]\nlet _ = mulByDigit 10 [1;2;3]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 5 [0;0;0]\nlet _ = mulByDigit 9 []\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 []\n\n\nlet bigMul l1 l2 = \n  let f a x =  match a with \n    | (_, z) -> (0, bigAdd z x) in\n  let base = (0, []) in\n  let args = \n    let rec digitProducts acc place l1 l2 = match l1 with\n      | [] -> acc\n      | h::t -> \n          let placeHolders = \n            (let rec buildZeros a places = \n              if places = 0 then a else buildZeros (0::a) (places-1) in \n               buildZeros [] place) in \n          let a = \n            (List.append (mulByDigit h l2) placeHolders) in\n            digitProducts (a::acc) (place+1) t l2 in\n      digitProducts [] 0 (List.rev l1) l2 in\n  let (_, res) = List.fold_left f base args in\n    res;;\n\n\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \nlet _ = bigMul [] []\nlet _ = bigMul [0] [0]\nlet _ = bigMul [] [0]\nlet _ = bigMul [0] []\nlet _ = bigMul [] [1;2;3]\nlet _ = bigMul [1;2;3] []\nlet _ = bigMul [0] [1;2;3]\nlet _ = bigMul [1;2;3] [0]\nlet _ = bigMul [1] [1;2;3]\nlet _ = bigMul [1;2;3] [1]\nlet _ = bigMul [1;2;3] [5]\nlet _ = bigMul [5] [1;2;3]\nlet _ = bigMul [1;2;3] [5;6]\nlet _ = bigMul [5;6] [1;2;3]\nlet _ = bigMul [1;0;0] [5]\nlet _ = bigMul [5;2;1] [0;0]\nlet _ = bigMul [1;2;3;3] [0;0;0]\nlet _ = bigMul [5] [5]\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec mulByDigit i l =\nlet rec helper acc carry i l = match l with\n| [] -> (match acc with\n| [] -> []\n| h::t -> if h = 0 then t else acc)\n| h::t -> let x = (h*i + carry) in \nlet n = if x > 9 then x mod 10 else x in\nlet carry' = if x > 9 then x/10 else 0 in\nlet acc' = n::acc in\nhelper acc' carry' i t\nin helper [] 0 i (List.rev (0::l))","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n","type":"","out":""},{"in":"let _ = mulByDigit 9 [9;9;9;9]","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let _ = mulByDigit 0 [1;2;3]","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 0 [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = mulByDigit 1 [1;2;3]","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 1 [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = mulByDigit 10 [1;2;3]","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 10 [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = mulByDigit 5 [0;0;0]","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 5 [0; 0; 0];;\n","type":"","out":""},{"in":"let _ = mulByDigit 9 []","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 9 [];;\n","type":"","out":""},{"in":"let _ = mulByDigit 0 []","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 0 [];;\n","type":"","out":""},{"in":"let bigMul l1 l2 = \nlet f a x =  match a with \n| (_, z) -> (0, bigAdd z x) in\nlet base = (0, []) in\nlet args = \nlet rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = \n(List.append (mulByDigit h l2) placeHolders) in\ndigitProducts (a::acc) (place+1) t l2 in\ndigitProducts [] 0 (List.rev l1) l2 in\nlet (_, res) = List.fold_left f base args in\nres","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n","type":"","out":""},{"in":"let _ = bigMul [9;9;9;9] [9;9;9;9]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9; 9] [9; 9; 9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigMul [] []","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [] [];;\n","type":"","out":""},{"in":"let _ = bigMul [0] [0]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [0] [0];;\n","type":"","out":""},{"in":"let _ = bigMul [] [0]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [] [0];;\n","type":"","out":""},{"in":"let _ = bigMul [0] []","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [0] [];;\n","type":"","out":""},{"in":"let _ = bigMul [] [1;2;3]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [] [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = bigMul [1;2;3] []","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1; 2; 3] [];;\n","type":"","out":""},{"in":"let _ = bigMul [0] [1;2;3]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [0] [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = bigMul [1;2;3] [0]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1; 2; 3] [0];;\n","type":"","out":""},{"in":"let _ = bigMul [1] [1;2;3]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1] [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = bigMul [1;2;3] [1]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1; 2; 3] [1];;\n","type":"","out":""},{"in":"let _ = bigMul [1;2;3] [5]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1; 2; 3] [5];;\n","type":"","out":""},{"in":"let _ = bigMul [5] [1;2;3]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [5] [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = bigMul [1;2;3] [5;6]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1; 2; 3] [5; 6];;\n","type":"","out":""},{"in":"let _ = bigMul [5;6] [1;2;3]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [5; 6] [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = bigMul [1;0;0] [5]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1; 0; 0] [5];;\n","type":"","out":""},{"in":"let _ = bigMul [5;2;1] [0;0]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [5; 2; 1] [0; 0];;\n","type":"","out":""},{"in":"let _ = bigMul [1;2;3;3] [0;0;0]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1; 2; 3; 3] [0; 0; 0];;\n","type":"","out":""},{"in":"let _ = bigMul [5] [5]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [5] [5];;\n","type":"","out":""}],"event":{"region":{"start":3749,"stop":5501},"type":"eval"},"cursor":5502,"time":1.398659151879647e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base = fun y -> y in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]\nlet _ = padZero [1;0;0;2] []\nlet _ = padZero [77] [9;9;4;5;6;7;8;9;0]\nlet _ = padZero [] []\nlet _ = padZero [] [9]\nlet _ = padZero [0;0] [1]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = List.append (List.combine (List.rev l1) (List.rev l2)) [(0,0)]\n    (*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [1;2;3] [];;\nlet _ = bigAdd [] [];;\nlet _ = bigAdd [] [3;4;5];;\nlet _ = bigAdd [1] [9;9;9];;\nlet _ = bigAdd [0;0;0] [9;9;9];;\nlet _ = bigAdd [0;0;0;0] [9;9;9];;\nlet _ = bigAdd [0] [];;\nlet _ = bigAdd [3] [];;\nlet _ = bigAdd [0] [0];;\n\n\n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> (match acc with\n              | [] -> []\n              | h::t -> if h = 0 then t else acc)\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 [1;2;3]\nlet _ = mulByDigit 1 [1;2;3]\nlet _ = mulByDigit 10 [1;2;3]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 5 [0;0;0]\nlet _ = mulByDigit 9 []\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 []\n\n\nlet bigMul l1 l2 = \n  let f a x =  match a with \n    | (_, z) -> (0, bigAdd z x) in\n  let base = (0, []) in\n  let args = \n    let rec digitProducts acc place l1 l2 = match l1 with\n      | [] -> acc\n      | h::t -> \n          let placeHolders = \n            (let rec buildZeros a places = \n              if places = 0 then a else buildZeros (0::a) (places-1) in \n               buildZeros [] place) in \n          let a = \n            (List.append (mulByDigit h l2) placeHolders) in\n            digitProducts (a::acc) (place+1) t l2 in\n      digitProducts [] 0 (List.rev l1) l2 in\n  let (_, res) = List.fold_left f base args in\n    res;;\n\n\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \nlet _ = bigMul [] []\nlet _ = bigMul [0] [0]\nlet _ = bigMul [] [0]\nlet _ = bigMul [0] []\nlet _ = bigMul [] [1;2;3]\nlet _ = bigMul [1;2;3] []\nlet _ = bigMul [0] [1;2;3]\nlet _ = bigMul [1;2;3] [0]\nlet _ = bigMul [1] [1;2;3]\nlet _ = bigMul [1;2;3] [1]\nlet _ = bigMul [1;2;3] [5]\nlet _ = bigMul [5] [1;2;3]\nlet _ = bigMul [1;2;3] [5;6]\nlet _ = bigMul [5;6] [1;2;3]\nlet _ = bigMul [1;0;0] [5]\nlet _ = bigMul [5;2;1] [0;0]\nlet _ = bigMul [1;2;3;3] [0;0;0]\nlet _ = bigMul [5] [5]\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let pipe fs = \nlet f a x = (*XXXXX*) failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nList.fold_left f base fs","min":"\nlet pipe fs =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n","type":"","out":""},{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x  in\nlet base = h in\nlet l = t in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n","type":"","out":""},{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"---\" []","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"---\" [];;\n","type":"","out":""},{"in":"let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"\" [\"a\"; \"b\"; \"c\"; \"d\"; \"e\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"X\" [\"hello\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"X\" [\"hello\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"a\" []","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"a\" [];;\n","type":"","out":""},{"in":"let _ = sepConcat \"a\" [\"b\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"a\" [\"b\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"\" []","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"\" [];;\n","type":"","out":""},{"in":"let _ = sepConcat \"\" [\"bc\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"\" [\"bc\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"z\" [\"\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"z\" [\"\"];;\n","type":"","out":""},{"in":"let stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n","type":"","out":""},{"in":"let _ = stringOfList string_of_int [1;2;3;4;5;6]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n\nlet _ = stringOfList string_of_int [1; 2; 3; 4; 5; 6];;\n","type":"","out":""},{"in":"let _ = stringOfList (fun x -> x) [\"foo\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n\nlet _ = stringOfList (fun x  -> x) [\"foo\"];;\n","type":"","out":""},{"in":"let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n\nlet _ =\n  stringOfList (stringOfList string_of_int) [[1; 2; 3]; [4; 5]; [6]; []];;\n","type":"","out":""},{"in":"let rec clone x n = \nlet rec helper a x n =\nif n <= 0 then a\nelse \nlet a' = x::a in\nhelper a' x (n-1)\nin helper [] x n","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n","type":"","out":""},{"in":"let _ = clone 3 5","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet _ = clone 3 5;;\n","type":"","out":""},{"in":"let _ = clone \"foo\" 2","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet _ = clone \"foo\" 2;;\n","type":"","out":""},{"in":"let _ = clone clone (-3)","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet _ = clone clone (-3);;\n","type":"","out":""},{"in":"let padZero l1 l2 = \nlet length1 = List.length l1 in\nlet length2 = List.length l2 in\nif length1 > length2 then \n(l1, List.append (clone 0 (length1 - length2)) l2)\nelse if length2 > length1 then \n(List.append (clone 0 (length2 - length1)) l1, l2)\nelse (l1,l2)","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n","type":"","out":""},{"in":"let _ = padZero [9;9] [1;0;0;2]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet _ = padZero [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = padZero [1;0;0;2] [9;9]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet _ = padZero [1; 0; 0; 2] [9; 9];;\n","type":"","out":""},{"in":"let _ = padZero [1;0;0;2] []","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet _ = padZero [1; 0; 0; 2] [];;\n","type":"","out":""},{"in":"let _ = padZero [77] [9;9;4;5;6;7;8;9;0]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet _ = padZero [77] [9; 9; 4; 5; 6; 7; 8; 9; 0];;\n","type":"","out":""},{"in":"let _ = padZero [] []","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet _ = padZero [] [];;\n","type":"","out":""},{"in":"let _ = padZero [] [9]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet _ = padZero [] [9];;\n","type":"","out":""},{"in":"let _ = padZero [0;0] [1]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet _ = padZero [0; 0] [1];;\n","type":"","out":""},{"in":"let rec removeZero l = match l with\n| [] -> []\n| h::t -> if h = 0 then removeZero t else l","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;1;0;0;2]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet _ = removeZero [0; 0; 0; 1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = removeZero [9;9]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet _ = removeZero [9; 9];;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;0]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet _ = removeZero [0; 0; 0; 0];;\n","type":"","out":""},{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(x1, x2) -> \nmatch a with\n(o , z) -> if o + x1 + x2 > 9 \nthen (1, ((o + x1 + x2) mod 10)::z )\nelse (0, (o + x1 + x2)::z)\nin\nlet base = (0, []) in\nlet args = List.append (List.combine (List.rev l1) (List.rev l2)) [(0,0)]\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nin\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9] [1;0;0;2]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9;9;9] [9;9;9]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigAdd [1;2;3] []","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [1; 2; 3] [];;\n","type":"","out":""},{"in":"let _ = bigAdd [] []","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [] [];;\n","type":"","out":""},{"in":"let _ = bigAdd [] [3;4;5]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [] [3; 4; 5];;\n","type":"","out":""},{"in":"let _ = bigAdd [1] [9;9;9]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [1] [9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigAdd [0;0;0] [9;9;9]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [0; 0; 0] [9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigAdd [0;0;0;0] [9;9;9]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [0; 0; 0; 0] [9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigAdd [0] []","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [0] [];;\n","type":"","out":""},{"in":"let _ = bigAdd [3] []","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [3] [];;\n","type":"","out":""},{"in":"let _ = bigAdd [0] [0]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [0] [0];;\n","type":"","out":""},{"in":"let rec mulByDigit i l =\nlet rec helper acc carry i l = match l with\n| [] -> (match acc with\n| [] -> []\n| h::t -> if h = 0 then t else acc)\n| h::t -> let x = (h*i + carry) in \nlet n = if x > 9 then x mod 10 else x in\nlet carry' = if x > 9 then x/10 else 0 in\nlet acc' = n::acc in\nhelper acc' carry' i t\nin helper [] 0 i (List.rev (0::l))","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n","type":"","out":""},{"in":"let _ = mulByDigit 9 [9;9;9;9]","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let _ = mulByDigit 0 [1;2;3]","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 0 [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = mulByDigit 1 [1;2;3]","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 1 [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = mulByDigit 10 [1;2;3]","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 10 [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = mulByDigit 5 [0;0;0]","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 5 [0; 0; 0];;\n","type":"","out":""},{"in":"let _ = mulByDigit 9 []","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 9 [];;\n","type":"","out":""},{"in":"let _ = mulByDigit 0 []","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 0 [];;\n","type":"","out":""},{"in":"let bigMul l1 l2 = \nlet f a x =  match a with \n| (_, z) -> (0, bigAdd z x) in\nlet base = (0, []) in\nlet args = \nlet rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = \n(List.append (mulByDigit h l2) placeHolders) in\ndigitProducts (a::acc) (place+1) t l2 in\ndigitProducts [] 0 (List.rev l1) l2 in\nlet (_, res) = List.fold_left f base args in\nres","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n","type":"","out":""},{"in":"let _ = bigMul [9;9;9;9] [9;9;9;9]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9; 9] [9; 9; 9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigMul [] []","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [] [];;\n","type":"","out":""},{"in":"let _ = bigMul [0] [0]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [0] [0];;\n","type":"","out":""},{"in":"let _ = bigMul [] [0]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [] [0];;\n","type":"","out":""},{"in":"let _ = bigMul [0] []","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [0] [];;\n","type":"","out":""},{"in":"let _ = bigMul [] [1;2;3]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [] [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = bigMul [1;2;3] []","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1; 2; 3] [];;\n","type":"","out":""},{"in":"let _ = bigMul [0] [1;2;3]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [0] [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = bigMul [1;2;3] [0]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1; 2; 3] [0];;\n","type":"","out":""},{"in":"let _ = bigMul [1] [1;2;3]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1] [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = bigMul [1;2;3] [1]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1; 2; 3] [1];;\n","type":"","out":""},{"in":"let _ = bigMul [1;2;3] [5]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1; 2; 3] [5];;\n","type":"","out":""},{"in":"let _ = bigMul [5] [1;2;3]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [5] [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = bigMul [1;2;3] [5;6]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1; 2; 3] [5; 6];;\n","type":"","out":""},{"in":"let _ = bigMul [5;6] [1;2;3]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [5; 6] [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = bigMul [1;0;0] [5]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1; 0; 0] [5];;\n","type":"","out":""},{"in":"let _ = bigMul [5;2;1] [0;0]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [5; 2; 1] [0; 0];;\n","type":"","out":""},{"in":"let _ = bigMul [1;2;3;3] [0;0;0]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1; 2; 3; 3] [0; 0; 0];;\n","type":"","out":""},{"in":"let _ = bigMul [5] [5]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [5] [5];;\n","type":"","out":""},{"in":"let key = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130 = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ ((Printexc.to_string e) ^ \"\\n\"));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n","type":"","out":""},{"in":"let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","min":"\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n","type":"","out":""},{"in":"let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n\nlet drop_paren s =\n  implode\n    (List.filter (fun c  -> not (List.mem c ['('; ' '; ')'])) (explode s));;\n","type":"","out":""},{"in":"let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","min":"\nlet eq_real p (r1,r2) = ((r1 -. r2) < p) || ((r2 -. r1) < p);;\n","type":"","out":""},{"in":"let wrap_curried_2 f (a,b) = f a b","min":"\nlet wrap_curried_2 f (a,b) = f a b;;\n","type":"","out":""}],"event":{"region":{"start":915,"stop":9572},"type":"eval"},"cursor":1027,"time":1.398660662818659e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = (*XXXXX*) failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]\nlet _ = padZero [1;0;0;2] []\nlet _ = padZero [77] [9;9;4;5;6;7;8;9;0]\nlet _ = padZero [] []\nlet _ = padZero [] [9]\nlet _ = padZero [0;0] [1]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = List.append (List.combine (List.rev l1) (List.rev l2)) [(0,0)]\n    (*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [1;2;3] [];;\nlet _ = bigAdd [] [];;\nlet _ = bigAdd [] [3;4;5];;\nlet _ = bigAdd [1] [9;9;9];;\nlet _ = bigAdd [0;0;0] [9;9;9];;\nlet _ = bigAdd [0;0;0;0] [9;9;9];;\nlet _ = bigAdd [0] [];;\nlet _ = bigAdd [3] [];;\nlet _ = bigAdd [0] [0];;\n\n\n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> (match acc with\n              | [] -> []\n              | h::t -> if h = 0 then t else acc)\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 [1;2;3]\nlet _ = mulByDigit 1 [1;2;3]\nlet _ = mulByDigit 10 [1;2;3]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 5 [0;0;0]\nlet _ = mulByDigit 9 []\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 []\n\n\nlet bigMul l1 l2 = \n  let f a x =  match a with \n    | (_, z) -> (0, bigAdd z x) in\n  let base = (0, []) in\n  let args = \n    let rec digitProducts acc place l1 l2 = match l1 with\n      | [] -> acc\n      | h::t -> \n          let placeHolders = \n            (let rec buildZeros a places = \n              if places = 0 then a else buildZeros (0::a) (places-1) in \n               buildZeros [] place) in \n          let a = \n            (List.append (mulByDigit h l2) placeHolders) in\n            digitProducts (a::acc) (place+1) t l2 in\n      digitProducts [] 0 (List.rev l1) l2 in\n  let (_, res) = List.fold_left f base args in\n    res;;\n\n\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \nlet _ = bigMul [] []\nlet _ = bigMul [0] [0]\nlet _ = bigMul [] [0]\nlet _ = bigMul [0] []\nlet _ = bigMul [] [1;2;3]\nlet _ = bigMul [1;2;3] []\nlet _ = bigMul [0] [1;2;3]\nlet _ = bigMul [1;2;3] [0]\nlet _ = bigMul [1] [1;2;3]\nlet _ = bigMul [1;2;3] [1]\nlet _ = bigMul [1;2;3] [5]\nlet _ = bigMul [5] [1;2;3]\nlet _ = bigMul [1;2;3] [5;6]\nlet _ = bigMul [5;6] [1;2;3]\nlet _ = bigMul [1;0;0] [5]\nlet _ = bigMul [5;2;1] [0;0]\nlet _ = bigMul [1;2;3;3] [0;0;0]\nlet _ = bigMul [5] [5]\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let (o) f g = fun x -> f (g x)","min":"","type":"syntax","out":"Characters 8-9:\n  let (o) f g = fun x -> f (g x);;\n          ^\nError: Syntax error\n"},{"in":"let foo   = (fun x -> x + 1) o (fun y -> 2 * y)","min":"\nlet foo = (fun x  -> x + 1) o (fun y  -> 2 * y);;\n","type":"type","out":"Characters 12-28:\n  let foo   = (fun x -> x + 1) o (fun y -> 2 * y);;\n              ^^^^^^^^^^^^^^^^\nError: This function has type int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"},{"in":"let ans  = foo 10","min":"\nlet ans = foo 10;;\n","type":"scope","out":"Characters 11-14:\n  let ans  = foo 10;;\n             ^^^\nError: Unbound value foo\n"}],"event":{"region":{"start":753,"stop":851},"type":"eval"},"cursor":753,"time":1.398722534802737e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet (o) f g = fun x -> f (g x)\n\nlet foo   = (fun x -> x + 1) o (fun y -> 2 * y)\n\nlet ans  = foo 10\n\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = (*XXXXX*) failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n    List.fold_left f base fs\n\n\n(*\nXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]\nlet _ = padZero [1;0;0;2] []\nlet _ = padZero [77] [9;9;4;5;6;7;8;9;0]\nlet _ = padZero [] []\nlet _ = padZero [] [9]\nlet _ = padZero [0;0] [1]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = List.append (List.combine (List.rev l1) (List.rev l2)) [(0,0)]\n    (*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [1;2;3] [];;\nlet _ = bigAdd [] [];;\nlet _ = bigAdd [] [3;4;5];;\nlet _ = bigAdd [1] [9;9;9];;\nlet _ = bigAdd [0;0;0] [9;9;9];;\nlet _ = bigAdd [0;0;0;0] [9;9;9];;\nlet _ = bigAdd [0] [];;\nlet _ = bigAdd [3] [];;\nlet _ = bigAdd [0] [0];;\n\n\n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> (match acc with\n              | [] -> []\n              | h::t -> if h = 0 then t else acc)\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 [1;2;3]\nlet _ = mulByDigit 1 [1;2;3]\nlet _ = mulByDigit 10 [1;2;3]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 5 [0;0;0]\nlet _ = mulByDigit 9 []\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 []\n\n\nlet bigMul l1 l2 = \n  let f a x =  match a with \n    | (_, z) -> (0, bigAdd z x) in\n  let base = (0, []) in\n  let args = \n    let rec digitProducts acc place l1 l2 = match l1 with\n      | [] -> acc\n      | h::t -> \n          let placeHolders = \n            (let rec buildZeros a places = \n              if places = 0 then a else buildZeros (0::a) (places-1) in \n               buildZeros [] place) in \n          let a = \n            (List.append (mulByDigit h l2) placeHolders) in\n            digitProducts (a::acc) (place+1) t l2 in\n      digitProducts [] 0 (List.rev l1) l2 in\n  let (_, res) = List.fold_left f base args in\n    res;;\n\n\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \nlet _ = bigMul [] []\nlet _ = bigMul [0] [0]\nlet _ = bigMul [] [0]\nlet _ = bigMul [0] []\nlet _ = bigMul [] [1;2;3]\nlet _ = bigMul [1;2;3] []\nlet _ = bigMul [0] [1;2;3]\nlet _ = bigMul [1;2;3] [0]\nlet _ = bigMul [1] [1;2;3]\nlet _ = bigMul [1;2;3] [1]\nlet _ = bigMul [1;2;3] [5]\nlet _ = bigMul [5] [1;2;3]\nlet _ = bigMul [1;2;3] [5;6]\nlet _ = bigMul [5;6] [1;2;3]\nlet _ = bigMul [1;0;0] [5]\nlet _ = bigMul [5;2;1] [0;0]\nlet _ = bigMul [1;2;3;3] [0;0;0]\nlet _ = bigMul [5] [5]\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let sqsum xs = \nlet f a x =  a + x*x in\nlet base = 0 in\nList.fold_left f base xs","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n","type":"","out":""},{"in":"let _ = sqsum []","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [];;\n","type":"","out":""},{"in":"let _ = sqsum [1;2;3;4]","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sqsum [(-1); (-2); (-3); (-4)]","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [(-1); (-2); (-3); (-4)];;\n","type":"","out":""},{"in":"let pipe fs = \nlet f a x =  x a  in\nlet base = failwith \"to be implemented\" in\nList.fold_left f base fs","min":"\nlet pipe fs =\n  let f a x = x a in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n","type":"","out":""},{"in":"let _ = pipe [] 3","min":"\nlet pipe fs =\n  let f a x = x a in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n","type":"","out":""},{"in":"let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3","min":"\nlet pipe fs =\n  let f a x = x a in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n","type":"type","out":"Characters 24-25:\n  let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3;;\n                          ^\nError: This expression has type 'a -> 'b\n       but an expression was expected of type int\n"},{"in":"let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3","min":"\nlet pipe fs =\n  let f a x = x a in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n","type":"type","out":"Characters 24-25:\n  let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3;;\n                          ^\nError: This expression has type 'a -> 'b\n       but an expression was expected of type int\n"}],"event":{"region":{"start":0,"stop":1146},"type":"eval"},"cursor":1103,"time":1.398722823595215e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x =  x a  in\n  let base = failwith \"to be implemented\" in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]\nlet _ = padZero [1;0;0;2] []\nlet _ = padZero [77] [9;9;4;5;6;7;8;9;0]\nlet _ = padZero [] []\nlet _ = padZero [] [9]\nlet _ = padZero [0;0] [1]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = List.append (List.combine (List.rev l1) (List.rev l2)) [(0,0)]\n    (*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [1;2;3] [];;\nlet _ = bigAdd [] [];;\nlet _ = bigAdd [] [3;4;5];;\nlet _ = bigAdd [1] [9;9;9];;\nlet _ = bigAdd [0;0;0] [9;9;9];;\nlet _ = bigAdd [0;0;0;0] [9;9;9];;\nlet _ = bigAdd [0] [];;\nlet _ = bigAdd [3] [];;\nlet _ = bigAdd [0] [0];;\n\n\n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> (match acc with\n              | [] -> []\n              | h::t -> if h = 0 then t else acc)\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 [1;2;3]\nlet _ = mulByDigit 1 [1;2;3]\nlet _ = mulByDigit 10 [1;2;3]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 5 [0;0;0]\nlet _ = mulByDigit 9 []\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 []\n\n\nlet bigMul l1 l2 = \n  let f a x =  match a with \n    | (_, z) -> (0, bigAdd z x) in\n  let base = (0, []) in\n  let args = \n    let rec digitProducts acc place l1 l2 = match l1 with\n      | [] -> acc\n      | h::t -> \n          let placeHolders = \n            (let rec buildZeros a places = \n              if places = 0 then a else buildZeros (0::a) (places-1) in \n               buildZeros [] place) in \n          let a = \n            (List.append (mulByDigit h l2) placeHolders) in\n            digitProducts (a::acc) (place+1) t l2 in\n      digitProducts [] 0 (List.rev l1) l2 in\n  let (_, res) = List.fold_left f base args in\n    res;;\n\n\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \nlet _ = bigMul [] []\nlet _ = bigMul [0] [0]\nlet _ = bigMul [] [0]\nlet _ = bigMul [0] []\nlet _ = bigMul [] [1;2;3]\nlet _ = bigMul [1;2;3] []\nlet _ = bigMul [0] [1;2;3]\nlet _ = bigMul [1;2;3] [0]\nlet _ = bigMul [1] [1;2;3]\nlet _ = bigMul [1;2;3] [1]\nlet _ = bigMul [1;2;3] [5]\nlet _ = bigMul [5] [1;2;3]\nlet _ = bigMul [1;2;3] [5;6]\nlet _ = bigMul [5;6] [1;2;3]\nlet _ = bigMul [1;0;0] [5]\nlet _ = bigMul [5;2;1] [0;0]\nlet _ = bigMul [1;2;3;3] [0;0;0]\nlet _ = bigMul [5] [5]\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let pipe fs = \nlet f a x =  fun b -> x (a b) in\nlet base = fun b -> b in\nList.fold_left f base fs","min":"\nlet pipe fs =\n  let f a x b = x (a b) in let base b = b in List.fold_left f base fs;;\n","type":"","out":""}],"event":{"region":{"start":916,"stop":1017},"type":"eval"},"cursor":1017,"time":1.398722953452009e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x =  fun b -> x (a b) in\n  let base = fun b -> b in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]\nlet _ = padZero [1;0;0;2] []\nlet _ = padZero [77] [9;9;4;5;6;7;8;9;0]\nlet _ = padZero [] []\nlet _ = padZero [] [9]\nlet _ = padZero [0;0] [1]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = List.append (List.combine (List.rev l1) (List.rev l2)) [(0,0)]\n    (*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [1;2;3] [];;\nlet _ = bigAdd [] [];;\nlet _ = bigAdd [] [3;4;5];;\nlet _ = bigAdd [1] [9;9;9];;\nlet _ = bigAdd [0;0;0] [9;9;9];;\nlet _ = bigAdd [0;0;0;0] [9;9;9];;\nlet _ = bigAdd [0] [];;\nlet _ = bigAdd [3] [];;\nlet _ = bigAdd [0] [0];;\n\n\n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> (match acc with\n              | [] -> []\n              | h::t -> if h = 0 then t else acc)\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 [1;2;3]\nlet _ = mulByDigit 1 [1;2;3]\nlet _ = mulByDigit 10 [1;2;3]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 5 [0;0;0]\nlet _ = mulByDigit 9 []\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 []\n\n\nlet bigMul l1 l2 = \n  let f a x =  match a with \n    | (_, z) -> (0, bigAdd z x) in\n  let base = (0, []) in\n  let args = \n    let rec digitProducts acc place l1 l2 = match l1 with\n      | [] -> acc\n      | h::t -> \n          let placeHolders = \n            (let rec buildZeros a places = \n              if places = 0 then a else buildZeros (0::a) (places-1) in \n               buildZeros [] place) in \n          let a = \n            (List.append (mulByDigit h l2) placeHolders) in\n            digitProducts (a::acc) (place+1) t l2 in\n      digitProducts [] 0 (List.rev l1) l2 in\n  let (_, res) = List.fold_left f base args in\n    res;;\n\n\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \nlet _ = bigMul [] []\nlet _ = bigMul [0] [0]\nlet _ = bigMul [] [0]\nlet _ = bigMul [0] []\nlet _ = bigMul [] [1;2;3]\nlet _ = bigMul [1;2;3] []\nlet _ = bigMul [0] [1;2;3]\nlet _ = bigMul [1;2;3] [0]\nlet _ = bigMul [1] [1;2;3]\nlet _ = bigMul [1;2;3] [1]\nlet _ = bigMul [1;2;3] [5]\nlet _ = bigMul [5] [1;2;3]\nlet _ = bigMul [1;2;3] [5;6]\nlet _ = bigMul [5;6] [1;2;3]\nlet _ = bigMul [1;0;0] [5]\nlet _ = bigMul [5;2;1] [0;0]\nlet _ = bigMul [1;2;3;3] [0;0;0]\nlet _ = bigMul [5] [5]\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = pipe [] 3","min":"\nlet pipe fs =\n  let f a x b = x (a b) in let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n","type":"","out":""},{"in":"let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3","min":"\nlet pipe fs =\n  let f a x b = x (a b) in let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n","type":"","out":""},{"in":"let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3","min":"\nlet pipe fs =\n  let f a x b = x (a b) in let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n","type":"","out":""}],"event":{"region":{"start":1017,"stop":1140},"type":"eval"},"cursor":1141,"time":1.39872295717382e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x =  fun b -> x (a b) in\n  let base = fun b -> b in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]\nlet _ = padZero [1;0;0;2] []\nlet _ = padZero [77] [9;9;4;5;6;7;8;9;0]\nlet _ = padZero [] []\nlet _ = padZero [] [9]\nlet _ = padZero [0;0] [1]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = List.append (List.combine (List.rev l1) (List.rev l2)) [(0,0)]\n    (*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [1;2;3] [];;\nlet _ = bigAdd [] [];;\nlet _ = bigAdd [] [3;4;5];;\nlet _ = bigAdd [1] [9;9;9];;\nlet _ = bigAdd [0;0;0] [9;9;9];;\nlet _ = bigAdd [0;0;0;0] [9;9;9];;\nlet _ = bigAdd [0] [];;\nlet _ = bigAdd [3] [];;\nlet _ = bigAdd [0] [0];;\n\n\n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> (match acc with\n              | [] -> []\n              | h::t -> if h = 0 then t else acc)\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 [1;2;3]\nlet _ = mulByDigit 1 [1;2;3]\nlet _ = mulByDigit 10 [1;2;3]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 5 [0;0;0]\nlet _ = mulByDigit 9 []\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 []\n\n\nlet bigMul l1 l2 = \n  let f a x =  match a with \n    | (_, z) -> (0, bigAdd z x) in\n  let base = (0, []) in\n  let args = \n    let rec digitProducts acc place l1 l2 = match l1 with\n      | [] -> acc\n      | h::t -> \n          let placeHolders = \n            (let rec buildZeros a places = \n              if places = 0 then a else buildZeros (0::a) (places-1) in \n               buildZeros [] place) in \n          let a = \n            (List.append (mulByDigit h l2) placeHolders) in\n            digitProducts (a::acc) (place+1) t l2 in\n      digitProducts [] 0 (List.rev l1) l2 in\n  let (_, res) = List.fold_left f base args in\n    res;;\n\n\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \nlet _ = bigMul [] []\nlet _ = bigMul [0] [0]\nlet _ = bigMul [] [0]\nlet _ = bigMul [0] []\nlet _ = bigMul [] [1;2;3]\nlet _ = bigMul [1;2;3] []\nlet _ = bigMul [0] [1;2;3]\nlet _ = bigMul [1;2;3] [0]\nlet _ = bigMul [1] [1;2;3]\nlet _ = bigMul [1;2;3] [1]\nlet _ = bigMul [1;2;3] [5]\nlet _ = bigMul [5] [1;2;3]\nlet _ = bigMul [1;2;3] [5;6]\nlet _ = bigMul [5;6] [1;2;3]\nlet _ = bigMul [1;0;0] [5]\nlet _ = bigMul [5;2;1] [0;0]\nlet _ = bigMul [1;2;3;3] [0;0;0]\nlet _ = bigMul [5] [5]\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x  in\nlet base = h in\nlet l = t in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n","type":"","out":""},{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"---\" []","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"---\" [];;\n","type":"","out":""},{"in":"let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"\" [\"a\"; \"b\"; \"c\"; \"d\"; \"e\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"X\" [\"hello\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"X\" [\"hello\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"a\" []","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"a\" [];;\n","type":"","out":""},{"in":"let _ = sepConcat \"a\" [\"b\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"a\" [\"b\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"\" []","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"\" [];;\n","type":"","out":""},{"in":"let _ = sepConcat \"\" [\"bc\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"\" [\"bc\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"z\" [\"\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"z\" [\"\"];;\n","type":"","out":""},{"in":"let stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n","type":"","out":""},{"in":"let _ = stringOfList string_of_int [1;2;3;4;5;6]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n\nlet _ = stringOfList string_of_int [1; 2; 3; 4; 5; 6];;\n","type":"","out":""},{"in":"let _ = stringOfList (fun x -> x) [\"foo\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n\nlet _ = stringOfList (fun x  -> x) [\"foo\"];;\n","type":"","out":""},{"in":"let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n\nlet _ =\n  stringOfList (stringOfList string_of_int) [[1; 2; 3]; [4; 5]; [6]; []];;\n","type":"","out":""},{"in":"let rec clone x n = \nlet rec helper a x n =\nif n <= 0 then a\nelse \nlet a' = x::a in\nhelper a' x (n-1)\nin helper [] x n","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n","type":"","out":""},{"in":"let _ = clone 3 5","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet _ = clone 3 5;;\n","type":"","out":""},{"in":"let _ = clone \"foo\" 2","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet _ = clone \"foo\" 2;;\n","type":"","out":""},{"in":"let _ = clone clone (-3)","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet _ = clone clone (-3);;\n","type":"","out":""},{"in":"let padZero l1 l2 = \nlet length1 = List.length l1 in\nlet length2 = List.length l2 in\nif length1 > length2 then \n(l1, List.append (clone 0 (length1 - length2)) l2)\nelse if length2 > length1 then \n(List.append (clone 0 (length2 - length1)) l1, l2)\nelse (l1,l2)","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n","type":"","out":""},{"in":"let _ = padZero [9;9] [1;0;0;2]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet _ = padZero [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = padZero [1;0;0;2] [9;9]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet _ = padZero [1; 0; 0; 2] [9; 9];;\n","type":"","out":""},{"in":"let _ = padZero [1;0;0;2] []","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet _ = padZero [1; 0; 0; 2] [];;\n","type":"","out":""},{"in":"let _ = padZero [77] [9;9;4;5;6;7;8;9;0]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet _ = padZero [77] [9; 9; 4; 5; 6; 7; 8; 9; 0];;\n","type":"","out":""},{"in":"let _ = padZero [] []","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet _ = padZero [] [];;\n","type":"","out":""},{"in":"let _ = padZero [] [9]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet _ = padZero [] [9];;\n","type":"","out":""},{"in":"let _ = padZero [0;0] [1]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet _ = padZero [0; 0] [1];;\n","type":"","out":""},{"in":"let rec removeZero l = match l with\n| [] -> []\n| h::t -> if h = 0 then removeZero t else l","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;1;0;0;2]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet _ = removeZero [0; 0; 0; 1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = removeZero [9;9]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet _ = removeZero [9; 9];;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;0]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet _ = removeZero [0; 0; 0; 0];;\n","type":"","out":""},{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(x1, x2) -> \nmatch a with\n(o , z) -> if o + x1 + x2 > 9 \nthen (1, ((o + x1 + x2) mod 10)::z )\nelse (0, (o + x1 + x2)::z)\nin\nlet base = (0, []) in\nlet args = List.append (List.combine (List.rev l1) (List.rev l2)) [(0,0)]\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nin\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9] [1;0;0;2]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9;9;9] [9;9;9]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigAdd [1;2;3] []","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [1; 2; 3] [];;\n","type":"","out":""},{"in":"let _ = bigAdd [] []","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [] [];;\n","type":"","out":""},{"in":"let _ = bigAdd [] [3;4;5]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [] [3; 4; 5];;\n","type":"","out":""},{"in":"let _ = bigAdd [1] [9;9;9]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [1] [9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigAdd [0;0;0] [9;9;9]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [0; 0; 0] [9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigAdd [0;0;0;0] [9;9;9]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [0; 0; 0; 0] [9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigAdd [0] []","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [0] [];;\n","type":"","out":""},{"in":"let _ = bigAdd [3] []","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [3] [];;\n","type":"","out":""},{"in":"let _ = bigAdd [0] [0]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [0] [0];;\n","type":"","out":""}],"event":{"region":{"start":1140,"stop":3760},"type":"eval"},"cursor":3762,"time":1.398722988930061e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x =  fun b -> x (a b) in\n  let base = fun b -> b in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]\nlet _ = padZero [1;0;0;2] []\nlet _ = padZero [77] [9;9;4;5;6;7;8;9;0]\nlet _ = padZero [] []\nlet _ = padZero [] [9]\nlet _ = padZero [0;0] [1]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = List.append (List.combine (List.rev l1) (List.rev l2)) [(0,0)]\n    (*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [1;2;3] [];;\nlet _ = bigAdd [] [];;\nlet _ = bigAdd [] [3;4;5];;\nlet _ = bigAdd [1] [9;9;9];;\nlet _ = bigAdd [0;0;0] [9;9;9];;\nlet _ = bigAdd [0;0;0;0] [9;9;9];;\nlet _ = bigAdd [0] [];;\nlet _ = bigAdd [3] [];;\nlet _ = bigAdd [0] [0];;\n\n\n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> (match acc with\n              | [] -> []\n              | h::t -> if h = 0 then t else acc)\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 [1;2;3]\nlet _ = mulByDigit 1 [1;2;3]\nlet _ = mulByDigit 10 [1;2;3]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 5 [0;0;0]\nlet _ = mulByDigit 9 []\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 []\n\n\nlet bigMul l1 l2 = \n  let f a x =  match a with \n    | (_, z) -> (0, bigAdd z x) in\n  let base = (0, []) in\n  let args = \n    let rec digitProducts acc place l1 l2 = match l1 with\n      | [] -> acc\n      | h::t -> \n          let placeHolders = \n            (let rec buildZeros a places = \n              if places = 0 then a else buildZeros (0::a) (places-1) in \n               buildZeros [] place) in \n          let a = \n            (List.append (mulByDigit h l2) placeHolders) in\n            digitProducts (a::acc) (place+1) t l2 in\n      digitProducts [] 0 (List.rev l1) l2 in\n  let (_, res) = List.fold_left f base args in\n    res;;\n\n\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \nlet _ = bigMul [] []\nlet _ = bigMul [0] [0]\nlet _ = bigMul [] [0]\nlet _ = bigMul [0] []\nlet _ = bigMul [] [1;2;3]\nlet _ = bigMul [1;2;3] []\nlet _ = bigMul [0] [1;2;3]\nlet _ = bigMul [1;2;3] [0]\nlet _ = bigMul [1] [1;2;3]\nlet _ = bigMul [1;2;3] [1]\nlet _ = bigMul [1;2;3] [5]\nlet _ = bigMul [5] [1;2;3]\nlet _ = bigMul [1;2;3] [5;6]\nlet _ = bigMul [5;6] [1;2;3]\nlet _ = bigMul [1;0;0] [5]\nlet _ = bigMul [5;2;1] [0;0]\nlet _ = bigMul [1;2;3;3] [0;0;0]\nlet _ = bigMul [5] [5]\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = bigAdd [0] [0]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [0] [0];;\n","type":"","out":""},{"in":"let rec mulByDigit i l =\nlet rec helper acc carry i l = match l with\n| [] -> (match acc with\n| [] -> []\n| h::t -> if h = 0 then t else acc)\n| h::t -> let x = (h*i + carry) in \nlet n = if x > 9 then x mod 10 else x in\nlet carry' = if x > 9 then x/10 else 0 in\nlet acc' = n::acc in\nhelper acc' carry' i t\nin helper [] 0 i (List.rev (0::l))","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n","type":"","out":""},{"in":"let _ = mulByDigit 9 [9;9;9;9]","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let _ = mulByDigit 0 [1;2;3]","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 0 [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = mulByDigit 1 [1;2;3]","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 1 [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = mulByDigit 10 [1;2;3]","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 10 [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = mulByDigit 5 [0;0;0]","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 5 [0; 0; 0];;\n","type":"","out":""},{"in":"let _ = mulByDigit 9 []","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 9 [];;\n","type":"","out":""},{"in":"let _ = mulByDigit 0 []","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 0 [];;\n","type":"","out":""},{"in":"let bigMul l1 l2 = \nlet f a x =  match a with \n| (_, z) -> (0, bigAdd z x) in\nlet base = (0, []) in\nlet args = \nlet rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = \n(List.append (mulByDigit h l2) placeHolders) in\ndigitProducts (a::acc) (place+1) t l2 in\ndigitProducts [] 0 (List.rev l1) l2 in\nlet (_, res) = List.fold_left f base args in\nres","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n","type":"","out":""},{"in":"let _ = bigMul [9;9;9;9] [9;9;9;9]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9; 9] [9; 9; 9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigMul [] []","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [] [];;\n","type":"","out":""},{"in":"let _ = bigMul [0] [0]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [0] [0];;\n","type":"","out":""},{"in":"let _ = bigMul [] [0]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [] [0];;\n","type":"","out":""},{"in":"let _ = bigMul [0] []","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [0] [];;\n","type":"","out":""},{"in":"let _ = bigMul [] [1;2;3]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [] [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = bigMul [1;2;3] []","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1; 2; 3] [];;\n","type":"","out":""},{"in":"let _ = bigMul [0] [1;2;3]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [0] [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = bigMul [1;2;3] [0]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1; 2; 3] [0];;\n","type":"","out":""},{"in":"let _ = bigMul [1] [1;2;3]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1] [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = bigMul [1;2;3] [1]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1; 2; 3] [1];;\n","type":"","out":""},{"in":"let _ = bigMul [1;2;3] [5]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1; 2; 3] [5];;\n","type":"","out":""},{"in":"let _ = bigMul [5] [1;2;3]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [5] [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = bigMul [1;2;3] [5;6]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1; 2; 3] [5; 6];;\n","type":"","out":""},{"in":"let _ = bigMul [5;6] [1;2;3]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [5; 6] [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = bigMul [1;0;0] [5]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1; 0; 0] [5];;\n","type":"","out":""},{"in":"let _ = bigMul [5;2;1] [0;0]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [5; 2; 1] [0; 0];;\n","type":"","out":""},{"in":"let _ = bigMul [1;2;3;3] [0;0;0]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1; 2; 3; 3] [0; 0; 0];;\n","type":"","out":""},{"in":"let _ = bigMul [5] [5]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [5] [5];;\n","type":"","out":""},{"in":"let key = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130 = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ ((Printexc.to_string e) ^ \"\\n\"));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n","type":"","out":""},{"in":"let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","min":"\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n","type":"","out":""},{"in":"let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n\nlet drop_paren s =\n  implode\n    (List.filter (fun c  -> not (List.mem c ['('; ' '; ')'])) (explode s));;\n","type":"","out":""},{"in":"let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","min":"\nlet eq_real p (r1,r2) = ((r1 -. r2) < p) || ((r2 -. r1) < p);;\n","type":"","out":""},{"in":"let wrap_curried_2 f (a,b) = f a b","min":"\nlet wrap_curried_2 f (a,b) = f a b;;\n","type":"","out":""}],"event":{"region":{"start":3738,"stop":9530},"type":"eval"},"cursor":3762,"time":1.398723021491674e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x =  fun b -> x (a b) in\n  let base = fun b -> b in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]\nlet _ = padZero [1;0;0;2] []\nlet _ = padZero [77] [9;9;4;5;6;7;8;9;0]\nlet _ = padZero [] []\nlet _ = padZero [] [9]\nlet _ = padZero [0;0] [1]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = List.append (List.combine (List.rev l1) (List.rev l2)) [(0,0)]\n    (*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [1;2;3] [];;\nlet _ = bigAdd [] [];;\nlet _ = bigAdd [] [3;4;5];;\nlet _ = bigAdd [1] [9;9;9];;\nlet _ = bigAdd [0;0;0] [9;9;9];;\nlet _ = bigAdd [0;0;0;0] [9;9;9];;\nlet _ = bigAdd [0] [];;\nlet _ = bigAdd [3] [];;\nlet _ = bigAdd [0] [0];;\n\n\n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> (match acc with\n              | [] -> []\n              | h::t -> if h = 0 then t else acc)\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 [1;2;3]\nlet _ = mulByDigit 1 [1;2;3]\nlet _ = mulByDigit 10 [1;2;3]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 5 [0;0;0]\nlet _ = mulByDigit 9 []\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 []\n\n\nlet bigMul l1 l2 = \n  let f a x =  match a with \n    | (_, z) -> (0, bigAdd z x) in\n  let base = (0, []) in\n  let args = \n    let rec digitProducts acc place l1 l2 = match l1 with\n      | [] -> acc\n      | h::t -> \n          let placeHolders = \n            (let rec buildZeros a places = \n              if places = 0 then a else buildZeros (0::a) (places-1) in \n               buildZeros [] place) in \n          let a = \n            (List.append (mulByDigit h l2) placeHolders) in\n            digitProducts (a::acc) (place+1) t l2 in\n      digitProducts [] 0 (List.rev l1) l2 in\n  let (_, res) = List.fold_left f base args in\n    res;;\n\n\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \nlet _ = bigMul [] []\nlet _ = bigMul [0] [0]\nlet _ = bigMul [] [0]\nlet _ = bigMul [0] []\nlet _ = bigMul [] [1;2;3]\nlet _ = bigMul [1;2;3] []\nlet _ = bigMul [0] [1;2;3]\nlet _ = bigMul [1;2;3] [0]\nlet _ = bigMul [1] [1;2;3]\nlet _ = bigMul [1;2;3] [1]\nlet _ = bigMul [1;2;3] [5]\nlet _ = bigMul [5] [1;2;3]\nlet _ = bigMul [1;2;3] [5;6]\nlet _ = bigMul [5;6] [1;2;3]\nlet _ = bigMul [1;0;0] [5]\nlet _ = bigMul [5;2;1] [0;0]\nlet _ = bigMul [1;2;3;3] [0;0;0]\nlet _ = bigMul [5] [5]\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = stringOfList string_of_int [1;2;3;4;5;6]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n\nlet _ = stringOfList string_of_int [1; 2; 3; 4; 5; 6];;\n","type":"","out":""}],"event":{"region":{"start":1641,"stop":1689},"type":"eval"},"cursor":1691,"time":1.398723048217061e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x =  fun b -> x (a b) in\n  let base = fun b -> b in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]\nlet _ = padZero [1;0;0;2] []\nlet _ = padZero [77] [9;9;4;5;6;7;8;9;0]\nlet _ = padZero [] []\nlet _ = padZero [] [9]\nlet _ = padZero [0;0] [1]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = List.append (List.combine (List.rev l1) (List.rev l2)) [(0,0)]\n    (*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [1;2;3] [];;\nlet _ = bigAdd [] [];;\nlet _ = bigAdd [] [3;4;5];;\nlet _ = bigAdd [1] [9;9;9];;\nlet _ = bigAdd [0;0;0] [9;9;9];;\nlet _ = bigAdd [0;0;0;0] [9;9;9];;\nlet _ = bigAdd [0] [];;\nlet _ = bigAdd [3] [];;\nlet _ = bigAdd [0] [0];;\n\n\n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> (match acc with\n              | [] -> []\n              | h::t -> if h = 0 then t else acc)\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 [1;2;3]\nlet _ = mulByDigit 1 [1;2;3]\nlet _ = mulByDigit 10 [1;2;3]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 5 [0;0;0]\nlet _ = mulByDigit 9 []\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 []\n\n\nlet bigMul l1 l2 = \n  let f a x =  match a with \n    | (_, z) -> (0, bigAdd z x) in\n  let base = (0, []) in\n  let args = \n    let rec digitProducts acc place l1 l2 = match l1 with\n      | [] -> acc\n      | h::t -> \n          let placeHolders = \n            (let rec buildZeros a places = \n              if places = 0 then a else buildZeros (0::a) (places-1) in \n               buildZeros [] place) in \n          let a = \n            (List.append (mulByDigit h l2) placeHolders) in\n            digitProducts (a::acc) (place+1) t l2 in\n      digitProducts [] 0 (List.rev l1) l2 in\n  let (_, res) = List.fold_left f base args in\n    res;;\n\n\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \nlet _ = bigMul [] []\nlet _ = bigMul [0] [0]\nlet _ = bigMul [] [0]\nlet _ = bigMul [0] []\nlet _ = bigMul [] [1;2;3]\nlet _ = bigMul [1;2;3] []\nlet _ = bigMul [0] [1;2;3]\nlet _ = bigMul [1;2;3] [0]\nlet _ = bigMul [1] [1;2;3]\nlet _ = bigMul [1;2;3] [1]\nlet _ = bigMul [1;2;3] [5]\nlet _ = bigMul [5] [1;2;3]\nlet _ = bigMul [1;2;3] [5;6]\nlet _ = bigMul [5;6] [1;2;3]\nlet _ = bigMul [1;0;0] [5]\nlet _ = bigMul [5;2;1] [0;0]\nlet _ = bigMul [1;2;3;3] [0;0;0]\nlet _ = bigMul [5] [5]\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = stringOfList (fun x -> x) [\"foo\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n\nlet _ = stringOfList (fun x  -> x) [\"foo\"];;\n","type":"","out":""}],"event":{"region":{"start":1689,"stop":1733},"type":"eval"},"cursor":1735,"time":1.39872305253167e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x =  fun b -> x (a b) in\n  let base = fun b -> b in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]\nlet _ = padZero [1;0;0;2] []\nlet _ = padZero [77] [9;9;4;5;6;7;8;9;0]\nlet _ = padZero [] []\nlet _ = padZero [] [9]\nlet _ = padZero [0;0] [1]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = List.append (List.combine (List.rev l1) (List.rev l2)) [(0,0)]\n    (*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [1;2;3] [];;\nlet _ = bigAdd [] [];;\nlet _ = bigAdd [] [3;4;5];;\nlet _ = bigAdd [1] [9;9;9];;\nlet _ = bigAdd [0;0;0] [9;9;9];;\nlet _ = bigAdd [0;0;0;0] [9;9;9];;\nlet _ = bigAdd [0] [];;\nlet _ = bigAdd [3] [];;\nlet _ = bigAdd [0] [0];;\n\n\n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> (match acc with\n              | [] -> []\n              | h::t -> if h = 0 then t else acc)\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 [1;2;3]\nlet _ = mulByDigit 1 [1;2;3]\nlet _ = mulByDigit 10 [1;2;3]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 5 [0;0;0]\nlet _ = mulByDigit 9 []\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 []\n\n\nlet bigMul l1 l2 = \n  let f a x =  match a with \n    | (_, z) -> (0, bigAdd z x) in\n  let base = (0, []) in\n  let args = \n    let rec digitProducts acc place l1 l2 = match l1 with\n      | [] -> acc\n      | h::t -> \n          let placeHolders = \n            (let rec buildZeros a places = \n              if places = 0 then a else buildZeros (0::a) (places-1) in \n               buildZeros [] place) in \n          let a = \n            (List.append (mulByDigit h l2) placeHolders) in\n            digitProducts (a::acc) (place+1) t l2 in\n      digitProducts [] 0 (List.rev l1) l2 in\n  let (_, res) = List.fold_left f base args in\n    res;;\n\n\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \nlet _ = bigMul [] []\nlet _ = bigMul [0] [0]\nlet _ = bigMul [] [0]\nlet _ = bigMul [0] []\nlet _ = bigMul [] [1;2;3]\nlet _ = bigMul [1;2;3] []\nlet _ = bigMul [0] [1;2;3]\nlet _ = bigMul [1;2;3] [0]\nlet _ = bigMul [1] [1;2;3]\nlet _ = bigMul [1;2;3] [1]\nlet _ = bigMul [1;2;3] [5]\nlet _ = bigMul [5] [1;2;3]\nlet _ = bigMul [1;2;3] [5;6]\nlet _ = bigMul [5;6] [1;2;3]\nlet _ = bigMul [1;0;0] [5]\nlet _ = bigMul [5;2;1] [0;0]\nlet _ = bigMul [1;2;3;3] [0;0;0]\nlet _ = bigMul [5] [5]\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n\nlet _ =\n  stringOfList (stringOfList string_of_int) [[1; 2; 3]; [4; 5]; [6]; []];;\n","type":"","out":""}],"event":{"region":{"start":1733,"stop":1808},"type":"eval"},"cursor":1810,"time":1.398723128841124e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x =  fun b -> x (a b) in\n  let base = fun b -> b in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]\nlet _ = padZero [1;0;0;2] []\nlet _ = padZero [77] [9;9;4;5;6;7;8;9;0]\nlet _ = padZero [] []\nlet _ = padZero [] [9]\nlet _ = padZero [0;0] [1]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = List.append (List.combine (List.rev l1) (List.rev l2)) [(0,0)]\n    (*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [1;2;3] [];;\nlet _ = bigAdd [] [];;\nlet _ = bigAdd [] [3;4;5];;\nlet _ = bigAdd [1] [9;9;9];;\nlet _ = bigAdd [0;0;0] [9;9;9];;\nlet _ = bigAdd [0;0;0;0] [9;9;9];;\nlet _ = bigAdd [0] [];;\nlet _ = bigAdd [3] [];;\nlet _ = bigAdd [0] [0];;\n\n\n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> (match acc with\n              | [] -> []\n              | h::t -> if h = 0 then t else acc)\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 [1;2;3]\nlet _ = mulByDigit 1 [1;2;3]\nlet _ = mulByDigit 10 [1;2;3]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 5 [0;0;0]\nlet _ = mulByDigit 9 []\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 []\n\n\nlet bigMul l1 l2 = \n  let f a x =  match a with \n    | (_, z) -> (0, bigAdd z x) in\n  let base = (0, []) in\n  let args = \n    let rec digitProducts acc place l1 l2 = match l1 with\n      | [] -> acc\n      | h::t -> \n          let placeHolders = \n            (let rec buildZeros a places = \n              if places = 0 then a else buildZeros (0::a) (places-1) in \n               buildZeros [] place) in \n          let a = \n            (List.append (mulByDigit h l2) placeHolders) in\n            digitProducts (a::acc) (place+1) t l2 in\n      digitProducts [] 0 (List.rev l1) l2 in\n  let (_, res) = List.fold_left f base args in\n    res;;\n\n\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \nlet _ = bigMul [] []\nlet _ = bigMul [0] [0]\nlet _ = bigMul [] [0]\nlet _ = bigMul [0] []\nlet _ = bigMul [] [1;2;3]\nlet _ = bigMul [1;2;3] []\nlet _ = bigMul [0] [1;2;3]\nlet _ = bigMul [1;2;3] [0]\nlet _ = bigMul [1] [1;2;3]\nlet _ = bigMul [1;2;3] [1]\nlet _ = bigMul [1;2;3] [5]\nlet _ = bigMul [5] [1;2;3]\nlet _ = bigMul [1;2;3] [5;6]\nlet _ = bigMul [5;6] [1;2;3]\nlet _ = bigMul [1;0;0] [5]\nlet _ = bigMul [5;2;1] [0;0]\nlet _ = bigMul [1;2;3;3] [0;0;0]\nlet _ = bigMul [5] [5]\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n","type":"","out":""},{"in":"let _ = stringOfList string_of_int [1;2;3;4;5;6]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n\nlet _ = stringOfList string_of_int [1; 2; 3; 4; 5; 6];;\n","type":"","out":""},{"in":"let _ = stringOfList (fun x -> x) [\"foo\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n\nlet _ = stringOfList (fun x  -> x) [\"foo\"];;\n","type":"","out":""},{"in":"let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n\nlet _ =\n  stringOfList (stringOfList string_of_int) [[1; 2; 3]; [4; 5]; [6]; []];;\n","type":"","out":""},{"in":"let rec clone x n = \nlet rec helper a x n =\nif n <= 0 then a\nelse \nlet a' = x::a in\nhelper a' x (n-1)\nin helper [] x n","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n","type":"","out":""},{"in":"let _ = clone 3 5","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet _ = clone 3 5;;\n","type":"","out":""},{"in":"let _ = clone \"foo\" 2","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet _ = clone \"foo\" 2;;\n","type":"","out":""},{"in":"let _ = clone clone (-3)","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet _ = clone clone (-3);;\n","type":"","out":""},{"in":"let padZero l1 l2 = \nlet length1 = List.length l1 in\nlet length2 = List.length l2 in\nif length1 > length2 then \n(l1, List.append (clone 0 (length1 - length2)) l2)\nelse if length2 > length1 then \n(List.append (clone 0 (length2 - length1)) l1, l2)\nelse (l1,l2)","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n","type":"","out":""},{"in":"let _ = padZero [9;9] [1;0;0;2]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet _ = padZero [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = padZero [1;0;0;2] [9;9]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet _ = padZero [1; 0; 0; 2] [9; 9];;\n","type":"","out":""},{"in":"let _ = padZero [1;0;0;2] []","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet _ = padZero [1; 0; 0; 2] [];;\n","type":"","out":""},{"in":"let _ = padZero [77] [9;9;4;5;6;7;8;9;0]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet _ = padZero [77] [9; 9; 4; 5; 6; 7; 8; 9; 0];;\n","type":"","out":""},{"in":"let _ = padZero [] []","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet _ = padZero [] [];;\n","type":"","out":""},{"in":"let _ = padZero [] [9]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet _ = padZero [] [9];;\n","type":"","out":""},{"in":"let _ = padZero [0;0] [1]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet _ = padZero [0; 0] [1];;\n","type":"","out":""},{"in":"let rec removeZero l = match l with\n| [] -> []\n| h::t -> if h = 0 then removeZero t else l","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;1;0;0;2]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet _ = removeZero [0; 0; 0; 1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = removeZero [9;9]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet _ = removeZero [9; 9];;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;0]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet _ = removeZero [0; 0; 0; 0];;\n","type":"","out":""},{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(x1, x2) -> \nmatch a with\n(o , z) -> if o + x1 + x2 > 9 \nthen (1, ((o + x1 + x2) mod 10)::z )\nelse (0, (o + x1 + x2)::z)\nin\nlet base = (0, []) in\nlet args = List.append (List.combine (List.rev l1) (List.rev l2)) [(0,0)]\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nin\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9] [1;0;0;2]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9;9;9] [9;9;9]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigAdd [1;2;3] []","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [1; 2; 3] [];;\n","type":"","out":""},{"in":"let _ = bigAdd [] []","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [] [];;\n","type":"","out":""},{"in":"let _ = bigAdd [] [3;4;5]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [] [3; 4; 5];;\n","type":"","out":""},{"in":"let _ = bigAdd [1] [9;9;9]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [1] [9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigAdd [0;0;0] [9;9;9]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [0; 0; 0] [9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigAdd [0;0;0;0] [9;9;9]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [0; 0; 0; 0] [9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigAdd [0] []","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [0] [];;\n","type":"","out":""},{"in":"let _ = bigAdd [3] []","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [3] [];;\n","type":"","out":""},{"in":"let _ = bigAdd [0] [0]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [0] [0];;\n","type":"","out":""},{"in":"let rec mulByDigit i l =\nlet rec helper acc carry i l = match l with\n| [] -> (match acc with\n| [] -> []\n| h::t -> if h = 0 then t else acc)\n| h::t -> let x = (h*i + carry) in \nlet n = if x > 9 then x mod 10 else x in\nlet carry' = if x > 9 then x/10 else 0 in\nlet acc' = n::acc in\nhelper acc' carry' i t\nin helper [] 0 i (List.rev (0::l))","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n","type":"","out":""},{"in":"let _ = mulByDigit 9 [9;9;9;9]","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let _ = mulByDigit 0 [1;2;3]","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 0 [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = mulByDigit 1 [1;2;3]","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 1 [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = mulByDigit 10 [1;2;3]","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 10 [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = mulByDigit 5 [0;0;0]","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 5 [0; 0; 0];;\n","type":"","out":""},{"in":"let _ = mulByDigit 9 []","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 9 [];;\n","type":"","out":""},{"in":"let _ = mulByDigit 0 []","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 0 [];;\n","type":"","out":""},{"in":"let bigMul l1 l2 = \nlet f a x =  match a with \n| (_, z) -> (0, bigAdd z x) in\nlet base = (0, []) in\nlet args = \nlet rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = \n(List.append (mulByDigit h l2) placeHolders) in\ndigitProducts (a::acc) (place+1) t l2 in\ndigitProducts [] 0 (List.rev l1) l2 in\nlet (_, res) = List.fold_left f base args in\nres","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n","type":"","out":""},{"in":"let _ = bigMul [9;9;9;9] [9;9;9;9]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9; 9] [9; 9; 9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigMul [] []","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [] [];;\n","type":"","out":""},{"in":"let _ = bigMul [0] [0]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [0] [0];;\n","type":"","out":""},{"in":"let _ = bigMul [] [0]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [] [0];;\n","type":"","out":""},{"in":"let _ = bigMul [0] []","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [0] [];;\n","type":"","out":""},{"in":"let _ = bigMul [] [1;2;3]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [] [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = bigMul [1;2;3] []","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1; 2; 3] [];;\n","type":"","out":""},{"in":"let _ = bigMul [0] [1;2;3]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [0] [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = bigMul [1;2;3] [0]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1; 2; 3] [0];;\n","type":"","out":""},{"in":"let _ = bigMul [1] [1;2;3]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1] [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = bigMul [1;2;3] [1]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1; 2; 3] [1];;\n","type":"","out":""},{"in":"let _ = bigMul [1;2;3] [5]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1; 2; 3] [5];;\n","type":"","out":""},{"in":"let _ = bigMul [5] [1;2;3]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [5] [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = bigMul [1;2;3] [5;6]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1; 2; 3] [5; 6];;\n","type":"","out":""},{"in":"let _ = bigMul [5;6] [1;2;3]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [5; 6] [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = bigMul [1;0;0] [5]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1; 0; 0] [5];;\n","type":"","out":""},{"in":"let _ = bigMul [5;2;1] [0;0]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [5; 2; 1] [0; 0];;\n","type":"","out":""},{"in":"let _ = bigMul [1;2;3;3] [0;0;0]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1; 2; 3; 3] [0; 0; 0];;\n","type":"","out":""},{"in":"let _ = bigMul [5] [5]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [5] [5];;\n","type":"","out":""},{"in":"let key = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130 = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ ((Printexc.to_string e) ^ \"\\n\"));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n","type":"","out":""},{"in":"let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","min":"\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n","type":"","out":""},{"in":"let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n\nlet drop_paren s =\n  implode\n    (List.filter (fun c  -> not (List.mem c ['('; ' '; ')'])) (explode s));;\n","type":"","out":""},{"in":"let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","min":"\nlet eq_real p (r1,r2) = ((r1 -. r2) < p) || ((r2 -. r1) < p);;\n","type":"","out":""},{"in":"let wrap_curried_2 f (a,b) = f a b","min":"\nlet wrap_curried_2 f (a,b) = f a b;;\n","type":"","out":""}],"event":{"region":{"start":1571,"stop":9531},"type":"eval"},"cursor":1617,"time":1.398723195870403e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x =  fun b -> x (a b) in\n  let base = fun b -> b in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]\nlet _ = padZero [1;0;0;2] []\nlet _ = padZero [77] [9;9;4;5;6;7;8;9;0]\nlet _ = padZero [] []\nlet _ = padZero [] [9]\nlet _ = padZero [0;0] [1]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = List.append (List.combine (List.rev l1) (List.rev l2)) [(0,0)]\n    (*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [1;2;3] [];;\nlet _ = bigAdd [] [];;\nlet _ = bigAdd [] [3;4;5];;\nlet _ = bigAdd [1] [9;9;9];;\nlet _ = bigAdd [0;0;0] [9;9;9];;\nlet _ = bigAdd [0;0;0;0] [9;9;9];;\nlet _ = bigAdd [0] [];;\nlet _ = bigAdd [3] [];;\nlet _ = bigAdd [0] [0];;\n\n\n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> (match acc with\n              | [] -> []\n              | h::t -> if h = 0 then t else acc)\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 [1;2;3]\nlet _ = mulByDigit 1 [1;2;3]\nlet _ = mulByDigit 10 [1;2;3]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 5 [0;0;0]\nlet _ = mulByDigit 9 []\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 []\n\n\nlet bigMul l1 l2 = \n  let f a x =  match a with \n    | (_, z) -> (0, bigAdd z x) in\n  let base = (0, []) in\n  let args = \n    let rec digitProducts acc place l1 l2 = match l1 with\n      | [] -> acc\n      | h::t -> \n          let placeHolders = \n            (let rec buildZeros a places = \n              if places = 0 then a else buildZeros (0::a) (places-1) in \n               buildZeros [] place) in \n          let a = \n            (List.append (mulByDigit h l2) placeHolders) in\n            digitProducts (a::acc) (place+1) t l2 in\n      digitProducts [] 0 (List.rev l1) l2 in\n  let (_, res) = List.fold_left f base args in\n    res;;\n\n\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \nlet _ = bigMul [] []\nlet _ = bigMul [0] [0]\nlet _ = bigMul [] [0]\nlet _ = bigMul [0] []\nlet _ = bigMul [] [1;2;3]\nlet _ = bigMul [1;2;3] []\nlet _ = bigMul [0] [1;2;3]\nlet _ = bigMul [1;2;3] [0]\nlet _ = bigMul [1] [1;2;3]\nlet _ = bigMul [1;2;3] [1]\nlet _ = bigMul [1;2;3] [5]\nlet _ = bigMul [5] [1;2;3]\nlet _ = bigMul [1;2;3] [5;6]\nlet _ = bigMul [5;6] [1;2;3]\nlet _ = bigMul [1;0;0] [5]\nlet _ = bigMul [5;2;1] [0;0]\nlet _ = bigMul [1;2;3;3] [0;0;0]\nlet _ = bigMul [5] [5]\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let sqsum xs = \nlet f a x =  a + x*x in\nlet base = 0 in\nList.fold_left f base xs","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n","type":"","out":""},{"in":"let _ = sqsum []","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [];;\n","type":"","out":""},{"in":"let _ = sqsum [1;2;3;4]","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sqsum [(-1); (-2); (-3); (-4)]","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [(-1); (-2); (-3); (-4)];;\n","type":"","out":""},{"in":"let pipe fs = \nlet f a x =  fun b -> x (a b) in\nlet base = fun b -> b in\nList.fold_left f base fs","min":"\nlet pipe fs =\n  let f a x b = x (a b) in let base b = b in List.fold_left f base fs;;\n","type":"","out":""},{"in":"let _ = pipe [] 3","min":"\nlet pipe fs =\n  let f a x b = x (a b) in let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n","type":"","out":""},{"in":"let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3","min":"\nlet pipe fs =\n  let f a x b = x (a b) in let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n","type":"","out":""},{"in":"let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3","min":"\nlet pipe fs =\n  let f a x b = x (a b) in let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n","type":"","out":""},{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x  in\nlet base = h in\nlet l = t in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n","type":"","out":""},{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"---\" []","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"---\" [];;\n","type":"","out":""},{"in":"let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"\" [\"a\"; \"b\"; \"c\"; \"d\"; \"e\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"X\" [\"hello\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"X\" [\"hello\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"a\" []","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"a\" [];;\n","type":"","out":""},{"in":"let _ = sepConcat \"a\" [\"b\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"a\" [\"b\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"\" []","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"\" [];;\n","type":"","out":""},{"in":"let _ = sepConcat \"\" [\"bc\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"\" [\"bc\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"z\" [\"\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"z\" [\"\"];;\n","type":"","out":""},{"in":"let stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n","type":"","out":""},{"in":"let _ = stringOfList string_of_int [1;2;3;4;5;6]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n\nlet _ = stringOfList string_of_int [1; 2; 3; 4; 5; 6];;\n","type":"","out":""},{"in":"let _ = stringOfList (fun x -> x) [\"foo\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n\nlet _ = stringOfList (fun x  -> x) [\"foo\"];;\n","type":"","out":""},{"in":"let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n\nlet _ =\n  stringOfList (stringOfList string_of_int) [[1; 2; 3]; [4; 5]; [6]; []];;\n","type":"","out":""},{"in":"let rec clone x n = \nlet rec helper a x n =\nif n <= 0 then a\nelse \nlet a' = x::a in\nhelper a' x (n-1)\nin helper [] x n","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n","type":"","out":""},{"in":"let _ = clone 3 5","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet _ = clone 3 5;;\n","type":"","out":""},{"in":"let _ = clone \"foo\" 2","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet _ = clone \"foo\" 2;;\n","type":"","out":""},{"in":"let _ = clone clone (-3)","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet _ = clone clone (-3);;\n","type":"","out":""},{"in":"let padZero l1 l2 = \nlet length1 = List.length l1 in\nlet length2 = List.length l2 in\nif length1 > length2 then \n(l1, List.append (clone 0 (length1 - length2)) l2)\nelse if length2 > length1 then \n(List.append (clone 0 (length2 - length1)) l1, l2)\nelse (l1,l2)","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n","type":"","out":""},{"in":"let _ = padZero [9;9] [1;0;0;2]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet _ = padZero [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = padZero [1;0;0;2] [9;9]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet _ = padZero [1; 0; 0; 2] [9; 9];;\n","type":"","out":""},{"in":"let _ = padZero [1;0;0;2] []","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet _ = padZero [1; 0; 0; 2] [];;\n","type":"","out":""},{"in":"let _ = padZero [77] [9;9;4;5;6;7;8;9;0]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet _ = padZero [77] [9; 9; 4; 5; 6; 7; 8; 9; 0];;\n","type":"","out":""},{"in":"let _ = padZero [] []","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet _ = padZero [] [];;\n","type":"","out":""},{"in":"let _ = padZero [] [9]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet _ = padZero [] [9];;\n","type":"","out":""},{"in":"let _ = padZero [0;0] [1]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet _ = padZero [0; 0] [1];;\n","type":"","out":""},{"in":"let rec removeZero l = match l with\n| [] -> []\n| h::t -> if h = 0 then removeZero t else l","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;1;0;0;2]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet _ = removeZero [0; 0; 0; 1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = removeZero [9;9]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet _ = removeZero [9; 9];;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;0]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet _ = removeZero [0; 0; 0; 0];;\n","type":"","out":""},{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(x1, x2) -> \nmatch a with\n(o , z) -> if o + x1 + x2 > 9 \nthen (1, ((o + x1 + x2) mod 10)::z )\nelse (0, (o + x1 + x2)::z)\nin\nlet base = (0, []) in\nlet args = List.append (List.combine (List.rev l1) (List.rev l2)) [(0,0)]\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nin\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9] [1;0;0;2]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9;9;9] [9;9;9]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigAdd [1;2;3] []","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [1; 2; 3] [];;\n","type":"","out":""},{"in":"let _ = bigAdd [] []","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [] [];;\n","type":"","out":""},{"in":"let _ = bigAdd [] [3;4;5]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [] [3; 4; 5];;\n","type":"","out":""},{"in":"let _ = bigAdd [1] [9;9;9]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [1] [9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigAdd [0;0;0] [9;9;9]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [0; 0; 0] [9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigAdd [0;0;0;0] [9;9;9]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [0; 0; 0; 0] [9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigAdd [0] []","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [0] [];;\n","type":"","out":""},{"in":"let _ = bigAdd [3] []","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [3] [];;\n","type":"","out":""},{"in":"let _ = bigAdd [0] [0]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [0] [0];;\n","type":"","out":""},{"in":"let rec mulByDigit i l =\nlet rec helper acc carry i l = match l with\n| [] -> (match acc with\n| [] -> []\n| h::t -> if h = 0 then t else acc)\n| h::t -> let x = (h*i + carry) in \nlet n = if x > 9 then x mod 10 else x in\nlet carry' = if x > 9 then x/10 else 0 in\nlet acc' = n::acc in\nhelper acc' carry' i t\nin helper [] 0 i (List.rev (0::l))","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n","type":"","out":""},{"in":"let _ = mulByDigit 9 [9;9;9;9]","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let _ = mulByDigit 0 [1;2;3]","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 0 [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = mulByDigit 1 [1;2;3]","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 1 [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = mulByDigit 10 [1;2;3]","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 10 [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = mulByDigit 5 [0;0;0]","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 5 [0; 0; 0];;\n","type":"","out":""},{"in":"let _ = mulByDigit 9 []","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 9 [];;\n","type":"","out":""},{"in":"let _ = mulByDigit 0 []","min":"\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet _ = mulByDigit 0 [];;\n","type":"","out":""},{"in":"let bigMul l1 l2 = \nlet f a x =  match a with \n| (_, z) -> (0, bigAdd z x) in\nlet base = (0, []) in\nlet args = \nlet rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = \n(List.append (mulByDigit h l2) placeHolders) in\ndigitProducts (a::acc) (place+1) t l2 in\ndigitProducts [] 0 (List.rev l1) l2 in\nlet (_, res) = List.fold_left f base args in\nres","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n","type":"","out":""},{"in":"let _ = bigMul [9;9;9;9] [9;9;9;9]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9; 9] [9; 9; 9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigMul [] []","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [] [];;\n","type":"","out":""},{"in":"let _ = bigMul [0] [0]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [0] [0];;\n","type":"","out":""},{"in":"let _ = bigMul [] [0]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [] [0];;\n","type":"","out":""},{"in":"let _ = bigMul [0] []","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [0] [];;\n","type":"","out":""},{"in":"let _ = bigMul [] [1;2;3]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [] [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = bigMul [1;2;3] []","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1; 2; 3] [];;\n","type":"","out":""},{"in":"let _ = bigMul [0] [1;2;3]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [0] [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = bigMul [1;2;3] [0]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1; 2; 3] [0];;\n","type":"","out":""},{"in":"let _ = bigMul [1] [1;2;3]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1] [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = bigMul [1;2;3] [1]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1; 2; 3] [1];;\n","type":"","out":""},{"in":"let _ = bigMul [1;2;3] [5]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1; 2; 3] [5];;\n","type":"","out":""},{"in":"let _ = bigMul [5] [1;2;3]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [5] [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = bigMul [1;2;3] [5;6]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1; 2; 3] [5; 6];;\n","type":"","out":""},{"in":"let _ = bigMul [5;6] [1;2;3]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [5; 6] [1; 2; 3];;\n","type":"","out":""},{"in":"let _ = bigMul [1;0;0] [5]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1; 0; 0] [5];;\n","type":"","out":""},{"in":"let _ = bigMul [5;2;1] [0;0]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [5; 2; 1] [0; 0];;\n","type":"","out":""},{"in":"let _ = bigMul [1;2;3;3] [0;0;0]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1; 2; 3; 3] [0; 0; 0];;\n","type":"","out":""},{"in":"let _ = bigMul [5] [5]","min":"\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      List.append (List.combine (List.rev l1) (List.rev l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [5] [5];;\n","type":"","out":""},{"in":"let key = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130 = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ ((Printexc.to_string e) ^ \"\\n\"));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n","type":"","out":""},{"in":"let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","min":"\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n","type":"","out":""},{"in":"let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n\nlet drop_paren s =\n  implode\n    (List.filter (fun c  -> not (List.mem c ['('; ' '; ')'])) (explode s));;\n","type":"","out":""},{"in":"let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","min":"\nlet eq_real p (r1,r2) = ((r1 -. r2) < p) || ((r2 -. r1) < p);;\n","type":"","out":""},{"in":"let wrap_curried_2 f (a,b) = f a b","min":"\nlet wrap_curried_2 f (a,b) = f a b;;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":9531},"type":"eval"},"cursor":157,"time":1.398979044249796e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x =  a + x*x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x =  fun b -> x (a b) in\n  let base = fun b -> b in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x  in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\nlet _ = sepConcat \"a\" []\nlet _ = sepConcat \"a\" [\"b\"]\nlet _ = sepConcat \"\" []\nlet _ = sepConcat \"\" [\"bc\"]\nlet _ = sepConcat \"z\" [\"\"]\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper a x n =\n    if n <= 0 then a\n    else \n      let a' = x::a in\n        helper a' x (n-1)\n  in helper [] x n;;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = \n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n    if length1 > length2 then \n      (l1, List.append (clone 0 (length1 - length2)) l2)\n    else if length2 > length1 then \n      (List.append (clone 0 (length2 - length1)) l1, l2)\n    else (l1,l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]\nlet _ = padZero [1;0;0;2] []\nlet _ = padZero [77] [9;9;4;5;6;7;8;9;0]\nlet _ = padZero [] []\nlet _ = padZero [] [9]\nlet _ = padZero [0;0] [1]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n        (x1, x2) -> \n          match a with\n              (o , z) -> if o + x1 + x2 > 9 \n                then (1, ((o + x1 + x2) mod 10)::z )\n                else (0, (o + x1 + x2)::z)\n    in\n    let base = (0, []) in\n    let args = List.append (List.combine (List.rev l1) (List.rev l2)) [(0,0)]\n    (*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [1;2;3] [];;\nlet _ = bigAdd [] [];;\nlet _ = bigAdd [] [3;4;5];;\nlet _ = bigAdd [1] [9;9;9];;\nlet _ = bigAdd [0;0;0] [9;9;9];;\nlet _ = bigAdd [0;0;0;0] [9;9;9];;\nlet _ = bigAdd [0] [];;\nlet _ = bigAdd [3] [];;\nlet _ = bigAdd [0] [0];;\n\n\n\n\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l = match l with\n    | [] -> (match acc with\n              | [] -> []\n              | h::t -> if h = 0 then t else acc)\n    | h::t -> let x = (h*i + carry) in \n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x/10 else 0 in\n        let acc' = n::acc in\n          helper acc' carry' i t\n  in helper [] 0 i (List.rev (0::l))\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 [1;2;3]\nlet _ = mulByDigit 1 [1;2;3]\nlet _ = mulByDigit 10 [1;2;3]\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 5 [0;0;0]\nlet _ = mulByDigit 9 []\n(*XXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 0 []\n\n\nlet bigMul l1 l2 = \n  let f a x =  match a with \n    | (_, z) -> (0, bigAdd z x) in\n  let base = (0, []) in\n  let args = \n    let rec digitProducts acc place l1 l2 = match l1 with\n      | [] -> acc\n      | h::t -> \n          let placeHolders = \n            (let rec buildZeros a places = \n              if places = 0 then a else buildZeros (0::a) (places-1) in \n               buildZeros [] place) in \n          let a = \n            (List.append (mulByDigit h l2) placeHolders) in\n            digitProducts (a::acc) (place+1) t l2 in\n      digitProducts [] 0 (List.rev l1) l2 in\n  let (_, res) = List.fold_left f base args in\n    res;;\n\n\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \nlet _ = bigMul [] []\nlet _ = bigMul [0] [0]\nlet _ = bigMul [] [0]\nlet _ = bigMul [0] []\nlet _ = bigMul [] [1;2;3]\nlet _ = bigMul [1;2;3] []\nlet _ = bigMul [0] [1;2;3]\nlet _ = bigMul [1;2;3] [0]\nlet _ = bigMul [1] [1;2;3]\nlet _ = bigMul [1;2;3] [1]\nlet _ = bigMul [1;2;3] [5]\nlet _ = bigMul [5] [1;2;3]\nlet _ = bigMul [1;2;3] [5;6]\nlet _ = bigMul [5;6] [1;2;3]\nlet _ = bigMul [1;0;0] [5]\nlet _ = bigMul [5;2;1] [0;0]\nlet _ = bigMul [1;2;3;3] [0;0;0]\nlet _ = bigMul [5] [5]\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
