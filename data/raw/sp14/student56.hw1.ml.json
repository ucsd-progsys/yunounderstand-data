{"ocaml":[],"event":{"region":{"start":0,"stop":0},"type":"eval"},"cursor":0,"time":1.396571286595699e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\nlet rec unfoldr f x = match f x with\n  | Some (e, r) -> List.append (unfoldr f e) [r]\n  | None -> []\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList = List.fold_left (+) 0\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n =\n  let takeOnesPlace x = match x with\n      0 -> None\n    | x -> Some (x / 10, x mod 10)\n  in match unfoldr takeOnesPlace n with \n      [] -> [0]\n    | l -> l\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec additivePersistence n =\n  if n < 10 then 0 else 1 + additivePersistence(sumList(digits n))\n\nlet _ = additivePersistence 9876\n\nlet rec digitalRoot n = \n  if n < 10 then n else digitalRoot(sumList(digits n))\n\nlet _ = digitalRoot 9876\n\nlet listReverse = List.rev\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome str =\n  let join s c = (Char.escaped c) ^ s\n  in List.fold_left join \"\" (explode str) = str\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec unfoldr f x = match f x with\n| Some (e, r) -> List.append (unfoldr f e) [r]\n| None -> []","min":"\nlet rec unfoldr f x =\n  match f x with | Some (e,r) -> List.append (unfoldr f e) [r] | None  -> [];;\n","type":"","out":""},{"in":"let rec sumList = List.fold_left (+) 0","min":"\nlet rec sumList = List.fold_left (+) 0;;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList = List.fold_left (+) 0;;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList = List.fold_left (+) 0;;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList = List.fold_left (+) 0;;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec digitsOfInt n =\nlet takeOnesPlace x = match x with\n0 -> None\n| x -> Some (x / 10, x mod 10)\nin match unfoldr takeOnesPlace n with \n[] -> [0]\n| l -> l","min":"\nlet rec unfoldr f x =\n  match f x with | Some (e,r) -> List.append (unfoldr f e) [r] | None  -> [];;\n\nlet rec digitsOfInt n =\n  let takeOnesPlace x =\n    match x with | 0 -> None | x -> Some ((x / 10), (x mod 10)) in\n  match unfoldr takeOnesPlace n with | [] -> [0] | l -> l;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec unfoldr f x =\n  match f x with | Some (e,r) -> List.append (unfoldr f e) [r] | None  -> [];;\n\nlet rec digitsOfInt n =\n  let takeOnesPlace x =\n    match x with | 0 -> None | x -> Some ((x / 10), (x mod 10)) in\n  match unfoldr takeOnesPlace n with | [] -> [0] | l -> l;;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec unfoldr f x =\n  match f x with | Some (e,r) -> List.append (unfoldr f e) [r] | None  -> [];;\n\nlet rec digitsOfInt n =\n  let takeOnesPlace x =\n    match x with | 0 -> None | x -> Some ((x / 10), (x mod 10)) in\n  match unfoldr takeOnesPlace n with | [] -> [0] | l -> l;;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec unfoldr f x =\n  match f x with | Some (e,r) -> List.append (unfoldr f e) [r] | None  -> [];;\n\nlet rec digitsOfInt n =\n  let takeOnesPlace x =\n    match x with | 0 -> None | x -> Some ((x / 10), (x mod 10)) in\n  match unfoldr takeOnesPlace n with | [] -> [0] | l -> l;;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec additivePersistence n =\nif n < 10 then 0 else 1 + additivePersistence(sumList(digits n))","min":"\nlet rec unfoldr f x =\n  match f x with | Some (e,r) -> List.append (unfoldr f e) [r] | None  -> [];;\n\nlet rec digitsOfInt n =\n  let takeOnesPlace x =\n    match x with | 0 -> None | x -> Some ((x / 10), (x mod 10)) in\n  match unfoldr takeOnesPlace n with | [] -> [0] | l -> l;;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList = List.fold_left (+) 0;;\n\nlet rec additivePersistence n =\n  if n < 10 then 0 else 1 + (additivePersistence (sumList (digits n)));;\n","type":"","out":""},{"in":"let _ = additivePersistence 9876","min":"\nlet rec unfoldr f x =\n  match f x with | Some (e,r) -> List.append (unfoldr f e) [r] | None  -> [];;\n\nlet rec digitsOfInt n =\n  let takeOnesPlace x =\n    match x with | 0 -> None | x -> Some ((x / 10), (x mod 10)) in\n  match unfoldr takeOnesPlace n with | [] -> [0] | l -> l;;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList = List.fold_left (+) 0;;\n\nlet rec additivePersistence n =\n  if n < 10 then 0 else 1 + (additivePersistence (sumList (digits n)));;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""},{"in":"let rec digitalRoot n = \nif n < 10 then n else digitalRoot(sumList(digits n))","min":"\nlet rec unfoldr f x =\n  match f x with | Some (e,r) -> List.append (unfoldr f e) [r] | None  -> [];;\n\nlet rec digitsOfInt n =\n  let takeOnesPlace x =\n    match x with | 0 -> None | x -> Some ((x / 10), (x mod 10)) in\n  match unfoldr takeOnesPlace n with | [] -> [0] | l -> l;;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList = List.fold_left (+) 0;;\n\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digits n));;\n","type":"","out":""},{"in":"let _ = digitalRoot 9876","min":"\nlet rec unfoldr f x =\n  match f x with | Some (e,r) -> List.append (unfoldr f e) [r] | None  -> [];;\n\nlet rec digitsOfInt n =\n  let takeOnesPlace x =\n    match x with | 0 -> None | x -> Some ((x / 10), (x mod 10)) in\n  match unfoldr takeOnesPlace n with | [] -> [0] | l -> l;;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList = List.fold_left (+) 0;;\n\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digits n));;\n\nlet _ = digitalRoot 9876;;\n","type":"","out":""},{"in":"let listReverse = List.rev","min":"\nlet listReverse = List.rev;;\n","type":"","out":""},{"in":"let _ = listReverse [1; 2; 3; 4]","min":"\nlet listReverse = List.rev;;\n\nlet _ = listReverse [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]","min":"\nlet listReverse = List.rev;;\n\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n","type":"","out":""},{"in":"let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n","type":"","out":""},{"in":"let palindrome str =\nlet join s c = (Char.escaped c) ^ s\nin List.fold_left join \"\" (explode str) = str","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet palindrome str =\n  let join s c = (Char.escaped c) ^ s in\n  (List.fold_left join \"\" (explode str)) = str;;\n","type":"","out":""},{"in":"let _ = palindrome \"malayalam\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet palindrome str =\n  let join s c = (Char.escaped c) ^ s in\n  (List.fold_left join \"\" (explode str)) = str;;\n\nlet _ = palindrome \"malayalam\";;\n","type":"","out":""},{"in":"let _ = palindrome \"myxomatosis\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet palindrome str =\n  let join s c = (Char.escaped c) ^ s in\n  (List.fold_left join \"\" (explode str)) = str;;\n\nlet _ = palindrome \"myxomatosis\";;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key        = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130  = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":5251},"type":"eval"},"cursor":0,"time":1.39657129261307e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\nlet rec unfoldr f x = match f x with\n  | Some (e, r) -> List.append (unfoldr f e) [r]\n  | None -> []\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList = List.fold_left (+) 0\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n =\n  let takeOnesPlace x = match x with\n      0 -> None\n    | x -> Some (x / 10, x mod 10)\n  in match unfoldr takeOnesPlace n with \n      [] -> [0]\n    | l -> l\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec additivePersistence n =\n  if n < 10 then 0 else 1 + additivePersistence(sumList(digits n))\n\nlet _ = additivePersistence 9876\n\nlet rec digitalRoot n = \n  if n < 10 then n else digitalRoot(sumList(digits n))\n\nlet _ = digitalRoot 9876\n\nlet listReverse = List.rev\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome str =\n  let join s c = (Char.escaped c) ^ s\n  in List.fold_left join \"\" (explode str) = str\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":0,"stop":0},"type":"eval"},"cursor":0,"time":1.396880940599427e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet unfoldr f x = \n  let rec unfold f x lst = \n    match f x with\n        Some (e, res) -> unfold f (e) (res :: lst)\n      | None -> lst\n  in unfold f x []\n\nlet rec foldl f s l = match l with\n    [] -> s\n  | head :: tail -> foldl f (f head s) tail\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList = foldl (+) 0\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n =\n  let takeOnesPlace x = match x with\n      neg when x <= 0 -> None\n    | x               -> Some (x / 10, x mod 10)\n  in unfoldr takeOnesPlace n\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec additivePersistence n =\n  if n < 10 then 0 else 1 + additivePersistence(n |> digits |> sumList)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if abs n < 10 then n else digitalRoot (n |> digits |> sumList)\n\nlet _ = digitalRoot 9876\n\n\nlet listReverse l = \n  let rec lr ver rev = match ver with\n      [] -> rev\n    | head :: tail -> lr tail (head :: rev)\n  in lr l []\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet implode carr = \n  let join c s = s ^ (Char.escaped c) in\n    foldl join \"\" carr\n\nlet palindrome str =\n  str |> explode |> listReverse |> implode = str\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":0,"stop":0},"type":"eval"},"cursor":0,"time":1.396880940793206e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet unfoldr f x = \n  let rec unfold f x lst = \n    match f x with\n        Some (e, res) -> unfold f (e) (res :: lst)\n      | None -> lst\n  in unfold f x []\n\nlet rec foldl f s l = match l with\n    [] -> s\n  | head :: tail -> foldl f (f head s) tail\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList = foldl (+) 0\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n =\n  let takeOnesPlace x = match x with\n      neg when x <= 0 -> None\n    | x               -> Some (x / 10, x mod 10)\n  in unfoldr takeOnesPlace n\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec additivePersistence n =\n  if n < 10 then 0 else 1 + additivePersistence(n |> digits |> sumList)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if abs n < 10 then n else digitalRoot (n |> digits |> sumList)\n\nlet _ = digitalRoot 9876\n\n\nlet listReverse l = \n  let rec lr ver rev = match ver with\n      [] -> rev\n    | head :: tail -> lr tail (head :: rev)\n  in lr l []\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet implode carr = \n  let join c s = s ^ (Char.escaped c) in\n    foldl join \"\" carr\n\nlet palindrome str =\n  str |> explode |> listReverse |> implode = str\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let unfoldr f x = \nlet rec unfold f x lst = \nmatch f x with\nSome (e, res) -> unfold f (e) (res :: lst)\n| None -> lst\nin unfold f x []","min":"\nlet unfoldr f x =\n  let rec unfold f x lst =\n    match f x with | Some (e,res) -> unfold f e (res :: lst) | None  -> lst in\n  unfold f x [];;\n","type":"","out":""},{"in":"let rec foldl f s l = match l with\n[] -> s\n| head :: tail -> foldl f (f head s) tail","min":"\nlet rec foldl f s l =\n  match l with | [] -> s | head::tail -> foldl f (f head s) tail;;\n","type":"","out":""},{"in":"let rec sumList = foldl (+) 0","min":"\nlet rec foldl f s l =\n  match l with | [] -> s | head::tail -> foldl f (f head s) tail;;\n\nlet rec sumList = foldl (+) 0;;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec foldl f s l =\n  match l with | [] -> s | head::tail -> foldl f (f head s) tail;;\n\nlet rec sumList = foldl (+) 0;;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec foldl f s l =\n  match l with | [] -> s | head::tail -> foldl f (f head s) tail;;\n\nlet rec sumList = foldl (+) 0;;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec foldl f s l =\n  match l with | [] -> s | head::tail -> foldl f (f head s) tail;;\n\nlet rec sumList = foldl (+) 0;;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec digitsOfInt n =\nlet takeOnesPlace x = match x with\nneg when x <= 0 -> None\n| x               -> Some (x / 10, x mod 10)\nin unfoldr takeOnesPlace n","min":"\nlet unfoldr f x =\n  let rec unfold f x lst =\n    match f x with | Some (e,res) -> unfold f e (res :: lst) | None  -> lst in\n  unfold f x [];;\n\nlet rec digitsOfInt n =\n  let takeOnesPlace x =\n    match x with | neg when x <= 0 -> None | x -> Some ((x / 10), (x mod 10)) in\n  unfoldr takeOnesPlace n;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet unfoldr f x =\n  let rec unfold f x lst =\n    match f x with | Some (e,res) -> unfold f e (res :: lst) | None  -> lst in\n  unfold f x [];;\n\nlet rec digitsOfInt n =\n  let takeOnesPlace x =\n    match x with | neg when x <= 0 -> None | x -> Some ((x / 10), (x mod 10)) in\n  unfoldr takeOnesPlace n;;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet unfoldr f x =\n  let rec unfold f x lst =\n    match f x with | Some (e,res) -> unfold f e (res :: lst) | None  -> lst in\n  unfold f x [];;\n\nlet rec digitsOfInt n =\n  let takeOnesPlace x =\n    match x with | neg when x <= 0 -> None | x -> Some ((x / 10), (x mod 10)) in\n  unfoldr takeOnesPlace n;;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet unfoldr f x =\n  let rec unfold f x lst =\n    match f x with | Some (e,res) -> unfold f e (res :: lst) | None  -> lst in\n  unfold f x [];;\n\nlet rec digitsOfInt n =\n  let takeOnesPlace x =\n    match x with | neg when x <= 0 -> None | x -> Some ((x / 10), (x mod 10)) in\n  unfoldr takeOnesPlace n;;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec additivePersistence n =\nif n < 10 then 0 else 1 + additivePersistence(n |> digits |> sumList)","min":"\nlet rec foldl f s l =\n  match l with | [] -> s | head::tail -> foldl f (f head s) tail;;\n\nlet unfoldr f x =\n  let rec unfold f x lst =\n    match f x with | Some (e,res) -> unfold f e (res :: lst) | None  -> lst in\n  unfold f x [];;\n\nlet rec digitsOfInt n =\n  let takeOnesPlace x =\n    match x with | neg when x <= 0 -> None | x -> Some ((x / 10), (x mod 10)) in\n  unfoldr takeOnesPlace n;;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList = foldl (+) 0;;\n\nlet rec additivePersistence n =\n  if n < 10 then 0 else 1 + (additivePersistence ((n |> digits) |> sumList));;\n","type":"","out":""},{"in":"let rec digitalRoot n = \nif abs n < 10 then n else digitalRoot (n |> digits |> sumList)","min":"\nlet rec foldl f s l =\n  match l with | [] -> s | head::tail -> foldl f (f head s) tail;;\n\nlet unfoldr f x =\n  let rec unfold f x lst =\n    match f x with | Some (e,res) -> unfold f e (res :: lst) | None  -> lst in\n  unfold f x [];;\n\nlet rec digitsOfInt n =\n  let takeOnesPlace x =\n    match x with | neg when x <= 0 -> None | x -> Some ((x / 10), (x mod 10)) in\n  unfoldr takeOnesPlace n;;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList = foldl (+) 0;;\n\nlet rec digitalRoot n =\n  if (abs n) < 10 then n else digitalRoot ((n |> digits) |> sumList);;\n","type":"","out":""},{"in":"let _ = digitalRoot 9876","min":"\nlet rec foldl f s l =\n  match l with | [] -> s | head::tail -> foldl f (f head s) tail;;\n\nlet unfoldr f x =\n  let rec unfold f x lst =\n    match f x with | Some (e,res) -> unfold f e (res :: lst) | None  -> lst in\n  unfold f x [];;\n\nlet rec digitsOfInt n =\n  let takeOnesPlace x =\n    match x with | neg when x <= 0 -> None | x -> Some ((x / 10), (x mod 10)) in\n  unfoldr takeOnesPlace n;;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList = foldl (+) 0;;\n\nlet rec digitalRoot n =\n  if (abs n) < 10 then n else digitalRoot ((n |> digits) |> sumList);;\n\nlet _ = digitalRoot 9876;;\n","type":"","out":""},{"in":"let listReverse l = \nlet rec lr ver rev = match ver with\n[] -> rev\n| head :: tail -> lr tail (head :: rev)\nin lr l []","min":"\nlet listReverse l =\n  let rec lr ver rev =\n    match ver with | [] -> rev | head::tail -> lr tail (head :: rev) in\n  lr l [];;\n","type":"","out":""},{"in":"let _ = listReverse [1; 2; 3; 4]","min":"\nlet listReverse l =\n  let rec lr ver rev =\n    match ver with | [] -> rev | head::tail -> lr tail (head :: rev) in\n  lr l [];;\n\nlet _ = listReverse [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]","min":"\nlet listReverse l =\n  let rec lr ver rev =\n    match ver with | [] -> rev | head::tail -> lr tail (head :: rev) in\n  lr l [];;\n\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n","type":"","out":""},{"in":"let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n","type":"","out":""},{"in":"let implode carr = \nlet join c s = s ^ (Char.escaped c) in\nfoldl join \"\" carr","min":"\nlet rec foldl f s l =\n  match l with | [] -> s | head::tail -> foldl f (f head s) tail;;\n\nlet implode carr = let join c s = s ^ (Char.escaped c) in foldl join \"\" carr;;\n","type":"","out":""},{"in":"let palindrome str =\nstr |> explode |> listReverse |> implode = str","min":"\nlet rec foldl f s l =\n  match l with | [] -> s | head::tail -> foldl f (f head s) tail;;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet implode carr = let join c s = s ^ (Char.escaped c) in foldl join \"\" carr;;\n\nlet listReverse l =\n  let rec lr ver rev =\n    match ver with | [] -> rev | head::tail -> lr tail (head :: rev) in\n  lr l [];;\n\nlet palindrome str = (((str |> explode) |> listReverse) |> implode) = str;;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key        = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130  = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":5909},"type":"eval"},"cursor":0,"time":1.396880952022671e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet unfoldr f x = \n  let rec unfold f x lst = \n    match f x with\n        Some (e, res) -> unfold f (e) (res :: lst)\n      | None -> lst\n  in unfold f x []\n\nlet rec foldl f s l = match l with\n    [] -> s\n  | head :: tail -> foldl f (f head s) tail\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList = foldl (+) 0\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n =\n  let takeOnesPlace x = match x with\n      neg when x <= 0 -> None\n    | x               -> Some (x / 10, x mod 10)\n  in unfoldr takeOnesPlace n\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec additivePersistence n =\n  if n < 10 then 0 else 1 + additivePersistence(n |> digits |> sumList)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if abs n < 10 then n else digitalRoot (n |> digits |> sumList)\n\nlet _ = digitalRoot 9876\n\n\nlet listReverse l = \n  let rec lr ver rev = match ver with\n      [] -> rev\n    | head :: tail -> lr tail (head :: rev)\n  in lr l []\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet implode carr = \n  let join c s = s ^ (Char.escaped c) in\n    foldl join \"\" carr\n\nlet palindrome str =\n  str |> explode |> listReverse |> implode = str\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let unfoldr f x = \nlet rec unfold f x lst = \nmatch f x with\nSome (e, res) -> unfold f (e) (res :: lst)\n| None -> lst\nin unfold f x []","min":"\nlet unfoldr f x =\n  let rec unfold f x lst =\n    match f x with | Some (e,res) -> unfold f e (res :: lst) | None  -> lst in\n  unfold f x [];;\n","type":"","out":""},{"in":"let rec foldl f s l = match l with\n[] -> s\n| head :: tail -> foldl f (f head s) tail","min":"\nlet rec foldl f s l =\n  match l with | [] -> s | head::tail -> foldl f (f head s) tail;;\n","type":"","out":""},{"in":"let rec sumList = foldl (+) 0","min":"\nlet rec foldl f s l =\n  match l with | [] -> s | head::tail -> foldl f (f head s) tail;;\n\nlet rec sumList = foldl (+) 0;;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec foldl f s l =\n  match l with | [] -> s | head::tail -> foldl f (f head s) tail;;\n\nlet rec sumList = foldl (+) 0;;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec foldl f s l =\n  match l with | [] -> s | head::tail -> foldl f (f head s) tail;;\n\nlet rec sumList = foldl (+) 0;;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec foldl f s l =\n  match l with | [] -> s | head::tail -> foldl f (f head s) tail;;\n\nlet rec sumList = foldl (+) 0;;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec digitsOfInt n =\nlet takeOnesPlace x = match x with\nneg when x <= 0 -> None\n| x               -> Some (x / 10, x mod 10)\nin unfoldr takeOnesPlace n","min":"\nlet unfoldr f x =\n  let rec unfold f x lst =\n    match f x with | Some (e,res) -> unfold f e (res :: lst) | None  -> lst in\n  unfold f x [];;\n\nlet rec digitsOfInt n =\n  let takeOnesPlace x =\n    match x with | neg when x <= 0 -> None | x -> Some ((x / 10), (x mod 10)) in\n  unfoldr takeOnesPlace n;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet unfoldr f x =\n  let rec unfold f x lst =\n    match f x with | Some (e,res) -> unfold f e (res :: lst) | None  -> lst in\n  unfold f x [];;\n\nlet rec digitsOfInt n =\n  let takeOnesPlace x =\n    match x with | neg when x <= 0 -> None | x -> Some ((x / 10), (x mod 10)) in\n  unfoldr takeOnesPlace n;;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet unfoldr f x =\n  let rec unfold f x lst =\n    match f x with | Some (e,res) -> unfold f e (res :: lst) | None  -> lst in\n  unfold f x [];;\n\nlet rec digitsOfInt n =\n  let takeOnesPlace x =\n    match x with | neg when x <= 0 -> None | x -> Some ((x / 10), (x mod 10)) in\n  unfoldr takeOnesPlace n;;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet unfoldr f x =\n  let rec unfold f x lst =\n    match f x with | Some (e,res) -> unfold f e (res :: lst) | None  -> lst in\n  unfold f x [];;\n\nlet rec digitsOfInt n =\n  let takeOnesPlace x =\n    match x with | neg when x <= 0 -> None | x -> Some ((x / 10), (x mod 10)) in\n  unfoldr takeOnesPlace n;;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec additivePersistence n =\nif n < 10 then 0 else 1 + additivePersistence(n |> digits |> sumList)","min":"\nlet rec foldl f s l =\n  match l with | [] -> s | head::tail -> foldl f (f head s) tail;;\n\nlet unfoldr f x =\n  let rec unfold f x lst =\n    match f x with | Some (e,res) -> unfold f e (res :: lst) | None  -> lst in\n  unfold f x [];;\n\nlet rec digitsOfInt n =\n  let takeOnesPlace x =\n    match x with | neg when x <= 0 -> None | x -> Some ((x / 10), (x mod 10)) in\n  unfoldr takeOnesPlace n;;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList = foldl (+) 0;;\n\nlet rec additivePersistence n =\n  if n < 10 then 0 else 1 + (additivePersistence ((n |> digits) |> sumList));;\n","type":"","out":""},{"in":"let _ = additivePersistence 9876","min":"\nlet rec foldl f s l =\n  match l with | [] -> s | head::tail -> foldl f (f head s) tail;;\n\nlet unfoldr f x =\n  let rec unfold f x lst =\n    match f x with | Some (e,res) -> unfold f e (res :: lst) | None  -> lst in\n  unfold f x [];;\n\nlet rec digitsOfInt n =\n  let takeOnesPlace x =\n    match x with | neg when x <= 0 -> None | x -> Some ((x / 10), (x mod 10)) in\n  unfoldr takeOnesPlace n;;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList = foldl (+) 0;;\n\nlet rec additivePersistence n =\n  if n < 10 then 0 else 1 + (additivePersistence ((n |> digits) |> sumList));;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""},{"in":"let rec digitalRoot n = \nif n < 10 then n else digitalRoot (n |> digits |> sumList)","min":"\nlet rec foldl f s l =\n  match l with | [] -> s | head::tail -> foldl f (f head s) tail;;\n\nlet unfoldr f x =\n  let rec unfold f x lst =\n    match f x with | Some (e,res) -> unfold f e (res :: lst) | None  -> lst in\n  unfold f x [];;\n\nlet rec digitsOfInt n =\n  let takeOnesPlace x =\n    match x with | neg when x <= 0 -> None | x -> Some ((x / 10), (x mod 10)) in\n  unfoldr takeOnesPlace n;;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList = foldl (+) 0;;\n\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot ((n |> digits) |> sumList);;\n","type":"","out":""},{"in":"let _ = digitalRoot 9876","min":"\nlet rec foldl f s l =\n  match l with | [] -> s | head::tail -> foldl f (f head s) tail;;\n\nlet unfoldr f x =\n  let rec unfold f x lst =\n    match f x with | Some (e,res) -> unfold f e (res :: lst) | None  -> lst in\n  unfold f x [];;\n\nlet rec digitsOfInt n =\n  let takeOnesPlace x =\n    match x with | neg when x <= 0 -> None | x -> Some ((x / 10), (x mod 10)) in\n  unfoldr takeOnesPlace n;;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList = foldl (+) 0;;\n\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot ((n |> digits) |> sumList);;\n\nlet _ = digitalRoot 9876;;\n","type":"","out":""},{"in":"let listReverse l = \nlet rec lr ver rev = match ver with\n[] -> rev\n| head :: tail -> lr tail (head :: rev)\nin lr l []","min":"\nlet listReverse l =\n  let rec lr ver rev =\n    match ver with | [] -> rev | head::tail -> lr tail (head :: rev) in\n  lr l [];;\n","type":"","out":""},{"in":"let _ = listReverse [1; 2; 3; 4]","min":"\nlet listReverse l =\n  let rec lr ver rev =\n    match ver with | [] -> rev | head::tail -> lr tail (head :: rev) in\n  lr l [];;\n\nlet _ = listReverse [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]","min":"\nlet listReverse l =\n  let rec lr ver rev =\n    match ver with | [] -> rev | head::tail -> lr tail (head :: rev) in\n  lr l [];;\n\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n","type":"","out":""},{"in":"let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n","type":"","out":""},{"in":"let implode carr = \nlet join c s = s ^ (Char.escaped c) in\nfoldl join \"\" carr","min":"\nlet rec foldl f s l =\n  match l with | [] -> s | head::tail -> foldl f (f head s) tail;;\n\nlet implode carr = let join c s = s ^ (Char.escaped c) in foldl join \"\" carr;;\n","type":"","out":""},{"in":"let palindrome str =\nstr |> explode |> listReverse |> implode = str","min":"\nlet rec foldl f s l =\n  match l with | [] -> s | head::tail -> foldl f (f head s) tail;;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet implode carr = let join c s = s ^ (Char.escaped c) in foldl join \"\" carr;;\n\nlet listReverse l =\n  let rec lr ver rev =\n    match ver with | [] -> rev | head::tail -> lr tail (head :: rev) in\n  lr l [];;\n\nlet palindrome str = (((str |> explode) |> listReverse) |> implode) = str;;\n","type":"","out":""},{"in":"let _ = palindrome \"malayalam\"","min":"\nlet rec foldl f s l =\n  match l with | [] -> s | head::tail -> foldl f (f head s) tail;;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet implode carr = let join c s = s ^ (Char.escaped c) in foldl join \"\" carr;;\n\nlet listReverse l =\n  let rec lr ver rev =\n    match ver with | [] -> rev | head::tail -> lr tail (head :: rev) in\n  lr l [];;\n\nlet palindrome str = (((str |> explode) |> listReverse) |> implode) = str;;\n\nlet _ = palindrome \"malayalam\";;\n","type":"","out":""},{"in":"let _ = palindrome \"myxomatosis\"","min":"\nlet rec foldl f s l =\n  match l with | [] -> s | head::tail -> foldl f (f head s) tail;;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet implode carr = let join c s = s ^ (Char.escaped c) in foldl join \"\" carr;;\n\nlet listReverse l =\n  let rec lr ver rev =\n    match ver with | [] -> rev | head::tail -> lr tail (head :: rev) in\n  lr l [];;\n\nlet palindrome str = (((str |> explode) |> listReverse) |> implode) = str;;\n\nlet _ = palindrome \"myxomatosis\";;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key        = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130  = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":5763},"type":"eval"},"cursor":379,"time":1.396881038447958e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet unfoldr f x = \n  let rec unfold f x lst = \n    match f x with\n        Some (e, res) -> unfold f (e) (res :: lst)\n      | None -> lst\n  in unfold f x []\n\nlet rec foldl f s l = match l with\n    [] -> s\n  | head :: tail -> foldl f (f head s) tail\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList = foldl (+) 0\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n =\n  let takeOnesPlace x = match x with\n      neg when x <= 0 -> None\n    | x               -> Some (x / 10, x mod 10)\n  in unfoldr takeOnesPlace n\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec additivePersistence n =\n  if n < 10 then 0 else 1 + additivePersistence(n |> digits |> sumList)\n\nlet _ = additivePersistence 9876\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if n < 10 then n else digitalRoot (n |> digits |> sumList)\n\nlet _ = digitalRoot 9876\n\n\nlet listReverse l = \n  let rec lr ver rev = match ver with\n      [] -> rev\n    | head :: tail -> lr tail (head :: rev)\n  in lr l []\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet implode carr = \n  let join c s = s ^ (Char.escaped c) in\n    foldl join \"\" carr\n\nlet palindrome str =\n  str |> explode |> listReverse |> implode = str\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let unfoldr f x = \nlet rec unfold f x lst = \nmatch f x with\nSome (e, res) -> unfold f e (res :: lst)\n| None -> lst\nin unfold f x []","min":"\nlet unfoldr f x =\n  let rec unfold f x lst =\n    match f x with | Some (e,res) -> unfold f e (res :: lst) | None  -> lst in\n  unfold f x [];;\n","type":"","out":""},{"in":"let rec foldl f s l = match l with\n[] -> s\n| head :: tail -> foldl f (f head s) tail","min":"\nlet rec foldl f s l =\n  match l with | [] -> s | head::tail -> foldl f (f head s) tail;;\n","type":"","out":""},{"in":"let rec sumList = foldl (+) 0","min":"\nlet rec foldl f s l =\n  match l with | [] -> s | head::tail -> foldl f (f head s) tail;;\n\nlet rec sumList = foldl (+) 0;;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec foldl f s l =\n  match l with | [] -> s | head::tail -> foldl f (f head s) tail;;\n\nlet rec sumList = foldl (+) 0;;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec foldl f s l =\n  match l with | [] -> s | head::tail -> foldl f (f head s) tail;;\n\nlet rec sumList = foldl (+) 0;;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec foldl f s l =\n  match l with | [] -> s | head::tail -> foldl f (f head s) tail;;\n\nlet rec sumList = foldl (+) 0;;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec digitsOfInt n =\nlet takeOnesPlace x = match x with\nneg when x <= 0 -> None\n| x               -> Some (x / 10, x mod 10)\nin unfoldr takeOnesPlace n","min":"\nlet unfoldr f x =\n  let rec unfold f x lst =\n    match f x with | Some (e,res) -> unfold f e (res :: lst) | None  -> lst in\n  unfold f x [];;\n\nlet rec digitsOfInt n =\n  let takeOnesPlace x =\n    match x with | neg when x <= 0 -> None | x -> Some ((x / 10), (x mod 10)) in\n  unfoldr takeOnesPlace n;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet unfoldr f x =\n  let rec unfold f x lst =\n    match f x with | Some (e,res) -> unfold f e (res :: lst) | None  -> lst in\n  unfold f x [];;\n\nlet rec digitsOfInt n =\n  let takeOnesPlace x =\n    match x with | neg when x <= 0 -> None | x -> Some ((x / 10), (x mod 10)) in\n  unfoldr takeOnesPlace n;;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet unfoldr f x =\n  let rec unfold f x lst =\n    match f x with | Some (e,res) -> unfold f e (res :: lst) | None  -> lst in\n  unfold f x [];;\n\nlet rec digitsOfInt n =\n  let takeOnesPlace x =\n    match x with | neg when x <= 0 -> None | x -> Some ((x / 10), (x mod 10)) in\n  unfoldr takeOnesPlace n;;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet unfoldr f x =\n  let rec unfold f x lst =\n    match f x with | Some (e,res) -> unfold f e (res :: lst) | None  -> lst in\n  unfold f x [];;\n\nlet rec digitsOfInt n =\n  let takeOnesPlace x =\n    match x with | neg when x <= 0 -> None | x -> Some ((x / 10), (x mod 10)) in\n  unfoldr takeOnesPlace n;;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec additivePersistence n =\nif n < 10 then 0 else 1 + additivePersistence(n |> digits |> sumList)","min":"\nlet rec foldl f s l =\n  match l with | [] -> s | head::tail -> foldl f (f head s) tail;;\n\nlet unfoldr f x =\n  let rec unfold f x lst =\n    match f x with | Some (e,res) -> unfold f e (res :: lst) | None  -> lst in\n  unfold f x [];;\n\nlet rec digitsOfInt n =\n  let takeOnesPlace x =\n    match x with | neg when x <= 0 -> None | x -> Some ((x / 10), (x mod 10)) in\n  unfoldr takeOnesPlace n;;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList = foldl (+) 0;;\n\nlet rec additivePersistence n =\n  if n < 10 then 0 else 1 + (additivePersistence ((n |> digits) |> sumList));;\n","type":"","out":""},{"in":"let _ = additivePersistence 9876","min":"\nlet rec foldl f s l =\n  match l with | [] -> s | head::tail -> foldl f (f head s) tail;;\n\nlet unfoldr f x =\n  let rec unfold f x lst =\n    match f x with | Some (e,res) -> unfold f e (res :: lst) | None  -> lst in\n  unfold f x [];;\n\nlet rec digitsOfInt n =\n  let takeOnesPlace x =\n    match x with | neg when x <= 0 -> None | x -> Some ((x / 10), (x mod 10)) in\n  unfoldr takeOnesPlace n;;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList = foldl (+) 0;;\n\nlet rec additivePersistence n =\n  if n < 10 then 0 else 1 + (additivePersistence ((n |> digits) |> sumList));;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""},{"in":"let rec digitalRoot n = \nif n < 10 then n else digitalRoot (n |> digits |> sumList)","min":"\nlet rec foldl f s l =\n  match l with | [] -> s | head::tail -> foldl f (f head s) tail;;\n\nlet unfoldr f x =\n  let rec unfold f x lst =\n    match f x with | Some (e,res) -> unfold f e (res :: lst) | None  -> lst in\n  unfold f x [];;\n\nlet rec digitsOfInt n =\n  let takeOnesPlace x =\n    match x with | neg when x <= 0 -> None | x -> Some ((x / 10), (x mod 10)) in\n  unfoldr takeOnesPlace n;;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList = foldl (+) 0;;\n\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot ((n |> digits) |> sumList);;\n","type":"","out":""},{"in":"let _ = digitalRoot 9876","min":"\nlet rec foldl f s l =\n  match l with | [] -> s | head::tail -> foldl f (f head s) tail;;\n\nlet unfoldr f x =\n  let rec unfold f x lst =\n    match f x with | Some (e,res) -> unfold f e (res :: lst) | None  -> lst in\n  unfold f x [];;\n\nlet rec digitsOfInt n =\n  let takeOnesPlace x =\n    match x with | neg when x <= 0 -> None | x -> Some ((x / 10), (x mod 10)) in\n  unfoldr takeOnesPlace n;;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList = foldl (+) 0;;\n\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot ((n |> digits) |> sumList);;\n\nlet _ = digitalRoot 9876;;\n","type":"","out":""},{"in":"let listReverse l = \nlet rec lr ver rev = match ver with\n[] -> rev\n| head :: tail -> lr tail (head :: rev)\nin lr l []","min":"\nlet listReverse l =\n  let rec lr ver rev =\n    match ver with | [] -> rev | head::tail -> lr tail (head :: rev) in\n  lr l [];;\n","type":"","out":""},{"in":"let _ = listReverse [1; 2; 3; 4]","min":"\nlet listReverse l =\n  let rec lr ver rev =\n    match ver with | [] -> rev | head::tail -> lr tail (head :: rev) in\n  lr l [];;\n\nlet _ = listReverse [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]","min":"\nlet listReverse l =\n  let rec lr ver rev =\n    match ver with | [] -> rev | head::tail -> lr tail (head :: rev) in\n  lr l [];;\n\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n","type":"","out":""},{"in":"let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n","type":"","out":""},{"in":"let palindrome str =\nstr |> explode |> listReverse = (str |> explode)","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet listReverse l =\n  let rec lr ver rev =\n    match ver with | [] -> rev | head::tail -> lr tail (head :: rev) in\n  lr l [];;\n\nlet palindrome str = ((str |> explode) |> listReverse) = (str |> explode);;\n","type":"","out":""},{"in":"let _ = palindrome \"malayalam\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet listReverse l =\n  let rec lr ver rev =\n    match ver with | [] -> rev | head::tail -> lr tail (head :: rev) in\n  lr l [];;\n\nlet palindrome str = ((str |> explode) |> listReverse) = (str |> explode);;\n\nlet _ = palindrome \"malayalam\";;\n","type":"","out":""},{"in":"let _ = palindrome \"myxomatosis\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet listReverse l =\n  let rec lr ver rev =\n    match ver with | [] -> rev | head::tail -> lr tail (head :: rev) in\n  lr l [];;\n\nlet palindrome str = ((str |> explode) |> listReverse) = (str |> explode);;\n\nlet _ = palindrome \"myxomatosis\";;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key        = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130  = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":5684},"type":"eval"},"cursor":0,"time":1.396996765048254e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet unfoldr f x = \n  let rec unfold f x lst = \n    match f x with\n        Some (e, res) -> unfold f e (res :: lst)\n      | None -> lst\n  in unfold f x []\n\nlet rec foldl f s l = match l with\n    [] -> s\n  | head :: tail -> foldl f (f head s) tail\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList = foldl (+) 0\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n =\n  let takeOnesPlace x = match x with\n      neg when x <= 0 -> None\n    | x               -> Some (x / 10, x mod 10)\n  in unfoldr takeOnesPlace n\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec additivePersistence n =\n  if n < 10 then 0 else 1 + additivePersistence(n |> digits |> sumList)\n\nlet _ = additivePersistence 9876\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if n < 10 then n else digitalRoot (n |> digits |> sumList)\n\nlet _ = digitalRoot 9876\n\n\nlet listReverse l = \n  let rec lr ver rev = match ver with\n      [] -> rev\n    | head :: tail -> lr tail (head :: rev)\n  in lr l []\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome str =\n  str |> explode |> listReverse = (str |> explode)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let unfoldr f x = \nlet rec unfold f x lst = \nmatch f x with\nSome (e, res) -> unfold f e (res :: lst)\n| None -> lst\nin unfold f x []","min":"\nlet unfoldr f x =\n  let rec unfold f x lst =\n    match f x with | Some (e,res) -> unfold f e (res :: lst) | None  -> lst in\n  unfold f x [];;\n","type":"","out":""},{"in":"let rec foldl f s l = match l with\n[] -> s\n| head :: tail -> foldl f (f head s) tail","min":"\nlet rec foldl f s l =\n  match l with | [] -> s | head::tail -> foldl f (f head s) tail;;\n","type":"","out":""},{"in":"let rec sumList = foldl (+) 0","min":"\nlet rec foldl f s l =\n  match l with | [] -> s | head::tail -> foldl f (f head s) tail;;\n\nlet rec sumList = foldl (+) 0;;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec foldl f s l =\n  match l with | [] -> s | head::tail -> foldl f (f head s) tail;;\n\nlet rec sumList = foldl (+) 0;;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec foldl f s l =\n  match l with | [] -> s | head::tail -> foldl f (f head s) tail;;\n\nlet rec sumList = foldl (+) 0;;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec foldl f s l =\n  match l with | [] -> s | head::tail -> foldl f (f head s) tail;;\n\nlet rec sumList = foldl (+) 0;;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec digitsOfInt n =\nlet takeOnesPlace x = match x with\nneg when x <= 0 -> None\n| x               -> Some (x / 10, x mod 10)\nin unfoldr takeOnesPlace n","min":"\nlet unfoldr f x =\n  let rec unfold f x lst =\n    match f x with | Some (e,res) -> unfold f e (res :: lst) | None  -> lst in\n  unfold f x [];;\n\nlet rec digitsOfInt n =\n  let takeOnesPlace x =\n    match x with | neg when x <= 0 -> None | x -> Some ((x / 10), (x mod 10)) in\n  unfoldr takeOnesPlace n;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet unfoldr f x =\n  let rec unfold f x lst =\n    match f x with | Some (e,res) -> unfold f e (res :: lst) | None  -> lst in\n  unfold f x [];;\n\nlet rec digitsOfInt n =\n  let takeOnesPlace x =\n    match x with | neg when x <= 0 -> None | x -> Some ((x / 10), (x mod 10)) in\n  unfoldr takeOnesPlace n;;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet unfoldr f x =\n  let rec unfold f x lst =\n    match f x with | Some (e,res) -> unfold f e (res :: lst) | None  -> lst in\n  unfold f x [];;\n\nlet rec digitsOfInt n =\n  let takeOnesPlace x =\n    match x with | neg when x <= 0 -> None | x -> Some ((x / 10), (x mod 10)) in\n  unfoldr takeOnesPlace n;;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet unfoldr f x =\n  let rec unfold f x lst =\n    match f x with | Some (e,res) -> unfold f e (res :: lst) | None  -> lst in\n  unfold f x [];;\n\nlet rec digitsOfInt n =\n  let takeOnesPlace x =\n    match x with | neg when x <= 0 -> None | x -> Some ((x / 10), (x mod 10)) in\n  unfoldr takeOnesPlace n;;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec additivePersistence n =\nif n < 10 then 0 else 1 + additivePersistence(n |> digits |> sumList)","min":"\nlet rec foldl f s l =\n  match l with | [] -> s | head::tail -> foldl f (f head s) tail;;\n\nlet unfoldr f x =\n  let rec unfold f x lst =\n    match f x with | Some (e,res) -> unfold f e (res :: lst) | None  -> lst in\n  unfold f x [];;\n\nlet rec digitsOfInt n =\n  let takeOnesPlace x =\n    match x with | neg when x <= 0 -> None | x -> Some ((x / 10), (x mod 10)) in\n  unfoldr takeOnesPlace n;;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList = foldl (+) 0;;\n\nlet rec additivePersistence n =\n  if n < 10 then 0 else 1 + (additivePersistence ((n |> digits) |> sumList));;\n","type":"","out":""},{"in":"let _ = additivePersistence 9876","min":"\nlet rec foldl f s l =\n  match l with | [] -> s | head::tail -> foldl f (f head s) tail;;\n\nlet unfoldr f x =\n  let rec unfold f x lst =\n    match f x with | Some (e,res) -> unfold f e (res :: lst) | None  -> lst in\n  unfold f x [];;\n\nlet rec digitsOfInt n =\n  let takeOnesPlace x =\n    match x with | neg when x <= 0 -> None | x -> Some ((x / 10), (x mod 10)) in\n  unfoldr takeOnesPlace n;;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList = foldl (+) 0;;\n\nlet rec additivePersistence n =\n  if n < 10 then 0 else 1 + (additivePersistence ((n |> digits) |> sumList));;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""},{"in":"let rec digitalRoot n = \nif n < 10 then n else digitalRoot (n |> digits |> sumList)","min":"\nlet rec foldl f s l =\n  match l with | [] -> s | head::tail -> foldl f (f head s) tail;;\n\nlet unfoldr f x =\n  let rec unfold f x lst =\n    match f x with | Some (e,res) -> unfold f e (res :: lst) | None  -> lst in\n  unfold f x [];;\n\nlet rec digitsOfInt n =\n  let takeOnesPlace x =\n    match x with | neg when x <= 0 -> None | x -> Some ((x / 10), (x mod 10)) in\n  unfoldr takeOnesPlace n;;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList = foldl (+) 0;;\n\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot ((n |> digits) |> sumList);;\n","type":"","out":""},{"in":"let _ = digitalRoot 9876","min":"\nlet rec foldl f s l =\n  match l with | [] -> s | head::tail -> foldl f (f head s) tail;;\n\nlet unfoldr f x =\n  let rec unfold f x lst =\n    match f x with | Some (e,res) -> unfold f e (res :: lst) | None  -> lst in\n  unfold f x [];;\n\nlet rec digitsOfInt n =\n  let takeOnesPlace x =\n    match x with | neg when x <= 0 -> None | x -> Some ((x / 10), (x mod 10)) in\n  unfoldr takeOnesPlace n;;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList = foldl (+) 0;;\n\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot ((n |> digits) |> sumList);;\n\nlet _ = digitalRoot 9876;;\n","type":"","out":""},{"in":"let listReverse l = \nlet rec lr ver rev = match ver with\n[] -> rev\n| head :: tail -> lr tail (head :: rev)\nin lr l []","min":"\nlet listReverse l =\n  let rec lr ver rev =\n    match ver with | [] -> rev | head::tail -> lr tail (head :: rev) in\n  lr l [];;\n","type":"","out":""},{"in":"let _ = listReverse [1; 2; 3; 4]","min":"\nlet listReverse l =\n  let rec lr ver rev =\n    match ver with | [] -> rev | head::tail -> lr tail (head :: rev) in\n  lr l [];;\n\nlet _ = listReverse [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]","min":"\nlet listReverse l =\n  let rec lr ver rev =\n    match ver with | [] -> rev | head::tail -> lr tail (head :: rev) in\n  lr l [];;\n\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n","type":"","out":""},{"in":"let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n","type":"","out":""},{"in":"let palindrome str =\nstr |> explode |> listReverse = (str |> explode)","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet listReverse l =\n  let rec lr ver rev =\n    match ver with | [] -> rev | head::tail -> lr tail (head :: rev) in\n  lr l [];;\n\nlet palindrome str = ((str |> explode) |> listReverse) = (str |> explode);;\n","type":"","out":""},{"in":"let _ = palindrome \"malayalam\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet listReverse l =\n  let rec lr ver rev =\n    match ver with | [] -> rev | head::tail -> lr tail (head :: rev) in\n  lr l [];;\n\nlet palindrome str = ((str |> explode) |> listReverse) = (str |> explode);;\n\nlet _ = palindrome \"malayalam\";;\n","type":"","out":""},{"in":"let _ = palindrome \"myxomatosis\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet listReverse l =\n  let rec lr ver rev =\n    match ver with | [] -> rev | head::tail -> lr tail (head :: rev) in\n  lr l [];;\n\nlet palindrome str = ((str |> explode) |> listReverse) = (str |> explode);;\n\nlet _ = palindrome \"myxomatosis\";;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key        = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130  = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":5684},"type":"eval"},"cursor":2668,"time":1.39750922304481e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet unfoldr f x = \n  let rec unfold f x lst = \n    match f x with\n        Some (e, res) -> unfold f e (res :: lst)\n      | None -> lst\n  in unfold f x []\n\nlet rec foldl f s l = match l with\n    [] -> s\n  | head :: tail -> foldl f (f head s) tail\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList = foldl (+) 0\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n =\n  let takeOnesPlace x = match x with\n      neg when x <= 0 -> None\n    | x               -> Some (x / 10, x mod 10)\n  in unfoldr takeOnesPlace n\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec additivePersistence n =\n  if n < 10 then 0 else 1 + additivePersistence(n |> digits |> sumList)\n\nlet _ = additivePersistence 9876\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if n < 10 then n else digitalRoot (n |> digits |> sumList)\n\nlet _ = digitalRoot 9876\n\n\nlet listReverse l = \n  let rec lr ver rev = match ver with\n      [] -> rev\n    | head :: tail -> lr tail (head :: rev)\n  in lr l []\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome str =\n  str |> explode |> listReverse = (str |> explode)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
