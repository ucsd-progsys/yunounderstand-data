{"ocaml":[{"in":"let sqsum xs = \nlet f a x = x * x + a in\nlet base = 0 in\nList.fold_left f base xs","min":"\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n","type":"","out":""},{"in":"let _ = sqsum []","min":"\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [];;\n","type":"","out":""},{"in":"let _ = sqsum [1;2;3;4]","min":"\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sqsum [(-1); (-2); (-3); (-4)]","min":"\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [(-1); (-2); (-3); (-4)];;\n","type":"","out":""},{"in":"let pipe fs y= \nlet f a x = x a in\nlet base = y in\nList.fold_left f base fs","min":"\nlet pipe fs y = let f a x = x a in let base = y in List.fold_left f base fs;;\n","type":"","out":""},{"in":"let _ = pipe [] 3","min":"\nlet pipe fs y = let f a x = x a in let base = y in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n","type":"","out":""},{"in":"let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3","min":"\nlet pipe fs y = let f a x = x a in let base = y in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n","type":"","out":""},{"in":"let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3","min":"\nlet pipe fs y = let f a x = x a in let base = y in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n","type":"","out":""},{"in":"let rec sepConcat ","min":"","type":"syntax","out":"Characters 18-20:\n  let rec sepConcat ;;\n                    ^^\nError: Syntax error\n"}],"event":{"region":{"start":0,"stop":1202},"type":"eval"},"cursor":1176,"time":1.398788278567385e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\n*)\n\n\n\n (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n  let sqsum xs = \n    let f a x = x * x + a in\n      let base = 0 in\nList.fold_left f base xs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\n          let _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\r\n\n\r\n      let pipe fs y= \nlet f a x = x a in\nlet base = y in\n      List.fold_left f base fs\n\n\r\n          (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = pipe [] 3\n\r\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\r\n      let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\r\n\r\n\n\r\n   let rec sepConcat sep sl = match sl with \n   | [] -> \"\"\n   | h :: t -> \n   let f a x = failwith \"to be implemented\" in\n   let base = failwith \"to be implemented\" in\nlet l = failwith \"to be implemented\" in\n          List.fold_left f base l\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\r\n                         let stringOfList f l = failwith \"to be implemented\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\n\r\n   (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n   (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\n                         let rec clone x n = failwith \"to be implemented\" \n\r\n   (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXX*)\n\r\n    let padZero l1 l2 = failwith \"to be implemented\"\n\r\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\r\nlet rec removeZero l = failwith \"to be implemented\"\n\r\n   (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXX*)\n\r\n      let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\n   let base = failwith \"to be implemented\" in\n   let args = failwith \"to be implemented\" in\n   let (_, res) = List.fold_left f base args in\n   res\nin \n      removeZero (add (padZero l1 l2))\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\r\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\r\nlet bigMul l1 l2 = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\r\n            (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet key = \"\" (*XXXXXXXX*)\n  let prefix130 = \"130\" (*XXXXXXXX*)\n    let print130 s = print_string (prefix130^\">>\"^s)\n\r\n                    exception ErrorCode of string\n\r\ntype result = Pass | Fail | ErrorCode of string\n\r\n    let score = ref 0\n     let max = ref 0\n     let timeout = 300\n\r\n     let runWTimeout (f,arg,out,time) = \n     try if compare (f arg) out = 0 then Pass else Fail\n     with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\r\n     exception TestException\n     let testTest () =\n     let testGood x = 1 in\n     let testBad x = 0 in \n     let testException x = raise TestException in\n     let rec testTimeout x = testTimeout x in\n     runWTimeout(testGood,0,1,5) = Pass &&  \n     runWTimeout(testBad,0,1,5) = Fail &&  \n     runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n     runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\r\n     let runTest (f,arg,out,points,name) =\n     let _ = max := !max + points in\n     let outs = \n     match runWTimeout(f,arg,out,timeout) with \n     Pass -> (score := !score + points; \"[pass]\")\n     | Fail -> \"[fail]\"\n     | ErrorCode e -> \"[error: \"^e^\"]\"  in\n     name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\r\n     (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n    let explode s = \n  let rec _exp i = \n  if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\r\n          let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)\n\r\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\r  \nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\r  \nlet wrap_curried_2 f (a,b) = f a b\n\r  \nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\r     \n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\r     \n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\r     \n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\r     \n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\r     \n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\r     \n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\r     \n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\r     \n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\r     \n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\r  \nlet _ = runAllTests ()\n\r  \nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let sqsum xs = \nlet f a x = x * x + a in\nlet base = 0 in\nList.fold_left f base xs","min":"\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n","type":"","out":""},{"in":"let _ = sqsum []","min":"\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [];;\n","type":"","out":""},{"in":"let _ = sqsum [1;2;3;","min":"","type":"syntax","out":"Characters 20-22:\n  let _ = sqsum [1;2;3;;;\n                      ^^\nError: Syntax error\n"}],"event":{"region":{"start":0,"stop":884},"type":"eval"},"cursor":925,"time":1.398788354089688e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\n*)\n\n\n\n (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n  let sqsum xs = \n    let f a x = x * x + a in\n      let base = 0 in\nList.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\n          let _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\r\n\n\r\n      let pipe fs y= \nlet f a x = x a in\nlet base = y in\n      List.fold_left f base fs\n\n\r\n          (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = pipe [] 3\n\r\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\r\n      let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\r\n\r\n\n\r\n   let rec sepConcat sep sl = match sl with \n   | [] -> \"\"\n   | h :: t -> \n   let f a x = failwith \"to be implemented\" in\n   let base = failwith \"to be implemented\" in\nlet l = failwith \"to be implemented\" in\n          List.fold_left f base l\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\r\n                         let stringOfList f l = failwith \"to be implemented\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\n\r\n   (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n   (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\n                         let rec clone x n = failwith \"to be implemented\" \n\r\n   (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXX*)\n\r\n    let padZero l1 l2 = failwith \"to be implemented\"\n\r\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\r\nlet rec removeZero l = failwith \"to be implemented\"\n\r\n   (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXX*)\n\r\n      let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\n   let base = failwith \"to be implemented\" in\n   let args = failwith \"to be implemented\" in\n   let (_, res) = List.fold_left f base args in\n   res\nin \n      removeZero (add (padZero l1 l2))\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\r\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\r\nlet bigMul l1 l2 = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\r\n            (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet key = \"\" (*XXXXXXXX*)\n  let prefix130 = \"130\" (*XXXXXXXX*)\n    let print130 s = print_string (prefix130^\">>\"^s)\n\r\n                    exception ErrorCode of string\n\r\ntype result = Pass | Fail | ErrorCode of string\n\r\n    let score = ref 0\n     let max = ref 0\n     let timeout = 300\n\r\n     let runWTimeout (f,arg,out,time) = \n     try if compare (f arg) out = 0 then Pass else Fail\n     with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\r\n     exception TestException\n     let testTest () =\n     let testGood x = 1 in\n     let testBad x = 0 in \n     let testException x = raise TestException in\n     let rec testTimeout x = testTimeout x in\n     runWTimeout(testGood,0,1,5) = Pass &&  \n     runWTimeout(testBad,0,1,5) = Fail &&  \n     runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n     runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\r\n     let runTest (f,arg,out,points,name) =\n     let _ = max := !max + points in\n     let outs = \n     match runWTimeout(f,arg,out,timeout) with \n     Pass -> (score := !score + points; \"[pass]\")\n     | Fail -> \"[fail]\"\n     | ErrorCode e -> \"[error: \"^e^\"]\"  in\n     name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\r\n     (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n    let explode s = \n  let rec _exp i = \n  if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\r\n          let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)\n\r\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\r  \nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\r  \nlet wrap_curried_2 f (a,b) = f a b\n\r  \nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\r     \n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\r     \n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\r     \n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\r     \n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\r     \n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\r     \n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\r     \n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\r     \n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\r     \n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\r  \nlet _ = runAllTests ()\n\r  \nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let sqsum xs = \nlet f a x = x * x + a in \nlet base = 0 in\nList.fold_left f base xs","min":"\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n","type":"","out":""},{"in":"let _ = sqsum []","min":"\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [];;\n","type":"","out":""},{"in":"let _ = sqsum [1;2;3;","min":"","type":"syntax","out":"Characters 20-22:\n  let _ = sqsum [1;2;3;;;\n                      ^^\nError: Syntax error\n"}],"event":{"region":{"start":0,"stop":885},"type":"eval"},"cursor":927,"time":1.398788397130866e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\n*)\n\n\n\n (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n  let sqsum xs = \n    let f a x = x * x + a in \n      let base = 0 in\nList.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\n          let _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\r\n\n\r\n      let pipe fs y= \nlet f a x = x a in\nlet base = y in\n      List.fold_left f base fs\n\n\r\n          (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = pipe [] 3\n\r\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\r\n      let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\r\n\r\n\n\r\n   let rec sepConcat sep sl = match sl with \n   | [] -> \"\"\n   | h :: t -> \n   let f a x = failwith \"to be implemented\" in\n   let base = failwith \"to be implemented\" in\nlet l = failwith \"to be implemented\" in\n          List.fold_left f base l\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\r\n                         let stringOfList f l = failwith \"to be implemented\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\n\r\n   (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n   (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\n                         let rec clone x n = failwith \"to be implemented\" \n\r\n   (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXX*)\n\r\n    let padZero l1 l2 = failwith \"to be implemented\"\n\r\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\r\nlet rec removeZero l = failwith \"to be implemented\"\n\r\n   (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXX*)\n\r\n      let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\n   let base = failwith \"to be implemented\" in\n   let args = failwith \"to be implemented\" in\n   let (_, res) = List.fold_left f base args in\n   res\nin \n      removeZero (add (padZero l1 l2))\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\r\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\r\nlet bigMul l1 l2 = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\r\n            (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet key = \"\" (*XXXXXXXX*)\n  let prefix130 = \"130\" (*XXXXXXXX*)\n    let print130 s = print_string (prefix130^\">>\"^s)\n\r\n                    exception ErrorCode of string\n\r\ntype result = Pass | Fail | ErrorCode of string\n\r\n    let score = ref 0\n     let max = ref 0\n     let timeout = 300\n\r\n     let runWTimeout (f,arg,out,time) = \n     try if compare (f arg) out = 0 then Pass else Fail\n     with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\r\n     exception TestException\n     let testTest () =\n     let testGood x = 1 in\n     let testBad x = 0 in \n     let testException x = raise TestException in\n     let rec testTimeout x = testTimeout x in\n     runWTimeout(testGood,0,1,5) = Pass &&  \n     runWTimeout(testBad,0,1,5) = Fail &&  \n     runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n     runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\r\n     let runTest (f,arg,out,points,name) =\n     let _ = max := !max + points in\n     let outs = \n     match runWTimeout(f,arg,out,timeout) with \n     Pass -> (score := !score + points; \"[pass]\")\n     | Fail -> \"[fail]\"\n     | ErrorCode e -> \"[error: \"^e^\"]\"  in\n     name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\r\n     (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n    let explode s = \n  let rec _exp i = \n  if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\r\n          let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)\n\r\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\r  \nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\r  \nlet wrap_curried_2 f (a,b) = f a b\n\r  \nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\r     \n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\r     \n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\r     \n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\r     \n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\r     \n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\r     \n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\r     \n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\r     \n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\r     \n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\r  \nlet _ = runAllTests ()\n\r  \nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"\n\nlet sqsum xs = \nlet f a x = x * x + a in","min":"","type":"syntax","out":"Characters 42-44:\n  let f a x = x * x + a in;;\n                          ^^\nError: Syntax error\n"}],"event":{"region":{"start":0,"stop":800},"type":"eval"},"cursor":802,"time":1.398788441583194e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in \n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\r\n\n\r\nlet pipe fs y= \n  let f a x = x a in\n  let base = y in\n    List.fold_left f base fs\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = pipe [] 3\n\r\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\r\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\r\n\r\n\n\r\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\r\nlet stringOfList f l = failwith \"to be implemented\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet rec clone x n = failwith \"to be implemented\" \n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\r\nlet padZero l1 l2 = failwith \"to be implemented\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\r\nlet rec removeZero l = failwith \"to be implemented\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\r\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\r\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\r\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\n\n\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\r\nexception ErrorCode of string\n\r\ntype result = Pass | Fail | ErrorCode of string\n\r\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\r\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\r\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\r\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\r\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\r\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\r\n  let eq_real p (r1,r2) = \n                    (r1 -. r2) < p || (r2 -. r1) < p\n\r\nlet wrap_curried_2 f (a,b) = f a b\n\r\n    let runAllTests () =\n     let _ = (score := 0; max := 0) in\n     let report = \n     [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\r\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\r\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\r\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\r\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\r\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\r\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n    runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\r\n    runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n    runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\r\nrunTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\r\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\r  \nlet _ = runAllTests ()\n\r  \nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"\n(* UNCOMMENT AF","min":"\n;;\n","type":"","out":""},{"in":"(* UNCOMMENT AFTER IMPL","min":"\n;;\n","type":"","out":""},{"in":"let _ = sqsum []\nlet _ = sqsum [1;2;3;","min":"","type":"syntax","out":"Characters 37-39:\n  let _ = sqsum [1;2;3;;;\n                      ^^\nError: Syntax error\n"},{"in":"\n\r\nlet pipe fs y= \nlet f a x = x a in\nlet b","min":"","type":"syntax","out":"Characters 43-45:\n  let b;;\n       ^^\nError: Syntax error\n"},{"in":"(* UNCOMMENT AFTE","min":"\n;;\n","type":"","out":""},{"in":"let _ = pipe [] 3\n\r\nlet _ = pipe [(fun x -> x+x);","min":"","type":"syntax","out":"Characters 48-50:\n  let _ = pipe [(fun x -> x+x);;;\n                              ^^\nError: Syntax error\n"},{"in":"let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3","min":"\nlet pipe fs y = let f a x = x a in let base = y in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n","type":"","out":""}],"event":{"region":{"start":800,"stop":1179},"type":"eval"},"cursor":1179,"time":1.398788446533275e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in \n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\r\n\n\r\nlet pipe fs y= \n  let f a x = x a in\n  let base = y in\n    List.fold_left f base fs\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = pipe [] 3\n\r\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\r\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\r\n\r\n\n\r\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\r\nlet stringOfList f l = failwith \"to be implemented\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet rec clone x n = failwith \"to be implemented\" \n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\r\nlet padZero l1 l2 = failwith \"to be implemented\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\r\nlet rec removeZero l = failwith \"to be implemented\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\r\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\r\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\r\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\n\n\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\r\nexception ErrorCode of string\n\r\ntype result = Pass | Fail | ErrorCode of string\n\r\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\r\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\r\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\r\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\r\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\r\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\r\n  let eq_real p (r1,r2) = \n                    (r1 -. r2) < p || (r2 -. r1) < p\n\r\nlet wrap_curried_2 f (a,b) = f a b\n\r\n    let runAllTests () =\n     let _ = (score := 0; max := 0) in\n     let report = \n     [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\r\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\r\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\r\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\r\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\r\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\r\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n    runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\r\n    runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n    runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\r\nrunTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\r\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\r  \nlet _ = runAllTests ()\n\r  \nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"\n\nlet sqsum xs = \nlet f a x = x * x + a in","min":"","type":"syntax","out":"Characters 42-44:\n  let f a x = x * x + a in;;\n                          ^^\nError: Syntax error\n"},{"in":"\n(* UNCOMMENT AF","min":"\n;;\n","type":"","out":""},{"in":"(* UNCOMMENT AFTER IMPL","min":"\n;;\n","type":"","out":""},{"in":"let _ = sqsum []\nlet _ = sqsum [1;2;3;","min":"","type":"syntax","out":"Characters 37-39:\n  let _ = sqsum [1;2;3;;;\n                      ^^\nError: Syntax error\n"},{"in":"\n\r\nlet pipe fs = \nlet f a x = x a in\nlet b","min":"","type":"syntax","out":"Characters 42-44:\n  let b;;\n       ^^\nError: Syntax error\n"}],"event":{"region":{"start":0,"stop":1015},"type":"eval"},"cursor":1016,"time":1.398810478849243e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in \n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\r\n\n\r\nlet pipe fs = \n  let f a x = x a in\n  let base = function f in\n    List.fold_left f base fs\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = pipe [] 3\n\r\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\r\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\r\n\r\n\n\r\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\r\nlet stringOfList f l = failwith \"to be implemented\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet rec clone x n = failwith \"to be implemented\" \n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\r\nlet padZero l1 l2 = failwith \"to be implemented\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\r\nlet rec removeZero l = failwith \"to be implemented\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\r\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\r\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\r\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\n\n\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\r\nexception ErrorCode of string\n\r\ntype result = Pass | Fail | ErrorCode of string\n\r\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\r\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\r\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\r\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\r\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\r\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\r\n  let eq_real p (r1,r2) = \n                    (r1 -. r2) < p || (r2 -. r1) < p\n\r\nlet wrap_curried_2 f (a,b) = f a b\n\r\n    let runAllTests () =\n     let _ = (score := 0; max := 0) in\n     let report = \n     [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\r\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\r\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\r\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\r\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\r\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\r\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n    runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\r\n    runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n    runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\r\nrunTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\r\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\r  \nlet _ = runAllTests ()\n\r  \nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"\n\r\nlet pipe fs = \nlet f a x = x a in\nlet b","min":"","type":"syntax","out":"Characters 42-44:\n  let b;;\n       ^^\nError: Syntax error\n"}],"event":{"region":{"start":926,"stop":1014},"type":"eval"},"cursor":1015,"time":1.39881048469007e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in \n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\r\n\n\r\nlet pipe fs = \n  let f a x = x a in\n  let base = function  in\n    List.fold_left f base fs\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = pipe [] 3\n\r\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\r\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\r\n\r\n\n\r\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\r\nlet stringOfList f l = failwith \"to be implemented\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet rec clone x n = failwith \"to be implemented\" \n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\r\nlet padZero l1 l2 = failwith \"to be implemented\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\r\nlet rec removeZero l = failwith \"to be implemented\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\r\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\r\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\r\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\n\n\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\r\nexception ErrorCode of string\n\r\ntype result = Pass | Fail | ErrorCode of string\n\r\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\r\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\r\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\r\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\r\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\r\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\r\n  let eq_real p (r1,r2) = \n                    (r1 -. r2) < p || (r2 -. r1) < p\n\r\nlet wrap_curried_2 f (a,b) = f a b\n\r\n    let runAllTests () =\n     let _ = (score := 0; max := 0) in\n     let report = \n     [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\r\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\r\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\r\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\r\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\r\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\r\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n    runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\r\n    runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n    runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\r\nrunTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\r\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\r  \nlet _ = runAllTests ()\n\r  \nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"\n\r\nlet pipe fs = \nlet f a x = x a in\nlet b","min":"","type":"syntax","out":"Characters 42-44:\n  let b;;\n       ^^\nError: Syntax error\n"}],"event":{"region":{"start":926,"stop":1016},"type":"eval"},"cursor":1016,"time":1.398810496579523e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in \n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\r\n\n\r\nlet pipe fs = \n  let f a x = x a in\n  let base = function fs in\n    List.fold_left f base fs\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = pipe [] 3\n\r\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\r\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\r\n\r\n\n\r\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\r\nlet stringOfList f l = failwith \"to be implemented\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet rec clone x n = failwith \"to be implemented\" \n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\r\nlet padZero l1 l2 = failwith \"to be implemented\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\r\nlet rec removeZero l = failwith \"to be implemented\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\r\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\r\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\r\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\n\n\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\r\nexception ErrorCode of string\n\r\ntype result = Pass | Fail | ErrorCode of string\n\r\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\r\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\r\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\r\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\r\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\r\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\r\n  let eq_real p (r1,r2) = \n                    (r1 -. r2) < p || (r2 -. r1) < p\n\r\nlet wrap_curried_2 f (a,b) = f a b\n\r\n    let runAllTests () =\n     let _ = (score := 0; max := 0) in\n     let report = \n     [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\r\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\r\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\r\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\r\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\r\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\r\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n    runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\r\n    runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n    runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\r\nrunTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\r\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\r  \nlet _ = runAllTests ()\n\r  \nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"\n\r\nlet pipe fs = \nlet f a x = x a in\nlet b","min":"","type":"syntax","out":"Characters 42-44:\n  let b;;\n       ^^\nError: Syntax error\n"}],"event":{"region":{"start":926,"stop":1015},"type":"eval"},"cursor":1015,"time":1.398810517049503e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in \n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\r\n\n\r\nlet pipe fs = \n  let f a x = x a in\n  let base = fun f -> a in\n    List.fold_left f base fs\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = pipe [] 3\n\r\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\r\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\r\n\r\n\n\r\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\r\nlet stringOfList f l = failwith \"to be implemented\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet rec clone x n = failwith \"to be implemented\" \n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\r\nlet padZero l1 l2 = failwith \"to be implemented\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\r\nlet rec removeZero l = failwith \"to be implemented\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\r\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\r\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\r\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\n\n\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\r\nexception ErrorCode of string\n\r\ntype result = Pass | Fail | ErrorCode of string\n\r\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\r\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\r\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\r\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\r\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\r\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\r\n  let eq_real p (r1,r2) = \n                    (r1 -. r2) < p || (r2 -. r1) < p\n\r\nlet wrap_curried_2 f (a,b) = f a b\n\r\n    let runAllTests () =\n     let _ = (score := 0; max := 0) in\n     let report = \n     [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\r\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\r\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\r\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\r\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\r\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\r\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n    runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\r\n    runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n    runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\r\nrunTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\r\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\r  \nlet _ = runAllTests ()\n\r  \nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"\n\r\nlet pipe fs = \nlet f a x = x a in\nlet b","min":"","type":"syntax","out":"Characters 42-44:\n  let b;;\n       ^^\nError: Syntax error\n"}],"event":{"region":{"start":926,"stop":1019},"type":"eval"},"cursor":1019,"time":1.398810523459108e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in \n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\r\n\n\r\nlet pipe fs = \n  let f a x = x a in\n  let base = fun f -> fun f in\n    List.fold_left f base fs\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = pipe [] 3\n\r\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\r\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\r\n\r\n\n\r\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\r\nlet stringOfList f l = failwith \"to be implemented\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet rec clone x n = failwith \"to be implemented\" \n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\r\nlet padZero l1 l2 = failwith \"to be implemented\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\r\nlet rec removeZero l = failwith \"to be implemented\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\r\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\r\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\r\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\n\n\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\r\nexception ErrorCode of string\n\r\ntype result = Pass | Fail | ErrorCode of string\n\r\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\r\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\r\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\r\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\r\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\r\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\r\n  let eq_real p (r1,r2) = \n                    (r1 -. r2) < p || (r2 -. r1) < p\n\r\nlet wrap_curried_2 f (a,b) = f a b\n\r\n    let runAllTests () =\n     let _ = (score := 0; max := 0) in\n     let report = \n     [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\r\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\r\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\r\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\r\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\r\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\r\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n    runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\r\n    runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n    runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\r\nrunTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\r\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\r  \nlet _ = runAllTests ()\n\r  \nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"\n\r\nlet pipe fs y = \nlet f a x = x a in\nlet b","min":"","type":"syntax","out":"Characters 44-46:\n  let b;;\n       ^^\nError: Syntax error\n"}],"event":{"region":{"start":926,"stop":1008},"type":"eval"},"cursor":1008,"time":1.398810538570212e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in \n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\r\n\n\r\nlet pipe fs y = \n  let f a x = x a in\n  let base = y in\n    List.fold_left f base fs\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = pipe [] 3\n\r\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\r\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\r\n\r\n\n\r\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\r\nlet stringOfList f l = failwith \"to be implemented\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet rec clone x n = failwith \"to be implemented\" \n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\r\nlet padZero l1 l2 = failwith \"to be implemented\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\r\nlet rec removeZero l = failwith \"to be implemented\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\r\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\r\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\r\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\n\n\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\r\nexception ErrorCode of string\n\r\ntype result = Pass | Fail | ErrorCode of string\n\r\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\r\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\r\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\r\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\r\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\r\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\r\n  let eq_real p (r1,r2) = \n                    (r1 -. r2) < p || (r2 -. r1) < p\n\r\nlet wrap_curried_2 f (a,b) = f a b\n\r\n    let runAllTests () =\n     let _ = (score := 0; max := 0) in\n     let report = \n     [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\r\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\r\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\r\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\r\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\r\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\r\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n    runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\r\n    runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n    runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\r\nrunTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\r\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\r  \nlet _ = runAllTests ()\n\r  \nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"\n\r\nlet pipe fs  = function \nlet f a x = x a in\nlet b","min":"","type":"syntax","out":"Characters 28-31:\n  let f a x = x a in\n  ^^^\nError: Syntax error\n"}],"event":{"region":{"start":926,"stop":1023},"type":"eval"},"cursor":1023,"time":1.398810615296124e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in \n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\r\n\n\r\nlet pipe fs  = function \n  let f a x = x a in\n  let base = function in\n    List.fold_left f base fs\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = pipe [] 3\n\r\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\r\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\r\n\r\n\n\r\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\r\nlet stringOfList f l = failwith \"to be implemented\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet rec clone x n = failwith \"to be implemented\" \n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\r\nlet padZero l1 l2 = failwith \"to be implemented\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\r\nlet rec removeZero l = failwith \"to be implemented\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\r\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\r\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\r\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\n\n\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\r\nexception ErrorCode of string\n\r\ntype result = Pass | Fail | ErrorCode of string\n\r\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\r\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\r\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\r\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\r\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\r\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\r\n  let eq_real p (r1,r2) = \n                    (r1 -. r2) < p || (r2 -. r1) < p\n\r\nlet wrap_curried_2 f (a,b) = f a b\n\r\n    let runAllTests () =\n     let _ = (score := 0; max := 0) in\n     let report = \n     [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\r\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\r\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\r\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\r\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\r\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\r\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n    runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\r\n    runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n    runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\r\nrunTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\r\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\r  \nlet _ = runAllTests ()\n\r  \nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"\n\r\nlet pipe fs  y=  \nlet f a x = x a in\nlet b","min":"","type":"syntax","out":"Characters 45-47:\n  let b;;\n       ^^\nError: Syntax error\n"}],"event":{"region":{"start":926,"stop":1009},"type":"eval"},"cursor":981,"time":1.398810630358097e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in \n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\r\n\n\r\nlet pipe fs  y=  \n  let f a x = x a in\n  let base = y in\n    List.fold_left f base fs\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = pipe [] 3\n\r\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\r\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\r\n\r\n\n\r\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\r\nlet stringOfList f l = failwith \"to be implemented\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet rec clone x n = failwith \"to be implemented\" \n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\r\nlet padZero l1 l2 = failwith \"to be implemented\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\r\nlet rec removeZero l = failwith \"to be implemented\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\r\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\r\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\r\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\n\n\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\r\nexception ErrorCode of string\n\r\ntype result = Pass | Fail | ErrorCode of string\n\r\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\r\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\r\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\r\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\r\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\r\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\r\n  let eq_real p (r1,r2) = \n                    (r1 -. r2) < p || (r2 -. r1) < p\n\r\nlet wrap_curried_2 f (a,b) = f a b\n\r\n    let runAllTests () =\n     let _ = (score := 0; max := 0) in\n     let report = \n     [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\r\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\r\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\r\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\r\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\r\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\r\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n    runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\r\n    runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n    runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\r\nrunTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\r\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\r  \nlet _ = runAllTests ()\n\r  \nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"(* UNCOMMENT AFTE","min":"\n;;\n","type":"","out":""},{"in":"let _ = pipe [] 3\n\r\nlet _ = pipe [(fun x -> x+x);","min":"","type":"syntax","out":"Characters 48-50:\n  let _ = pipe [(fun x -> x+x);;;\n                              ^^\nError: Syntax error\n"},{"in":"let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3","min":"\nlet pipe fs y = let f a x = x a in let base = y in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n","type":"","out":""}],"event":{"region":{"start":1009,"stop":1181},"type":"eval"},"cursor":1182,"time":1.398810631287149e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in \n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\r\n\n\r\nlet pipe fs  y=  \n  let f a x = x a in\n  let base = y in\n    List.fold_left f base fs\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = pipe [] 3\n\r\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\r\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\r\n\r\n\n\r\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\r\nlet stringOfList f l = failwith \"to be implemented\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet rec clone x n = failwith \"to be implemented\" \n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\r\nlet padZero l1 l2 = failwith \"to be implemented\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\r\nlet rec removeZero l = failwith \"to be implemented\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\r\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\r\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\r\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\n\n\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\r\nexception ErrorCode of string\n\r\ntype result = Pass | Fail | ErrorCode of string\n\r\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\r\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\r\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\r\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\r\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\r\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\r\n  let eq_real p (r1,r2) = \n                    (r1 -. r2) < p || (r2 -. r1) < p\n\r\nlet wrap_curried_2 f (a,b) = f a b\n\r\n    let runAllTests () =\n     let _ = (score := 0; max := 0) in\n     let report = \n     [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\r\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\r\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\r\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\r\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\r\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\r\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n    runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\r\n    runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n    runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\r\nrunTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\r\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\r  \nlet _ = runAllTests ()\n\r  \nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"\n\r\nlet pipe fs y=  \nlet f a x = x a in\nlet b","min":"","type":"syntax","out":"Characters 44-46:\n  let b;;\n       ^^\nError: Syntax error\n"},{"in":"(* UNCOMMENT AFTE","min":"\n;;\n","type":"","out":""},{"in":"let _ = pipe [] 3\n\r\nlet _ = pipe [(fun x -> x+x);","min":"","type":"syntax","out":"Characters 48-50:\n  let _ = pipe [(fun x -> x+x);;;\n                              ^^\nError: Syntax error\n"},{"in":"let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3","min":"\nlet pipe fs y = let f a x = x a in let base = y in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n","type":"","out":""}],"event":{"region":{"start":926,"stop":1180},"type":"eval"},"cursor":1180,"time":1.398811300345848e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in \n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\r\n\n\r\nlet pipe fs y=  \n  let f a x = x a in\n  let base = y in\n    List.fold_left f base fs\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = pipe [] 3\n\r\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\r\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\r\n\r\n\n\r\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ x in\n      let base = [] in\n      let l = t in\n        List.fold_left f base l\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\r\nlet stringOfList f l = failwith \"to be implemented\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet rec clone x n = failwith \"to be implemented\" \n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\r\nlet padZero l1 l2 = failwith \"to be implemented\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\r\nlet rec removeZero l = failwith \"to be implemented\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\r\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\r\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\r\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\n\n\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\r\nexception ErrorCode of string\n\r\ntype result = Pass | Fail | ErrorCode of string\n\r\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\r\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\r\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\r\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\r\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\r\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\r\n  let eq_real p (r1,r2) = \n                    (r1 -. r2) < p || (r2 -. r1) < p\n\r\nlet wrap_curried_2 f (a,b) = f a b\n\r\n    let runAllTests () =\n     let _ = (score := 0; max := 0) in\n     let report = \n     [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\r\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\r\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\r\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\r\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\r\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\r\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n    runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\r\n    runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n    runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\r\nrunTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\r\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\r  \nlet _ = runAllTests ()\n\r  \nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"\n\r\nlet pipe fs y=  \nlet f a x = x a in\nlet b","min":"","type":"syntax","out":"Characters 44-46:\n  let b;;\n       ^^\nError: Syntax error\n"},{"in":"(* UNCOMMENT AFTE","min":"\n;;\n","type":"","out":""},{"in":"let _ = pipe [] 3\n\r\nlet _ = pipe [(fun x -> x+x);","min":"","type":"syntax","out":"Characters 48-50:\n  let _ = pipe [(fun x -> x+x);;;\n                              ^^\nError: Syntax error\n"},{"in":"let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3","min":"\nlet pipe fs y = let f a x = x a in let base = y in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n","type":"","out":""}],"event":{"region":{"start":926,"stop":1180},"type":"eval"},"cursor":1183,"time":1.398811958977971e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in \n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\r\n\n\r\nlet pipe fs y=  \n  let f a x = x a in\n  let base = y in\n    List.fold_left f base fs\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = pipe [] 3\n\r\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\r\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\r\n\r\n\n\r\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ x in\n      let base = [] in\n      let l = t in\n        List.fold_left f base l\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\r\nlet stringOfList f l = failwith \"to be implemented\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet rec clone x n = failwith \"to be implemented\" \n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\r\nlet padZero l1 l2 = failwith \"to be implemented\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\r\nlet rec removeZero l = failwith \"to be implemented\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\r\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\r\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\r\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\n\n\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\r\nexception ErrorCode of string\n\r\ntype result = Pass | Fail | ErrorCode of string\n\r\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\r\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\r\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\r\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\r\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\r\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\r\n  let eq_real p (r1,r2) = \n                    (r1 -. r2) < p || (r2 -. r1) < p\n\r\nlet wrap_curried_2 f (a,b) = f a b\n\r\n    let runAllTests () =\n     let _ = (score := 0; max := 0) in\n     let report = \n     [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\r\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\r\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\r\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\r\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\r\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\r\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n    runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\r\n    runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n    runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\r\nrunTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\r\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\r  \nlet _ = runAllTests ()\n\r  \nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"\n\r\nlet rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ x in\nlet base = \"\" in\nlet l ","min":"","type":"syntax","out":"Characters 113-115:\n  let l ;;\n        ^^\nError: Syntax error\n"}],"event":{"region":{"start":1180,"stop":1328},"type":"eval"},"cursor":1316,"time":1.398812492760058e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in \n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\r\n\n\r\nlet pipe fs y=  \n  let f a x = x a in\n  let base = y in\n    List.fold_left f base fs\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = pipe [] 3\n\r\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\r\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\r\n\r\n\n\r\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ x in\n      let base = \"\" in\n      let l = t in\n        List.fold_left f base l\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\r\nlet stringOfList f l = failwith \"to be implemented\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet rec clone x n = failwith \"to be implemented\" \n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\r\nlet padZero l1 l2 = failwith \"to be implemented\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\r\nlet rec removeZero l = failwith \"to be implemented\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\r\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\r\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\r\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\n\n\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\r\nexception ErrorCode of string\n\r\ntype result = Pass | Fail | ErrorCode of string\n\r\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\r\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\r\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\r\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\r\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\r\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\r\n  let eq_real p (r1,r2) = \n                    (r1 -. r2) < p || (r2 -. r1) < p\n\r\nlet wrap_curried_2 f (a,b) = f a b\n\r\n    let runAllTests () =\n     let _ = (score := 0; max := 0) in\n     let report = \n     [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\r\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\r\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\r\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\r\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\r\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\r\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n    runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\r\n    runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n    runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\r\nrunTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\r\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\r  \nlet _ = runAllTests ()\n\r  \nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"\n\r\nlet rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ \"x\" in\nlet base = \"\" in\nlet l ","min":"","type":"syntax","out":"Characters 115-117:\n  let l ;;\n        ^^\nError: Syntax error\n"}],"event":{"region":{"start":1180,"stop":1330},"type":"eval"},"cursor":1324,"time":1.39881251427975e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in \n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\r\n\n\r\nlet pipe fs y=  \n  let f a x = x a in\n  let base = y in\n    List.fold_left f base fs\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = pipe [] 3\n\r\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\r\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\r\n\r\n\n\r\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ \"x\" in\n      let base = \"\" in\n      let l = t in\n        List.fold_left f base l\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\r\nlet stringOfList f l = failwith \"to be implemented\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet rec clone x n = failwith \"to be implemented\" \n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\r\nlet padZero l1 l2 = failwith \"to be implemented\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\r\nlet rec removeZero l = failwith \"to be implemented\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\r\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\r\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\r\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\n\n\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\r\nexception ErrorCode of string\n\r\ntype result = Pass | Fail | ErrorCode of string\n\r\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\r\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\r\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\r\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\r\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\r\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\r\n  let eq_real p (r1,r2) = \n                    (r1 -. r2) < p || (r2 -. r1) < p\n\r\nlet wrap_curried_2 f (a,b) = f a b\n\r\n    let runAllTests () =\n     let _ = (score := 0; max := 0) in\n     let report = \n     [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\r\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\r\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\r\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\r\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\r\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\r\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n    runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\r\n    runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n    runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\r\nrunTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\r\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\r  \nlet _ = runAllTests ()\n\r  \nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"\n\r\nlet rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = \"\" in\nlet l ","min":"","type":"syntax","out":"Characters 119-121:\n  let l ;;\n        ^^\nError: Syntax error\n"}],"event":{"region":{"start":1180,"stop":1334},"type":"eval"},"cursor":1328,"time":1.39881254772548e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in \n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\r\n\n\r\nlet pipe fs y=  \n  let f a x = x a in\n  let base = y in\n    List.fold_left f base fs\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = pipe [] 3\n\r\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\r\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\r\n\r\n\n\r\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = \"\" in\n      let l = t in\n        List.fold_left f base l\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\r\nlet stringOfList f l = failwith \"to be implemented\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet rec clone x n = failwith \"to be implemented\" \n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\r\nlet padZero l1 l2 = failwith \"to be implemented\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\r\nlet rec removeZero l = failwith \"to be implemented\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\r\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\r\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\r\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\n\n\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\r\nexception ErrorCode of string\n\r\ntype result = Pass | Fail | ErrorCode of string\n\r\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\r\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\r\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\r\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\r\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\r\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\r\n  let eq_real p (r1,r2) = \n                    (r1 -. r2) < p || (r2 -. r1) < p\n\r\nlet wrap_curried_2 f (a,b) = f a b\n\r\n    let runAllTests () =\n     let _ = (score := 0; max := 0) in\n     let report = \n     [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\r\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\r\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\r\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\r\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\r\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\r\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n    runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\r\n    runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n    runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\r\nrunTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\r\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\r  \nlet _ = runAllTests ()\n\r  \nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"(* UNCOMMENT AFTER IMPLEMENTING THE ABOVE*","min":"\n;;\n","type":"","out":""},{"in":"\r\nlet _ = sepConcat \", \" [","min":"","type":"syntax","out":"Characters 26-28:\n  let _ = sepConcat \", \" [;;\n                          ^^\nError: Syntax error\n"},{"in":"\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"","min":"","type":"syntax","out":"Characters 42-44:\n  let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\";;\n                                           ^^\nError: Syntax error\n"},{"in":"let _ = sepConcat \", \" [\"foo\";\"","min":"","type":"syntax","out":"Characters 32-34:\n  let _ = sepConcat \", \" [\"foo\";\"\";;\n                                  ^^\nError: Syntax error\n"}],"event":{"region":{"start":1334,"stop":1528},"type":"eval"},"cursor":1528,"time":1.398812555237093e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in \n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\r\n\n\r\nlet pipe fs y=  \n  let f a x = x a in\n  let base = y in\n    List.fold_left f base fs\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = pipe [] 3\n\r\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\r\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\r\n\r\n\n\r\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = \"\" in\n      let l = t in\n        List.fold_left f base l\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r   \nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\r  \n\n\n\r  \nlet stringOfList f l = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r  \nlet rec clone x n = failwith \"to be implemented\" \n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet padZero l1 l2 = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet rec removeZero l = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\r  \nlet rec mulByDigit i l = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r  \nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\r  \nexception ErrorCode of string\n\r  \ntype result = Pass | Fail | ErrorCode of string\n\r  \nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\r  \nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\r  \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\r  \nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\r  \nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\r  \nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\r\n  let eq_real p (r1,r2) = \n                    (r1 -. r2) < p || (r2 -. r1) < p\n\r\nlet wrap_curried_2 f (a,b) = f a b\n\r\n    let runAllTests () =\n     let _ = (score := 0; max := 0) in\n     let report = \n     [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\r\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\r\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\r\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\r\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\r\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\r\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n    runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\r\n    runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n    runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\r\nrunTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\r\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\r  \nlet _ = runAllTests ()\n\r  \nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"\n\r\nlet rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = \"\" in\nlet l ","min":"","type":"syntax","out":"Characters 119-121:\n  let l ;;\n        ^^\nError: Syntax error\n"},{"in":"(* UNCOMMENT AFTER IMPLEMENTING THE ABOVE*","min":"\n;;\n","type":"","out":""},{"in":"\r\nlet _ = sepConcat \", \" [","min":"","type":"syntax","out":"Characters 26-28:\n  let _ = sepConcat \", \" [;;\n                          ^^\nError: Syntax error\n"},{"in":"\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"","min":"","type":"syntax","out":"Characters 42-44:\n  let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\";;\n                                           ^^\nError: Syntax error\n"},{"in":"let _ = sepConcat \", \" [\"foo\";\"","min":"","type":"syntax","out":"Characters 32-34:\n  let _ = sepConcat \", \" [\"foo\";\"\";;\n                                  ^^\nError: Syntax error\n"}],"event":{"region":{"start":1180,"stop":1529},"type":"eval"},"cursor":1529,"time":1.398812578401484e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in \n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\r\n\n\r\nlet pipe fs y=  \n  let f a x = x a in\n  let base = y in\n    List.fold_left f base fs\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = pipe [] 3\n\r\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\r\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\r\n\r\n\n\r\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = \"\" in\n      let l = sl in\n        List.fold_left f base l\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r   \nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\r  \n\n\n\r  \nlet stringOfList f l = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r  \nlet rec clone x n = failwith \"to be implemented\" \n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet padZero l1 l2 = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet rec removeZero l = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\r  \nlet rec mulByDigit i l = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r  \nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\r  \nexception ErrorCode of string\n\r  \ntype result = Pass | Fail | ErrorCode of string\n\r  \nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\r  \nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\r  \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\r  \nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\r  \nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\r  \nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\r\n  let eq_real p (r1,r2) = \n                    (r1 -. r2) < p || (r2 -. r1) < p\n\r\nlet wrap_curried_2 f (a,b) = f a b\n\r\n    let runAllTests () =\n     let _ = (score := 0; max := 0) in\n     let report = \n     [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\r\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\r\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\r\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\r\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\r\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\r\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n    runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\r\n    runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n    runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\r\nrunTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\r\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\r  \nlet _ = runAllTests ()\n\r  \nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"\n\r\nlet rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h ^ sep ^ x in\nlet base = \"\" in\nlet l ","min":"","type":"syntax","out":"Characters 119-121:\n  let l ;;\n        ^^\nError: Syntax error\n"}],"event":{"region":{"start":1180,"stop":1335},"type":"eval"},"cursor":1323,"time":1.398812638886094e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in \n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\r\n\n\r\nlet pipe fs y=  \n  let f a x = x a in\n  let base = y in\n    List.fold_left f base fs\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = pipe [] 3\n\r\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\r\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\r\n\r\n\n\r\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = h ^ sep ^ x in\n      let base = \"\" in\n      let l = sl in\n        List.fold_left f base l\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r   \nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\r  \n\n\n\r  \nlet stringOfList f l = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r  \nlet rec clone x n = failwith \"to be implemented\" \n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet padZero l1 l2 = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet rec removeZero l = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\r  \nlet rec mulByDigit i l = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r  \nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\r  \nexception ErrorCode of string\n\r  \ntype result = Pass | Fail | ErrorCode of string\n\r  \nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\r  \nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\r  \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\r  \nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\r  \nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\r  \nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\r\n  let eq_real p (r1,r2) = \n                    (r1 -. r2) < p || (r2 -. r1) < p\n\r\nlet wrap_curried_2 f (a,b) = f a b\n\r\n    let runAllTests () =\n     let _ = (score := 0; max := 0) in\n     let report = \n     [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\r\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\r\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\r\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\r\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\r\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\r\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n    runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\r\n    runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n    runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\r\nrunTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\r\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\r  \nlet _ = runAllTests ()\n\r  \nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"(* UNCOMMENT AFTER IMPLEMENTING THE ABOVE*","min":"\n;;\n","type":"","out":""},{"in":"\r\nlet _ = sepConcat \", \" [","min":"","type":"syntax","out":"Characters 26-28:\n  let _ = sepConcat \", \" [;;\n                          ^^\nError: Syntax error\n"},{"in":"\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"","min":"","type":"syntax","out":"Characters 42-44:\n  let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\";;\n                                           ^^\nError: Syntax error\n"},{"in":"let _ = sepConcat \", \" [\"foo\";\"","min":"","type":"syntax","out":"Characters 32-34:\n  let _ = sepConcat \", \" [\"foo\";\"\";;\n                                  ^^\nError: Syntax error\n"}],"event":{"region":{"start":1335,"stop":1529},"type":"eval"},"cursor":1517,"time":1.398812640969813e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in \n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\r\n\n\r\nlet pipe fs y=  \n  let f a x = x a in\n  let base = y in\n    List.fold_left f base fs\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = pipe [] 3\n\r\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\r\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\r\n\r\n\n\r\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = h ^ sep ^ x in\n      let base = \"\" in\n      let l = sl in\n        List.fold_left f base l\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r   \nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\r  \n\n\n\r  \nlet stringOfList f l = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r  \nlet rec clone x n = failwith \"to be implemented\" \n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet padZero l1 l2 = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet rec removeZero l = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\r  \nlet rec mulByDigit i l = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r  \nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\r  \nexception ErrorCode of string\n\r  \ntype result = Pass | Fail | ErrorCode of string\n\r  \nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\r  \nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\r  \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\r  \nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\r  \nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\r  \nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\r\n  let eq_real p (r1,r2) = \n                    (r1 -. r2) < p || (r2 -. r1) < p\n\r\nlet wrap_curried_2 f (a,b) = f a b\n\r\n    let runAllTests () =\n     let _ = (score := 0; max := 0) in\n     let report = \n     [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\r\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\r\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\r\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\r\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\r\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\r\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n    runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\r\n    runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n    runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\r\nrunTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\r\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\r  \nlet _ = runAllTests ()\n\r  \nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"\n\r\nlet rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = \"h\" in\nlet l","min":"","type":"syntax","out":"Characters 119-121:\n  let l;;\n       ^^\nError: Syntax error\n"}],"event":{"region":{"start":1180,"stop":1336},"type":"eval"},"cursor":1324,"time":1.398812746300026e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in \n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\r\n\n\r\nlet pipe fs y=  \n  let f a x = x a in\n  let base = y in\n    List.fold_left f base fs\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = pipe [] 3\n\r\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\r\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\r\n\r\n\n\r\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = \"h\" in\n      let l = sl in\n        List.fold_left f base l\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r   \nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\r  \n\n\n\r  \nlet stringOfList f l = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r  \nlet rec clone x n = failwith \"to be implemented\" \n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet padZero l1 l2 = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet rec removeZero l = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\r  \nlet rec mulByDigit i l = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r  \nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\r  \nexception ErrorCode of string\n\r  \ntype result = Pass | Fail | ErrorCode of string\n\r  \nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\r  \nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\r  \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\r  \nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\r  \nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\r  \nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\r\n  let eq_real p (r1,r2) = \n                    (r1 -. r2) < p || (r2 -. r1) < p\n\r\nlet wrap_curried_2 f (a,b) = f a b\n\r\n    let runAllTests () =\n     let _ = (score := 0; max := 0) in\n     let report = \n     [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\r\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\r\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\r\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\r\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\r\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\r\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n    runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\r\n    runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n    runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\r\nrunTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\r\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\r  \nlet _ = runAllTests ()\n\r  \nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"(* UNCOMMENT AFTER IMPLEMENTING THE ABOVE*","min":"\n;;\n","type":"","out":""},{"in":"\r\nlet _ = sepConcat \", \" [","min":"","type":"syntax","out":"Characters 26-28:\n  let _ = sepConcat \", \" [;;\n                          ^^\nError: Syntax error\n"},{"in":"\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"","min":"","type":"syntax","out":"Characters 42-44:\n  let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\";;\n                                           ^^\nError: Syntax error\n"},{"in":"let _ = sepConcat \", \" [\"foo\";\"","min":"","type":"syntax","out":"Characters 32-34:\n  let _ = sepConcat \", \" [\"foo\";\"\";;\n                                  ^^\nError: Syntax error\n"}],"event":{"region":{"start":1336,"stop":1530},"type":"eval"},"cursor":1518,"time":1.398812749740517e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in \n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\r\n\n\r\nlet pipe fs y=  \n  let f a x = x a in\n  let base = y in\n    List.fold_left f base fs\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = pipe [] 3\n\r\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\r\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\r\n\r\n\n\r\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = \"h\" in\n      let l = sl in\n        List.fold_left f base l\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r   \nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\r  \n\n\n\r  \nlet stringOfList f l = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r  \nlet rec clone x n = failwith \"to be implemented\" \n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet padZero l1 l2 = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet rec removeZero l = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\r  \nlet rec mulByDigit i l = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r  \nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\r  \nexception ErrorCode of string\n\r  \ntype result = Pass | Fail | ErrorCode of string\n\r  \nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\r  \nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\r  \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\r  \nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\r  \nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\r  \nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\r\n  let eq_real p (r1,r2) = \n                    (r1 -. r2) < p || (r2 -. r1) < p\n\r\nlet wrap_curried_2 f (a,b) = f a b\n\r\n    let runAllTests () =\n     let _ = (score := 0; max := 0) in\n     let report = \n     [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\r\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\r\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\r\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\r\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\r\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\r\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n    runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\r\n    runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n    runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\r\nrunTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\r\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\r  \nlet _ = runAllTests ()\n\r  \nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"\n\r\nlet rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l =","min":"","type":"syntax","out":"Characters 119-121:\n  let l =;;\n         ^^\nError: Syntax error\n"}],"event":{"region":{"start":1180,"stop":1334},"type":"eval"},"cursor":1320,"time":1.39881275776724e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in \n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\r\n\n\r\nlet pipe fs y=  \n  let f a x = x a in\n  let base = y in\n    List.fold_left f base fs\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = pipe [] 3\n\r\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\r\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\r\n\r\n\n\r\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = sl in\n        List.fold_left f base l\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r   \nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\r  \n\n\n\r  \nlet stringOfList f l = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r  \nlet rec clone x n = failwith \"to be implemented\" \n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet padZero l1 l2 = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet rec removeZero l = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\r  \nlet rec mulByDigit i l = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r  \nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\r  \nexception ErrorCode of string\n\r  \ntype result = Pass | Fail | ErrorCode of string\n\r  \nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\r  \nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\r  \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\r  \nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\r  \nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\r  \nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\r\n  let eq_real p (r1,r2) = \n                    (r1 -. r2) < p || (r2 -. r1) < p\n\r\nlet wrap_curried_2 f (a,b) = f a b\n\r\n    let runAllTests () =\n     let _ = (score := 0; max := 0) in\n     let report = \n     [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\r\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\r\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\r\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\r\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\r\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\r\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n    runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\r\n    runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n    runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\r\nrunTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\r\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\r  \nlet _ = runAllTests ()\n\r  \nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"(* UNCOMMENT AFTER IMPLEMENTING THE ABOVE*","min":"\n;;\n","type":"","out":""},{"in":"\r\nlet _ = sepConcat \", \" [","min":"","type":"syntax","out":"Characters 26-28:\n  let _ = sepConcat \", \" [;;\n                          ^^\nError: Syntax error\n"},{"in":"\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"","min":"","type":"syntax","out":"Characters 42-44:\n  let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\";;\n                                           ^^\nError: Syntax error\n"},{"in":"let _ = sepConcat \", \" [\"foo\";\"","min":"","type":"syntax","out":"Characters 32-34:\n  let _ = sepConcat \", \" [\"foo\";\"\";;\n                                  ^^\nError: Syntax error\n"}],"event":{"region":{"start":1334,"stop":1528},"type":"eval"},"cursor":1514,"time":1.398812760229256e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in \n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\r\n\n\r\nlet pipe fs y=  \n  let f a x = x a in\n  let base = y in\n    List.fold_left f base fs\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = pipe [] 3\n\r\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\r\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\r\n\r\n\n\r\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = sl in\n        List.fold_left f base l\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r   \nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\r  \n\n\n\r  \nlet stringOfList f l = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r  \nlet rec clone x n = failwith \"to be implemented\" \n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet padZero l1 l2 = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet rec removeZero l = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\r  \nlet rec mulByDigit i l = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r  \nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\r  \nexception ErrorCode of string\n\r  \ntype result = Pass | Fail | ErrorCode of string\n\r  \nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\r  \nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\r  \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\r  \nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\r  \nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\r  \nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\r\n  let eq_real p (r1,r2) = \n                    (r1 -. r2) < p || (r2 -. r1) < p\n\r\nlet wrap_curried_2 f (a,b) = f a b\n\r\n    let runAllTests () =\n     let _ = (score := 0; max := 0) in\n     let report = \n     [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\r\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\r\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\r\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\r\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\r\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\r\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n    runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\r\n    runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n    runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\r\nrunTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\r\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\r  \nlet _ = runAllTests ()\n\r  \nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"\n\r\nlet rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l =","min":"","type":"syntax","out":"Characters 119-121:\n  let l =;;\n         ^^\nError: Syntax error\n"},{"in":"(* UNCOMMENT AFTER IMPLEMENTING THE ABOVE*","min":"\n;;\n","type":"","out":""},{"in":"\r\nlet _ = sepConcat \", \" [","min":"","type":"syntax","out":"Characters 26-28:\n  let _ = sepConcat \", \" [;;\n                          ^^\nError: Syntax error\n"},{"in":"\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"","min":"","type":"syntax","out":"Characters 42-44:\n  let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\";;\n                                           ^^\nError: Syntax error\n"},{"in":"let _ = sepConcat \", \" [\"foo\";\"","min":"","type":"syntax","out":"Characters 32-34:\n  let _ = sepConcat \", \" [\"foo\";\"\";;\n                                  ^^\nError: Syntax error\n"}],"event":{"region":{"start":1180,"stop":1527},"type":"eval"},"cursor":1511,"time":1.39881286929644e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in \n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\r\n\n\r\nlet pipe fs y=  \n  let f a x = x a in\n  let base = y in\n    List.fold_left f base fs\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = pipe [] 3\n\r\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\r\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\r\n\r\n\n\r\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r   \nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\r  \n\n\n\r  \nlet stringOfList f l = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r  \nlet rec clone x n = failwith \"to be implemented\" \n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet padZero l1 l2 = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet rec removeZero l = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\r  \nlet rec mulByDigit i l = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r  \nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\r  \nexception ErrorCode of string\n\r  \ntype result = Pass | Fail | ErrorCode of string\n\r  \nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\r  \nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\r  \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\r  \nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\r  \nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\r  \nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\r\n  let eq_real p (r1,r2) = \n                    (r1 -. r2) < p || (r2 -. r1) < p\n\r\nlet wrap_curried_2 f (a,b) = f a b\n\r\n    let runAllTests () =\n     let _ = (score := 0; max := 0) in\n     let report = \n     [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\r\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\r\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\r\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\r\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\r\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\r\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n    runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\r\n    runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n    runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\r\nrunTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\r\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\r  \nlet _ = runAllTests ()\n\r  \nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"documentation.\n*)\nlet re","min":"","type":"syntax","out":"Characters 15-16:\n  *)\n  ^\nError: Syntax error\n"},{"in":"\n\nlet sqsum xs = \nlet f a x = x * x + a in","min":"","type":"syntax","out":"Characters 42-44:\n  let f a x = x * x + a in;;\n                          ^^\nError: Syntax error\n"},{"in":"\n(* UNCOMMENT AF","min":"\n;;\n","type":"","out":""},{"in":"(* UNCOMMENT AFTER IMPL","min":"\n;;\n","type":"","out":""},{"in":"let _ = sqsum []\nlet _ = sqsum [1;2;3;","min":"","type":"syntax","out":"Characters 37-39:\n  let _ = sqsum [1;2;3;;;\n                      ^^\nError: Syntax error\n"},{"in":"\n\r\nlet pipe fs y=  \nlet f a x = x a in\nlet b","min":"","type":"syntax","out":"Characters 44-46:\n  let b;;\n       ^^\nError: Syntax error\n"},{"in":"(* UNCOMMENT AFTE","min":"\n;;\n","type":"","out":""},{"in":"let _ = pipe [] 3\n\r\nlet _ = pipe [(fun x -> x+x);","min":"","type":"syntax","out":"Characters 48-50:\n  let _ = pipe [(fun x -> x+x);;;\n                              ^^\nError: Syntax error\n"},{"in":"let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3","min":"\nlet pipe fs y = let f a x = x a in let base = y in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n","type":"","out":""},{"in":"\n\r\nlet rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l =","min":"","type":"syntax","out":"Characters 119-121:\n  let l =;;\n         ^^\nError: Syntax error\n"},{"in":"(* UNCOMMENT AFTER IMPLEMENTING THE ABOVE*","min":"\n;;\n","type":"","out":""},{"in":"\r\nlet _ = sepConcat \", \" [","min":"","type":"syntax","out":"Characters 26-28:\n  let _ = sepConcat \", \" [;;\n                          ^^\nError: Syntax error\n"},{"in":"\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"","min":"","type":"syntax","out":"Characters 42-44:\n  let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\";;\n                                           ^^\nError: Syntax error\n"},{"in":"let _ = sepConcat \", \" [\"foo\";\"","min":"","type":"syntax","out":"Characters 32-34:\n  let _ = sepConcat \", \" [\"foo\";\"\";;\n                                  ^^\nError: Syntax error\n"}],"event":{"region":{"start":0,"stop":1553},"type":"eval"},"cursor":1553,"time":1.398813016480266e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\nlet rec x y = x y in x 2;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in \n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\r\n\n\r\nlet pipe fs y=  \n  let f a x = x a in\n  let base = y in\n    List.fold_left f base fs\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = pipe [] 3\n\r\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\r\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\r\n\r\n\n\r\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r   \nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\r  \n\n\n\r  \nlet stringOfList f l = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r  \nlet rec clone x n = failwith \"to be implemented\" \n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet padZero l1 l2 = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet rec removeZero l = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\r  \nlet rec mulByDigit i l = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r  \nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\r  \nexception ErrorCode of string\n\r  \ntype result = Pass | Fail | ErrorCode of string\n\r  \nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\r  \nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\r  \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\r  \nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\r  \nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\r  \nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\r\n  let eq_real p (r1,r2) = \n                    (r1 -. r2) < p || (r2 -. r1) < p\n\r\nlet wrap_curried_2 f (a,b) = f a b\n\r\n    let runAllTests () =\n     let _ = (score := 0; max := 0) in\n     let report = \n     [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\r\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\r\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\r\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\r\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\r\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\r\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n    runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\r\n    runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n    runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\r\nrunTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\r\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\r  \nlet _ = runAllTests ()\n\r  \nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"documentation.\n*)\nlet re","min":"","type":"syntax","out":"Characters 15-16:\n  *)\n  ^\nError: Syntax error\n"},{"in":"\n\nlet sqsum xs = \nlet f a x = x * x + a in","min":"","type":"syntax","out":"Characters 42-44:\n  let f a x = x * x + a in;;\n                          ^^\nError: Syntax error\n"},{"in":"\n(* UNCOMMENT AF","min":"\n;;\n","type":"","out":""},{"in":"(* UNCOMMENT AFTER IMPL","min":"\n;;\n","type":"","out":""},{"in":"let _ = sqsum []\nlet _ = sqsum [1;2;3;","min":"","type":"syntax","out":"Characters 37-39:\n  let _ = sqsum [1;2;3;;;\n                      ^^\nError: Syntax error\n"},{"in":"\n\r\nlet pipe fs y=  \nlet f a x = x a in\nlet b","min":"","type":"syntax","out":"Characters 44-46:\n  let b;;\n       ^^\nError: Syntax error\n"},{"in":"(* UNCOMMENT AFTE","min":"\n;;\n","type":"","out":""},{"in":"let _ = pipe [] 3\n\r\nlet _ = pipe [(fun x -> x+x);","min":"","type":"syntax","out":"Characters 48-50:\n  let _ = pipe [(fun x -> x+x);;;\n                              ^^\nError: Syntax error\n"},{"in":"let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3","min":"\nlet pipe fs y = let f a x = x a in let base = y in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n","type":"","out":""},{"in":"\n\r\nlet rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l =","min":"","type":"syntax","out":"Characters 119-121:\n  let l =;;\n         ^^\nError: Syntax error\n"},{"in":"(* UNCOMMENT AFTER IMPLEMENTING THE ABOVE*","min":"\n;;\n","type":"","out":""},{"in":"\r\nlet _ = sepConcat \", \" [","min":"","type":"syntax","out":"Characters 26-28:\n  let _ = sepConcat \", \" [;;\n                          ^^\nError: Syntax error\n"},{"in":"\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"","min":"","type":"syntax","out":"Characters 42-44:\n  let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\";;\n                                           ^^\nError: Syntax error\n"},{"in":"let _ = sepConcat \", \" [\"foo\";\"","min":"","type":"syntax","out":"Characters 32-34:\n  let _ = sepConcat \", \" [\"foo\";\"\";;\n                                  ^^\nError: Syntax error\n"}],"event":{"region":{"start":0,"stop":1553},"type":"eval"},"cursor":1553,"time":1.398813042898865e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\nlet rec x y = x y in x 2;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in \n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\r\n\n\r\nlet pipe fs y=  \n  let f a x = x a in\n  let base = y in\n    List.fold_left f base fs\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = pipe [] 3\n\r\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\r\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\r\n\r\n\n\r\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r   \nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\r  \n\n\n\r  \nlet stringOfList f l = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r  \nlet rec clone x n = failwith \"to be implemented\" \n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet padZero l1 l2 = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet rec removeZero l = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\r  \nlet rec mulByDigit i l = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r  \nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\r  \nexception ErrorCode of string\n\r  \ntype result = Pass | Fail | ErrorCode of string\n\r  \nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\r  \nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\r  \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\r  \nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\r  \nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\r  \nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\r\n  let eq_real p (r1,r2) = \n                    (r1 -. r2) < p || (r2 -. r1) < p\n\r\nlet wrap_curried_2 f (a,b) = f a b\n\r\n    let runAllTests () =\n     let _ = (score := 0; max := 0) in\n     let report = \n     [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\r\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\r\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\r\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\r\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\r\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\r\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n    runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\r\n    runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n    runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\r\nrunTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\r\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\r  \nlet _ = runAllTests ()\n\r  \nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"documentation.\n*)\nlet ","min":"","type":"syntax","out":"Characters 15-16:\n  *)\n  ^\nError: Syntax error\n"},{"in":"\n\nlet sqsum xs = \nlet f a x = x * x + a in","min":"","type":"syntax","out":"Characters 42-44:\n  let f a x = x * x + a in;;\n                          ^^\nError: Syntax error\n"},{"in":"\n(* UNCOMMENT AF","min":"\n;;\n","type":"","out":""},{"in":"(* UNCOMMENT AFTER IMPL","min":"\n;;\n","type":"","out":""},{"in":"let _ = sqsum []\nlet _ = sqsum [1;2;3;","min":"","type":"syntax","out":"Characters 37-39:\n  let _ = sqsum [1;2;3;;;\n                      ^^\nError: Syntax error\n"},{"in":"\n\r\nlet pipe fs y=  \nlet f a x = x a in\nlet b","min":"","type":"syntax","out":"Characters 44-46:\n  let b;;\n       ^^\nError: Syntax error\n"},{"in":"(* UNCOMMENT AFTE","min":"\n;;\n","type":"","out":""},{"in":"let _ = pipe [] 3\n\r\nlet _ = pipe [(fun x -> x+x);","min":"","type":"syntax","out":"Characters 48-50:\n  let _ = pipe [(fun x -> x+x);;;\n                              ^^\nError: Syntax error\n"},{"in":"let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3","min":"\nlet pipe fs y = let f a x = x a in let base = y in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n","type":"","out":""},{"in":"\n\r\nlet rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l =","min":"","type":"syntax","out":"Characters 119-121:\n  let l =;;\n         ^^\nError: Syntax error\n"},{"in":"(* UNCOMMENT AFTER IMPLEMENTING THE ABOVE*","min":"\n;;\n","type":"","out":""},{"in":"\r\nlet _ = sepConcat \", \" [","min":"","type":"syntax","out":"Characters 26-28:\n  let _ = sepConcat \", \" [;;\n                          ^^\nError: Syntax error\n"},{"in":"\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"","min":"","type":"syntax","out":"Characters 42-44:\n  let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\";;\n                                           ^^\nError: Syntax error\n"},{"in":"let _ = sepConcat \", \" [\"foo\";\"","min":"","type":"syntax","out":"Characters 32-34:\n  let _ = sepConcat \", \" [\"foo\";\"\";;\n                                  ^^\nError: Syntax error\n"}],"event":{"region":{"start":0,"stop":1550},"type":"eval"},"cursor":1550,"time":1.39881306017806e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\nlet rec x y = x y in x \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in \n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\r\n\n\r\nlet pipe fs y=  \n  let f a x = x a in\n  let base = y in\n    List.fold_left f base fs\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = pipe [] 3\n\r\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\r\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\r\n\r\n\n\r\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r   \nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\r  \n\n\n\r  \nlet stringOfList f l = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r  \nlet rec clone x n = failwith \"to be implemented\" \n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet padZero l1 l2 = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet rec removeZero l = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\r  \nlet rec mulByDigit i l = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r  \nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\r  \nexception ErrorCode of string\n\r  \ntype result = Pass | Fail | ErrorCode of string\n\r  \nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\r  \nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\r  \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\r  \nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\r  \nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\r  \nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\r\n  let eq_real p (r1,r2) = \n                    (r1 -. r2) < p || (r2 -. r1) < p\n\r\nlet wrap_curried_2 f (a,b) = f a b\n\r\n    let runAllTests () =\n     let _ = (score := 0; max := 0) in\n     let report = \n     [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\r\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\r\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\r\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\r\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\r\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\r\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n    runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\r\n    runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n    runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\r\nrunTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\r\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\r  \nlet _ = runAllTests ()\n\r  \nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"documentation.\n*)\nlet ","min":"","type":"syntax","out":"Characters 15-16:\n  *)\n  ^\nError: Syntax error\n"},{"in":"\n\nlet sqsum xs = \nlet f a x = x * x + a in","min":"","type":"syntax","out":"Characters 42-44:\n  let f a x = x * x + a in;;\n                          ^^\nError: Syntax error\n"},{"in":"\n(* UNCOMMENT AF","min":"\n;;\n","type":"","out":""},{"in":"(* UNCOMMENT AFTER IMPL","min":"\n;;\n","type":"","out":""},{"in":"let _ = sqsum []\nlet _ = sqsum [1;2;3;","min":"","type":"syntax","out":"Characters 37-39:\n  let _ = sqsum [1;2;3;;;\n                      ^^\nError: Syntax error\n"},{"in":"\n\r\nlet pipe fs y=  \nlet f a x = x a in\nlet b","min":"","type":"syntax","out":"Characters 44-46:\n  let b;;\n       ^^\nError: Syntax error\n"},{"in":"(* UNCOMMENT AFTE","min":"\n;;\n","type":"","out":""},{"in":"let _ = pipe [] 3\n\r\nlet _ = pipe [(fun x -> x+x);","min":"","type":"syntax","out":"Characters 48-50:\n  let _ = pipe [(fun x -> x+x);;;\n                              ^^\nError: Syntax error\n"},{"in":"let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3","min":"\nlet pipe fs y = let f a x = x a in let base = y in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n","type":"","out":""},{"in":"\n\r\nlet rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l =","min":"","type":"syntax","out":"Characters 119-121:\n  let l =;;\n         ^^\nError: Syntax error\n"},{"in":"(* UNCOMMENT AFTER IMPLEMENTING THE ABOVE*","min":"\n;;\n","type":"","out":""},{"in":"\r\nlet _ = sepConcat \", \" [","min":"","type":"syntax","out":"Characters 26-28:\n  let _ = sepConcat \", \" [;;\n                          ^^\nError: Syntax error\n"},{"in":"\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"","min":"","type":"syntax","out":"Characters 42-44:\n  let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\";;\n                                           ^^\nError: Syntax error\n"},{"in":"let _ = sepConcat \", \" [\"foo\";\"","min":"","type":"syntax","out":"Characters 32-34:\n  let _ = sepConcat \", \" [\"foo\";\"\";;\n                                  ^^\nError: Syntax error\n"}],"event":{"region":{"start":0,"stop":1550},"type":"eval"},"cursor":1550,"time":1.398813093400939e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\nlet rec x y = x y in x \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in \n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\r\n\n\r\nlet pipe fs y=  \n  let f a x = x a in\n  let base = y in\n    List.fold_left f base fs\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = pipe [] 3\n\r\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\r\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\r\n\r\n\n\r\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r   \nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\r  \n\n\n\r  \nlet stringOfList f l = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r  \nlet rec clone x n = failwith \"to be implemented\" \n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet padZero l1 l2 = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet rec removeZero l = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\r  \nlet rec mulByDigit i l = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r  \nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\r  \nexception ErrorCode of string\n\r  \ntype result = Pass | Fail | ErrorCode of string\n\r  \nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\r  \nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\r  \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\r  \nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\r  \nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\r  \nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\r\n  let eq_real p (r1,r2) = \n                    (r1 -. r2) < p || (r2 -. r1) < p\n\r\nlet wrap_curried_2 f (a,b) = f a b\n\r\n    let runAllTests () =\n     let _ = (score := 0; max := 0) in\n     let report = \n     [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\r\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\r\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\r\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\r\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\r\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\r\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n    runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\r\n    runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n    runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\r\nrunTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\r\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\r  \nlet _ = runAllTests ()\n\r  \nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"\n\nlet sqsum xs = \nlet f a x = x * x + a in","min":"","type":"syntax","out":"Characters 42-44:\n  let f a x = x * x + a in;;\n                          ^^\nError: Syntax error\n"},{"in":"\n(* UNCOMMENT AF","min":"\n;;\n","type":"","out":""},{"in":"(* UNCOMMENT AFTER IMPL","min":"\n;;\n","type":"","out":""},{"in":"let _ = sqsum []\nlet _ = sqsum [1;2;3;","min":"","type":"syntax","out":"Characters 37-39:\n  let _ = sqsum [1;2;3;;;\n                      ^^\nError: Syntax error\n"},{"in":"\n\r\nlet pipe fs y=  \nlet f a x = x a in\nlet b","min":"","type":"syntax","out":"Characters 44-46:\n  let b;;\n       ^^\nError: Syntax error\n"},{"in":"(* UNCOMMENT AFTE","min":"\n;;\n","type":"","out":""},{"in":"let _ = pipe [] 3\n\r\nlet _ = pipe [(fun x -> x+x);","min":"","type":"syntax","out":"Characters 48-50:\n  let _ = pipe [(fun x -> x+x);;;\n                              ^^\nError: Syntax error\n"},{"in":"let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3","min":"\nlet pipe fs y = let f a x = x a in let base = y in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n","type":"","out":""},{"in":"\n\r\nlet rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l =","min":"","type":"syntax","out":"Characters 119-121:\n  let l =;;\n         ^^\nError: Syntax error\n"},{"in":"(* UNCOMMENT AFTER IMPLEMENTING THE ABOVE*","min":"\n;;\n","type":"","out":""},{"in":"\r\nlet _ = sepConcat \", \" [","min":"","type":"syntax","out":"Characters 26-28:\n  let _ = sepConcat \", \" [;;\n                          ^^\nError: Syntax error\n"},{"in":"\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"","min":"","type":"syntax","out":"Characters 42-44:\n  let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\";;\n                                           ^^\nError: Syntax error\n"},{"in":"let _ = sepConcat \", \" [\"foo\";\"","min":"","type":"syntax","out":"Characters 32-34:\n  let _ = sepConcat \", \" [\"foo\";\"\";;\n                                  ^^\nError: Syntax error\n"}],"event":{"region":{"start":0,"stop":1527},"type":"eval"},"cursor":1527,"time":1.398813119845636e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in \n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\r\n\n\r\nlet pipe fs y=  \n  let f a x = x a in\n  let base = y in\n    List.fold_left f base fs\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = pipe [] 3\n\r\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\r\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\r\n\r\n\n\r\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r   \nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\r  \n\n\n\r  \nlet stringOfList f l = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r  \nlet rec clone x n = failwith \"to be implemented\" \n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet padZero l1 l2 = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet rec removeZero l = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\r  \nlet rec mulByDigit i l = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r  \nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\r  \nexception ErrorCode of string\n\r  \ntype result = Pass | Fail | ErrorCode of string\n\r  \nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\r  \nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\r  \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\r  \nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\r  \nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\r  \nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\r\n  let eq_real p (r1,r2) = \n                    (r1 -. r2) < p || (r2 -. r1) < p\n\r\nlet wrap_curried_2 f (a,b) = f a b\n\r\n    let runAllTests () =\n     let _ = (score := 0; max := 0) in\n     let report = \n     [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\r\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\r\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\r\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\r\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\r\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\r\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n    runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\r\n    runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n    runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\r\nrunTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\r\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\r  \nlet _ = runAllTests ()\n\r  \nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"\n\nlet sqsum xs = \nlet f a x = x * x + a in","min":"","type":"syntax","out":"Characters 42-44:\n  let f a x = x * x + a in;;\n                          ^^\nError: Syntax error\n"},{"in":"\n(* UNCOMMENT AF","min":"\n;;\n","type":"","out":""},{"in":"(* UNCOMMENT AFTER IMPL","min":"\n;;\n","type":"","out":""},{"in":"let _ = sqsum []\nlet _ = sqsum [1;2;3;","min":"","type":"syntax","out":"Characters 37-39:\n  let _ = sqsum [1;2;3;;;\n                      ^^\nError: Syntax error\n"},{"in":"\n\r\nlet pipe fs y=  \nlet f a x = x a in\nlet b","min":"","type":"syntax","out":"Characters 44-46:\n  let b;;\n       ^^\nError: Syntax error\n"},{"in":"(* UNCOMMENT AFTE","min":"\n;;\n","type":"","out":""},{"in":"let _ = pipe [] 3\n\r\nlet _ = pipe [(fun x -> x+x);","min":"","type":"syntax","out":"Characters 48-50:\n  let _ = pipe [(fun x -> x+x);;;\n                              ^^\nError: Syntax error\n"},{"in":"let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3","min":"\nlet pipe fs y = let f a x = x a in let base = y in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n","type":"","out":""},{"in":"\n\r\nlet rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l =","min":"","type":"syntax","out":"Characters 119-121:\n  let l =;;\n         ^^\nError: Syntax error\n"},{"in":"(* UNCOMMENT AFTER IMPLEMENTING THE ABOVE*","min":"\n;;\n","type":"","out":""},{"in":"\r\nlet _ = sepConcat \", \" [","min":"","type":"syntax","out":"Characters 26-28:\n  let _ = sepConcat \", \" [;;\n                          ^^\nError: Syntax error\n"},{"in":"\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"","min":"","type":"syntax","out":"Characters 42-44:\n  let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\";;\n                                           ^^\nError: Syntax error\n"},{"in":"let _ = sepConcat \", \" [\"foo\";\"","min":"","type":"syntax","out":"Characters 32-34:\n  let _ = sepConcat \", \" [\"foo\";\"\";;\n                                  ^^\nError: Syntax error\n"}],"event":{"region":{"start":0,"stop":1527},"type":"eval"},"cursor":1527,"time":1.398814151869468e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in \n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\r\n\n\r\nlet pipe fs y=  \n  let f a x = x a in\n  let base = y in\n    List.fold_left f base fs\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = pipe [] 3\n\r\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\r\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\r\n\r\n\n\r\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r   \nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\r  \n\n\n\r  \nlet stringOfList f l = \n\r  \n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXX*)\n\n\n\r  \n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r  \n  let rec clone x n = failwith \"to be implemented\" \n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet padZero l1 l2 = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet rec removeZero l = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\r  \nlet rec mulByDigit i l = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r  \nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\r  \nexception ErrorCode of string\n\r  \ntype result = Pass | Fail | ErrorCode of string\n\r  \nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\r  \nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\r  \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\r  \nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\r  \nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\r  \nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\r\n  let eq_real p (r1,r2) = \n                    (r1 -. r2) < p || (r2 -. r1) < p\n\r\nlet wrap_curried_2 f (a,b) = f a b\n\r\n    let runAllTests () =\n     let _ = (score := 0; max := 0) in\n     let report = \n     [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\r\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\r\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\r\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\r\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\r\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\r\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n    runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\r\n    runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n    runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\r\nrunTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\r\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\r  \nlet _ = runAllTests ()\n\r  \nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"\n\n\n\r\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ","min":"\nlet stringOfList f l = \"[\" ^ (sepConcat \"; \" (List.map f l));;\n","type":"scope","out":"Characters 34-43:\n  let stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ;;\n                               ^^^^^^^^^\nError: Unbound value sepConcat\n"}],"event":{"region":{"start":1527,"stop":1598},"type":"eval"},"cursor":1592,"time":1.398814548538677e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in \n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\r\n\n\r\nlet pipe fs y=  \n  let f a x = x a in\n  let base = y in\n    List.fold_left f base fs\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = pipe [] 3\n\r\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\r\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\r\n\r\n\n\r\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r   \nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\r  \n\n\n\r  \nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r  \nlet rec clone x n = failwith \"to be implemented\" \n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet padZero l1 l2 = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet rec removeZero l = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\r  \nlet rec mulByDigit i l = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r  \nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\r  \nexception ErrorCode of string\n\r  \ntype result = Pass | Fail | ErrorCode of string\n\r  \nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\r  \nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\r  \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\r  \nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\r  \nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\r  \nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\r\n  let eq_real p (r1,r2) = \n                    (r1 -. r2) < p || (r2 -. r1) < p\n\r\nlet wrap_curried_2 f (a,b) = f a b\n\r\n    let runAllTests () =\n     let _ = (score := 0; max := 0) in\n     let report = \n     [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\r\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\r\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\r\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\r\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\r\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\r\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n    runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\r\n    runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n    runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\r\nrunTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\r\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\r  \nlet _ = runAllTests ()\n\r  \nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = stringOfList str","min":"\nlet _ = stringOfList str;;\n","type":"scope","out":"Characters 13-25:\n  let _ = stringOfList str;;\n          ^^^^^^^^^^^^\nError: Unbound value stringOfList\n"}],"event":{"region":{"start":1598,"stop":1814},"type":"eval"},"cursor":1816,"time":1.398814566600293e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in \n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\r\n\n\r\nlet pipe fs y=  \n  let f a x = x a in\n  let base = y in\n    List.fold_left f base fs\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = pipe [] 3\n\r\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\r\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\r\n\r\n\n\r\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r   \nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\r  \n\n\n\r  \nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r     \nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\r  \n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r  \nlet rec clone x n = failwith \"to be implemented\" \n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet padZero l1 l2 = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet rec removeZero l = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\r  \nlet rec mulByDigit i l = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r  \nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\r  \nexception ErrorCode of string\n\r  \ntype result = Pass | Fail | ErrorCode of string\n\r  \nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\r  \nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\r  \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\r  \nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\r  \nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\r  \nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\r\n  let eq_real p (r1,r2) = \n                    (r1 -. r2) < p || (r2 -. r1) < p\n\r\nlet wrap_curried_2 f (a,b) = f a b\n\r\n    let runAllTests () =\n     let _ = (score := 0; max := 0) in\n     let report = \n     [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\r\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\r\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\r\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\r\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\r\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\r\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n    runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\r\n    runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n    runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\r\nrunTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\r\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\r  \nlet _ = runAllTests ()\n\r  \nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[],"event":{"region":{"start":1742,"stop":1814},"type":"eval"},"cursor":1816,"time":1.398817021629751e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in \n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\r\n\n\r\nlet pipe fs y=  \n  let f a x = x a in\n  let base = y in\n    List.fold_left f base fs\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = pipe [] 3\n\r\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\r\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\r\n\r\n\n\r\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r   \nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\r  \n\n\n\r  \nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r     \nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\r  \n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r  \nlet rec clone x n = failwith \"to be implemented\" \n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet padZero l1 l2 = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet rec removeZero l = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\r  \nlet rec mulByDigit i l = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r  \nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\r  \nexception ErrorCode of string\n\r  \ntype result = Pass | Fail | ErrorCode of string\n\r  \nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\r  \nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\r  \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\r  \nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\r  \nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\r  \nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\r\n  let eq_real p (r1,r2) = \n                    (r1 -. r2) < p || (r2 -. r1) < p\n\r\nlet wrap_curried_2 f (a,b) = f a b\n\r\n    let runAllTests () =\n     let _ = (score := 0; max := 0) in\n     let report = \n     [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\r\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\r\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\r\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\r\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\r\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\r\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n    runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\r\n    runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n    runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\r\nrunTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\r\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\r  \nlet _ = runAllTests ()\n\r  \nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"\n\n\n\r\n(******************************************","min":"\n;;\n","type":"","out":""},{"in":"let rec clone x n = failwith \"to be implemented\"","min":"\nlet rec clone x n = failwith \"to be implemented\";;\n","type":"","out":""},{"in":"\r\n*)\n\r\nlet padZero l1 l2 = failwith \"to be implemen","min":"","type":"syntax","out":"Characters 2-3:\n  *)\n  ^\nError: Syntax error\n"},{"in":"\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\r\n*)\n\r\nlet rec removeZero l = failwith ","min":"","type":"syntax","out":"Characters 69-70:\n  *)\n   ^\nError: Syntax error\n"},{"in":"\n*)\n\r\nlet bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a","min":"","type":"syntax","out":"Characters 1-2:\n  *)\n  ^\nError: Syntax error\n"},{"in":"let args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))\n\r\n(","min":"","type":"syntax","out":"Characters 92-94:\n  in \n  ^^\nError: Syntax error\n"},{"in":"\n\n\n\r\n(****","min":"\n;;\n","type":"","out":""},{"in":"\n\n\r\n(**************","min":"\n;;\n","type":"","out":""},{"in":"\n\r\n(********************************************","min":"\n;;\n","type":"","out":""},{"in":"\n(***************************","min":"\n;;\n","type":"","out":""},{"in":"(******************** DO NOT MODIFY ANYTHING AF","min":"\n;;\n","type":"","out":""},{"in":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","min":"\n;;\n","type":"","out":""},{"in":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","min":"\n;;\n","type":"","out":""},{"in":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","min":"\n;;\n","type":"","out":""},{"in":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 ","min":"","type":"syntax","out":"Characters 52-54:\n  let prefix130 ;;\n                ^^\nError: Syntax error\n"},{"in":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r\n(* C","min":"\n;;\n","type":"","out":""},{"in":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet key","min":"","type":"syntax","out":"Characters 26-28:\n  let key;;\n         ^^\nError: Syntax error\n"},{"in":"\n\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130","min":"\nlet key = \"\" let prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)\n\r\nexcept","min":"\nlet key = \"\" let prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s)) except;;\n","type":"type","out":"Characters 17-29:\n  let print130 s = print_string (prefix130^\">>\"^s)\n                   ^^^^^^^^^^^^\nError: This function has type string -> unit\n       It is applied to too many arguments; maybe you forgot a `;'.\n"},{"in":"\ntype result = Pass | Fail | ErrorCode of strin","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of strin;;\n","type":"scope","out":"Characters 42-47:\n  type result = Pass | Fail | ErrorCode of strin;;\n                                           ^^^^^\nError: Unbound type constructor strin\n"},{"in":"\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\r\nlet runWTimeout (f,","min":"","type":"syntax","out":"Characters 74-76:\n  let runWTimeout (f,;;\n                     ^^\nError: Syntax error: pattern expected.\n"},{"in":"let timeout = 300\n\r\nlet runWTimeout (f,arg,out,tim","min":"","type":"syntax","out":"Characters 50-52:\n  let runWTimeout (f,arg,out,tim;;\n                                ^^\nError: Syntax error: operator expected.\n"},{"in":"let runWTimeout (f,arg,out,time) =","min":"","type":"syntax","out":"Characters 34-36:\n  let runWTimeout (f,arg,out,time) =;;\n                                    ^^\nError: Syntax error\n"}],"event":{"region":{"start":1698,"stop":7478},"type":"eval"},"cursor":1741,"time":1.398817025179032e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in \n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\r\n\n\r\nlet pipe fs y=  \n  let f a x = x a in\n  let base = y in\n    List.fold_left f base fs\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = pipe [] 3\n\r\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\r\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\r\n\r\n\n\r\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r   \nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\r  \n\n\n\r  \nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r     \nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\r  \n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r  \nlet rec clone x n = failwith \"to be implemented\" \n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet padZero l1 l2 = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet rec removeZero l = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\r  \nlet rec mulByDigit i l = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r  \nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\r  \nexception ErrorCode of string\n\r  \ntype result = Pass | Fail | ErrorCode of string\n\r  \nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\r  \nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\r  \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\r  \nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\r  \nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\r  \nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\r\n  let eq_real p (r1,r2) = \n                    (r1 -. r2) < p || (r2 -. r1) < p\n\r\nlet wrap_curried_2 f (a,b) = f a b\n\r\n    let runAllTests () =\n     let _ = (score := 0; max := 0) in\n     let report = \n     [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\r\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\r\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\r\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\r\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\r\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\r\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n    runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\r\n    runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n    runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\r\nrunTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\r\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\r  \nlet _ = runAllTests ()\n\r  \nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"\n\r\nlet pipe fs y=  \nlet f a x = x a in\nlet b","min":"","type":"syntax","out":"Characters 44-46:\n  let b;;\n       ^^\nError: Syntax error\n"}],"event":{"region":{"start":926,"stop":1008},"type":"eval"},"cursor":993,"time":1.398817174725602e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in \n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\r\n\n\r\nlet pipe fs y=  \n  let f a x = x a in\n  let base = y in\n    List.fold_left f base fs\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = pipe [] 3\n\r\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\r\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\r\n\r\n\n\r\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r   \nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\r  \n\n\n\r  \nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r     \nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\r  \n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r  \nlet rec clone x n = failwith \"to be implemented\" \n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet padZero l1 l2 = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet rec removeZero l = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\r  \nlet rec mulByDigit i l = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r  \nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\r  \nexception ErrorCode of string\n\r  \ntype result = Pass | Fail | ErrorCode of string\n\r  \nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\r  \nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\r  \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\r  \nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\r  \nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\r  \nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\r\n  let eq_real p (r1,r2) = \n                    (r1 -. r2) < p || (r2 -. r1) < p\n\r\nlet wrap_curried_2 f (a,b) = f a b\n\r\n    let runAllTests () =\n     let _ = (score := 0; max := 0) in\n     let report = \n     [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\r\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\r\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\r\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\r\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\r\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\r\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n    runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\r\n    runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n    runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\r\nrunTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\r\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\r  \nlet _ = runAllTests ()\n\r  \nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"\n\r\nlet pipe fs =  \nlet f a x = x a in\nlet b","min":"","type":"syntax","out":"Characters 43-45:\n  let b;;\n       ^^\nError: Syntax error\n"},{"in":"(* UNCOMMENT AFTE","min":"\n;;\n","type":"","out":""},{"in":"let _ = pipe [] 3","min":"\nlet pipe fs y = let f a x = x a in let base = y in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n","type":"","out":""}],"event":{"region":{"start":926,"stop":1085},"type":"eval"},"cursor":1085,"time":1.398817437869379e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in \n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\r\n\n\r\nlet pipe fs =  \n  let f a x = x a in\n  let base =  fun y -> y in\n    List.fold_left f base fs\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = pipe [] 3\n\r\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\r\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\r\n\r\n\n\r\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r   \nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\r  \n\n\n\r  \nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r     \nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\r  \n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r  \nlet rec clone x n = failwith \"to be implemented\" \n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet padZero l1 l2 = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet rec removeZero l = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\r  \nlet rec mulByDigit i l = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r  \nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\r  \nexception ErrorCode of string\n\r  \ntype result = Pass | Fail | ErrorCode of string\n\r  \nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\r  \nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\r  \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\r  \nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\r  \nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\r  \nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\r\n  let eq_real p (r1,r2) = \n                    (r1 -. r2) < p || (r2 -. r1) < p\n\r\nlet wrap_curried_2 f (a,b) = f a b\n\r\n    let runAllTests () =\n     let _ = (score := 0; max := 0) in\n     let report = \n     [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\r\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\r\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\r\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\r\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\r\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\r\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n    runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\r\n    runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n    runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\r\nrunTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\r\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\r  \nlet _ = runAllTests ()\n\r  \nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"\n\r\nlet _ = pipe [(fun x -> x+x);","min":"","type":"syntax","out":"Characters 31-33:\n  let _ = pipe [(fun x -> x+x);;;\n                              ^^\nError: Syntax error\n"},{"in":"let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3","min":"\nlet pipe fs y = let f a x = x a in let base = y in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n","type":"","out":""}],"event":{"region":{"start":1085,"stop":1137},"type":"eval"},"cursor":1113,"time":1.398817439300691e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in \n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\r\n\n\r\nlet pipe fs =  \n  let f a x = x a in\n  let base =  fun y -> y in\n    List.fold_left f base fs\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = pipe [] 3\n\r\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\r\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\r\n\r\n\n\r\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r   \nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\r  \n\n\n\r  \nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r     \nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\r  \n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r  \nlet rec clone x n = failwith \"to be implemented\" \n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet padZero l1 l2 = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet rec removeZero l = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\r  \nlet rec mulByDigit i l = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r  \nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\r  \nexception ErrorCode of string\n\r  \ntype result = Pass | Fail | ErrorCode of string\n\r  \nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\r  \nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\r  \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\r  \nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\r  \nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\r  \nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\r\n  let eq_real p (r1,r2) = \n                    (r1 -. r2) < p || (r2 -. r1) < p\n\r\nlet wrap_curried_2 f (a,b) = f a b\n\r\n    let runAllTests () =\n     let _ = (score := 0; max := 0) in\n     let report = \n     [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\r\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\r\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\r\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\r\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\r\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\r\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n    runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\r\n    runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n    runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\r\nrunTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\r\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\r  \nlet _ = runAllTests ()\n\r  \nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"\n\r\nlet _ = pipe [(fun x -> x+x);","min":"","type":"syntax","out":"Characters 31-33:\n  let _ = pipe [(fun x -> x+x);;;\n                              ^^\nError: Syntax error\n"},{"in":"let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3","min":"\nlet pipe fs y = let f a x = x a in let base = y in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n","type":"","out":""}],"event":{"region":{"start":1085,"stop":1189},"type":"eval"},"cursor":1165,"time":1.398817441069222e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in \n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\r\n\n\r\nlet pipe fs =  \n  let f a x = x a in\n  let base =  fun y -> y in\n    List.fold_left f base fs\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = pipe [] 3\n\r\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\r\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\r\n\r\n\n\r\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r   \nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\r  \n\n\n\r  \nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r     \nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\r  \n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r  \nlet rec clone x n = failwith \"to be implemented\" \n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet padZero l1 l2 = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet rec removeZero l = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\r  \nlet rec mulByDigit i l = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r  \nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\r  \nexception ErrorCode of string\n\r  \ntype result = Pass | Fail | ErrorCode of string\n\r  \nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\r  \nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\r  \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\r  \nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\r  \nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\r  \nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\r\n  let eq_real p (r1,r2) = \n                    (r1 -. r2) < p || (r2 -. r1) < p\n\r\nlet wrap_curried_2 f (a,b) = f a b\n\r\n    let runAllTests () =\n     let _ = (score := 0; max := 0) in\n     let report = \n     [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\r\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\r\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\r\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\r\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\r\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\r\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n    runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\r\n    runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n    runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\r\nrunTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\r\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\r  \nlet _ = runAllTests ()\n\r  \nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let pipe fs =  \nlet f a x = x a in\nlet b","min":"","type":"syntax","out":"Characters 40-42:\n  let b;;\n       ^^\nError: Syntax error\n"}],"event":{"region":{"start":932,"stop":1017},"type":"eval"},"cursor":1017,"time":1.398817484905863e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in \n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\r\n\n\r\nlet pipe fs =  \n  let f a x = x a in\n  let base =  fun y -> y in\n    List.fold_left f base fs\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = pipe [] 3\n\r\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\r\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\r\n\r\n\n\r\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r   \nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\r  \n\n\n\r  \nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r     \nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\r  \n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r  \nlet rec clone x n = failwith \"to be implemented\" \n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet padZero l1 l2 = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet rec removeZero l = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\r  \nlet rec mulByDigit i l = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r  \nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\r  \nexception ErrorCode of string\n\r  \ntype result = Pass | Fail | ErrorCode of string\n\r  \nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\r  \nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\r  \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\r  \nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\r  \nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\r  \nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\r\n  let eq_real p (r1,r2) = \n                    (r1 -. r2) < p || (r2 -. r1) < p\n\r\nlet wrap_curried_2 f (a,b) = f a b\n\r\n    let runAllTests () =\n     let _ = (score := 0; max := 0) in\n     let report = \n     [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\r\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\r\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\r\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\r\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\r\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\r\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n    runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\r\n    runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n    runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\r\nrunTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\r\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\r  \nlet _ = runAllTests ()\n\r  \nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"\n\r\nlet pipe fs =  \nlet f a x = x base in\nle","min":"\nlet pipe fs = let f a x = x base in le;;\n","type":"scope","out":"Characters 33-37:\n  let f a x = x base in\n                ^^^^\nError: Unbound value base\n"}],"event":{"region":{"start":926,"stop":1019},"type":"eval"},"cursor":1011,"time":1.398817926517421e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in \n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\r\n\n\r\nlet pipe fs =  \n  let f a x = x base in\n  let base = fun y -> y in\n    List.fold_left f base fs\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = pipe [] 3\n\r\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\r\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\r\n\r\n\n\r\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r   \nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\r  \n\n\n\r  \nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r     \nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\r  \n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r  \nlet rec clone x n = failwith \"to be implemented\" \n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet padZero l1 l2 = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet rec removeZero l = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\r  \nlet rec mulByDigit i l = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r  \nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\r  \nexception ErrorCode of string\n\r  \ntype result = Pass | Fail | ErrorCode of string\n\r  \nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\r  \nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\r  \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\r  \nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\r  \nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\r  \nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\r\n  let eq_real p (r1,r2) = \n                    (r1 -. r2) < p || (r2 -. r1) < p\n\r\nlet wrap_curried_2 f (a,b) = f a b\n\r\n    let runAllTests () =\n     let _ = (score := 0; max := 0) in\n     let report = \n     [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\r\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\r\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\r\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\r\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\r\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\r\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n    runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\r\n    runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n    runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\r\nrunTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\r\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\r  \nlet _ = runAllTests ()\n\r  \nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"\n\r\nlet pipe fs =  \nlet f a x = x' (x a)  in","min":"","type":"syntax","out":"Characters 43-45:\n  let f a x = x' (x a)  in;;\n                          ^^\nError: Syntax error\n"}],"event":{"region":{"start":926,"stop":1022},"type":"eval"},"cursor":1016,"time":1.398817954571302e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in \n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\r\n\n\r\nlet pipe fs =  \n  let f a x = x' (x a)  in\n  let base = fun y -> y in\n    List.fold_left f base fs\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = pipe [] 3\n\r\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\r\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\r\n\r\n\n\r\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r   \nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\r  \n\n\n\r  \nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r     \nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\r  \n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r  \nlet rec clone x n = failwith \"to be implemented\" \n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet padZero l1 l2 = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet rec removeZero l = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\r  \nlet rec mulByDigit i l = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r  \nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\r  \nexception ErrorCode of string\n\r  \ntype result = Pass | Fail | ErrorCode of string\n\r  \nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\r  \nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\r  \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\r  \nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\r  \nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\r  \nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\r\n  let eq_real p (r1,r2) = \n                    (r1 -. r2) < p || (r2 -. r1) < p\n\r\nlet wrap_curried_2 f (a,b) = f a b\n\r\n    let runAllTests () =\n     let _ = (score := 0; max := 0) in\n     let report = \n     [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\r\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\r\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\r\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\r\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\r\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\r\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n    runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\r\n    runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n    runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\r\nrunTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\r\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\r  \nlet _ = runAllTests ()\n\r  \nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"\n\r\nlet pipe fs =  \nlet f a x = fun (x a)  i","min":"","type":"syntax","out":"Characters 35-36:\n  let f a x = fun (x a)  i;;\n                  ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n"}],"event":{"region":{"start":926,"stop":1023},"type":"eval"},"cursor":1012,"time":1.398817960758314e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in \n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\r\n\n\r\nlet pipe fs =  \n  let f a x = fun (x a)  in\n  let base = fun y -> y in\n    List.fold_left f base fs\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = pipe [] 3\n\r\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\r\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\r\n\r\n\n\r\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r   \nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\r  \n\n\n\r  \nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r     \nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\r  \n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r  \nlet rec clone x n = failwith \"to be implemented\" \n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet padZero l1 l2 = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet rec removeZero l = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\r  \nlet rec mulByDigit i l = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r  \nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\r  \nexception ErrorCode of string\n\r  \ntype result = Pass | Fail | ErrorCode of string\n\r  \nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\r  \nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\r  \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\r  \nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\r  \nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\r  \nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\r\n  let eq_real p (r1,r2) = \n                    (r1 -. r2) < p || (r2 -. r1) < p\n\r\nlet wrap_curried_2 f (a,b) = f a b\n\r\n    let runAllTests () =\n     let _ = (score := 0; max := 0) in\n     let report = \n     [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\r\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\r\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\r\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\r\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\r\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\r\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n    runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\r\n    runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n    runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\r\nrunTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\r\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\r  \nlet _ = runAllTests ()\n\r  \nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"\n\r\nlet pipe fs =  \nlet f a x = fun x' ->  x","min":"","type":"syntax","out":"Characters 43-45:\n  let f a x = fun x' ->  x;;\n                          ^^\nError: Syntax error\n"}],"event":{"region":{"start":926,"stop":1028},"type":"eval"},"cursor":1024,"time":1.39881797924775e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in \n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\r\n\n\r\nlet pipe fs =  \n  let f a x = fun x' ->  x a  in\n  let base = fun y -> y in\n    List.fold_left f base fs\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = pipe [] 3\n\r\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\r\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\r\n\r\n\n\r\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r   \nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\r  \n\n\n\r  \nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r     \nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\r  \n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r  \nlet rec clone x n = failwith \"to be implemented\" \n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet padZero l1 l2 = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet rec removeZero l = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\r  \nlet rec mulByDigit i l = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r  \nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\r  \nexception ErrorCode of string\n\r  \ntype result = Pass | Fail | ErrorCode of string\n\r  \nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\r  \nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\r  \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\r  \nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\r  \nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\r  \nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\r\n  let eq_real p (r1,r2) = \n                    (r1 -. r2) < p || (r2 -. r1) < p\n\r\nlet wrap_curried_2 f (a,b) = f a b\n\r\n    let runAllTests () =\n     let _ = (score := 0; max := 0) in\n     let report = \n     [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\r\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\r\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\r\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\r\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\r\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\r\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n    runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\r\n    runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n    runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\r\nrunTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\r\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\r  \nlet _ = runAllTests ()\n\r  \nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"\n\r\nlet pipe fs y=  \nlet f a x = x a  in\nlet ","min":"","type":"syntax","out":"Characters 44-46:\n  let ;;\n      ^^\nError: Syntax error\n"}],"event":{"region":{"start":926,"stop":1009},"type":"eval"},"cursor":996,"time":1.398818022140574e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in \n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\r\n\n\r\nlet pipe fs y=  \n  let f a x = x a  in\n  let base = y in\n    List.fold_left f base fs\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = pipe [] 3\n\r\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\r\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\r\n\r\n\n\r\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r   \nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\r  \n\n\n\r  \nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r     \nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\r  \n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r  \nlet rec clone x n = failwith \"to be implemented\" \n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet padZero l1 l2 = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet rec removeZero l = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\r  \nlet rec mulByDigit i l = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r  \nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\r  \nexception ErrorCode of string\n\r  \ntype result = Pass | Fail | ErrorCode of string\n\r  \nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\r  \nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\r  \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\r  \nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\r  \nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\r  \nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\r\n  let eq_real p (r1,r2) = \n                    (r1 -. r2) < p || (r2 -. r1) < p\n\r\nlet wrap_curried_2 f (a,b) = f a b\n\r\n    let runAllTests () =\n     let _ = (score := 0; max := 0) in\n     let report = \n     [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\r\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\r\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\r\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\r\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\r\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\r\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n    runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\r\n    runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n    runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\r\nrunTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\r\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\r  \nlet _ = runAllTests ()\n\r  \nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"(* UNCOMMENT AFTE","min":"\n;;\n","type":"","out":""},{"in":"let _ = pipe [] 3\n\r\nlet _ = pipe [(fun x -> x+x);","min":"","type":"syntax","out":"Characters 48-50:\n  let _ = pipe [(fun x -> x+x);;;\n                              ^^\nError: Syntax error\n"},{"in":"let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3","min":"\nlet pipe fs y = let f a x = x a in let base = y in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n","type":"","out":""}],"event":{"region":{"start":1009,"stop":1181},"type":"eval"},"cursor":1147,"time":1.398818025540183e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in \n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\r\n\n\r\nlet pipe fs y=  \n  let f a x = x a  in\n  let base = y in\n    List.fold_left f base fs\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = pipe [] 3\n\r\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\r\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\r\n\r\n\n\r\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r   \nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\r  \n\n\n\r  \nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r     \nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\r  \n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r  \nlet rec clone x n = failwith \"to be implemented\" \n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet padZero l1 l2 = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet rec removeZero l = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\r  \nlet rec mulByDigit i l = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r  \nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\r  \nexception ErrorCode of string\n\r  \ntype result = Pass | Fail | ErrorCode of string\n\r  \nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\r  \nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\r  \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\r  \nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\r  \nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\r  \nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\r\n  let eq_real p (r1,r2) = \n                    (r1 -. r2) < p || (r2 -. r1) < p\n\r\nlet wrap_curried_2 f (a,b) = f a b\n\r\n    let runAllTests () =\n     let _ = (score := 0; max := 0) in\n     let report = \n     [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\r\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\r\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\r\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\r\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\r\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\r\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n    runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\r\n    runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n    runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\r\nrunTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\r\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\r  \nlet _ = runAllTests ()\n\r  \nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"\n\r\nlet rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l =","min":"","type":"syntax","out":"Characters 119-121:\n  let l =;;\n         ^^\nError: Syntax error\n"},{"in":"(* UNCOMMENT AFTER IMPLEMENTING THE ABOVE*","min":"\n;;\n","type":"","out":""},{"in":"\r\nlet _ = sepConcat \", \" [","min":"","type":"syntax","out":"Characters 26-28:\n  let _ = sepConcat \", \" [;;\n                          ^^\nError: Syntax error\n"},{"in":"\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"","min":"","type":"syntax","out":"Characters 42-44:\n  let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\";;\n                                           ^^\nError: Syntax error\n"},{"in":"let _ = sepConcat \", \" [\"foo\";\"","min":"","type":"syntax","out":"Characters 32-34:\n  let _ = sepConcat \", \" [\"foo\";\"\";;\n                                  ^^\nError: Syntax error\n"},{"in":"\n\n\n\r\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ","min":"\nlet stringOfList f l = \"[\" ^ (sepConcat \"; \" (List.map f l));;\n","type":"scope","out":"Characters 34-43:\n  let stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ;;\n                               ^^^^^^^^^\nError: Unbound value sepConcat\n"},{"in":"\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (Li","min":"","type":"syntax","out":"Characters 45-46:\n  let stringOfList f l = \"[\" ^ sepConcat \"; \" (Li;;\n                                              ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n"},{"in":"let stringOfList f l = \"[\" ^ sepConcat \";","min":"\nlet stringOfList f l = \"[\" ^ (sepConcat \";\");;\n","type":"scope","out":"Characters 29-38:\n  let stringOfList f l = \"[\" ^ sepConcat \";\";;\n                               ^^^^^^^^^\nError: Unbound value sepConcat\n"},{"in":"\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = stringOfList str","min":"\nlet _ = stringOfList str;;\n","type":"scope","out":"Characters 13-25:\n  let _ = stringOfList str;;\n          ^^^^^^^^^^^^\nError: Unbound value stringOfList\n"},{"in":"\n\n\n\r\n(**","min":"\n;;\n","type":"","out":""},{"in":"(****************","min":"\n;;\n","type":"","out":""},{"in":"(******************* ","min":"\n;;\n","type":"","out":""},{"in":"(***********************","min":"\n;;\n","type":"","out":""},{"in":"else []","min":"","type":"syntax","out":"Characters 0-4:\n  else [];;\n  ^^^^\nError: Syntax error\n"},{"in":"\r\n(* UNCOMMENT AFTER IMPLEMENTING THE ","min":"\n;;\n","type":"","out":""}],"event":{"region":{"start":1181,"stop":2211},"type":"eval"},"cursor":2213,"time":1.398818739128981e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in \n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\r\n\n\r\nlet pipe fs y=  \n  let f a x = x a  in\n  let base = y in\n    List.fold_left f base fs\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = pipe [] 3\n\r\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\r\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\r\n\r\n\n\r\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r   \nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\r  \n\n\n\r  \nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r     \nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\r  \n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r  \nlet rec clone x n = if n > 0 then x :: clone x (n-1)\n  else [];;\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r  \nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\r  \n\n\r  \nlet padZero l1 l2 = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet rec removeZero l = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\r  \nlet rec mulByDigit i l = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r  \nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\r  \nexception ErrorCode of string\n\r  \ntype result = Pass | Fail | ErrorCode of string\n\r  \nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\r  \nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\r  \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\r  \nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\r  \nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\r  \nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\r\n  let eq_real p (r1,r2) = \n                    (r1 -. r2) < p || (r2 -. r1) < p\n\r\nlet wrap_curried_2 f (a,b) = f a b\n\r\n    let runAllTests () =\n     let _ = (score := 0; max := 0) in\n     let report = \n     [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\r\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\r\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\r\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\r\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\r\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\r\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n    runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\r\n    runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n    runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\r\nrunTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\r\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\r  \nlet _ = runAllTests ()\n\r  \nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"\n\n\n\r\n(******************************************************","min":"\n;;\n","type":"","out":""},{"in":"\n(***************","min":"\n;;\n","type":"","out":""},{"in":"(********************","min":"\n;;\n","type":"","out":""},{"in":"(******************* 2. ","min":"\n;;\n","type":"","out":""},{"in":"let rec clone x n = if n > 0 then x :: clone x (","min":"","type":"syntax","out":"Characters 48-50:\n  let rec clone x n = if n > 0 then x :: clone x (;;\n                                                  ^^\nError: Syntax error: operator expected.\n"}],"event":{"region":{"start":1815,"stop":2211},"type":"eval"},"cursor":2213,"time":1.398818864121731e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in \n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\r\n\n\r\nlet pipe fs y=  \n  let f a x = x a  in\n  let base = y in\n    List.fold_left f base fs\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = pipe [] 3\n\r\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\r\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\r\n\r\n\n\r\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r   \nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\r  \n\n\n\r  \nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r     \nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\r  \n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r  \nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r  \nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\r  \n\n\r  \nlet padZero l1 l2 = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet rec removeZero l = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\r  \nlet rec mulByDigit i l = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r  \nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\r  \nexception ErrorCode of string\n\r  \ntype result = Pass | Fail | ErrorCode of string\n\r  \nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\r  \nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\r  \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\r  \nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\r  \nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\r  \nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\r\n  let eq_real p (r1,r2) = \n                    (r1 -. r2) < p || (r2 -. r1) < p\n\r\nlet wrap_curried_2 f (a,b) = f a b\n\r\n    let runAllTests () =\n     let _ = (score := 0; max := 0) in\n     let report = \n     [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\r\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\r\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\r\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\r\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\r\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\r\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n    runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\r\n    runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n    runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\r\nrunTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\r\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\r  \nlet _ = runAllTests ()\n\r  \nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"\r\n","min":"\n;;\n","type":"","out":""},{"in":"\r\n\n\r\nlet padZero l1 l2 = if Lis","min":"","type":"syntax","out":"Characters 31-33:\n  let padZero l1 l2 = if Lis;;\n                            ^^\nError: Syntax error\n"},{"in":"\nlet padZero l1 l2 = if List.length l1 > List.lengt","min":"","type":"syntax","out":"Characters 51-53:\n  let padZero l1 l2 = if List.length l1 > List.lengt;;\n                                                    ^^\nError: Syntax error\n"},{"in":"\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]","min":"\nlet _ = padZero [9; 9] [1; 0; 0; 2] let _ = padZero [1; 0; 0; 2] [9; 9];;\n","type":"scope","out":"Characters 9-16:\n  let _ = padZero [9;9] [1;0;0;2]\n          ^^^^^^^\nError: Unbound value padZero\n"}],"event":{"region":{"start":2211,"stop":2483},"type":"eval"},"cursor":2484,"time":1.398819911921356e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in \n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\r\n\n\r\nlet pipe fs y=  \n  let f a x = x a  in\n  let base = y in\n    List.fold_left f base fs\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = pipe [] 3\n\r\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\r\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\r\n\r\n\n\r\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r   \nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\r  \n\n\n\r  \nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r     \nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\r  \n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r  \nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r  \nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\r  \n\n\r  \nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    clone 0 (List.length l1 - List.length l2)\n  else \n    clone 0 (List.length l2 - List.length l1)\n;;\n\r    \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r       \nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\r    \n\n\r    \nlet rec removeZero l = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\r  \nlet rec mulByDigit i l = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r  \nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\r  \nexception ErrorCode of string\n\r  \ntype result = Pass | Fail | ErrorCode of string\n\r  \nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\r  \nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\r  \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\r  \nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\r  \nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\r  \nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\r\n  let eq_real p (r1,r2) = \n                    (r1 -. r2) < p || (r2 -. r1) < p\n\r\nlet wrap_curried_2 f (a,b) = f a b\n\r\n    let runAllTests () =\n     let _ = (score := 0; max := 0) in\n     let report = \n     [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\r\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\r\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\r\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\r\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\r\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\r\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n    runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\r\n    runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n    runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\r\nrunTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\r\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\r  \nlet _ = runAllTests ()\n\r  \nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"\r\n","min":"\n;;\n","type":"","out":""},{"in":"\r\n\n\r\nlet padZero l1 l2 = if Lis","min":"","type":"syntax","out":"Characters 31-33:\n  let padZero l1 l2 = if Lis;;\n                            ^^\nError: Syntax error\n"},{"in":"\nlet padZero l1 l2 = if List.length l1 > List.lengt","min":"","type":"syntax","out":"Characters 51-53:\n  let padZero l1 l2 = if List.length l1 > List.lengt;;\n                                                    ^^\nError: Syntax error\n"},{"in":"\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9]","min":"\nlet _ = padZero [9; 9] [1; 0; 0; 2] let _ = padZero [1; 0; 0; 2] [9; 9];;\n","type":"scope","out":"Characters 9-16:\n  let _ = padZero [9;9] [1;0;0;2]\n          ^^^^^^^\nError: Unbound value padZero\n"}],"event":{"region":{"start":2211,"stop":2530},"type":"eval"},"cursor":2531,"time":1.398820043011677e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in \n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\r\n\n\r\nlet pipe fs y=  \n  let f a x = x a  in\n  let base = y in\n    List.fold_left f base fs\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = pipe [] 3\n\r\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\r\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\r\n\r\n\n\r\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r   \nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\r  \n\n\n\r  \nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r     \nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\r  \n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r  \nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r  \nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\r  \n\n\r  \nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n\r    \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r       \nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\r    \n\n\r    \nlet rec removeZero l = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\r  \nlet rec mulByDigit i l = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r  \nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\r  \nexception ErrorCode of string\n\r  \ntype result = Pass | Fail | ErrorCode of string\n\r  \nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\r  \nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\r  \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\r  \nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\r  \nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\r  \nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\r\n  let eq_real p (r1,r2) = \n                    (r1 -. r2) < p || (r2 -. r1) < p\n\r\nlet wrap_curried_2 f (a,b) = f a b\n\r\n    let runAllTests () =\n     let _ = (score := 0; max := 0) in\n     let report = \n     [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\r\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\r\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\r\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\r\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\r\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\r\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n    runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\r\n    runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n    runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\r\nrunTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\r\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\r  \nlet _ = runAllTests ()\n\r  \nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"\n\n\r\nlet rec removeZero l = match l with\n| [] -> []\n| h::t -> if h = 0 then removeZero t\nelse h :: removeZero t","min":"\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else h :: (removeZero t);;\n","type":"","out":""}],"event":{"region":{"start":2530,"stop":2643},"type":"eval"},"cursor":2646,"time":1.398820284981868e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in \n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\r\n\n\r\nlet pipe fs y=  \n  let f a x = x a  in\n  let base = y in\n    List.fold_left f base fs\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = pipe [] 3\n\r\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\r\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\r\n\r\n\n\r\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r   \nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\r  \n\n\n\r  \nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r     \nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\r  \n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r  \nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r  \nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\r  \n\n\r  \nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n\r    \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r       \nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\r    \n\n\r    \nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t\n      else h :: removeZero t\n;;\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\r  \nlet rec mulByDigit i l = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r  \nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\r  \nexception ErrorCode of string\n\r  \ntype result = Pass | Fail | ErrorCode of string\n\r  \nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\r  \nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\r  \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\r  \nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\r  \nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\r  \nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\r\n  let eq_real p (r1,r2) = \n                    (r1 -. r2) < p || (r2 -. r1) < p\n\r\nlet wrap_curried_2 f (a,b) = f a b\n\r\n    let runAllTests () =\n     let _ = (score := 0; max := 0) in\n     let report = \n     [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\r\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\r\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\r\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\r\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\r\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\r\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n    runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\r\n    runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n    runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\r\nrunTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\r\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\r  \nlet _ = runAllTests ()\n\r  \nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"\n","min":"\n;;\n","type":"","out":""},{"in":"\r\n(* UNCOMMENT AFTER IMPLEMEN","min":"\n;;\n","type":"","out":""}],"event":{"region":{"start":2643,"stop":2783},"type":"eval"},"cursor":2783,"time":1.398820290440266e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in \n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\r\n\n\r\nlet pipe fs y=  \n  let f a x = x a  in\n  let base = y in\n    List.fold_left f base fs\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = pipe [] 3\n\r\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\r\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\r\n\r\n\n\r\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r   \nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\r  \n\n\n\r  \nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r     \nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\r  \n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r  \nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r  \nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\r  \n\n\r  \nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n\r    \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r       \nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\r    \n\n\r    \nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t\n      else h :: removeZero t\n;;\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r     \nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\r  \n\n\r  \nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\r  \nlet rec mulByDigit i l = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r  \nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\r  \nexception ErrorCode of string\n\r  \ntype result = Pass | Fail | ErrorCode of string\n\r  \nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\r  \nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\r  \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\r  \nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\r  \nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\r  \nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\r\n  let eq_real p (r1,r2) = \n                    (r1 -. r2) < p || (r2 -. r1) < p\n\r\nlet wrap_curried_2 f (a,b) = f a b\n\r\n    let runAllTests () =\n     let _ = (score := 0; max := 0) in\n     let report = \n     [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\r\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\r\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\r\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\r\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\r\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\r\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n    runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\r\n    runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n    runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\r\nrunTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\r\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\r  \nlet _ = runAllTests ()\n\r  \nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"\n\n\r\nlet rec removeZero l = match l with\n| [] -> []\n| h::t -> if h != 0 then t\nelse  removeZero t\n","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then t else removeZero t;;\n","type":"","out":""},{"in":"\r\n(* UNCOMMENT AFTER IMPLEMEN","min":"\n;;\n","type":"","out":""}],"event":{"region":{"start":2530,"stop":2769},"type":"eval"},"cursor":2752,"time":1.398820400228975e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in \n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\r\n\n\r\nlet pipe fs y=  \n  let f a x = x a  in\n  let base = y in\n    List.fold_left f base fs\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = pipe [] 3\n\r\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\r\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\r\n\r\n\n\r\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r   \nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\r  \n\n\n\r  \nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r     \nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\r  \n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r  \nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r  \nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\r  \n\n\r  \nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n\r    \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r       \nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\r    \n\n\r    \nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then t\n      else  removeZero t\n;;\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r     \nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\r  \n\n\r  \nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\r  \nlet rec mulByDigit i l = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r  \nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\r  \nexception ErrorCode of string\n\r  \ntype result = Pass | Fail | ErrorCode of string\n\r  \nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\r  \nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\r  \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\r  \nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\r  \nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\r  \nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\r\n  let eq_real p (r1,r2) = \n                    (r1 -. r2) < p || (r2 -. r1) < p\n\r\nlet wrap_curried_2 f (a,b) = f a b\n\r\n    let runAllTests () =\n     let _ = (score := 0; max := 0) in\n     let report = \n     [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\r\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\r\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\r\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\r\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\r\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\r\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n    runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\r\n    runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n    runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\r\nrunTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\r\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\r  \nlet _ = runAllTests ()\n\r  \nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"\n\n\r\nlet rec removeZero l = match l with\n| [] -> []\n| h::t -> if h != 0 then l\nelse removeZero t\n","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n","type":"","out":""},{"in":"\r\n(* UNCOMMENT AFTER IMPLEMEN","min":"\n;;\n","type":"","out":""}],"event":{"region":{"start":2530,"stop":2768},"type":"eval"},"cursor":2768,"time":1.398820433220025e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in \n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\r\n\n\r\nlet pipe fs y=  \n  let f a x = x a  in\n  let base = y in\n    List.fold_left f base fs\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = pipe [] 3\n\r\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\r\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\r\n\r\n\n\r\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r   \nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\r  \n\n\n\r  \nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r     \nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\r  \n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r  \nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r  \nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\r  \n\n\r  \nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n\r    \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r       \nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\r    \n\n\r    \nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r     \nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\r  \n\n\r  \nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\r  \nlet rec mulByDigit i l = failwith \"to be implemented\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\r  \nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n*)\n\n\n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r  \nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\r  \nexception ErrorCode of string\n\r  \ntype result = Pass | Fail | ErrorCode of string\n\r  \nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\r  \nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\r  \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\r  \nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\r  \n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\r  \nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\r  \nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\r\n  let eq_real p (r1,r2) = \n                    (r1 -. r2) < p || (r2 -. r1) < p\n\r\nlet wrap_curried_2 f (a,b) = f a b\n\r\n    let runAllTests () =\n     let _ = (score := 0; max := 0) in\n     let report = \n     [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\r\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\r\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\r\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\r\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\r\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\r\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n    runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\r\n    runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n    runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\r\nrunTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\r\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\r  \nlet _ = runAllTests ()\n\r  \nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let sqsum xs = \nlet f a x = x * x + a in \nlet base = 0 in\nList.fold_left f base xs","min":"\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n","type":"","out":""},{"in":"let _ = sqsum []","min":"\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [];;\n","type":"","out":""},{"in":"let _ = sqsum [1;2;3;4]","min":"\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sqsum [(-1); (-2); (-3); (-4)]","min":"\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [(-1); (-2); (-3); (-4)];;\n","type":"","out":""},{"in":"\nlet pipe fs y=  \nlet f a x = x a  in\nlet base = y in\nList.fol","min":"\nlet pipe fs y = let f a x = x a in let base = y in List.fol;;\n","type":"scope","out":"Characters 54-62:\n  List.fol;;\n  ^^^^^^^^\nError: Unbound value List.fol\n"},{"in":"\r\nlet _ = pipe []","min":"\nlet pipe fs y = let f a x = x a in let base = y in List.fold_left f base fs;;\n\nlet _ = pipe [];;\n","type":"","out":""},{"in":"\r\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)]","min":"\nlet pipe fs y = let f a x = x a in let base = y in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)];;\n","type":"","out":""},{"in":"\r\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)]","min":"\nlet pipe fs y = let f a x = x a in let base = y in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)];;\n","type":"","out":""},{"in":"\r\nlet rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l =","min":"","type":"syntax","out":"Characters 118-120:\n  let l =;;\n         ^^\nError: Syntax error\n"},{"in":"(* UNCOMMENT AFTER IMPLEMENTING THE ABOVE*","min":"\n;;\n","type":"","out":""},{"in":"\r\nlet _ = sepConcat \", \" [","min":"","type":"syntax","out":"Characters 26-28:\n  let _ = sepConcat \", \" [;;\n                          ^^\nError: Syntax error\n"},{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"scope","out":"Characters 8-17:\n  let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"];;\n          ^^^^^^^^^\nError: Unbound value sepConcat\n"},{"in":"let _ = sepConcat \"---\" []\nlet ","min":"","type":"syntax","out":"Characters 31-33:\n  let ;;\n      ^^\nError: Syntax error\n"},{"in":"\n\r\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ ","min":"","type":"syntax","out":"Characters 64-66:\n  let stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ ;;\n                                                               ^^\nError: Syntax error\n"},{"in":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nle","min":"\nlet _ = le;;\n","type":"scope","out":"Characters 3-5:\n  le;;\n  ^^\nError: Unbound value le\n"},{"in":"\r\nlet _ = stringOfList string_of_int [1;2","min":"","type":"syntax","out":"Characters 41-43:\n  let _ = stringOfList string_of_int [1;2;;\n                                         ^^\nError: Syntax error\n"},{"in":"let _ = stringOfList string_of_int [1;2;3;4;5;6]","min":"\nlet _ = stringOfList string_of_int [1; 2; 3; 4; 5; 6];;\n","type":"scope","out":"Characters 8-20:\n  let _ = stringOfList string_of_int [1;2;3;4;5;6];;\n          ^^^^^^^^^^^^\nError: Unbound value stringOfList\n"},{"in":"let _ = stringOfList ","min":"\nlet _ = stringOfList;;\n","type":"scope","out":"Characters 8-20:\n  let _ = stringOfList ;;\n          ^^^^^^^^^^^^\nError: Unbound value stringOfList\n"},{"in":"(***********************************************************","min":"\n;;\n","type":"","out":""},{"in":"(* UNCOMMENT AFTE","min":"\n;;\n","type":"","out":""},{"in":"\r\nlet _ = clone 3 5;;","min":"\nlet rec clone x n = failwith \"to be implemented\";;\n\nlet _ = clone 3 5;;\n","type":"","out":""},{"in":"let _ = clone 3 5","min":"\nlet rec clone x n = failwith \"to be implemented\";;\n\nlet _ = clone 3 5;;\n","type":"","out":""},{"in":"let ","min":"","type":"syntax","out":"Characters 4-6:\n  let ;;\n      ^^\nError: Syntax error\n"},{"in":"\n\r\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n(l1, List.append (clone 0 (List.length l1 - List.length l2)) l2)","min":"\nlet rec clone x n = failwith \"to be implemented\";;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n","type":"type","out":"Characters 63-127:\n  (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2);;\n  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type unit\n"},{"in":"(* UNCOMMENT AFTER IMPLEMENTING","min":"\n;;\n","type":"","out":""},{"in":"\r\nlet _ = padZero [9;9] [1;0;0;","min":"","type":"syntax","out":"Characters 30-32:\n  let _ = padZero [9;9] [1;0;0;;;\n                              ^^\nError: Syntax error\n"},{"in":"\n\r\nlet rec removeZero l = match l with\n| [] -> []\n| h::t","min":"","type":"syntax","out":"Characters 56-58:\n  | h::t;;\n        ^^\nError: Syntax error: pattern expected.\n"},{"in":"(* UNCOMMENT AFTER IMPLEMENTING TH","min":"\n;;\n","type":"","out":""},{"in":"\r\nlet _ = removeZero [0;","min":"","type":"syntax","out":"Characters 23-25:\n  let _ = removeZero [0;;;\n                       ^^\nError: Syntax error\n"},{"in":"let _ = removeZero [0;0;0;1;","min":"","type":"syntax","out":"Characters 27-29:\n  let _ = removeZero [0;0;0;1;;;\n                             ^^\nError: Syntax error\n"},{"in":"\n\r\nlet bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero","min":"","type":"syntax","out":"Characters 242-243:\n  removeZero (add (padZero;;\n                  ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n"},{"in":"\n\r\nlet rec mulByDigit i l = failwith \"to be implement","min":"\nlet rec mulByDigit i l = failwith \"to be implement\";;\n","type":"","out":""},{"in":"*)\n\r\nlet bigMul l1 l2 = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet","min":"","type":"syntax","out":"Characters 0-1:\n  *)\n  ^\nError: Syntax error\n"},{"in":"(* CSE 130 P","min":"\n;;\n","type":"","out":""},{"in":"\r\nlet key = \"\" (* cha","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" ","min":"\nlet key = \"\" let prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string","min":"\nlet print130 s = print_string;;\n","type":"","out":""},{"in":"exception ErrorCode of string\n\r\ntype result = P","min":"\nexception ErrorCode of string type result =\n                                | P;;\n","type":"","out":""},{"in":"type result = Pas","min":"\ntype result =\n  | Pas;;\n","type":"","out":""},{"in":"\r\nlet score = r","min":"\nlet score = r;;\n","type":"scope","out":"Characters 14-15:\n  let score = r;;\n              ^\nError: Unbound value r\n"},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300\n\r\nlet runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e ->","min":"","type":"syntax","out":"Characters 116-118:\n  with e ->;;\n           ^^\nError: Syntax error\n"},{"in":"with e -> (print130 (\"U","min":"","type":"syntax","out":"Characters 0-4:\n  with e -> (print130 (\"U\";;\n  ^^^^\nError: Syntax error\n"},{"in":"\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \nlet re","min":"","type":"syntax","out":"Characters 26-28:\n  let re;;\n        ^^\nError: Syntax error\n"},{"in":"_exp 0\n\r\nlet implode cs = \nString.concat \"\" (List.map","min":"","type":"syntax","out":"Characters 9-12:\n  let implode cs = \n  ^^^\nError: Syntax error\n"},{"in":"String.concat \"\" (List.map (String.make 1) cs)\n\r\nlet drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';'","min":"","type":"syntax","out":"Characters 49-52:\n  let drop_paren s = \n  ^^^\nError: Syntax error\n"},{"in":"implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\r\nlet eq_real p (r1,r2) = \n(","min":"","type":"syntax","out":"Characters 78-81:\n  let eq_real p (r1,r2) = \n  ^^^\nError: Syntax error\n"},{"in":"let eq_real p (r1,r2) = \n(r1 -. r2","min":"","type":"syntax","out":"Characters 25-26:\n  (r1 -. r2;;\n  ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n"}],"event":{"region":{"start":0,"stop":7798},"type":"eval"},"cursor":0,"time":1.398984152024391e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\n*)\n\n\n\n (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n  let sqsum xs = \n    let f a x = x * x + a in \n      let base = 0 in\nList.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\n          let _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\r\n\n\r  \n  let pipe fs y=  \n    let f a x = x a  in\n      let base = y in\nList.fold_left f base fs\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = pipe [] 3\n\r\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\r\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\r\n\r\n\n\r  \n  let rec sepConcat sep sl = match sl with \n      | [] -> \"\"\n      | h :: t -> \n      let f a x = a ^ sep ^ x in\n        let base = h in\n          let l = t in\nList.fold_left f base l\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\n          let _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\r\n\n\n\r\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\r\n\n\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\r\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\r\n\n\r\n  let padZero l1 l2 = if List.length l1 > List.length l2 then\n  (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n      else \n(List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\n          let _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\r\n\n\r\n    let rec removeZero l = match l with\n    | [] -> []\n      | h::t -> if h != 0 then l\n  else removeZero t\n    ;;\n\r\n   (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\n   let _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\n      let _ = removeZero [0;0;0;0]\n\r\n\n\r\n   let bigAdd l1 l2 = \n   let add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\n                           let base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n  res\n  in \n  removeZero (add (padZero l1 l2))\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXXXX*)\n\n\r\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\r\nlet bigMul l1 l2 = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\n\n\n\n\r\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\n    let key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\r\n    exception ErrorCode of string\n\r\n  type result = Pass | Fail | ErrorCode of string\n\r\n  let score = ref 0\n    let max = ref 0\nlet timeout = 300\n\r\nlet runWTimeout (f,arg,out,time) = \n                               try if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\r\n    exception TestException\n     let testTest () =\n     let testGood x = 1 in\n     let testBad x = 0 in \n     let testException x = raise TestException in\n     let rec testTimeout x = testTimeout x in\n     runWTimeout(testGood,0,1,5) = Pass &&  \n     runWTimeout(testBad,0,1,5) = Fail &&  \n     runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n     runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\r\n     let runTest (f,arg,out,points,name) =\n     let _ = max := !max + points in\n     let outs = \n     match runWTimeout(f,arg,out,timeout) with \n     Pass -> (score := !score + points; \"[pass]\")\n     | Fail -> \"[fail]\"\n     | ErrorCode e -> \"[error: \"^e^\"]\"  in\n     name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\r\n     (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n     let explode s = \n     let rec _exp i = \n     if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n     _exp 0\n\r\n     let implode cs = \n     String.concat \"\" (List.map (String.make 1) cs)\n\r\n    let drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\r    \n    let eq_real p (r1,r2) = \n    (r1 -. r2) < p || (r2 -. r1) < p\n\r          \n          let wrap_curried_2 f (a,b) = f a b\n\r          \n          let runAllTests () =\nlet _ = (score := 0; max := 0) in\n     let report = \n     [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\r\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\r\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\r\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\r\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\r\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\r\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n    runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\r\n    runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n    runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\r\nrunTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\r\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\r  \nlet _ = runAllTests ()\n\r  \nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let sqsum xs = \nlet f a x = x * x + a in \nlet base = 0 in\nList.fold_left f base xs","min":"\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n","type":"","out":""},{"in":"let _ = sqsum []","min":"\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [];;\n","type":"","out":""},{"in":"let _ = sqsum [1;2;3;4]","min":"\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sqsum [(-1); (-2); (-3); (-4)]","min":"\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [(-1); (-2); (-3); (-4)];;\n","type":"","out":""},{"in":"\nlet pipe fs y=  \nlet f a x = x a  in\nlet base = y in\nList.fol","min":"\nlet pipe fs y = let f a x = x a in let base = y in List.fol;;\n","type":"scope","out":"Characters 54-62:\n  List.fol;;\n  ^^^^^^^^\nError: Unbound value List.fol\n"},{"in":"\r\nlet _ = pipe []","min":"\nlet pipe fs y = let f a x = x a in let base = y in List.fold_left f base fs;;\n\nlet _ = pipe [];;\n","type":"","out":""},{"in":"\r\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)]","min":"\nlet pipe fs y = let f a x = x a in let base = y in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)];;\n","type":"","out":""},{"in":"\r\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)]","min":"\nlet pipe fs y = let f a x = x a in let base = y in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)];;\n","type":"","out":""},{"in":"\r\nlet rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l =","min":"","type":"syntax","out":"Characters 118-120:\n  let l =;;\n         ^^\nError: Syntax error\n"},{"in":"(* UNCOMMENT AFTER IMPLEMENTING THE ABOVE*","min":"\n;;\n","type":"","out":""},{"in":"\r\nlet _ = sepConcat \", \" [","min":"","type":"syntax","out":"Characters 26-28:\n  let _ = sepConcat \", \" [;;\n                          ^^\nError: Syntax error\n"},{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"scope","out":"Characters 8-17:\n  let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"];;\n          ^^^^^^^^^\nError: Unbound value sepConcat\n"},{"in":"let _ = sepConcat \"---\" []\nlet ","min":"","type":"syntax","out":"Characters 31-33:\n  let ;;\n      ^^\nError: Syntax error\n"},{"in":"\n\r\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ ","min":"","type":"syntax","out":"Characters 64-66:\n  let stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ ;;\n                                                               ^^\nError: Syntax error\n"},{"in":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nle","min":"\nlet _ = le;;\n","type":"scope","out":"Characters 3-5:\n  le;;\n  ^^\nError: Unbound value le\n"},{"in":"\r\nlet _ = stringOfList string_of_int [1;2","min":"","type":"syntax","out":"Characters 41-43:\n  let _ = stringOfList string_of_int [1;2;;\n                                         ^^\nError: Syntax error\n"},{"in":"let _ = stringOfList string_of_int [1;2;3;4;5;6]","min":"\nlet _ = stringOfList string_of_int [1; 2; 3; 4; 5; 6];;\n","type":"scope","out":"Characters 8-20:\n  let _ = stringOfList string_of_int [1;2;3;4;5;6];;\n          ^^^^^^^^^^^^\nError: Unbound value stringOfList\n"},{"in":"let _ = stringOfList ","min":"\nlet _ = stringOfList;;\n","type":"scope","out":"Characters 8-20:\n  let _ = stringOfList ;;\n          ^^^^^^^^^^^^\nError: Unbound value stringOfList\n"},{"in":"(***********************************************************","min":"\n;;\n","type":"","out":""},{"in":"(* UNCOMMENT AFTE","min":"\n;;\n","type":"","out":""},{"in":"\r\nlet _ = clone 3 5;;","min":"\nlet rec clone x n = failwith \"to be implemented\";;\n\nlet _ = clone 3 5;;\n","type":"","out":""},{"in":"let _ = clone 3 5","min":"\nlet rec clone x n = failwith \"to be implemented\";;\n\nlet _ = clone 3 5;;\n","type":"","out":""},{"in":"let ","min":"","type":"syntax","out":"Characters 4-6:\n  let ;;\n      ^^\nError: Syntax error\n"},{"in":"\n\r\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n(l1, List.append (clone 0 (List.length l1 - List.length l2)) l2)","min":"\nlet rec clone x n = failwith \"to be implemented\";;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n","type":"type","out":"Characters 63-127:\n  (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2);;\n  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type unit\n"},{"in":"(* UNCOMMENT AFTER IMPLEMENTING","min":"\n;;\n","type":"","out":""},{"in":"\r\nlet _ = padZero [9;9] [1;0;0;","min":"","type":"syntax","out":"Characters 30-32:\n  let _ = padZero [9;9] [1;0;0;;;\n                              ^^\nError: Syntax error\n"},{"in":"\n\r\nlet rec removeZero l = match l with\n| [] -> []\n| h::t","min":"","type":"syntax","out":"Characters 56-58:\n  | h::t;;\n        ^^\nError: Syntax error: pattern expected.\n"},{"in":"(* UNCOMMENT AFTER IMPLEMENTING TH","min":"\n;;\n","type":"","out":""},{"in":"\r\nlet _ = removeZero [0;","min":"","type":"syntax","out":"Characters 23-25:\n  let _ = removeZero [0;;;\n                       ^^\nError: Syntax error\n"},{"in":"let _ = removeZero [0;0;0;1;","min":"","type":"syntax","out":"Characters 27-29:\n  let _ = removeZero [0;0;0;1;;;\n                             ^^\nError: Syntax error\n"},{"in":"\n\r\nlet bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero","min":"","type":"syntax","out":"Characters 242-243:\n  removeZero (add (padZero;;\n                  ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n"},{"in":"\n\r\nlet rec mulByDigit i l = failwith \"to be implement","min":"\nlet rec mulByDigit i l = failwith \"to be implement\";;\n","type":"","out":""},{"in":"*)\n\r\nlet bigMul l1 l2 = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet","min":"","type":"syntax","out":"Characters 0-1:\n  *)\n  ^\nError: Syntax error\n"},{"in":"(* CSE 130 P","min":"\n;;\n","type":"","out":""},{"in":"\r\nlet key = \"\" (* cha","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" ","min":"\nlet key = \"\" let prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string","min":"\nlet print130 s = print_string;;\n","type":"","out":""},{"in":"exception ErrorCode of string\n\r\ntype result = P","min":"\nexception ErrorCode of string type result =\n                                | P;;\n","type":"","out":""},{"in":"type result = Pas","min":"\ntype result =\n  | Pas;;\n","type":"","out":""},{"in":"\r\nlet score = r","min":"\nlet score = r;;\n","type":"scope","out":"Characters 14-15:\n  let score = r;;\n              ^\nError: Unbound value r\n"},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300\n\r\nlet runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e ->","min":"","type":"syntax","out":"Characters 116-118:\n  with e ->;;\n           ^^\nError: Syntax error\n"},{"in":"with e -> (print130 (\"U","min":"","type":"syntax","out":"Characters 0-4:\n  with e -> (print130 (\"U\";;\n  ^^^^\nError: Syntax error\n"},{"in":"\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \nlet re","min":"","type":"syntax","out":"Characters 26-28:\n  let re;;\n        ^^\nError: Syntax error\n"},{"in":"_exp 0\n\r\nlet implode cs = \nString.concat \"\" (List.map","min":"","type":"syntax","out":"Characters 9-12:\n  let implode cs = \n  ^^^\nError: Syntax error\n"},{"in":"String.concat \"\" (List.map (String.make 1) cs)\n\r\nlet drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';'","min":"","type":"syntax","out":"Characters 49-52:\n  let drop_paren s = \n  ^^^\nError: Syntax error\n"},{"in":"implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\r\nlet eq_real p (r1,r2) = \n(","min":"","type":"syntax","out":"Characters 78-81:\n  let eq_real p (r1,r2) = \n  ^^^\nError: Syntax error\n"},{"in":"let eq_real p (r1,r2) = \n(r1 -. r2","min":"","type":"syntax","out":"Characters 25-26:\n  (r1 -. r2;;\n  ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n"}],"event":{"region":{"start":0,"stop":7798},"type":"eval"},"cursor":0,"time":1.398984165859934e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\n*)\n\n\n\n (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n  let sqsum xs = \n    let f a x = x * x + a in \n      let base = 0 in\nList.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\n          let _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\r\n\n\r  \n  let pipe fs y=  \n    let f a x = x a  in\n      let base = y in\nList.fold_left f base fs\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = pipe [] 3\n\r\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\r\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\r\n\r\n\n\r  \n  let rec sepConcat sep sl = match sl with \n      | [] -> \"\"\n      | h :: t -> \n      let f a x = a ^ sep ^ x in\n        let base = h in\n          let l = t in\nList.fold_left f base l\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\n          let _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\r\n\n\n\r\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\r\n\n\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\r\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\r\n\n\r\n  let padZero l1 l2 = if List.length l1 > List.length l2 then\n  (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n      else \n(List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\n          let _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\r\n\n\r\n    let rec removeZero l = match l with\n    | [] -> []\n      | h::t -> if h != 0 then l\n  else removeZero t\n    ;;\n\r\n   (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\n   let _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\n      let _ = removeZero [0;0;0;0]\n\r\n\n\r\n   let bigAdd l1 l2 = \n   let add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\n                           let base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n  res\n  in \n  removeZero (add (padZero l1 l2))\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXXXX*)\n\n\r\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\r\nlet bigMul l1 l2 = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\n\n\n\n\r\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\n    let key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\r\n    exception ErrorCode of string\n\r\n  type result = Pass | Fail | ErrorCode of string\n\r\n  let score = ref 0\n    let max = ref 0\nlet timeout = 300\n\r\nlet runWTimeout (f,arg,out,time) = \n                               try if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\r\n    exception TestException\n     let testTest () =\n     let testGood x = 1 in\n     let testBad x = 0 in \n     let testException x = raise TestException in\n     let rec testTimeout x = testTimeout x in\n     runWTimeout(testGood,0,1,5) = Pass &&  \n     runWTimeout(testBad,0,1,5) = Fail &&  \n     runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n     runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\r\n     let runTest (f,arg,out,points,name) =\n     let _ = max := !max + points in\n     let outs = \n     match runWTimeout(f,arg,out,timeout) with \n     Pass -> (score := !score + points; \"[pass]\")\n     | Fail -> \"[fail]\"\n     | ErrorCode e -> \"[error: \"^e^\"]\"  in\n     name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\r\n     (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n     let explode s = \n     let rec _exp i = \n     if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n     _exp 0\n\r\n     let implode cs = \n     String.concat \"\" (List.map (String.make 1) cs)\n\r\n    let drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\r    \n    let eq_real p (r1,r2) = \n    (r1 -. r2) < p || (r2 -. r1) < p\n\r          \n          let wrap_curried_2 f (a,b) = f a b\n\r          \n          let runAllTests () =\nlet _ = (score := 0; max := 0) in\n     let report = \n     [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\r\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\r\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\r\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\r\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\r\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\r\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n    runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\r\n    runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n    runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\r\nrunTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\r\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\r  \nlet _ = runAllTests ()\n\r  \nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let sqsum xs = \nlet f a x = x * x + a in","min":"","type":"syntax","out":"Characters 40-42:\n  let f a x = x * x + a in;;\n                          ^^\nError: Syntax error\n"}],"event":{"region":{"start":0,"stop":757},"type":"eval"},"cursor":716,"time":1.398984206717648e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\n*)\n\n\n\n (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n  let sqsum xs = \n    let f a x = x * x + a in \n      let base = 0 in\nList.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\n          let _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\r\n\n\r  \n  let pipe fs y=  \n    let f a x = x a  in\n      let base = y in\nList.fold_left f base fs\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = pipe [] 3\n\r\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\r\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\r\n\r\n\n\r  \n  let rec sepConcat sep sl = match sl with \n      | [] -> \"\"\n      | h :: t -> \n      let f a x = a ^ sep ^ x in\n        let base = h in\n          let l = t in\nList.fold_left f base l\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\n          let _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\r\n\n\n\r\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\r\n\n\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\r\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\r\n\n\r\n  let padZero l1 l2 = if List.length l1 > List.length l2 then\n  (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n      else \n(List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\n          let _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\r\n\n\r\n    let rec removeZero l = match l with\n    | [] -> []\n      | h::t -> if h != 0 then l\n  else removeZero t\n    ;;\n\r\n   (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\n   let _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\n      let _ = removeZero [0;0;0;0]\n\r\n\n\r\n   let bigAdd l1 l2 = \n   let add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\n                           let base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n  res\n  in \n  removeZero (add (padZero l1 l2))\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXXXX*)\n\n\r\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\r\nlet bigMul l1 l2 = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\n\n\n\n\r\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\n    let key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\r\n    exception ErrorCode of string\n\r\n  type result = Pass | Fail | ErrorCode of string\n\r\n  let score = ref 0\n    let max = ref 0\nlet timeout = 300\n\r\nlet runWTimeout (f,arg,out,time) = \n                               try if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\r\n    exception TestException\n     let testTest () =\n     let testGood x = 1 in\n     let testBad x = 0 in \n     let testException x = raise TestException in\n     let rec testTimeout x = testTimeout x in\n     runWTimeout(testGood,0,1,5) = Pass &&  \n     runWTimeout(testBad,0,1,5) = Fail &&  \n     runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n     runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\r\n     let runTest (f,arg,out,points,name) =\n     let _ = max := !max + points in\n     let outs = \n     match runWTimeout(f,arg,out,timeout) with \n     Pass -> (score := !score + points; \"[pass]\")\n     | Fail -> \"[fail]\"\n     | ErrorCode e -> \"[error: \"^e^\"]\"  in\n     name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\r\n     (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n     let explode s = \n     let rec _exp i = \n     if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n     _exp 0\n\r\n     let implode cs = \n     String.concat \"\" (List.map (String.make 1) cs)\n\r\n    let drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\r    \n    let eq_real p (r1,r2) = \n    (r1 -. r2) < p || (r2 -. r1) < p\n\r          \n          let wrap_curried_2 f (a,b) = f a b\n\r          \n          let runAllTests () =\nlet _ = (score := 0; max := 0) in\n     let report = \n     [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\r\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\r\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\r\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\r\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\r\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\r\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n    runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\r\n    runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n    runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\r\nrunTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\r\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\r  \nlet _ = runAllTests ()\n\r  \nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":";;","min":"\n;;\n","type":"","out":""},{"in":"let sqsum xs = \nlet f a x = x * x + a in","min":"","type":"syntax","out":"Characters 40-42:\n  let f a x = x * x + a in;;\n                          ^^\nError: Syntax error\n"}],"event":{"region":{"start":582,"stop":761},"type":"eval"},"cursor":720,"time":1.398984235552036e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\n*)\n\n\n\n (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n;;\n\n\n  let sqsum xs = \n    let f a x = x * x + a in \n      let base = 0 in\nList.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\n          let _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\r\n\n\r  \n  let pipe fs y=  \n    let f a x = x a  in\n      let base = y in\nList.fold_left f base fs\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = pipe [] 3\n\r\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\r\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\r\n\r\n\n\r  \n  let rec sepConcat sep sl = match sl with \n      | [] -> \"\"\n      | h :: t -> \n      let f a x = a ^ sep ^ x in\n        let base = h in\n          let l = t in\nList.fold_left f base l\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\n          let _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\r\n\n\n\r\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\r\n\n\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\r\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\r\n\n\r\n  let padZero l1 l2 = if List.length l1 > List.length l2 then\n  (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n      else \n(List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\n          let _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\r\n\n\r\n    let rec removeZero l = match l with\n    | [] -> []\n      | h::t -> if h != 0 then l\n  else removeZero t\n    ;;\n\r\n   (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\n   let _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\n      let _ = removeZero [0;0;0;0]\n\r\n\n\r\n   let bigAdd l1 l2 = \n   let add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\n                           let base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n  res\n  in \n  removeZero (add (padZero l1 l2))\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXXXX*)\n\n\r\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\r\nlet bigMul l1 l2 = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\n\n\n\n\r\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\n    let key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\r\n    exception ErrorCode of string\n\r\n  type result = Pass | Fail | ErrorCode of string\n\r\n  let score = ref 0\n    let max = ref 0\nlet timeout = 300\n\r\nlet runWTimeout (f,arg,out,time) = \n                               try if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\r\n    exception TestException\n     let testTest () =\n     let testGood x = 1 in\n     let testBad x = 0 in \n     let testException x = raise TestException in\n     let rec testTimeout x = testTimeout x in\n     runWTimeout(testGood,0,1,5) = Pass &&  \n     runWTimeout(testBad,0,1,5) = Fail &&  \n     runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n     runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\r\n     let runTest (f,arg,out,points,name) =\n     let _ = max := !max + points in\n     let outs = \n     match runWTimeout(f,arg,out,timeout) with \n     Pass -> (score := !score + points; \"[pass]\")\n     | Fail -> \"[fail]\"\n     | ErrorCode e -> \"[error: \"^e^\"]\"  in\n     name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\r\n     (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n     let explode s = \n     let rec _exp i = \n     if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n     _exp 0\n\r\n     let implode cs = \n     String.concat \"\" (List.map (String.make 1) cs)\n\r\n    let drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\r    \n    let eq_real p (r1,r2) = \n    (r1 -. r2) < p || (r2 -. r1) < p\n\r          \n          let wrap_curried_2 f (a,b) = f a b\n\r          \n          let runAllTests () =\nlet _ = (score := 0; max := 0) in\n     let report = \n     [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\r\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\r\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\r\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\r\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\r\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\r\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n    runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\r\n    runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n    runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\r\nrunTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\r\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\r  \nlet _ = runAllTests ()\n\r  \nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let sqsum xs = \nlet f a x = x * x + a in","min":"","type":"syntax","out":"Characters 40-42:\n  let f a x = x * x + a in;;\n                          ^^\nError: Syntax error\n"}],"event":{"region":{"start":0,"stop":758},"type":"eval"},"cursor":800,"time":1.398984324439121e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\n*)\n\n\n\n (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n  let sqsum xs = \n    let f a x = x * x + a in \n      let base = 0 in\nList.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\n          let _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\r\n\n\r  \n  let pipe fs y=  \n    let f a x = x a  in\n      let base = y in\nList.fold_left f base fs\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = pipe [] 3\n\r\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\r\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\r\n\r\n\n\r  \n  let rec sepConcat sep sl = match sl with \n      | [] -> \"\"\n      | h :: t -> \n      let f a x = a ^ sep ^ x in\n        let base = h in\n          let l = t in\nList.fold_left f base l\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\n          let _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\r\n\n\n\r\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\r\n\n\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\r\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\r\n\n\r\n  let padZero l1 l2 = if List.length l1 > List.length l2 then\n  (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n      else \n(List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\n          let _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\r\n\n\r\n    let rec removeZero l = match l with\n    | [] -> []\n      | h::t -> if h != 0 then l\n  else removeZero t\n    ;;\n\r\n   (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\n   let _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\n      let _ = removeZero [0;0;0;0]\n\r\n\n\r\n   let bigAdd l1 l2 = \n   let add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\n                           let base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n  res\n  in \n  removeZero (add (padZero l1 l2))\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXXXX*)\n\n\r\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\r\nlet bigMul l1 l2 = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\n\n\n\n\r\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\n    let key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\r\n    exception ErrorCode of string\n\r\n  type result = Pass | Fail | ErrorCode of string\n\r\n  let score = ref 0\n    let max = ref 0\nlet timeout = 300\n\r\nlet runWTimeout (f,arg,out,time) = \n                               try if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\r\n    exception TestException\n     let testTest () =\n     let testGood x = 1 in\n     let testBad x = 0 in \n     let testException x = raise TestException in\n     let rec testTimeout x = testTimeout x in\n     runWTimeout(testGood,0,1,5) = Pass &&  \n     runWTimeout(testBad,0,1,5) = Fail &&  \n     runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n     runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\r\n     let runTest (f,arg,out,points,name) =\n     let _ = max := !max + points in\n     let outs = \n     match runWTimeout(f,arg,out,timeout) with \n     Pass -> (score := !score + points; \"[pass]\")\n     | Fail -> \"[fail]\"\n     | ErrorCode e -> \"[error: \"^e^\"]\"  in\n     name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\r\n     (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n     let explode s = \n     let rec _exp i = \n     if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n     _exp 0\n\r\n     let implode cs = \n     String.concat \"\" (List.map (String.make 1) cs)\n\r\n    let drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\r    \n    let eq_real p (r1,r2) = \n    (r1 -. r2) < p || (r2 -. r1) < p\n\r          \n          let wrap_curried_2 f (a,b) = f a b\n\r          \n          let runAllTests () =\nlet _ = (score := 0; max := 0) in\n     let report = \n     [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\r\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\r\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\r\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\r\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\r\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\r\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n    runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\r\n    runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n    runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\r\nrunTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\r\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\r  \nlet _ = runAllTests ()\n\r  \nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":";;","min":"\n;;\n","type":"","out":""},{"in":"let sqsum xs = \nlet f a x = x * x + a in","min":"","type":"syntax","out":"Characters 40-42:\n  let f a x = x * x + a in;;\n                          ^^\nError: Syntax error\n"}],"event":{"region":{"start":582,"stop":760},"type":"eval"},"cursor":802,"time":1.398984339749576e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\n*)\n\n\n\n (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n;;\n\n  let sqsum xs = \n    let f a x = x * x + a in \n      let base = 0 in\nList.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\n          let _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\r\n\n\r  \n  let pipe fs y=  \n    let f a x = x a  in\n      let base = y in\nList.fold_left f base fs\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = pipe [] 3\n\r\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\r\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\r\n\r\n\n\r  \n  let rec sepConcat sep sl = match sl with \n      | [] -> \"\"\n      | h :: t -> \n      let f a x = a ^ sep ^ x in\n        let base = h in\n          let l = t in\nList.fold_left f base l\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\n          let _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\r\n\n\n\r\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\r\n\n\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\r\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\r\n\n\r\n  let padZero l1 l2 = if List.length l1 > List.length l2 then\n  (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n      else \n(List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\n          let _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\r\n\n\r\n    let rec removeZero l = match l with\n    | [] -> []\n      | h::t -> if h != 0 then l\n  else removeZero t\n    ;;\n\r\n   (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\n   let _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\n      let _ = removeZero [0;0;0;0]\n\r\n\n\r\n   let bigAdd l1 l2 = \n   let add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\n                           let base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n  res\n  in \n  removeZero (add (padZero l1 l2))\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXXXX*)\n\n\r\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\r\nlet bigMul l1 l2 = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\n\n\n\n\r\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\n    let key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\r\n    exception ErrorCode of string\n\r\n  type result = Pass | Fail | ErrorCode of string\n\r\n  let score = ref 0\n    let max = ref 0\nlet timeout = 300\n\r\nlet runWTimeout (f,arg,out,time) = \n                               try if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\r\n    exception TestException\n     let testTest () =\n     let testGood x = 1 in\n     let testBad x = 0 in \n     let testException x = raise TestException in\n     let rec testTimeout x = testTimeout x in\n     runWTimeout(testGood,0,1,5) = Pass &&  \n     runWTimeout(testBad,0,1,5) = Fail &&  \n     runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n     runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\r\n     let runTest (f,arg,out,points,name) =\n     let _ = max := !max + points in\n     let outs = \n     match runWTimeout(f,arg,out,timeout) with \n     Pass -> (score := !score + points; \"[pass]\")\n     | Fail -> \"[fail]\"\n     | ErrorCode e -> \"[error: \"^e^\"]\"  in\n     name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\r\n     (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n     let explode s = \n     let rec _exp i = \n     if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n     _exp 0\n\r\n     let implode cs = \n     String.concat \"\" (List.map (String.make 1) cs)\n\r\n    let drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\r    \n    let eq_real p (r1,r2) = \n    (r1 -. r2) < p || (r2 -. r1) < p\n\r          \n          let wrap_curried_2 f (a,b) = f a b\n\r          \n          let runAllTests () =\nlet _ = (score := 0; max := 0) in\n     let report = \n     [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\r\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\r\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\r\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\r\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\r\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\r\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n    runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\r\n    runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n    runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\r\nrunTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\r\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\r  \nlet _ = runAllTests ()\n\r  \nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let sqsum xs = \nlet f a x = x * x + a in\nlet base = 0 in\nList.fold_left f base xs","min":"\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n","type":"","out":""},{"in":"let _ = sqsum []","min":"\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [];;\n","type":"","out":""},{"in":"let _ = sqsum [1;2;3;4]","min":"\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sqsum [(-1); (-2); (-3); (-4)]","min":"\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [(-1); (-2); (-3); (-4)];;\n","type":"","out":""},{"in":"\nlet pipe fs y=  \nlet f a x = x a  in\nlet base = y in\nList.fol","min":"\nlet pipe fs y = let f a x = x a in let base = y in List.fol;;\n","type":"scope","out":"Characters 54-62:\n  List.fol;;\n  ^^^^^^^^\nError: Unbound value List.fol\n"},{"in":"\r\nlet _ = pipe []","min":"\nlet pipe fs y = let f a x = x a in let base = y in List.fold_left f base fs;;\n\nlet _ = pipe [];;\n","type":"","out":""},{"in":"\r\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)]","min":"\nlet pipe fs y = let f a x = x a in let base = y in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)];;\n","type":"","out":""},{"in":"\r\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)]","min":"\nlet pipe fs y = let f a x = x a in let base = y in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)];;\n","type":"","out":""},{"in":"\r\nlet rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l =","min":"","type":"syntax","out":"Characters 118-120:\n  let l =;;\n         ^^\nError: Syntax error\n"},{"in":"(* UNCOMMENT AFTER IMPLEMENTING THE ABOVE*","min":"\n;;\n","type":"","out":""},{"in":"\r\nlet _ = sepConcat \", \" [","min":"","type":"syntax","out":"Characters 26-28:\n  let _ = sepConcat \", \" [;;\n                          ^^\nError: Syntax error\n"},{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"scope","out":"Characters 8-17:\n  let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"];;\n          ^^^^^^^^^\nError: Unbound value sepConcat\n"},{"in":"let _ = sepConcat \"---\" []\nlet ","min":"","type":"syntax","out":"Characters 31-33:\n  let ;;\n      ^^\nError: Syntax error\n"},{"in":"\n\r\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ ","min":"","type":"syntax","out":"Characters 64-66:\n  let stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ ;;\n                                                               ^^\nError: Syntax error\n"},{"in":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nle","min":"\nlet _ = le;;\n","type":"scope","out":"Characters 3-5:\n  le;;\n  ^^\nError: Unbound value le\n"},{"in":"\r\nlet _ = stringOfList string_of_int [1;2","min":"","type":"syntax","out":"Characters 41-43:\n  let _ = stringOfList string_of_int [1;2;;\n                                         ^^\nError: Syntax error\n"},{"in":"let _ = stringOfList string_of_int [1;2;3;4;5;6]","min":"\nlet _ = stringOfList string_of_int [1; 2; 3; 4; 5; 6];;\n","type":"scope","out":"Characters 8-20:\n  let _ = stringOfList string_of_int [1;2;3;4;5;6];;\n          ^^^^^^^^^^^^\nError: Unbound value stringOfList\n"},{"in":"let _ = stringOfList ","min":"\nlet _ = stringOfList;;\n","type":"scope","out":"Characters 8-20:\n  let _ = stringOfList ;;\n          ^^^^^^^^^^^^\nError: Unbound value stringOfList\n"},{"in":"(***********************************************************","min":"\n;;\n","type":"","out":""},{"in":"(* UNCOMMENT AFTE","min":"\n;;\n","type":"","out":""},{"in":"\r\nlet _ = clone 3 5;;","min":"\nlet rec clone x n = failwith \"to be implemented\";;\n\nlet _ = clone 3 5;;\n","type":"","out":""},{"in":"let _ = clone 3 5","min":"\nlet rec clone x n = failwith \"to be implemented\";;\n\nlet _ = clone 3 5;;\n","type":"","out":""},{"in":"let ","min":"","type":"syntax","out":"Characters 4-6:\n  let ;;\n      ^^\nError: Syntax error\n"},{"in":"\n\r\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n(l1, List.append (clone 0 (List.length l1 - List.length l2)) l2)","min":"\nlet rec clone x n = failwith \"to be implemented\";;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n","type":"type","out":"Characters 63-127:\n  (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2);;\n  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type unit\n"},{"in":"(* UNCOMMENT AFTER IMPLEMENTING","min":"\n;;\n","type":"","out":""},{"in":"\r\nlet _ = padZero [9;9] [1;0;0;","min":"","type":"syntax","out":"Characters 30-32:\n  let _ = padZero [9;9] [1;0;0;;;\n                              ^^\nError: Syntax error\n"},{"in":"\n\r\nlet rec removeZero l = match l with\n| [] -> []\n| h::t","min":"","type":"syntax","out":"Characters 56-58:\n  | h::t;;\n        ^^\nError: Syntax error: pattern expected.\n"},{"in":"(* UNCOMMENT AFTER IMPLEMENTING TH","min":"\n;;\n","type":"","out":""},{"in":"\r\nlet _ = removeZero [0;","min":"","type":"syntax","out":"Characters 23-25:\n  let _ = removeZero [0;;;\n                       ^^\nError: Syntax error\n"},{"in":"let _ = removeZero [0;0;0;1;","min":"","type":"syntax","out":"Characters 27-29:\n  let _ = removeZero [0;0;0;1;;;\n                             ^^\nError: Syntax error\n"},{"in":"\n\r\nlet bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero","min":"","type":"syntax","out":"Characters 242-243:\n  removeZero (add (padZero;;\n                  ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n"},{"in":"\n\r\nlet rec mulByDigit i l = failwith \"to be implement","min":"\nlet rec mulByDigit i l = failwith \"to be implement\";;\n","type":"","out":""},{"in":"*)\n\r\nlet bigMul l1 l2 = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet","min":"","type":"syntax","out":"Characters 0-1:\n  *)\n  ^\nError: Syntax error\n"},{"in":"(* CSE 130 P","min":"\n;;\n","type":"","out":""},{"in":"\r\nlet key = \"\" (* cha","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" ","min":"\nlet key = \"\" let prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string","min":"\nlet print130 s = print_string;;\n","type":"","out":""},{"in":"exception ErrorCode of string\n\r\ntype result = P","min":"\nexception ErrorCode of string type result =\n                                | P;;\n","type":"","out":""},{"in":"type result = Pas","min":"\ntype result =\n  | Pas;;\n","type":"","out":""},{"in":"\r\nlet score = r","min":"\nlet score = r;;\n","type":"scope","out":"Characters 14-15:\n  let score = r;;\n              ^\nError: Unbound value r\n"},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300\n\r\nlet runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e ->","min":"","type":"syntax","out":"Characters 116-118:\n  with e ->;;\n           ^^\nError: Syntax error\n"},{"in":"with e -> (print130 (\"U","min":"","type":"syntax","out":"Characters 0-4:\n  with e -> (print130 (\"U\";;\n  ^^^^\nError: Syntax error\n"},{"in":"\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \nlet re","min":"","type":"syntax","out":"Characters 26-28:\n  let re;;\n        ^^\nError: Syntax error\n"},{"in":"_exp 0\n\r\nlet implode cs = \nString.concat \"\" (List.map","min":"","type":"syntax","out":"Characters 9-12:\n  let implode cs = \n  ^^^\nError: Syntax error\n"},{"in":"String.concat \"\" (List.map (String.make 1) cs)\n\r\nlet drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';'","min":"","type":"syntax","out":"Characters 49-52:\n  let drop_paren s = \n  ^^^\nError: Syntax error\n"},{"in":"implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\r\nlet eq_real p (r1,r2) = \n(","min":"","type":"syntax","out":"Characters 78-81:\n  let eq_real p (r1,r2) = \n  ^^^\nError: Syntax error\n"},{"in":"let eq_real p (r1,r2) = \n(r1 -. r2","min":"","type":"syntax","out":"Characters 25-26:\n  (r1 -. r2;;\n  ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n"}],"event":{"region":{"start":0,"stop":7797},"type":"eval"},"cursor":800,"time":1.398984379719108e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\n*)\n\n\n\n (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n  let sqsum xs = \n    let f a x = x * x + a in\n      let base = 0 in\nList.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\n          let _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\r\n\n\r  \n  let pipe fs y=  \n    let f a x = x a  in\n      let base = y in\nList.fold_left f base fs\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = pipe [] 3\n\r\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\r\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\r\n\r\n\n\r  \n  let rec sepConcat sep sl = match sl with \n      | [] -> \"\"\n      | h :: t -> \n      let f a x = a ^ sep ^ x in\n        let base = h in\n          let l = t in\nList.fold_left f base l\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\n          let _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\r\n\n\n\r\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\r\n\n\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\r\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\r\n\n\r\n  let padZero l1 l2 = if List.length l1 > List.length l2 then\n  (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n      else \n(List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\n          let _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\r\n\n\r\n    let rec removeZero l = match l with\n    | [] -> []\n      | h::t -> if h != 0 then l\n  else removeZero t\n    ;;\n\r\n   (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\n   let _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\n      let _ = removeZero [0;0;0;0]\n\r\n\n\r\n   let bigAdd l1 l2 = \n   let add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\n                           let base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n  res\n  in \n  removeZero (add (padZero l1 l2))\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXXXX*)\n\n\r\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\r\nlet bigMul l1 l2 = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\n\n\n\n\r\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\n    let key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\r\n    exception ErrorCode of string\n\r\n  type result = Pass | Fail | ErrorCode of string\n\r\n  let score = ref 0\n    let max = ref 0\nlet timeout = 300\n\r\nlet runWTimeout (f,arg,out,time) = \n                               try if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\r\n    exception TestException\n     let testTest () =\n     let testGood x = 1 in\n     let testBad x = 0 in \n     let testException x = raise TestException in\n     let rec testTimeout x = testTimeout x in\n     runWTimeout(testGood,0,1,5) = Pass &&  \n     runWTimeout(testBad,0,1,5) = Fail &&  \n     runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n     runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\r\n     let runTest (f,arg,out,points,name) =\n     let _ = max := !max + points in\n     let outs = \n     match runWTimeout(f,arg,out,timeout) with \n     Pass -> (score := !score + points; \"[pass]\")\n     | Fail -> \"[fail]\"\n     | ErrorCode e -> \"[error: \"^e^\"]\"  in\n     name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\r\n     (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n     let explode s = \n     let rec _exp i = \n     if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n     _exp 0\n\r\n     let implode cs = \n     String.concat \"\" (List.map (String.make 1) cs)\n\r\n    let drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\r    \n    let eq_real p (r1,r2) = \n    (r1 -. r2) < p || (r2 -. r1) < p\n\r          \n          let wrap_curried_2 f (a,b) = f a b\n\r          \n          let runAllTests () =\nlet _ = (score := 0; max := 0) in\n     let report = \n     [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\r\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\r\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\r\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\r\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\r\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\r\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n    runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\r\n    runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n    runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\r\nrunTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\r\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\r  \nlet _ = runAllTests ()\n\r  \nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let sqsum xs = \nlet f a  x = x * x + a in\nlet base = 0 in\nList.fold_left f base xs","min":"\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n","type":"","out":""},{"in":"let sqsum xs = \nlet f a x = x * x + a in","min":"","type":"syntax","out":"Characters 40-42:\n  let f a x = x * x + a in;;\n                          ^^\nError: Syntax error\n"}],"event":{"region":{"start":0,"stop":846},"type":"eval"},"cursor":804,"time":1.398984432364121e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\n*)\n\n\n\n (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n  let sqsum xs = \n    let f a  x = x * x + a in\nlet base = 0 in\nList.fold_left f base xs\n;;\n\n  let sqsum xs = \n    let f a x = x * x + a in\n      let base = 0 in\nList.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\n          let _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\r\n\n\r  \n  let pipe fs y=  \n    let f a x = x a  in\n      let base = y in\nList.fold_left f base fs\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = pipe [] 3\n\r\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\r\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\r\n\r\n\n\r  \n  let rec sepConcat sep sl = match sl with \n      | [] -> \"\"\n      | h :: t -> \n      let f a x = a ^ sep ^ x in\n        let base = h in\n          let l = t in\nList.fold_left f base l\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\n          let _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\r\n\n\n\r\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\r\n\n\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\r\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\r\n\n\r\n  let padZero l1 l2 = if List.length l1 > List.length l2 then\n  (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n      else \n(List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\n          let _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\r\n\n\r\n    let rec removeZero l = match l with\n    | [] -> []\n      | h::t -> if h != 0 then l\n  else removeZero t\n    ;;\n\r\n   (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\n   let _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\n      let _ = removeZero [0;0;0;0]\n\r\n\n\r\n   let bigAdd l1 l2 = \n   let add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\n                           let base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n  res\n  in \n  removeZero (add (padZero l1 l2))\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXXXX*)\n\n\r\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\r\nlet bigMul l1 l2 = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\n\n\n\n\r\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\n    let key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\r\n    exception ErrorCode of string\n\r\n  type result = Pass | Fail | ErrorCode of string\n\r\n  let score = ref 0\n    let max = ref 0\nlet timeout = 300\n\r\nlet runWTimeout (f,arg,out,time) = \n                               try if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\r\n    exception TestException\n     let testTest () =\n     let testGood x = 1 in\n     let testBad x = 0 in \n     let testException x = raise TestException in\n     let rec testTimeout x = testTimeout x in\n     runWTimeout(testGood,0,1,5) = Pass &&  \n     runWTimeout(testBad,0,1,5) = Fail &&  \n     runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n     runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\r\n     let runTest (f,arg,out,points,name) =\n     let _ = max := !max + points in\n     let outs = \n     match runWTimeout(f,arg,out,timeout) with \n     Pass -> (score := !score + points; \"[pass]\")\n     | Fail -> \"[fail]\"\n     | ErrorCode e -> \"[error: \"^e^\"]\"  in\n     name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\r\n     (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n     let explode s = \n     let rec _exp i = \n     if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n     _exp 0\n\r\n     let implode cs = \n     String.concat \"\" (List.map (String.make 1) cs)\n\r\n    let drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\r    \n    let eq_real p (r1,r2) = \n    (r1 -. r2) < p || (r2 -. r1) < p\n\r          \n          let wrap_curried_2 f (a,b) = f a b\n\r          \n          let runAllTests () =\nlet _ = (score := 0; max := 0) in\n     let report = \n     [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\r\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\r\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\r\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\r\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\r\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\r\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n    runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\r\n    runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n    runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\r\nrunTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\r\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\r  \nlet _ = runAllTests ()\n\r  \nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let sqsum xs = \nlet f a x = (x * x + a) ","min":"","type":"syntax","out":"Characters 40-42:\n  let f a x = (x * x + a) ;;\n                          ^^\nError: Syntax error\n"}],"event":{"region":{"start":0,"stop":758},"type":"eval"},"cursor":801,"time":1.398984469338791e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\n*)\n\n\n\n (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n  let sqsum xs = \n    let f a x = (x * x + a) in\n      let base = 0 in\nList.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\n          let _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\r\n\n\r  \n  let pipe fs y=  \n    let f a x = x a  in\n      let base = y in\nList.fold_left f base fs\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = pipe [] 3\n\r\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\r\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\r\n\r\n\n\r  \n  let rec sepConcat sep sl = match sl with \n      | [] -> \"\"\n      | h :: t -> \n      let f a x = a ^ sep ^ x in\n        let base = h in\n          let l = t in\nList.fold_left f base l\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\n          let _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\r\n\n\n\r\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\r\n\n\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\r\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\r\n\n\r\n  let padZero l1 l2 = if List.length l1 > List.length l2 then\n  (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n      else \n(List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\n          let _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\r\n\n\r\n    let rec removeZero l = match l with\n    | [] -> []\n      | h::t -> if h != 0 then l\n  else removeZero t\n    ;;\n\r\n   (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\n   let _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\n      let _ = removeZero [0;0;0;0]\n\r\n\n\r\n   let bigAdd l1 l2 = \n   let add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\n                           let base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n  res\n  in \n  removeZero (add (padZero l1 l2))\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXXXX*)\n\n\r\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\r\nlet bigMul l1 l2 = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\n\n\n\n\r\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\n    let key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\r\n    exception ErrorCode of string\n\r\n  type result = Pass | Fail | ErrorCode of string\n\r\n  let score = ref 0\n    let max = ref 0\nlet timeout = 300\n\r\nlet runWTimeout (f,arg,out,time) = \n                               try if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\r\n    exception TestException\n     let testTest () =\n     let testGood x = 1 in\n     let testBad x = 0 in \n     let testException x = raise TestException in\n     let rec testTimeout x = testTimeout x in\n     runWTimeout(testGood,0,1,5) = Pass &&  \n     runWTimeout(testBad,0,1,5) = Fail &&  \n     runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n     runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\r\n     let runTest (f,arg,out,points,name) =\n     let _ = max := !max + points in\n     let outs = \n     match runWTimeout(f,arg,out,timeout) with \n     Pass -> (score := !score + points; \"[pass]\")\n     | Fail -> \"[fail]\"\n     | ErrorCode e -> \"[error: \"^e^\"]\"  in\n     name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\r\n     (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n     let explode s = \n     let rec _exp i = \n     if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n     _exp 0\n\r\n     let implode cs = \n     String.concat \"\" (List.map (String.make 1) cs)\n\r\n    let drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\r    \n    let eq_real p (r1,r2) = \n    (r1 -. r2) < p || (r2 -. r1) < p\n\r          \n          let wrap_curried_2 f (a,b) = f a b\n\r          \n          let runAllTests () =\nlet _ = (score := 0; max := 0) in\n     let report = \n     [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\r\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\r\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\r\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\r\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\r\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\r\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n    runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\r\n    runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n    runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\r\nrunTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\r\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\r  \nlet _ = runAllTests ()\n\r  \nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let sqsum xs = \nlet f a x = (x * x + a)","min":"","type":"syntax","out":"Characters 39-41:\n  let f a x = (x * x + a);;\n                         ^^\nError: Syntax error\n"},{"in":"let base = 0 \nList.fold_left f base xs","min":"\nlet base = 0 List.fold_left f base xs;;\n","type":"type","out":"Characters 11-12:\n  let base = 0 \n             ^\nError: This expression has type int\n       This is not a function; it cannot be applied.\n"},{"in":"let _ = sqsum []","min":"\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [];;\n","type":"","out":""},{"in":"let _ = sqsum [1;2;3;","min":"","type":"syntax","out":"Characters 20-22:\n  let _ = sqsum [1;2;3;;;\n                      ^^\nError: Syntax error\n"}],"event":{"region":{"start":0,"stop":884},"type":"eval"},"cursor":874,"time":1.398984497925666e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\n*)\n\n\n\n (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n             let f a x = (x * x + a) \nlet base = 0 \nList.fold_left f base xs\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\n          let _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\r\n\n\r  \n  let pipe fs y=  \n    let f a x = x a  in\n      let base = y in\nList.fold_left f base fs\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = pipe [] 3\n\r\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\r\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\r\n\r\n\n\r  \n  let rec sepConcat sep sl = match sl with \n      | [] -> \"\"\n      | h :: t -> \n      let f a x = a ^ sep ^ x in\n        let base = h in\n          let l = t in\nList.fold_left f base l\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\n          let _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\r\n\n\n\r\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\r\n\n\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\r\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\r\n\n\r\n  let padZero l1 l2 = if List.length l1 > List.length l2 then\n  (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n      else \n(List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\n          let _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\r\n\n\r\n    let rec removeZero l = match l with\n    | [] -> []\n      | h::t -> if h != 0 then l\n  else removeZero t\n    ;;\n\r\n   (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\n   let _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\n      let _ = removeZero [0;0;0;0]\n\r\n\n\r\n   let bigAdd l1 l2 = \n   let add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\n                           let base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n  res\n  in \n  removeZero (add (padZero l1 l2))\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXXXX*)\n\n\r\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\r\nlet bigMul l1 l2 = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\n\n\n\n\r\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\n    let key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\r\n    exception ErrorCode of string\n\r\n  type result = Pass | Fail | ErrorCode of string\n\r\n  let score = ref 0\n    let max = ref 0\nlet timeout = 300\n\r\nlet runWTimeout (f,arg,out,time) = \n                               try if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\r\n    exception TestException\n     let testTest () =\n     let testGood x = 1 in\n     let testBad x = 0 in \n     let testException x = raise TestException in\n     let rec testTimeout x = testTimeout x in\n     runWTimeout(testGood,0,1,5) = Pass &&  \n     runWTimeout(testBad,0,1,5) = Fail &&  \n     runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n     runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\r\n     let runTest (f,arg,out,points,name) =\n     let _ = max := !max + points in\n     let outs = \n     match runWTimeout(f,arg,out,timeout) with \n     Pass -> (score := !score + points; \"[pass]\")\n     | Fail -> \"[fail]\"\n     | ErrorCode e -> \"[error: \"^e^\"]\"  in\n     name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\r\n     (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n     let explode s = \n     let rec _exp i = \n     if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n     _exp 0\n\r\n     let implode cs = \n     String.concat \"\" (List.map (String.make 1) cs)\n\r\n    let drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\r    \n    let eq_real p (r1,r2) = \n    (r1 -. r2) < p || (r2 -. r1) < p\n\r          \n          let wrap_curried_2 f (a,b) = f a b\n\r          \n          let runAllTests () =\nlet _ = (score := 0; max := 0) in\n     let report = \n     [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\r\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\r\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\r\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\r\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\r\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\r\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n    runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\r\n    runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n    runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\r\nrunTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\r\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\r  \nlet _ = runAllTests ()\n\r  \nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let sqsum xs = \nlet f a x = x * x + a in","min":"","type":"syntax","out":"Characters 40-42:\n  let f a x = x * x + a in;;\n                          ^^\nError: Syntax error\n"}],"event":{"region":{"start":0,"stop":758},"type":"eval"},"cursor":800,"time":1.398984523150691e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\n*)\n\n\n\n (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n  let sqsum xs = \n    let f a x = x * x + a in\n      let base = 0 in\nList.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\n          let _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\r\n\n\r  \n  let pipe fs y=  \n    let f a x = x a  in\n      let base = y in\nList.fold_left f base fs\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = pipe [] 3\n\r\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\r\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\r\n\r\n\n\r  \n  let rec sepConcat sep sl = match sl with \n      | [] -> \"\"\n      | h :: t -> \n      let f a x = a ^ sep ^ x in\n        let base = h in\n          let l = t in\nList.fold_left f base l\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\n          let _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\r\n\n\n\r\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\r\n\n\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\r\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\r\n\n\r\n  let padZero l1 l2 = if List.length l1 > List.length l2 then\n  (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n      else \n(List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\n          let _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\r\n\n\r\n    let rec removeZero l = match l with\n    | [] -> []\n      | h::t -> if h != 0 then l\n  else removeZero t\n    ;;\n\r\n   (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\n   let _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\n      let _ = removeZero [0;0;0;0]\n\r\n\n\r\n   let bigAdd l1 l2 = \n   let add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\n                           let base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n  res\n  in \n  removeZero (add (padZero l1 l2))\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXXXX*)\n\n\r\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\r\nlet bigMul l1 l2 = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\n\n\n\n\r\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\n    let key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\r\n    exception ErrorCode of string\n\r\n  type result = Pass | Fail | ErrorCode of string\n\r\n  let score = ref 0\n    let max = ref 0\nlet timeout = 300\n\r\nlet runWTimeout (f,arg,out,time) = \n                               try if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\r\n    exception TestException\n     let testTest () =\n     let testGood x = 1 in\n     let testBad x = 0 in \n     let testException x = raise TestException in\n     let rec testTimeout x = testTimeout x in\n     runWTimeout(testGood,0,1,5) = Pass &&  \n     runWTimeout(testBad,0,1,5) = Fail &&  \n     runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n     runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\r\n     let runTest (f,arg,out,points,name) =\n     let _ = max := !max + points in\n     let outs = \n     match runWTimeout(f,arg,out,timeout) with \n     Pass -> (score := !score + points; \"[pass]\")\n     | Fail -> \"[fail]\"\n     | ErrorCode e -> \"[error: \"^e^\"]\"  in\n     name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\r\n     (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n     let explode s = \n     let rec _exp i = \n     if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n     _exp 0\n\r\n     let implode cs = \n     String.concat \"\" (List.map (String.make 1) cs)\n\r\n    let drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\r    \n    let eq_real p (r1,r2) = \n    (r1 -. r2) < p || (r2 -. r1) < p\n\r          \n          let wrap_curried_2 f (a,b) = f a b\n\r          \n          let runAllTests () =\nlet _ = (score := 0; max := 0) in\n     let report = \n     [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\r\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\r\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\r\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\r\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\r\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\r\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n    runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\r\n    runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n    runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\r\nrunTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\r\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\r  \nlet _ = runAllTests ()\n\r  \nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"\n\nlet sqsum xs = \nlet f a x = x * x + a in","min":"","type":"syntax","out":"Characters 42-44:\n  let f a x = x * x + a in;;\n                          ^^\nError: Syntax error\n"},{"in":"\n(* UNCOMMENT AF","min":"\n;;\n","type":"","out":""},{"in":"(* UNCOMMENT AFTER IMPL","min":"\n;;\n","type":"","out":""},{"in":"let _ = sqsum []\nlet _ = sqsum [1;2;3;","min":"","type":"syntax","out":"Characters 37-39:\n  let _ = sqsum [1;2;3;;;\n                      ^^\nError: Syntax error\n"}],"event":{"region":{"start":0,"stop":925},"type":"eval"},"cursor":925,"time":1.398984589810323e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\r\n\n\r\n  let pipe fs y=  \n  let f a x = x a  in\n    let base = y in\n      List.fold_left f base fs\n\n\r      \n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r          \n          let _ = pipe [] 3\n\r          \n          let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\r          \n          let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\r\n\r\n\n\r\n  let rec sepConcat sep sl = match sl with \n      | [] -> \"\"\n      | h :: t -> \n      let f a x = a ^ sep ^ x in\n        let base = h in\n          let l = t in\nList.fold_left f base l\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\n          let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\r\n\n\n\r\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\r\n\n\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\r\n\n\r  \n  let padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \nelse \n(List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r          \n          let _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\r\n\n\r  \n  let rec removeZero l = match l with\n      | [] -> []\n| h::t -> if h != 0 then l\nelse removeZero t\n;;\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = removeZero [0;0;0;1;0;0;2]\n          let _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\r\n\n\r    \n    let bigAdd l1 l2 = \n    let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n      let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n      in \nremoveZero (add (padZero l1 l2))\n\r   \n   (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\r\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\r   \n   (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\r  \n  let bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n      let (_, res) = List.fold_left f base args in\nres\n\n\r   \n   (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\n\n\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet key = \"\" (*XXXXXXXX*)\n                   let prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\r\nexception ErrorCode of string\n\r\ntype result = Pass | Fail | ErrorCode of string\n\r\nlet score = ref 0\n  let max = ref 0\nlet timeout = 300\n\r  \n  let runWTimeout (f,arg,out,time) = \n            try if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\r  \n  exception TestException\n  let testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n    let testException x = raise TestException in\n    let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n                                       runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \nrunWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\r  \n  let runTest (f,arg,out,points,name) =\n    let _ = max := !max + points in\n        let outs = \n      match runWTimeout(f,arg,out,timeout) with \n      Pass -> (score := !score + points; \"[pass]\")\n    | Fail -> \"[fail]\"\n    | ErrorCode e -> \"[error: \"^e^\"]\"  in\nname^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\r  \n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n    let explode s = \n    let rec _exp i = \n      if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0\n\r    \n    let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)\n\r    \n    let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\r\nlet eq_real p (r1,r2) = \n                               (r1 -. r2) < p || (r2 -. r1) < p\n\r\n  let wrap_curried_2 f (a,b) = f a b\n\r\n     let runAllTests () =\n     let _ = (score := 0; max := 0) in\n     let report = \n     [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\r     \n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\r     \n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\r     \n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\r     \n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\r     \n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\r     \n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\r     \n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\r  \n  runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\r    \n    runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n    runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n] in\n          let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\nlet _ = List.iter print130 (report@([s])) in\n          (!score,!max)\n\r  \nlet _ = runAllTests ()\n\r  \nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"\n\r\nlet pipe fs y=  \nlet f a x = x a  in\nlet ","min":"","type":"syntax","out":"Characters 44-46:\n  let ;;\n      ^^\nError: Syntax error\n"},{"in":"\n(* UNCOMMENT AFT","min":"\n;;\n","type":"","out":""},{"in":"\r\nlet _ = pipe [] 3\n\r\nlet _ =","min":"","type":"syntax","out":"Characters 29-31:\n  let _ =;;\n         ^^\nError: Syntax error\n"},{"in":"let _ = pipe [] 3\n\r\nlet _ = pipe [(fun x -> x+x);","min":"","type":"syntax","out":"Characters 48-50:\n  let _ = pipe [(fun x -> x+x);;;\n                              ^^\nError: Syntax error\n"},{"in":"\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)]","min":"\nlet pipe fs y = let f a x = x a in let base = y in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)];;\n","type":"","out":""}],"event":{"region":{"start":925,"stop":1178},"type":"eval"},"cursor":1180,"time":1.398984606969113e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\r\n\n\r\n  let pipe fs y=  \n  let f a x = x a  in\n    let base = y in\n      List.fold_left f base fs\n\n\r      \n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r          \n          let _ = pipe [] 3\n\r          \n          let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\r          \n          let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\r\n\r\n\n\r\n  let rec sepConcat sep sl = match sl with \n      | [] -> \"\"\n      | h :: t -> \n      let f a x = a ^ sep ^ x in\n        let base = h in\n          let l = t in\nList.fold_left f base l\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\n          let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\r\n\n\n\r\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\r\n\n\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\r\n\n\r  \n  let padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \nelse \n(List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r          \n          let _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\r\n\n\r  \n  let rec removeZero l = match l with\n      | [] -> []\n| h::t -> if h != 0 then l\nelse removeZero t\n;;\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet _ = removeZero [0;0;0;1;0;0;2]\n          let _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\r\n\n\r    \n    let bigAdd l1 l2 = \n    let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n      let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n      in \nremoveZero (add (padZero l1 l2))\n\r   \n   (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\r\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\r   \n   (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\r  \n  let bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n      let (_, res) = List.fold_left f base args in\nres\n\n\r   \n   (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nX\n*)\n\n\n\n\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet key = \"\" (*XXXXXXXX*)\n                   let prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\r\nexception ErrorCode of string\n\r\ntype result = Pass | Fail | ErrorCode of string\n\r\nlet score = ref 0\n  let max = ref 0\nlet timeout = 300\n\r  \n  let runWTimeout (f,arg,out,time) = \n            try if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\r  \n  exception TestException\n  let testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n    let testException x = raise TestException in\n    let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n                                       runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \nrunWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\r  \n  let runTest (f,arg,out,points,name) =\n    let _ = max := !max + points in\n        let outs = \n      match runWTimeout(f,arg,out,timeout) with \n      Pass -> (score := !score + points; \"[pass]\")\n    | Fail -> \"[fail]\"\n    | ErrorCode e -> \"[error: \"^e^\"]\"  in\nname^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\r  \n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n    let explode s = \n    let rec _exp i = \n      if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0\n\r    \n    let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)\n\r    \n    let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\r\nlet eq_real p (r1,r2) = \n                               (r1 -. r2) < p || (r2 -. r1) < p\n\r\n  let wrap_curried_2 f (a,b) = f a b\n\r\n     let runAllTests () =\n     let _ = (score := 0; max := 0) in\n     let report = \n     [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\r     \n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\r     \n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\r     \n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\r     \n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\r     \n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\r     \n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\r     \n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\r  \n  runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\r    \n    runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n    runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n] in\n          let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\nlet _ = List.iter print130 (report@([s])) in\n          (!score,!max)\n\r  \nlet _ = runAllTests ()\n\r  \nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let sqsum xs = \nlet f a x = x * x + a in\nlet base = 0 in\nList.fold_left f base xs","min":"\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n","type":"","out":""},{"in":"let _ = sqsum []","min":"\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [];;\n","type":"","out":""},{"in":"let _ = sqsum [1;2;3;4]","min":"\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sqsum [(-1); (-2); (-3); (-4)]","min":"\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [(-1); (-2); (-3); (-4)];;\n","type":"","out":""},{"in":"let pipe fs y=  \nlet f a x = x a  in\nlet base = y in\nList.fold_left f base fs","min":"\nlet pipe fs y = let f a x = x a in let base = y in List.fold_left f base fs;;\n","type":"","out":""},{"in":"let _ = pipe [] 3","min":"\nlet pipe fs y = let f a x = x a in let base = y in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n","type":"","out":""},{"in":"let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3","min":"\nlet pipe fs y = let f a x = x a in let base = y in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n","type":"","out":""},{"in":"let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3","min":"\nlet pipe fs y = let f a x = x a in let base = y in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n","type":"","out":""},{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n","type":"","out":""},{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"---\" []","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"---\" [];;\n","type":"","out":""},{"in":"let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"\" [\"a\"; \"b\"; \"c\"; \"d\"; \"e\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"X\" [\"hello\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"X\" [\"hello\"];;\n","type":"","out":""},{"in":"let stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n","type":"","out":""},{"in":"let _ = stringOfList string_of_int [1;2;3;4;5;6]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n\nlet _ = stringOfList string_of_int [1; 2; 3; 4; 5; 6];;\n","type":"","out":""},{"in":"let _ = stringOfList (fun x -> x) [\"foo\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n\nlet _ = stringOfList (fun x  -> x) [\"foo\"];;\n","type":"","out":""},{"in":"let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n\nlet _ =\n  stringOfList (stringOfList string_of_int) [[1; 2; 3]; [4; 5]; [6]; []];;\n","type":"","out":""},{"in":"let rec clone x n = if n > 0 then x :: clone x (n-1) else []","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n","type":"","out":""},{"in":"let _ = clone 3 5","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet _ = clone 3 5;;\n","type":"","out":""},{"in":"let _ = clone \"foo\" 2","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet _ = clone \"foo\" 2;;\n","type":"","out":""},{"in":"let _ = clone clone (-3)","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet _ = clone clone (-3);;\n","type":"","out":""},{"in":"let padZero l1 l2 = if List.length l1 > List.length l2 then\n(l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \nelse \n(List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n","type":"","out":""},{"in":"let _ = padZero [9;9] [1;0;0;2]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet _ = padZero [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = padZero [1;0;0;2] [9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet _ = padZero [1; 0; 0; 2] [9; 9];;\n","type":"","out":""},{"in":"let rec removeZero l = match l with\n| [] -> []\n| h::t -> if h != 0 then l\nelse removeZero t","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;1;0;0;2]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet _ = removeZero [0; 0; 0; 1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = removeZero [9;9]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet _ = removeZero [9; 9];;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;0]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet _ = removeZero [0; 0; 0; 0];;\n","type":"","out":""},{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"","out":""},{"in":"let rec mulByDigit i l = failwith \"to be implemented\"","min":"\nlet rec mulByDigit i l = failwith \"to be implemented\";;\n","type":"","out":""},{"in":"let bigMul l1 l2 = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres","min":"\nlet bigMul l1 l2 =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_,res) = List.fold_left f base args in res;;\n","type":"","out":""},{"in":"let key = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130 = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ ((Printexc.to_string e) ^ \"\\n\"));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n","type":"","out":""},{"in":"let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","min":"\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n","type":"","out":""},{"in":"let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n\nlet drop_paren s =\n  implode\n    (List.filter (fun c  -> not (List.mem c ['('; ' '; ')'])) (explode s));;\n","type":"","out":""},{"in":"let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","min":"\nlet eq_real p (r1,r2) = ((r1 -. r2) < p) || ((r2 -. r1) < p);;\n","type":"","out":""},{"in":"let wrap_curried_2 f (a,b) = f a b","min":"\nlet wrap_curried_2 f (a,b) = f a b;;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":7603},"type":"eval"},"cursor":7603,"time":1.398984826625197e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs y=  \n  let f a x = x a  in\n  let base = y in\n    List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\r\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\r\nexception ErrorCode of string\n\r\ntype result = Pass | Fail | ErrorCode of string\n\r\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\r\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\r\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\r\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\r\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\r\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\r\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\r\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\r\nlet wrap_curried_2 f (a,b) = f a b\n\r\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\r     \n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\r     \n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\r     \n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\r     \n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\r\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\r\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\r\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\r\n    runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\r\n    runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n    runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n] in\n          let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\nlet _ = List.iter print130 (report@([s])) in\n          (!score,!max)\n\r\nlet _ = runAllTests ()\n\r  \nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigMul l1 l2 = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n*******************************************************************************","min":"","type":"syntax","out":"Characters 286-288:\n  *******************************************************************************;;\n                                                                                 ^^\nError: Syntax error\n"},{"in":")","min":"","type":"syntax","out":"Characters 0-1:\n  );;\n  ^\nError: Syntax error\n"},{"in":"let key = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130 = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ ((Printexc.to_string e) ^ \"\\n\"));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n","type":"","out":""},{"in":"let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","min":"\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n","type":"","out":""},{"in":"let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n\nlet drop_paren s =\n  implode\n    (List.filter (fun c  -> not (List.mem c ['('; ' '; ')'])) (explode s));;\n","type":"","out":""},{"in":"let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","min":"\nlet eq_real p (r1,r2) = ((r1 -. r2) < p) || ((r2 -. r1) < p);;\n","type":"","out":""},{"in":"let wrap_curried_2 f (a,b) = f a b","min":"\nlet wrap_curried_2 f (a,b) = f a b;;\n","type":"","out":""}],"event":{"region":{"start":3154,"stop":7581},"type":"eval"},"cursor":7580,"time":1.398984883758934e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs y=  \n  let f a x = x a  in\n  let base = y in\n    List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXX*)\n\n\n\n\n\n    *******************************************************************************)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigMul l1 l2 = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres","min":"\nlet bigMul l1 l2 =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_,res) = List.fold_left f base args in res;;\n","type":"","out":""},{"in":"let key = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130 = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ ((Printexc.to_string e) ^ \"\\n\"));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n","type":"","out":""},{"in":"let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","min":"\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n","type":"","out":""},{"in":"let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n\nlet drop_paren s =\n  implode\n    (List.filter (fun c  -> not (List.mem c ['('; ' '; ')'])) (explode s));;\n","type":"","out":""},{"in":"let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","min":"\nlet eq_real p (r1,r2) = ((r1 -. r2) < p) || ((r2 -. r1) < p);;\n","type":"","out":""},{"in":"let wrap_curried_2 f (a,b) = f a b","min":"\nlet wrap_curried_2 f (a,b) = f a b;;\n","type":"","out":""}],"event":{"region":{"start":3154,"stop":7499},"type":"eval"},"cursor":3561,"time":1.398984895145712e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs y=  \n  let f a x = x a  in\n  let base = y in\n    List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n","file":"hw3.ml"}
{"ocaml":[{"in":"let sqsum xs = \nlet f a x = x * x + a in\nlet base = 0 in\nList.fold_left f base xs","min":"\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n","type":"","out":""},{"in":"let _ = sqsum []","min":"\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [];;\n","type":"","out":""},{"in":"let _ = sqsum [1;2;3;4]","min":"\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sqsum [(-1); (-2); (-3); (-4)]","min":"\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [(-1); (-2); (-3); (-4)];;\n","type":"","out":""},{"in":"let pipe fs y=  \nlet f a x = x a  in\nlet base = y in\nList.fold_left f base fs","min":"\nlet pipe fs y = let f a x = x a in let base = y in List.fold_left f base fs;;\n","type":"","out":""},{"in":"let _ = pipe [] 3","min":"\nlet pipe fs y = let f a x = x a in let base = y in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n","type":"","out":""},{"in":"let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3","min":"\nlet pipe fs y = let f a x = x a in let base = y in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n","type":"","out":""},{"in":"let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3","min":"\nlet pipe fs y = let f a x = x a in let base = y in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n","type":"","out":""},{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n","type":"","out":""},{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"---\" []","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"---\" [];;\n","type":"","out":""},{"in":"let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"\" [\"a\"; \"b\"; \"c\"; \"d\"; \"e\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"X\" [\"hello\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"X\" [\"hello\"];;\n","type":"","out":""},{"in":"let stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n","type":"","out":""},{"in":"let _ = stringOfList string_of_int [1;2;3;4;5;6]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n\nlet _ = stringOfList string_of_int [1; 2; 3; 4; 5; 6];;\n","type":"","out":""},{"in":"let _ = stringOfList (fun x -> x) [\"foo\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n\nlet _ = stringOfList (fun x  -> x) [\"foo\"];;\n","type":"","out":""},{"in":"let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n\nlet _ =\n  stringOfList (stringOfList string_of_int) [[1; 2; 3]; [4; 5]; [6]; []];;\n","type":"","out":""},{"in":"let rec clone x n = if n > 0 then x :: clone x (n-1) else []","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n","type":"","out":""},{"in":"let _ = clone 3 5","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet _ = clone 3 5;;\n","type":"","out":""},{"in":"let _ = clone \"foo\" 2","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet _ = clone \"foo\" 2;;\n","type":"","out":""},{"in":"let _ = clone clone (-3)","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet _ = clone clone (-3);;\n","type":"","out":""},{"in":"let padZero l1 l2 = if List.length l1 > List.length l2 then\n(l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \nelse \n(List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n","type":"","out":""},{"in":"let _ = padZero [9;9] [1;0;0;2]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet _ = padZero [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = padZero [1;0;0;2] [9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet _ = padZero [1; 0; 0; 2] [9; 9];;\n","type":"","out":""},{"in":"let rec removeZero l = match l with\n| [] -> []\n| h::t -> if h != 0 then l\nelse removeZero t","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;1;0;0;2]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet _ = removeZero [0; 0; 0; 1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = removeZero [9;9]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet _ = removeZero [9; 9];;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;0]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet _ = removeZero [0; 0; 0; 0];;\n","type":"","out":""},{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"","out":""},{"in":"let rec mulByDigit i l = failwith \"to be implemented\"","min":"\nlet rec mulByDigit i l = failwith \"to be implemented\";;\n","type":"","out":""},{"in":"let bigMul l1 l2 = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres","min":"\nlet bigMul l1 l2 =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_,res) = List.fold_left f base args in res;;\n","type":"","out":""},{"in":"let key = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130 = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ ((Printexc.to_string e) ^ \"\\n\"));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n","type":"","out":""},{"in":"let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","min":"\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n","type":"","out":""},{"in":"let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n\nlet drop_paren s =\n  implode\n    (List.filter (fun c  -> not (List.mem c ['('; ' '; ')'])) (explode s));;\n","type":"","out":""},{"in":"let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","min":"\nlet eq_real p (r1,r2) = ((r1 -. r2) < p) || ((r2 -. r1) < p);;\n","type":"","out":""},{"in":"let wrap_curried_2 f (a,b) = f a b","min":"\nlet wrap_curried_2 f (a,b) = f a b;;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":7576},"type":"eval"},"cursor":7576,"time":1.398985011846537e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs y=  \n  let f a x = x a  in\n  let base = y in\n    List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let sqsum xs = \nlet f a x = x * x + a in\nlet base = 0 in\nList.fold_left f base xs","min":"\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n","type":"","out":""},{"in":"let _ = sqsum []","min":"\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [];;\n","type":"","out":""},{"in":"let _ = sqsum [1;2;3;4]","min":"\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sqsum [(-1); (-2); (-3); (-4)]","min":"\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [(-1); (-2); (-3); (-4)];;\n","type":"","out":""},{"in":"let pipe fs y=  \nlet f a x = x a  in\nlet base = y in\nList.fold_left f base fs","min":"\nlet pipe fs y = let f a x = x a in let base = y in List.fold_left f base fs;;\n","type":"","out":""},{"in":"let _ = pipe [] 3","min":"\nlet pipe fs y = let f a x = x a in let base = y in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n","type":"","out":""},{"in":"let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3","min":"\nlet pipe fs y = let f a x = x a in let base = y in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n","type":"","out":""},{"in":"let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3","min":"\nlet pipe fs y = let f a x = x a in let base = y in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n","type":"","out":""},{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n","type":"","out":""},{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"---\" []","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"---\" [];;\n","type":"","out":""},{"in":"let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"\" [\"a\"; \"b\"; \"c\"; \"d\"; \"e\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"X\" [\"hello\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"X\" [\"hello\"];;\n","type":"","out":""},{"in":"let stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n","type":"","out":""},{"in":"let _ = stringOfList string_of_int [1;2;3;4;5;6]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n\nlet _ = stringOfList string_of_int [1; 2; 3; 4; 5; 6];;\n","type":"","out":""},{"in":"let _ = stringOfList (fun x -> x) [\"foo\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n\nlet _ = stringOfList (fun x  -> x) [\"foo\"];;\n","type":"","out":""},{"in":"let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n\nlet _ =\n  stringOfList (stringOfList string_of_int) [[1; 2; 3]; [4; 5]; [6]; []];;\n","type":"","out":""},{"in":"let rec clone x n = if n > 0 then x :: clone x (n-1) else []","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n","type":"","out":""},{"in":"let _ = clone 3 5","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet _ = clone 3 5;;\n","type":"","out":""},{"in":"let _ = clone \"foo\" 2","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet _ = clone \"foo\" 2;;\n","type":"","out":""},{"in":"let _ = clone clone (-3)","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet _ = clone clone (-3);;\n","type":"","out":""},{"in":"let padZero l1 l2 = if List.length l1 > List.length l2 then\n(l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \nelse \n(List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n","type":"","out":""},{"in":"let _ = padZero [9;9] [1;0;0;2]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet _ = padZero [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = padZero [1;0;0;2] [9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet _ = padZero [1; 0; 0; 2] [9; 9];;\n","type":"","out":""},{"in":"let rec removeZero l = match l with\n| [] -> []\n| h::t -> if h != 0 then l\nelse removeZero t","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;1;0;0;2]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet _ = removeZero [0; 0; 0; 1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = removeZero [9;9]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet _ = removeZero [9; 9];;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;0]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet _ = removeZero [0; 0; 0; 0];;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":2722},"type":"eval"},"cursor":2722,"time":1.398985142997299e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs y=  \n  let f a x = x a  in\n  let base = y in\n    List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = padZero [1;0;0;2] [9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet _ = padZero [1; 0; 0; 2] [9; 9];;\n","type":"","out":""}],"event":{"region":{"start":2457,"stop":2488},"type":"eval"},"cursor":2489,"time":1.398985343619349e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs y=  \n  let f a x = x a  in\n  let base = y in\n    List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let pipe fs =  \nlet f a x = x a  in\nfun base -> \nList.fold_left f base fs","min":"\nlet pipe fs = let f a x = x a in fun base  -> List.fold_left f base fs;;\n","type":"","out":""},{"in":"let _ = pipe [] 3","min":"\nlet pipe fs = let f a x = x a in fun base  -> List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n","type":"","out":""},{"in":"let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3","min":"\nlet pipe fs = let f a x = x a in fun base  -> List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n","type":"","out":""},{"in":"let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3","min":"\nlet pipe fs = let f a x = x a in fun base  -> List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n","type":"","out":""}],"event":{"region":{"start":921,"stop":1161},"type":"eval"},"cursor":1124,"time":1.398988962119022e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x =  in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let sqsum xs = \nlet f a x = x * x + a in\nlet base = 0 in\nList.fold_left f base xs","min":"\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n","type":"","out":""},{"in":"let _ = sqsum []","min":"\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [];;\n","type":"","out":""},{"in":"let _ = sqsum [1;2;3;4]","min":"\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sqsum [(-1); (-2); (-3); (-4)]","min":"\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [(-1); (-2); (-3); (-4)];;\n","type":"","out":""},{"in":"let pipe fs =  \nlet f a x = x a  in\nfun base -> \nList.fold_left f base fs","min":"\nlet pipe fs = let f a x = x a in fun base  -> List.fold_left f base fs;;\n","type":"","out":""},{"in":"let _ = pipe [] 3","min":"\nlet pipe fs = let f a x = x a in fun base  -> List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n","type":"","out":""},{"in":"let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3","min":"\nlet pipe fs = let f a x = x a in fun base  -> List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n","type":"","out":""},{"in":"let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3","min":"\nlet pipe fs = let f a x = x a in fun base  -> List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n","type":"","out":""},{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n","type":"","out":""},{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"---\" []","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"---\" [];;\n","type":"","out":""},{"in":"let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"\" [\"a\"; \"b\"; \"c\"; \"d\"; \"e\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"X\" [\"hello\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"X\" [\"hello\"];;\n","type":"","out":""},{"in":"let stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n","type":"","out":""},{"in":"let _ = stringOfList string_of_int [1;2;3;4;5;6]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n\nlet _ = stringOfList string_of_int [1; 2; 3; 4; 5; 6];;\n","type":"","out":""},{"in":"let _ = stringOfList (fun x -> x) [\"foo\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n\nlet _ = stringOfList (fun x  -> x) [\"foo\"];;\n","type":"","out":""},{"in":"let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n\nlet _ =\n  stringOfList (stringOfList string_of_int) [[1; 2; 3]; [4; 5]; [6]; []];;\n","type":"","out":""},{"in":"let rec clone x n = if n > 0 then x :: clone x (n-1) else []","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n","type":"","out":""},{"in":"let _ = clone 3 5","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet _ = clone 3 5;;\n","type":"","out":""},{"in":"let _ = clone \"foo\" 2","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet _ = clone \"foo\" 2;;\n","type":"","out":""},{"in":"let _ = clone clone (-3)","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet _ = clone clone (-3);;\n","type":"","out":""},{"in":"let padZero l1 l2 = if List.length l1 > List.length l2 then\n(l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \nelse \n(List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n","type":"","out":""},{"in":"let _ = padZero [9;9] [1;0;0;2]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet _ = padZero [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = padZero [1;0;0;2] [9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet _ = padZero [1; 0; 0; 2] [9; 9];;\n","type":"","out":""},{"in":"let rec removeZero l = match l with\n| [] -> []\n| h::t -> if h != 0 then l\nelse removeZero t","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;1;0;0;2]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet _ = removeZero [0; 0; 0; 1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = removeZero [9;9]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet _ = removeZero [9; 9];;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;0]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet _ = removeZero [0; 0; 0; 0];;\n","type":"","out":""},{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (list2, res) -> match list2 with \n| [] -> ([],res)\n| h::t -> match res with\n| [] -> (t,(h+x)::res)\n| h2::t2 -> if h2 >= 10 \nthen \n(t,if t != [] then (h+x+1)::(h2 mod 10)::t2\nelse \nif (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\nelse (h+x+1)::(h2 mod 10)::t2)\nelse \n(t,if t != [] then (h+x)::res\nelse if (h+x) >= 10 then 1::(h+x) mod 10::res\nelse (h+x)::res)\nin\nlet base = (List.rev l2, []) in\nlet args = List.rev l1 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9] [1;0;0;2]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9;9;9] [9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n","type":"","out":""},{"in":"let rec mulByDigit i l = \nmatch l with \n| [] -> []\n| h1::t1 -> bigAdd [h1*i] (mulByDigit i t1)","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match l with | [] -> [] | h1::t1 -> bigAdd [h1 * i] (mulByDigit i t1);;\n","type":"","out":""},{"in":"let _ = mulByDigit 9 [9;9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match l with | [] -> [] | h1::t1 -> bigAdd [h1 * i] (mulByDigit i t1);;\n\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let bigMul l1 l2 = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres","min":"\nlet bigMul l1 l2 =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_,res) = List.fold_left f base args in res;;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":3789},"type":"eval"},"cursor":3790,"time":1.399062182856671e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\nlet rec mulByDigit i l = \n  match l with \n    | [] -> []\n    | h1::t1 -> bigAdd [h1*i] (mulByDigit i t1)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec mulByDigit i l = \nmatch l with \n| [] -> []\n| h::t -> bigAdd [h1*i] (mulByDigit i t1)","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match l with | [] -> [] | h::t -> bigAdd [h1 * i] (mulByDigit i t1);;\n","type":"scope","out":"Characters 69-71:\n  | h::t -> bigAdd [h1*i] (mulByDigit i t1);;\n                    ^^\nError: Unbound value h1\n"},{"in":"let _ = mulByDigit 9 [9;9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match l with | [] -> [] | h1::t1 -> bigAdd [h1 * i] (mulByDigit i t1);;\n\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n","type":"","out":""}],"event":{"region":{"start":3412,"stop":3586},"type":"eval"},"cursor":3587,"time":1.399062913742989e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\nlet rec mulByDigit i l = \n  match l with \n    | [] -> []\n    | h::t -> bigAdd [h1*i] (mulByDigit i t1)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec mulByDigit i l = \nif i = 0 then []\nelse \nif i = 1 then l\nelse \nif i = 2 then bigAdd l l\nelse \nbigAdd (mulByDigit (i-1) l) (mulByDigit (i-1) l)","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0\n  then []\n  else\n    if i = 1\n    then l\n    else\n      if i = 2\n      then bigAdd l l\n      else bigAdd (mulByDigit (i - 1) l) (mulByDigit (i - 1) l);;\n","type":"","out":""}],"event":{"region":{"start":3412,"stop":3567},"type":"eval"},"cursor":3474,"time":1.399064057834274e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else \n  if i = 1 then l\n  else \n  if i = 2 then bigAdd l l\n  else \n    bigAdd (mulByDigit (i-1) l) (mulByDigit (i-1) l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = mulByDigit 9 [9;9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0\n  then []\n  else\n    if i = 1\n    then l\n    else\n      if i = 2\n      then bigAdd l l\n      else bigAdd (mulByDigit (i - 1) l) (mulByDigit (i - 1) l);;\n\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n","type":"","out":""}],"event":{"region":{"start":3567,"stop":3644},"type":"eval"},"cursor":3644,"time":1.399064060572454e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else \n  if i = 1 then l\n  else \n  if i = 2 then bigAdd l l\n  else \n    bigAdd (mulByDigit (i-1) l) (mulByDigit (i-1) l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec mulByDigit i l = \nif i = 0 then []\nelse if i = 1 then l\nelse if i = 2 then bigAdd l l\nelse bigAdd (mulByDigit (i-1) l) (mulByDigit (i-1) l)","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0\n  then []\n  else\n    if i = 1\n    then l\n    else\n      if i = 2\n      then bigAdd l l\n      else bigAdd (mulByDigit (i - 1) l) (mulByDigit (i - 1) l);;\n","type":"","out":""}],"event":{"region":{"start":3412,"stop":3564},"type":"eval"},"cursor":3516,"time":1.399064113225003e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else if i = 2 then bigAdd l l\n  else bigAdd (mulByDigit (i-1) l) (mulByDigit (i-1) l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = mulByDigit 9 [9;9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0\n  then []\n  else\n    if i = 1\n    then l\n    else\n      if i = 2\n      then bigAdd l l\n      else bigAdd (mulByDigit (i - 1) l) (mulByDigit (i - 1) l);;\n\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n","type":"","out":""}],"event":{"region":{"start":3564,"stop":3641},"type":"eval"},"cursor":3641,"time":1.399064115043599e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else if i = 2 then bigAdd l l\n  else bigAdd (mulByDigit (i-1) l) (mulByDigit (i-1) l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec mulByDigit i l = \nif i = 0 then []\nelse if i = 1 then l\nelse if i = 2 then bigAdd l l\nelse bigAdd (mulByDigit (i-2) l) (mulByDigit (i-1) l)","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0\n  then []\n  else\n    if i = 1\n    then l\n    else\n      if i = 2\n      then bigAdd l l\n      else bigAdd (mulByDigit (i - 2) l) (mulByDigit (i - 1) l);;\n","type":"","out":""}],"event":{"region":{"start":3412,"stop":3564},"type":"eval"},"cursor":3609,"time":1.399064122575969e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else if i = 2 then bigAdd l l\n  else bigAdd (mulByDigit (i-2) l) (mulByDigit (i-1) l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = mulByDigit 9 [9;9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0\n  then []\n  else\n    if i = 1\n    then l\n    else\n      if i = 2\n      then bigAdd l l\n      else bigAdd (mulByDigit (i - 2) l) (mulByDigit (i - 1) l);;\n\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n","type":"","out":""}],"event":{"region":{"start":3564,"stop":3641},"type":"eval"},"cursor":3642,"time":1.399064123455944e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else if i = 2 then bigAdd l l\n  else bigAdd (mulByDigit (i-2) l) (mulByDigit (i-1) l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec mulByDigit i l = \nif i = 0 then []\nelse if i = 1 then l\nelse if i = 2 then bigAdd l l\nelse bigAdd (mulByDigit (i-2) l) (mulByDigit (i-2) l)","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0\n  then []\n  else\n    if i = 1\n    then l\n    else\n      if i = 2\n      then bigAdd l l\n      else bigAdd (mulByDigit (i - 2) l) (mulByDigit (i - 2) l);;\n","type":"","out":""},{"in":"let _ = mulByDigit 9 [9;9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0\n  then []\n  else\n    if i = 1\n    then l\n    else\n      if i = 2\n      then bigAdd l l\n      else bigAdd (mulByDigit (i - 2) l) (mulByDigit (i - 2) l);;\n\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n","type":"","out":""}],"event":{"region":{"start":3412,"stop":3641},"type":"eval"},"cursor":3641,"time":1.399064131812069e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else if i = 2 then bigAdd l l\n  else bigAdd (mulByDigit (i-2) l) (mulByDigit (i-2) l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = bigAdd [1] [1]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [1] [1];;\n","type":"","out":""}],"event":{"region":{"start":3412,"stop":3438},"type":"eval"},"cursor":3440,"time":1.399064172954469e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [1] [1];;\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else if i = 2 then bigAdd l l\n  else bigAdd (mulByDigit (i-2) l) (mulByDigit (i-2) l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = bigAdd [1] [1;2]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [1] [1; 2];;\n","type":"","out":""}],"event":{"region":{"start":3412,"stop":3440},"type":"eval"},"cursor":3439,"time":1.399064176692026e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [1] [1;2];;\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else if i = 2 then bigAdd l l\n  else bigAdd (mulByDigit (i-2) l) (mulByDigit (i-2) l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = bigAdd [9;9;9;9] [9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n","type":"","out":""}],"event":{"region":{"start":3380,"stop":3412},"type":"eval"},"cursor":3414,"time":1.399064186864747e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else if i = 2 then bigAdd l l\n  else bigAdd (mulByDigit (i-2) l) (mulByDigit (i-2) l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec mulByDigit i l = \nif i = 0 then []\nelse if i = 1 then l\nelse if i = 2 then bigAdd l l\nelse bigAdd (mulByDigit (i-2) l) (mulByDigit (i-2) l)","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0\n  then []\n  else\n    if i = 1\n    then l\n    else\n      if i = 2\n      then bigAdd l l\n      else bigAdd (mulByDigit (i - 2) l) (mulByDigit (i - 2) l);;\n","type":"","out":""}],"event":{"region":{"start":3412,"stop":3563},"type":"eval"},"cursor":3458,"time":1.399064195274272e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else if i = 2 then bigAdd l l\n  else bigAdd (mulByDigit (i-2) l) (mulByDigit (i-2) l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec mulByDigit i l = \nif i = 0 then []\nelse if i = 1 then l\nelse if i = 2 then bigAdd l l\nelse bigAdd (mulByDigit (i-2) l) (mulByDigit 1 l)","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0\n  then []\n  else\n    if i = 1\n    then l\n    else\n      if i = 2\n      then bigAdd l l\n      else bigAdd (mulByDigit (i - 2) l) (mulByDigit 1 l);;\n","type":"","out":""}],"event":{"region":{"start":3412,"stop":3559},"type":"eval"},"cursor":3556,"time":1.399064485740319e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else if i = 2 then bigAdd l l\n  else bigAdd (mulByDigit (i-2) l) (mulByDigit 1 l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = mulByDigit 9 [9;9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0\n  then []\n  else\n    if i = 1\n    then l\n    else\n      if i = 2\n      then bigAdd l l\n      else bigAdd (mulByDigit (i - 2) l) (mulByDigit 1 l);;\n\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n","type":"","out":""}],"event":{"region":{"start":3559,"stop":3636},"type":"eval"},"cursor":3636,"time":1.399064488335156e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else if i = 2 then bigAdd l l\n  else bigAdd (mulByDigit (i-2) l) (mulByDigit 1 l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec mulByDigit i l = \nif i = 0 then []\nelse if i = 1 then l\nelse bigAdd (mulByDigit (i-2) l) (mulByDigit 1 l)","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0\n  then []\n  else if i = 1 then l else bigAdd (mulByDigit (i - 2) l) (mulByDigit 1 l);;\n","type":"","out":""}],"event":{"region":{"start":3412,"stop":3529},"type":"eval"},"cursor":3529,"time":1.399064508162715e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-2) l) (mulByDigit 1 l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = mulByDigit 9 [9;9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0\n  then []\n  else if i = 1 then l else bigAdd (mulByDigit (i - 2) l) (mulByDigit 1 l);;\n\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n","type":"","out":""}],"event":{"region":{"start":3529,"stop":3606},"type":"eval"},"cursor":3606,"time":1.399064509592983e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-2) l) (mulByDigit 1 l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec mulByDigit i l = \nif i = 0 then []\nelse if i = 1 then l\nelse bigAdd (mulByDigit (i-2) l) (mulByDigit i-2 l)","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0\n  then []\n  else\n    if i = 1\n    then l\n    else bigAdd (mulByDigit (i - 2) l) ((mulByDigit i) - (2 l));;\n","type":"type","out":"Characters 98-110:\n  else bigAdd (mulByDigit (i-2) l) (mulByDigit i-2 l);;\n                                    ^^^^^^^^^^^^\nError: This expression has type int list -> int list\n       but an expression was expected of type int\n"}],"event":{"region":{"start":3412,"stop":3531},"type":"eval"},"cursor":3528,"time":1.399064756633266e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-2) l) (mulByDigit i-2 l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec mulByDigit i l = \nif i = 0 then []\nelse if i = 1 then l\nelse bigAdd (mulByDigit (i-2) l) (mulByDigit (i-2) l)","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0\n  then []\n  else\n    if i = 1 then l else bigAdd (mulByDigit (i - 2) l) (mulByDigit (i - 2) l);;\n","type":"","out":""}],"event":{"region":{"start":3412,"stop":3533},"type":"eval"},"cursor":3530,"time":1.399064761562295e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-2) l) (mulByDigit (i-2) l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = mulByDigit 9 [9;9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0\n  then []\n  else\n    if i = 1 then l else bigAdd (mulByDigit (i - 2) l) (mulByDigit (i - 2) l);;\n\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n","type":"","out":""}],"event":{"region":{"start":3533,"stop":3610},"type":"eval"},"cursor":3610,"time":1.399064763073399e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-2) l) (mulByDigit (i-2) l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let x = bigAdd [9;9;9;9] [9;9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet x = bigAdd [9; 9; 9; 9] [9; 9; 9; 9];;\n","type":"","out":""}],"event":{"region":{"start":3412,"stop":3449},"type":"eval"},"cursor":3449,"time":1.399064836605831e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\nlet x = bigAdd [9;9;9;9] [9;9;9;9]\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-2) l) (mulByDigit (i-2) l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let y = bigAdd x x","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet x = bigAdd [9; 9; 9; 9] [9; 9; 9; 9];;\n\nlet y = bigAdd x x;;\n","type":"","out":""}],"event":{"region":{"start":3449,"stop":3468},"type":"eval"},"cursor":3468,"time":1.39906484972572e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\nlet x = bigAdd [9;9;9;9] [9;9;9;9]\nlet y = bigAdd x x\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-2) l) (mulByDigit (i-2) l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let z = bigAdd y x","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet x = bigAdd [9; 9; 9; 9] [9; 9; 9; 9];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n","type":"","out":""}],"event":{"region":{"start":3468,"stop":3487},"type":"eval"},"cursor":3487,"time":1.399064869486277e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\nlet x = bigAdd [9;9;9;9] [9;9;9;9]\nlet y = bigAdd x x\nlet z = bigAdd y x\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-2) l) (mulByDigit (i-2) l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let t = bigAdd x z","min":"\nlet y = bigAdd x x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet x = bigAdd [9; 9; 9; 9] [9; 9; 9; 9];;\n\nlet z = bigAdd y x;;\n\nlet t = bigAdd x z;;\n","type":"","out":""}],"event":{"region":{"start":3487,"stop":3506},"type":"eval"},"cursor":3506,"time":1.399064893655007e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\nlet x = bigAdd [9;9;9;9] [9;9;9;9]\nlet y = bigAdd x x\nlet z = bigAdd y x\nlet t = bigAdd x z\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-2) l) (mulByDigit (i-2) l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let r = bigAdd t x","min":"\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet t = bigAdd x z;;\n\nlet x = bigAdd [9; 9; 9; 9] [9; 9; 9; 9];;\n\nlet r = bigAdd t x;;\n","type":"","out":""}],"event":{"region":{"start":3506,"stop":3525},"type":"eval"},"cursor":3525,"time":1.399064902726002e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\nlet x = bigAdd [9;9;9;9] [9;9;9;9]\nlet y = bigAdd x x\nlet z = bigAdd y x\nlet t = bigAdd x z\nlet r = bigAdd t x\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-2) l) (mulByDigit (i-2) l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let e = bigAdd r x","min":"\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet t = bigAdd x z;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet r = bigAdd t x;;\n\nlet x = bigAdd [9; 9; 9; 9] [9; 9; 9; 9];;\n\nlet e = bigAdd r x;;\n","type":"","out":""}],"event":{"region":{"start":3525,"stop":3544},"type":"eval"},"cursor":3544,"time":1.399064926343773e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\nlet x = bigAdd [9;9;9;9] [9;9;9;9]\nlet y = bigAdd x x\nlet z = bigAdd y x\nlet t = bigAdd x z\nlet r = bigAdd t x\nlet e = bigAdd r x\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-2) l) (mulByDigit (i-2) l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let t = bigAdd x z","min":"\nlet y = bigAdd x x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet x = bigAdd [9; 9; 9; 9] [9; 9; 9; 9];;\n\nlet z = bigAdd y x;;\n\nlet t = bigAdd x z;;\n","type":"","out":""}],"event":{"region":{"start":3487,"stop":3506},"type":"eval"},"cursor":3506,"time":1.399065043223495e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\nlet x = bigAdd [9;9;9;9] [9;9;9;9]\nlet y = bigAdd x x\nlet z = bigAdd y x\nlet t = bigAdd x z\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-2) l) (mulByDigit (i-2) l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let d = bigAdd t x","min":"\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet t = bigAdd x z;;\n\nlet x = bigAdd [9; 9; 9; 9] [9; 9; 9; 9];;\n\nlet d = bigAdd t x;;\n","type":"","out":""}],"event":{"region":{"start":3506,"stop":3525},"type":"eval"},"cursor":3525,"time":1.39906506043702e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\nlet x = bigAdd [9;9;9;9] [9;9;9;9]\nlet y = bigAdd x x\nlet z = bigAdd y x\nlet t = bigAdd x z\nlet d = bigAdd t x\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-2) l) (mulByDigit (i-2) l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let x = [9;9;9;9]","min":"\nlet x = [9; 9; 9; 9];;\n","type":"","out":""}],"event":{"region":{"start":3412,"stop":3432},"type":"eval"},"cursor":3423,"time":1.399065110263946e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\nlet x = [9;9;9;9]\nlet y = bigAdd x x\nlet z = bigAdd y x\nlet t = bigAdd x z\nlet d = bigAdd t x\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-2) l) (mulByDigit (i-2) l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let y = bigAdd x x","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet x = [9; 9; 9; 9];;\n\nlet y = bigAdd x x;;\n","type":"","out":""}],"event":{"region":{"start":3432,"stop":3451},"type":"eval"},"cursor":3449,"time":1.399065115085861e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\nlet x = [9;9;9;9]\nlet y = bigAdd x x\nlet z = bigAdd y x\nlet t = bigAdd x z\nlet d = bigAdd t x\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-2) l) (mulByDigit (i-2) l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let z = bigAdd y x","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet x = [9; 9; 9; 9];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n","type":"","out":""}],"event":{"region":{"start":3451,"stop":3470},"type":"eval"},"cursor":3468,"time":1.399065116294935e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\nlet x = [9;9;9;9]\nlet y = bigAdd x x\nlet z = bigAdd y x\nlet t = bigAdd x z\nlet d = bigAdd t x\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-2) l) (mulByDigit (i-2) l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let t = bigAdd x z","min":"\nlet y = bigAdd x x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet x = [9; 9; 9; 9];;\n\nlet z = bigAdd y x;;\n\nlet t = bigAdd x z;;\n","type":"","out":""}],"event":{"region":{"start":3470,"stop":3489},"type":"eval"},"cursor":3487,"time":1.399065117259611e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\nlet x = [9;9;9;9]\nlet y = bigAdd x x\nlet z = bigAdd y x\nlet t = bigAdd x z\nlet d = bigAdd t x\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-2) l) (mulByDigit (i-2) l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let d = bigAdd t x","min":"\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet t = bigAdd x z;;\n\nlet x = [9; 9; 9; 9];;\n\nlet d = bigAdd t x;;\n","type":"","out":""}],"event":{"region":{"start":3489,"stop":3508},"type":"eval"},"cursor":3506,"time":1.399065118002154e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\nlet x = [9;9;9;9]\nlet y = bigAdd x x\nlet z = bigAdd y x\nlet t = bigAdd x z\nlet d = bigAdd t x\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-2) l) (mulByDigit (i-2) l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let 1 = bigAdd x x","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet x = [9; 9; 9; 9];;\n\nlet 1 = bigAdd x x;;\n","type":"type","out":"Characters 8-18:\n  let 1 = bigAdd x x;;\n          ^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n"},{"in":"let 2 = bigAdd 1 x","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet x = [9; 9; 9; 9];;\n\nlet 2 = bigAdd 1 x;;\n","type":"type","out":"Characters 15-16:\n  let 2 = bigAdd 1 x;;\n                 ^\nError: This expression has type int but an expression was expected of type\n         int list\n"},{"in":"let 3 = bigAdd 2 x","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet x = [9; 9; 9; 9];;\n\nlet 3 = bigAdd 2 x;;\n","type":"type","out":"Characters 15-16:\n  let 3 = bigAdd 2 x;;\n                 ^\nError: This expression has type int but an expression was expected of type\n         int list\n"},{"in":"let 4 = bigAdd 3 x","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet x = [9; 9; 9; 9];;\n\nlet 4 = bigAdd 3 x;;\n","type":"type","out":"Characters 15-16:\n  let 4 = bigAdd 3 x;;\n                 ^\nError: This expression has type int but an expression was expected of type\n         int list\n"},{"in":"let 5 = bigAdd 4 x","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet x = [9; 9; 9; 9];;\n\nlet 5 = bigAdd 4 x;;\n","type":"type","out":"Characters 15-16:\n  let 5 = bigAdd 4 x;;\n                 ^\nError: This expression has type int but an expression was expected of type\n         int list\n"}],"event":{"region":{"start":3432,"stop":3527},"type":"eval"},"cursor":3527,"time":1.399065145326021e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\nlet x = [9;9;9;9]\nlet 1 = bigAdd x x\nlet 2 = bigAdd 1 x\nlet 3 = bigAdd 2 x\nlet 4 = bigAdd 3 x\nlet 5 = bigAdd 4 x\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-2) l) (mulByDigit (i-2) l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let y = bigAdd x x","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet x = [9; 9; 9; 9];;\n\nlet y = bigAdd x x;;\n","type":"","out":""},{"in":"let z = bigAdd y x","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet x = [9; 9; 9; 9];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n","type":"","out":""},{"in":"let a = bigAdd z x","min":"\nlet y = bigAdd x x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet x = [9; 9; 9; 9];;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n","type":"","out":""},{"in":"let b = bigAdd a x","min":"\nlet y = bigAdd x x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet x = [9; 9; 9; 9];;\n\nlet b = bigAdd a x;;\n","type":"","out":""},{"in":"let c = bigAdd b x","min":"\nlet y = bigAdd x x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet x = [9; 9; 9; 9];;\n\nlet c = bigAdd b x;;\n","type":"","out":""}],"event":{"region":{"start":3432,"stop":3527},"type":"eval"},"cursor":3525,"time":1.39906516277456e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\nlet x = [9;9;9;9]\nlet y = bigAdd x x\nlet z = bigAdd y x\nlet a = bigAdd z x\nlet b = bigAdd a x\nlet c = bigAdd b x\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-2) l) (mulByDigit (i-2) l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let d = bigAdd c x","min":"\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet c = bigAdd b x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet d = bigAdd c x;;\n","type":"","out":""}],"event":{"region":{"start":3527,"stop":3546},"type":"eval"},"cursor":3546,"time":1.399065170925649e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\nlet x = [9;9;9;9]\nlet y = bigAdd x x\nlet z = bigAdd y x\nlet a = bigAdd z x\nlet b = bigAdd a x\nlet c = bigAdd b x\nlet d = bigAdd c x\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-2) l) (mulByDigit (i-2) l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let e = bigAdd e x","min":"\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet t = bigAdd x z;;\n\nlet r = bigAdd t x;;\n\nlet x = bigAdd [9; 9; 9; 9] [9; 9; 9; 9];;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet e = bigAdd r x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet e = bigAdd e x;;\n","type":"","out":""}],"event":{"region":{"start":3546,"stop":3565},"type":"eval"},"cursor":3565,"time":1.399065179552321e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\nlet x = [9;9;9;9]\nlet y = bigAdd x x\nlet z = bigAdd y x\nlet a = bigAdd z x\nlet b = bigAdd a x\nlet c = bigAdd b x\nlet d = bigAdd c x\nlet e = bigAdd e x\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-2) l) (mulByDigit (i-2) l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let e = bigAdd d x","min":"\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet d = bigAdd c x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet e = bigAdd d x;;\n","type":"","out":""}],"event":{"region":{"start":3546,"stop":3565},"type":"eval"},"cursor":3563,"time":1.399065184574282e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\nlet x = [9;9;9;9]\nlet y = bigAdd x x\nlet z = bigAdd y x\nlet a = bigAdd z x\nlet b = bigAdd a x\nlet c = bigAdd b x\nlet d = bigAdd c x\nlet e = bigAdd d x\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-2) l) (mulByDigit (i-2) l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let f = bigAdd e x","min":"\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet e = bigAdd d x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet f = bigAdd e x;;\n","type":"","out":""}],"event":{"region":{"start":3565,"stop":3584},"type":"eval"},"cursor":3584,"time":1.399065194165932e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\nlet x = [9;9;9;9]\nlet y = bigAdd x x\nlet z = bigAdd y x\nlet a = bigAdd z x\nlet b = bigAdd a x\nlet c = bigAdd b x\nlet d = bigAdd c x\nlet e = bigAdd d x\nlet f = bigAdd e x\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-2) l) (mulByDigit (i-2) l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let g = bigAdd f x","min":"\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet f = bigAdd e x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet g = bigAdd f x;;\n","type":"","out":""}],"event":{"region":{"start":3584,"stop":3603},"type":"eval"},"cursor":3603,"time":1.399065235863443e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\nlet x = [9;9;9;9]\nlet y = bigAdd x x\nlet z = bigAdd y x\nlet a = bigAdd z x\nlet b = bigAdd a x\nlet c = bigAdd b x\nlet d = bigAdd c x\nlet e = bigAdd d x\nlet f = bigAdd e x\nlet g = bigAdd f x\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-2) l) (mulByDigit (i-2) l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let h = bigAdd g x","min":"\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n","type":"","out":""}],"event":{"region":{"start":3603,"stop":3622},"type":"eval"},"cursor":3622,"time":1.399065243735006e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\nlet x = [9;9;9;9]\nlet y = bigAdd x x\nlet z = bigAdd y x\nlet a = bigAdd z x\nlet b = bigAdd a x\nlet c = bigAdd b x\nlet d = bigAdd c x\nlet e = bigAdd d x\nlet f = bigAdd e x\nlet g = bigAdd f x\nlet h = bigAdd g x\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-2) l) (mulByDigit (i-2) l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let f = bigAdd e x","min":"\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet e = bigAdd d x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet f = bigAdd e x;;\n","type":"","out":""}],"event":{"region":{"start":3566,"stop":3584},"type":"eval"},"cursor":3585,"time":1.399065266192795e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\nlet x = [9;9;9;9]\nlet y = bigAdd x x\nlet z = bigAdd y x\nlet a = bigAdd z x\nlet b = bigAdd a x\nlet c = bigAdd b x\nlet d = bigAdd c x\nlet e = bigAdd d x\nlet f = bigAdd e x\n\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-2) l) (mulByDigit (i-2) l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec mulByDigit i l = \nif i = 0 then []\nelse if i = 1 then l\nelse bigAdd (mulByDigit (i-2) l) (l)","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 2) l) l;;\n","type":"","out":""},{"in":"let _ = mulByDigit 9 [9;9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 2) l) l;;\n\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n","type":"","out":""}],"event":{"region":{"start":3412,"stop":3593},"type":"eval"},"cursor":3593,"time":1.399065563164106e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-2) l) (l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec mulByDigit i l = \nif i = 0 then []\nelse if i = 1 then l\nelse bigAdd (mulByDigit (i-1) l) (l)","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n","type":"","out":""},{"in":"let _ = mulByDigit 9 [9;9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n","type":"","out":""}],"event":{"region":{"start":3412,"stop":3593},"type":"eval"},"cursor":3593,"time":1.39906558454545e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-1) l) (l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = mulByDigit 6 [1;1;1;1]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet _ = mulByDigit 6 [1; 1; 1; 1];;\n","type":"","out":""}],"event":{"region":{"start":3593,"stop":3624},"type":"eval"},"cursor":3623,"time":1.399065618714844e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-1) l) (l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\nlet _ = mulByDigit 6 [1;1;1;1]\n\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = mulByDigit 9 [1;1;1;1]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet _ = mulByDigit 9 [1; 1; 1; 1];;\n","type":"","out":""}],"event":{"region":{"start":3593,"stop":3624},"type":"eval"},"cursor":3614,"time":1.399065625736252e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-1) l) (l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\nlet _ = mulByDigit 9 [1;1;1;1]\n\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = mulByDigit 10 [9;9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet _ = mulByDigit 10 [9; 9; 9; 9];;\n","type":"","out":""}],"event":{"region":{"start":3516,"stop":3594},"type":"eval"},"cursor":3584,"time":1.399065679363733e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-1) l) (l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 10 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = mulByDigit 11 [9;9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet _ = mulByDigit 11 [9; 9; 9; 9];;\n","type":"","out":""}],"event":{"region":{"start":3516,"stop":3594},"type":"eval"},"cursor":3584,"time":1.399065682874308e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-1) l) (l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 11 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = mulByDigit 9 [9;9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n","type":"","out":""}],"event":{"region":{"start":3516,"stop":3593},"type":"eval"},"cursor":3583,"time":1.3990656850923e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-1) l) (l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = bigAdd [130][260]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [130] [260];;\n","type":"","out":""}],"event":{"region":{"start":3412,"stop":3440},"type":"eval"},"cursor":3439,"time":1.399065801021344e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\nlet _ = bigAdd [130][260]\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-1) l) (l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec mulByDigit i l = \nif i = 0 then []\nelse if i = 1 then l\nelse bigAdd (mulByDigit (i-1) l) (l)","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n","type":"","out":""},{"in":"let _ = mulByDigit 9 [9;9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n","type":"","out":""}],"event":{"region":{"start":3412,"stop":3593},"type":"eval"},"cursor":3593,"time":1.399065828376133e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-1) l) (l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = removeZero [0;0;0;0]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet _ = removeZero [0; 0; 0; 0];;\n","type":"","out":""},{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (list2, res) -> match list2 with \n| [] -> ([],res)\n| h::t -> match res with\n| [] -> (t,(h+x)::res)\n| h2::t2 -> if h2 >= 10 \nthen \n(t,if t != [] then (h+x+1)::(h2 mod 10)::t2\nelse \nif (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\nelse (h+x+1)::(h2 mod 10)::t2)\nelse \n(t,if t != [] then (h+x)::res\nelse if (h+x) >= 10 then 1::(h+x) mod 10::res\nelse (h+x)::res)\nin\nlet base = (List.rev l2, []) in\nlet args = List.rev l1 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9] [1;0;0;2]","min":"\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9;9;9] [9;9;9]","min":"\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n","type":"","out":""},{"in":"let rec mulByDigit i l = \nif i = 0 then []\nelse if i = 1 then l\nelse bigAdd (mulByDigit (i-1) l) (l)","min":"\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n","type":"","out":""},{"in":"let _ = mulByDigit 9 [9;9;9;9]","min":"\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let bigMul l1 l2 = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres","min":"\nlet bigMul l1 l2 =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_,res) = List.fold_left f base args in res;;\n","type":"","out":""},{"in":"let key = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130 = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ ((Printexc.to_string e) ^ \"\\n\"));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n","type":"","out":""},{"in":"let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","min":"\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n","type":"","out":""},{"in":"let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n\nlet drop_paren s =\n  implode\n    (List.filter (fun c  -> not (List.mem c ['('; ' '; ')'])) (explode s));;\n","type":"","out":""},{"in":"let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","min":"\nlet eq_real p (r1,r2) = ((r1 -. r2) < p) || ((r2 -. r1) < p);;\n","type":"","out":""},{"in":"let wrap_curried_2 f (a,b) = f a b","min":"\nlet wrap_curried_2 f (a,b) = f a b;;\n","type":"","out":""}],"event":{"region":{"start":2690,"stop":7910},"type":"eval"},"cursor":2718,"time":1.399066108586065e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-1) l) (l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let sqsum xs = \nlet f a x = x * x + a in\nlet base = 0 in\nList.fold_left f base xs","min":"\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n","type":"","out":""},{"in":"let _ = sqsum []","min":"\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [];;\n","type":"","out":""},{"in":"let _ = sqsum [1;2;3;4]","min":"\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sqsum [(-1); (-2); (-3); (-4)]","min":"\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [(-1); (-2); (-3); (-4)];;\n","type":"","out":""},{"in":"let pipe fs =  \nlet f a x = x a  in\nfun base -> \nList.fold_left f base fs","min":"\nlet pipe fs = let f a x = x a in fun base  -> List.fold_left f base fs;;\n","type":"","out":""},{"in":"let _ = pipe [] 3","min":"\nlet pipe fs = let f a x = x a in fun base  -> List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n","type":"","out":""},{"in":"let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3","min":"\nlet pipe fs = let f a x = x a in fun base  -> List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n","type":"","out":""},{"in":"let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3","min":"\nlet pipe fs = let f a x = x a in fun base  -> List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n","type":"","out":""},{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l","min":"\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet t = bigAdd x z;;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n","type":"","out":""},{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet t = bigAdd x z;;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"---\" []","min":"\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet t = bigAdd x z;;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"---\" [];;\n","type":"","out":""},{"in":"let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]","min":"\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet t = bigAdd x z;;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"\" [\"a\"; \"b\"; \"c\"; \"d\"; \"e\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"X\" [\"hello\"]","min":"\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet t = bigAdd x z;;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"X\" [\"hello\"];;\n","type":"","out":""},{"in":"let stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"","min":"\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet t = bigAdd x z;;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n","type":"","out":""},{"in":"let _ = stringOfList string_of_int [1;2;3;4;5;6]","min":"\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet t = bigAdd x z;;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n\nlet _ = stringOfList string_of_int [1; 2; 3; 4; 5; 6];;\n","type":"","out":""},{"in":"let _ = stringOfList (fun x -> x) [\"foo\"]","min":"\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet t = bigAdd x z;;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n\nlet _ = stringOfList (fun x  -> x) [\"foo\"];;\n","type":"","out":""},{"in":"let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]","min":"\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet t = bigAdd x z;;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n\nlet _ =\n  stringOfList (stringOfList string_of_int) [[1; 2; 3]; [4; 5]; [6]; []];;\n","type":"","out":""},{"in":"let rec clone x n = if n > 0 then x :: clone x (n-1) else []","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n","type":"","out":""},{"in":"let _ = clone 3 5","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet _ = clone 3 5;;\n","type":"","out":""},{"in":"let _ = clone \"foo\" 2","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet _ = clone \"foo\" 2;;\n","type":"","out":""},{"in":"let _ = clone clone (-3)","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet _ = clone clone (-3);;\n","type":"","out":""},{"in":"let padZero l1 l2 = if List.length l1 > List.length l2 then\n(l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \nelse \n(List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n","type":"","out":""},{"in":"let _ = padZero [9;9] [1;0;0;2]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet _ = padZero [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = padZero [1;0;0;2] [9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet _ = padZero [1; 0; 0; 2] [9; 9];;\n","type":"","out":""},{"in":"let rec removeZero l = match l with\n| [] -> []\n| h::t -> if h != 0 then l\nelse removeZero t","min":"\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet t = bigAdd x z;;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;1;0;0;2]","min":"\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet t = bigAdd x z;;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet _ = removeZero [0; 0; 0; 1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = removeZero [9;9]","min":"\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet t = bigAdd x z;;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet _ = removeZero [9; 9];;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;0]","min":"\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet t = bigAdd x z;;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet _ = removeZero [0; 0; 0; 0];;\n","type":"","out":""},{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (list2, res) -> match list2 with \n| [] -> ([],res)\n| h::t -> match res with\n| [] -> (t,(h+x)::res)\n| h2::t2 -> if h2 >= 10 \nthen \n(t,if t != [] then (h+x+1)::(h2 mod 10)::t2\nelse \nif (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\nelse (h+x+1)::(h2 mod 10)::t2)\nelse \n(t,if t != [] then (h+x)::res\nelse if (h+x) >= 10 then 1::(h+x) mod 10::res\nelse (h+x)::res)\nin\nlet base = (List.rev l2, []) in\nlet args = List.rev l1 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9] [1;0;0;2]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9;9;9] [9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n","type":"","out":""},{"in":"let rec mulByDigit i l = \nif i = 0 then []\nelse if i = 1 then l\nelse bigAdd (mulByDigit (i-1) l) (l)","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n","type":"","out":""},{"in":"let _ = mulByDigit 9 [9;9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let bigMul l1 l2 = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres","min":"\nlet bigMul l1 l2 =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_,res) = List.fold_left f base args in res;;\n","type":"","out":""},{"in":"let key = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130 = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ ((Printexc.to_string e) ^ \"\\n\"));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n","type":"","out":""},{"in":"let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","min":"\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n","type":"","out":""},{"in":"let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n\nlet drop_paren s =\n  implode\n    (List.filter (fun c  -> not (List.mem c ['('; ' '; ')'])) (explode s));;\n","type":"","out":""},{"in":"let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","min":"\nlet eq_real p (r1,r2) = ((r1 -. r2) < p) || ((r2 -. r1) < p);;\n","type":"","out":""},{"in":"let wrap_curried_2 f (a,b) = f a b","min":"\nlet wrap_curried_2 f (a,b) = f a b;;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":7910},"type":"eval"},"cursor":3415,"time":1.399066155916277e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-1) l) (l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, mulByDigit x list1) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (list1,res) -> (list1, (mulByDigit x list1)) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n","type":"","out":""}],"event":{"region":{"start":3593,"stop":3786},"type":"eval"},"cursor":3786,"time":1.399067197457729e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-1) l) (l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = match a with\n    | (list1, res) -> (list1, mulByDigit x list1) in\n  let base = (l1,[]) in\n  let args = List.rev l2 in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = bigMul [9;9;9;9] [9;9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (list1,res) -> (list1, (mulByDigit x list1)) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (list1,res) -> (list1, (mulByDigit x list1)) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9; 9] [9; 9; 9; 9; 9];;\n","type":"","out":""}],"event":{"region":{"start":3786,"stop":3905},"type":"eval"},"cursor":3906,"time":1.399067206444814e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-1) l) (l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = match a with\n    | (list1, res) -> (list1, mulByDigit x list1) in\n  let base = (l1,[]) in\n  let args = List.rev l2 in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (mulByDigit x list1, mulByDigit x list1) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (list1,res) -> ((mulByDigit x list1), (mulByDigit x list1)) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n","type":"","out":""},{"in":"let _ = bigMul [9;9;9;9] [9;9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (list1,res) -> ((mulByDigit x list1), (mulByDigit x list1)) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (list1,res) -> ((mulByDigit x list1), (mulByDigit x list1)) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9; 9] [9; 9; 9; 9; 9];;\n","type":"","out":""}],"event":{"region":{"start":3593,"stop":3918},"type":"eval"},"cursor":3919,"time":1.399067269445305e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-1) l) (l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = match a with\n    | (list1, res) -> (mulByDigit x list1, mulByDigit x list1) in\n  let base = (l1,[]) in\n  let args = List.rev l2 in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let sqsum xs = \nlet f a x = x * x + a in\nlet base = 0 in\nList.fold_left f base xs","min":"\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n","type":"","out":""},{"in":"let _ = sqsum []","min":"\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [];;\n","type":"","out":""},{"in":"let _ = sqsum [1;2;3;4]","min":"\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sqsum [(-1); (-2); (-3); (-4)]","min":"\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [(-1); (-2); (-3); (-4)];;\n","type":"","out":""},{"in":"let pipe fs =  \nlet f a x = x a  in\nfun base -> \nList.fold_left f base fs","min":"\nlet pipe fs = let f a x = x a in fun base  -> List.fold_left f base fs;;\n","type":"","out":""},{"in":"let _ = pipe [] 3","min":"\nlet pipe fs = let f a x = x a in fun base  -> List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n","type":"","out":""},{"in":"let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3","min":"\nlet pipe fs = let f a x = x a in fun base  -> List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n","type":"","out":""},{"in":"let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3","min":"\nlet pipe fs = let f a x = x a in fun base  -> List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n","type":"","out":""},{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l","min":"\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet t = bigAdd x z;;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n","type":"","out":""},{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet t = bigAdd x z;;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"---\" []","min":"\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet t = bigAdd x z;;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"---\" [];;\n","type":"","out":""},{"in":"let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]","min":"\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet t = bigAdd x z;;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"\" [\"a\"; \"b\"; \"c\"; \"d\"; \"e\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"X\" [\"hello\"]","min":"\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet t = bigAdd x z;;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"X\" [\"hello\"];;\n","type":"","out":""},{"in":"let stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"","min":"\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet t = bigAdd x z;;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n","type":"","out":""},{"in":"let _ = stringOfList string_of_int [1;2;3;4;5;6]","min":"\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet t = bigAdd x z;;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n\nlet _ = stringOfList string_of_int [1; 2; 3; 4; 5; 6];;\n","type":"","out":""},{"in":"let _ = stringOfList (fun x -> x) [\"foo\"]","min":"\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet t = bigAdd x z;;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n\nlet _ = stringOfList (fun x  -> x) [\"foo\"];;\n","type":"","out":""},{"in":"let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]","min":"\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet t = bigAdd x z;;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n\nlet _ =\n  stringOfList (stringOfList string_of_int) [[1; 2; 3]; [4; 5]; [6]; []];;\n","type":"","out":""},{"in":"let rec clone x n = if n > 0 then x :: clone x (n-1) else []","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n","type":"","out":""},{"in":"let _ = clone 3 5","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet _ = clone 3 5;;\n","type":"","out":""},{"in":"let _ = clone \"foo\" 2","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet _ = clone \"foo\" 2;;\n","type":"","out":""},{"in":"let _ = clone clone (-3)","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet _ = clone clone (-3);;\n","type":"","out":""},{"in":"let padZero l1 l2 = if List.length l1 > List.length l2 then\n(l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \nelse \n(List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n","type":"","out":""},{"in":"let _ = padZero [9;9] [1;0;0;2]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet _ = padZero [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = padZero [1;0;0;2] [9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet _ = padZero [1; 0; 0; 2] [9; 9];;\n","type":"","out":""},{"in":"let rec removeZero l = match l with\n| [] -> []\n| h::t -> if h != 0 then l\nelse removeZero t","min":"\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet t = bigAdd x z;;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;1;0;0;2]","min":"\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet t = bigAdd x z;;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet _ = removeZero [0; 0; 0; 1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = removeZero [9;9]","min":"\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet t = bigAdd x z;;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet _ = removeZero [9; 9];;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;0]","min":"\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet t = bigAdd x z;;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet _ = removeZero [0; 0; 0; 0];;\n","type":"","out":""},{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (list2, res) -> match list2 with \n| [] -> ([],res)\n| h::t -> match res with\n| [] -> (t,(h+x)::res)\n| h2::t2 -> if h2 >= 10 \nthen \n(t,if t != [] then (h+x+1)::(h2 mod 10)::t2\nelse \nif (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\nelse (h+x+1)::(h2 mod 10)::t2)\nelse \n(t,if t != [] then (h+x)::res\nelse if (h+x) >= 10 then 1::(h+x) mod 10::res\nelse (h+x)::res)\nin\nlet base = (List.rev l2, []) in\nlet args = List.rev l1 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9] [1;0;0;2]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9;9;9] [9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n","type":"","out":""},{"in":"let rec mulByDigit i l = \nif i = 0 then []\nelse if i = 1 then l\nelse bigAdd (mulByDigit (i-1) l) (l)","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n","type":"","out":""},{"in":"let _ = mulByDigit 9 [9;9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":3593},"type":"eval"},"cursor":3593,"time":1.399068179060783e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-1) l) (l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = match a with\n    | (list1, res) -> (list1, mulByDigit x list1) in\n  let base = (l1,[]) in\n  let args = List.rev l2 in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, mulByDigit x list1) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (list1,res) -> (list1, (mulByDigit x list1)) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n","type":"","out":""},{"in":"let _ = bigMul [9;9;9;9] [9;9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (list1,res) -> (list1, (mulByDigit x list1)) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (list1,res) -> (list1, (mulByDigit x list1)) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9; 9] [9; 9; 9; 9; 9];;\n","type":"","out":""}],"event":{"region":{"start":3593,"stop":3905},"type":"eval"},"cursor":3906,"time":1.399068187370885e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-1) l) (l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = match a with\n    | (list1, res) -> (list1, mulByDigit x list1) in\n  let base = (l1,[]) in\n  let args = List.rev l2 in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, mulByDigit x*10 list1) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres","min":"","type":"scope","out":"Error: This expression has type int list -> int list\n       but an expression was expected of type int\nError: Unbound value bigAdd\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 71-83:\n  | (list1, res) -> (list1, mulByDigit x*10 list1) in\n                            ^^^^^^^^^^^^\nError: This expression has type int list -> int list\n       but an expression was expected of type int\n"},{"in":"let _ = bigMul [9;9;9;9] [9;9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (list1,res) -> (list1, (mulByDigit x list1)) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (list1,res) -> (list1, (mulByDigit x list1)) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9; 9] [9; 9; 9; 9; 9];;\n","type":"","out":""}],"event":{"region":{"start":3593,"stop":3908},"type":"eval"},"cursor":3909,"time":1.399068383446581e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-1) l) (l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = match a with\n    | (list1, res) -> (list1, mulByDigit x*10 list1) in\n  let base = (l1,[]) in\n  let args = List.rev l2 in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, mulByDigit (x*10) list1) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (list1,res) -> (list1, (mulByDigit (x * 10) list1)) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n","type":"","out":""},{"in":"let _ = bigMul [9;9;9;9] [9;9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (list1,res) -> (list1, (mulByDigit (x * 10) list1)) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (list1,res) -> (list1, (mulByDigit (x * 10) list1)) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9; 9] [9; 9; 9; 9; 9];;\n","type":"","out":""}],"event":{"region":{"start":3593,"stop":3910},"type":"eval"},"cursor":3911,"time":1.399068392719618e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-1) l) (l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = match a with\n    | (list1, res) -> (list1, mulByDigit (x*10) list1) in\n  let base = (l1,[]) in\n  let args = List.rev l2 in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, mulByDigit (x*10**List.length res) list1) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres","min":"","type":"scope","out":"Error: This expression has type int but an expression was expected of type\n         float\nError: Unbound value bigAdd\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 85-87:\n  | (list1, res) -> (list1, mulByDigit (x*10**List.length res) list1) in\n                                          ^^\nError: This expression has type int but an expression was expected of type\n         float\n"}],"event":{"region":{"start":3593,"stop":3808},"type":"eval"},"cursor":3700,"time":1.399069424869794e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-1) l) (l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = match a with\n    | (list1, res) -> (list1, mulByDigit (x*10**List.length res) list1) in\n  let base = (l1,[]) in\n  let args = List.rev l2 in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, mulByDigit (x*(10**List.length res)) list1) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres","min":"","type":"scope","out":"Error: This expression has type int but an expression was expected of type\n         float\nError: Unbound value bigAdd\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 86-88:\n  | (list1, res) -> (list1, mulByDigit (x*(10**List.length res)) list1) in\n                                           ^^\nError: This expression has type int but an expression was expected of type\n         float\n"},{"in":"let _ = bigMul [9;9;9;9] [9;9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (list1,res) -> (list1, (mulByDigit (x * 10) list1)) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (list1,res) -> (list1, (mulByDigit (x * 10) list1)) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9; 9] [9; 9; 9; 9; 9];;\n","type":"","out":""}],"event":{"region":{"start":3593,"stop":3929},"type":"eval"},"cursor":3930,"time":1.399069524746291e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-1) l) (l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = match a with\n    | (list1, res) -> (list1, mulByDigit (x*(10**List.length res)) list1) in\n  let base = (l1,[]) in\n  let args = List.rev l2 in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, mulByDigit (int_of_float float_of_int x*.(10.**List.length res)) list1) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres","min":"","type":"scope","out":"Error: This function has type float -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\nError: Unbound value bigAdd\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 83-95:\n  | (list1, res) -> (list1, mulByDigit (int_of_float float_of_int x*.(10.**List.length res)) list1) in\n                                        ^^^^^^^^^^^^\nError: This function has type float -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"},{"in":"let _ = bigMul [9;9;9;9] [9;9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (list1,res) -> (list1, (mulByDigit (x * 10) list1)) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (list1,res) -> (list1, (mulByDigit (x * 10) list1)) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9; 9] [9; 9; 9; 9; 9];;\n","type":"","out":""}],"event":{"region":{"start":3593,"stop":3957},"type":"eval"},"cursor":3958,"time":1.399069570846375e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-1) l) (l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = match a with\n    | (list1, res) -> (list1, mulByDigit (int_of_float float_of_int x*.(10.**List.length res)) list1) in\n  let base = (l1,[]) in\n  let args = List.rev l2 in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, mulByDigit (int_of_float (float_of_int x*.(10.**List.length res)) list1) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres","min":"","type":"syntax","out":"Characters 63-64:\n  | (list1, res) -> (list1, mulByDigit (int_of_float (float_of_int x*.(10.**List.length res)) list1) in\n                    ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n"},{"in":"let _ = bigMul [9;9;9;9] [9;9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (list1,res) -> (list1, (mulByDigit (x * 10) list1)) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (list1,res) -> (list1, (mulByDigit (x * 10) list1)) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9; 9] [9; 9; 9; 9; 9];;\n","type":"","out":""}],"event":{"region":{"start":3593,"stop":3958},"type":"eval"},"cursor":3960,"time":1.399069627220642e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-1) l) (l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = match a with\n    | (list1, res) -> (list1, mulByDigit (int_of_float (float_of_int x*.(10.**List.length res)) list1) in\n  let base = (l1,[]) in\n  let args = List.rev l2 in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, mulByDigit (int_of_float ((float_of_int x)*.(10.**List.length res)) list1) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres","min":"","type":"syntax","out":"Characters 63-64:\n  | (list1, res) -> (list1, mulByDigit (int_of_float ((float_of_int x)*.(10.**List.length res)) list1) in\n                    ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n"},{"in":"let _ = bigMul [9;9;9;9] [9;9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (list1,res) -> (list1, (mulByDigit (x * 10) list1)) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (list1,res) -> (list1, (mulByDigit (x * 10) list1)) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9; 9] [9; 9; 9; 9; 9];;\n","type":"","out":""}],"event":{"region":{"start":3593,"stop":3960},"type":"eval"},"cursor":3961,"time":1.399069649215173e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-1) l) (l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = match a with\n    | (list1, res) -> (list1, mulByDigit (int_of_float ((float_of_int x)*.(10.**List.length res)) list1) in\n  let base = (l1,[]) in\n  let args = List.rev l2 in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, mulByDigit (x*10**List.length res) list1) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres","min":"","type":"scope","out":"Error: This expression has type int but an expression was expected of type\n         float\nError: Unbound value bigAdd\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 85-87:\n  | (list1, res) -> (list1, mulByDigit (x*10**List.length res) list1) in\n                                          ^^\nError: This expression has type int but an expression was expected of type\n         float\n"},{"in":"let _ = bigMul [9;9;9;9] [9;9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (list1,res) -> (list1, (mulByDigit (x * 10) list1)) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (list1,res) -> (list1, (mulByDigit (x * 10) list1)) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9; 9] [9; 9; 9; 9; 9];;\n","type":"","out":""}],"event":{"region":{"start":3593,"stop":3927},"type":"eval"},"cursor":3928,"time":1.399069706784921e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-1) l) (l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = match a with\n    | (list1, res) -> (list1, mulByDigit (x*10**List.length res) list1) in\n  let base = (l1,[]) in\n  let args = List.rev l2 in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, mulByDigit (x*.10.**List.length res) list1) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres","min":"","type":"scope","out":"Error: This expression has type int but an expression was expected of type\n         float\nError: Unbound value bigAdd\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 91-106:\n  | (list1, res) -> (list1, mulByDigit (x*.10.**List.length res) list1) in\n                                                ^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         float\n"},{"in":"let _ = bigMul [9;9;9;9] [9;9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (list1,res) -> (list1, (mulByDigit (x * 10) list1)) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n","type":"","out":""}],"event":{"region":{"start":3593,"stop":3890},"type":"eval"},"cursor":3890,"time":1.399069763954783e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-1) l) (l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = match a with\n    | (list1, res) -> (list1, mulByDigit (x*.10.**List.length res) list1) in\n  let base = (l1,[]) in\n  let args = List.rev l2 in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, mulByDigit (x*(10 exp List.length res)) list1) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres","min":"","type":"scope","out":"Error: This expression has type int\n       This is not a function; it cannot be applied.\nError: Unbound value bigAdd\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 86-88:\n  | (list1, res) -> (list1, mulByDigit (x*(10 exp List.length res)) list1) in\n                                           ^^\nError: This expression has type int\n       This is not a function; it cannot be applied.\n"}],"event":{"region":{"start":3593,"stop":3813},"type":"eval"},"cursor":3705,"time":1.399069868155079e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-1) l) (l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = match a with\n    | (list1, res) -> (list1, mulByDigit (x*(10 exp List.length res)) list1) in\n  let base = (l1,[]) in\n  let args = List.rev l2 in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, mulByDigit (x*10 * List.length res) list1) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (list1,res) ->\n        (list1, (mulByDigit ((x * 10) * (List.length res)) list1)) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n","type":"","out":""}],"event":{"region":{"start":3593,"stop":3809},"type":"eval"},"cursor":3685,"time":1.39906988244163e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-1) l) (l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = match a with\n    | (list1, res) -> (list1, mulByDigit (x*10 * List.length res) list1) in\n  let base = (l1,[]) in\n  let args = List.rev l2 in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = bigMul [9;9;9;9] [9;9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (list1,res) ->\n        (list1, (mulByDigit ((x * 10) * (List.length res)) list1)) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (list1,res) ->\n        (list1, (mulByDigit ((x * 10) * (List.length res)) list1)) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9; 9] [9; 9; 9; 9; 9];;\n","type":"","out":""}],"event":{"region":{"start":3809,"stop":3928},"type":"eval"},"cursor":3929,"time":1.399069885140961e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-1) l) (l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = match a with\n    | (list1, res) -> (list1, mulByDigit (x*10 * List.length res) list1) in\n  let base = (l1,[]) in\n  let args = List.rev l2 in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, mulByDigit (x*10 ** List.length res) list1) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres","min":"","type":"scope","out":"Error: This expression has type int but an expression was expected of type\n         float\nError: Unbound value bigAdd\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 85-87:\n  | (list1, res) -> (list1, mulByDigit (x*10 ** List.length res) list1) in\n                                          ^^\nError: This expression has type int but an expression was expected of type\n         float\n"}],"event":{"region":{"start":3593,"stop":3810},"type":"eval"},"cursor":3686,"time":1.399069901538335e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-1) l) (l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = match a with\n    | (list1, res) -> (list1, mulByDigit (x*10 ** List.length res) list1) in\n  let base = (l1,[]) in\n  let args = List.rev l2 in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, mulByDigit (x*10 int_of_float ** List.length res) list1) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres","min":"","type":"scope","out":"Error: This expression has type int\n       This is not a function; it cannot be applied.\nError: Unbound value bigAdd\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 85-87:\n  | (list1, res) -> (list1, mulByDigit (x*10 int_of_float ** List.length res) list1) in\n                                          ^^\nError: This expression has type int\n       This is not a function; it cannot be applied.\n"},{"in":"let _ = bigMul [9;9;9;9] [9;9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (list1,res) ->\n        (list1, (mulByDigit ((x * 10) * (List.length res)) list1)) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (list1,res) ->\n        (list1, (mulByDigit ((x * 10) * (List.length res)) list1)) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9; 9] [9; 9; 9; 9; 9];;\n","type":"","out":""}],"event":{"region":{"start":3593,"stop":3942},"type":"eval"},"cursor":3943,"time":1.399069918922932e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-1) l) (l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = match a with\n    | (list1, res) -> (list1, mulByDigit (x*10 int_of_float ** List.length res) list1) in\n  let base = (l1,[]) in\n  let args = List.rev l2 in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, mulByDigit (int_of_float (float_of_int x *. 10. ** float_of_int List.length res)) list1) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres","min":"","type":"scope","out":"Error: This function has type int -> float\n       It is applied to too many arguments; maybe you forgot a `;'.\nError: Unbound value bigAdd\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 122-134:\n  | (list1, res) -> (list1, mulByDigit (int_of_float (float_of_int x *. 10. ** float_of_int List.length res)) list1) in\n                                                                               ^^^^^^^^^^^^\nError: This function has type int -> float\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}],"event":{"region":{"start":3593,"stop":3855},"type":"eval"},"cursor":3747,"time":1.399070087832368e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-1) l) (l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = match a with\n    | (list1, res) -> (list1, mulByDigit (int_of_float (float_of_int x *. 10. ** float_of_int List.length res)) list1) in\n  let base = (l1,[]) in\n  let args = List.rev l2 in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, mulByDigit (int_of_float (float_of_int x *. 10. ** float_of_int List.length res)) list1) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres","min":"","type":"scope","out":"Error: This function has type int -> float\n       It is applied to too many arguments; maybe you forgot a `;'.\nError: Unbound value bigAdd\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 122-134:\n  | (list1, res) -> (list1, mulByDigit (int_of_float (float_of_int x *. 10. ** float_of_int List.length res)) list1) in\n                                                                               ^^^^^^^^^^^^\nError: This function has type int -> float\n       It is applied to too many arguments; maybe you forgot a `;'.\n"},{"in":"let _ = bigMul [9;9;9;9] [9;9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (list1,res) ->\n        (list1, (mulByDigit ((x * 10) * (List.length res)) list1)) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (list1,res) ->\n        (list1, (mulByDigit ((x * 10) * (List.length res)) list1)) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9; 9] [9; 9; 9; 9; 9];;\n","type":"","out":""}],"event":{"region":{"start":3593,"stop":3974},"type":"eval"},"cursor":3965,"time":1.399070095875795e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-1) l) (l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = match a with\n    | (list1, res) -> (list1, mulByDigit (int_of_float (float_of_int x *. 10. ** float_of_int List.length res)) list1) in\n  let base = (l1,[]) in\n  let args = List.rev l2 in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, mulByDigit ((int_of_float (float_of_int x *. 10. ** float_of_int List.length res)) list1) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres","min":"","type":"syntax","out":"Characters 63-64:\n  | (list1, res) -> (list1, mulByDigit ((int_of_float (float_of_int x *. 10. ** float_of_int List.length res)) list1) in\n                    ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n"}],"event":{"region":{"start":3593,"stop":3856},"type":"eval"},"cursor":3680,"time":1.399070116667536e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-1) l) (l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = match a with\n    | (list1, res) -> (list1, mulByDigit ((int_of_float (float_of_int x *. 10. ** float_of_int List.length res)) list1) in\n  let base = (l1,[]) in\n  let args = List.rev l2 in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, mulByDigit (int_of_float (float_of_int x) *. 10. ** (float_of_int List.length res)) list1) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres","min":"","type":"scope","out":"Error: This expression has type int but an expression was expected of type\n         float\nError: Unbound value bigAdd\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 83-112:\n  | (list1, res) -> (list1, mulByDigit (int_of_float (float_of_int x) *. 10. ** (float_of_int List.length res)) list1) in\n                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         float\n"}],"event":{"region":{"start":3593,"stop":3857},"type":"eval"},"cursor":3720,"time":1.399070193568657e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-1) l) (l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = match a with\n    | (list1, res) -> (list1, mulByDigit (int_of_float (float_of_int x) *. 10. ** (float_of_int List.length res)) list1) in\n  let base = (l1,[]) in\n  let args = List.rev l2 in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, mulByDigit (int_of_float (float_of_int x) *. 10. ** (float_of_int (List.length res))) list1) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres","min":"","type":"scope","out":"Error: This expression has type int but an expression was expected of type\n         float\nError: Unbound value bigAdd\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 83-112:\n  | (list1, res) -> (list1, mulByDigit (int_of_float (float_of_int x) *. 10. ** (float_of_int (List.length res))) list1) in\n                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         float\n"}],"event":{"region":{"start":3593,"stop":3859},"type":"eval"},"cursor":3750,"time":1.399070217528952e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-1) l) (l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = match a with\n    | (list1, res) -> (list1, mulByDigit (int_of_float (float_of_int x) *. 10. ** (float_of_int (List.length res))) list1) in\n  let base = (l1,[]) in\n  let args = List.rev l2 in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, mulByDigit (int_of_float ((float_of_int x) *. 10. ** (float_of_int (List.length res)))) list1) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (list1,res) ->\n        (list1,\n          (mulByDigit\n             (int_of_float\n                ((float_of_int x) *.\n                   (10. ** (float_of_int (List.length res))))) list1)) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n","type":"","out":""}],"event":{"region":{"start":3593,"stop":3861},"type":"eval"},"cursor":3754,"time":1.399070233862197e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-1) l) (l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = match a with\n    | (list1, res) -> (list1, mulByDigit (int_of_float ((float_of_int x) *. 10. ** (float_of_int (List.length res)))) list1) in\n  let base = (l1,[]) in\n  let args = List.rev l2 in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = bigMul [9;9;9;9] [9;9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (list1,res) ->\n        (list1,\n          (mulByDigit\n             (int_of_float\n                ((float_of_int x) *.\n                   (10. ** (float_of_int (List.length res))))) list1)) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (list1,res) ->\n        (list1,\n          (mulByDigit\n             (int_of_float\n                ((float_of_int x) *.\n                   (10. ** (float_of_int (List.length res))))) list1)) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9; 9] [9; 9; 9; 9; 9];;\n","type":"","out":""}],"event":{"region":{"start":3861,"stop":3980},"type":"eval"},"cursor":3979,"time":1.39907023622564e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-1) l) (l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = match a with\n    | (list1, res) -> (list1, mulByDigit (int_of_float ((float_of_int x) *. 10. ** (float_of_int (List.length res)))) list1) in\n  let base = (l1,[]) in\n  let args = List.rev l2 in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, bigAdd res (mulByDigit x list1)) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (list1,res) -> (list1, (bigAdd res (mulByDigit x list1))) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n","type":"","out":""},{"in":"let _ = bigMul [9;9;9;9] [9;9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (list1,res) -> (list1, (bigAdd res (mulByDigit x list1))) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (list1,res) -> (list1, (bigAdd res (mulByDigit x list1))) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9; 9] [9; 9; 9; 9; 9];;\n","type":"","out":""}],"event":{"region":{"start":3593,"stop":3918},"type":"eval"},"cursor":3919,"time":1.399070506480807e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-1) l) (l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = match a with\n    | (list1, res) -> (list1, bigAdd res (mulByDigit x list1)) in\n  let base = (l1,[]) in\n  let args = List.rev l2 in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, bigAdd res (mulByDigit x*List.lengh res list1)) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres","min":"","type":"scope","out":"Error: This expression has type int list -> int list\n       but an expression was expected of type int\nError: Unbound value bigAdd\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 83-95:\n  | (list1, res) -> (list1, bigAdd res (mulByDigit x*List.lengh res list1)) in\n                                        ^^^^^^^^^^^^\nError: This expression has type int list -> int list\n       but an expression was expected of type int\n"}],"event":{"region":{"start":3593,"stop":3814},"type":"eval"},"cursor":3706,"time":1.399070557564719e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-1) l) (l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = match a with\n    | (list1, res) -> (list1, bigAdd res (mulByDigit x*List.lengh res list1)) in\n  let base = (l1,[]) in\n  let args = List.rev l2 in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, bigAdd res (mulByDigit (x*List.lengh res) list1)) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres","min":"","type":"scope","out":"Error: Unbound value List.lengh\nError: Unbound value bigAdd\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 97-107:\n  | (list1, res) -> (list1, bigAdd res (mulByDigit (x*List.lengh res) list1)) in\n                                                      ^^^^^^^^^^\nError: Unbound value List.lengh\n"}],"event":{"region":{"start":3593,"stop":3816},"type":"eval"},"cursor":3708,"time":1.39907056616736e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-1) l) (l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = match a with\n    | (list1, res) -> (list1, bigAdd res (mulByDigit (x*List.lengh res) list1)) in\n  let base = (l1,[]) in\n  let args = List.rev l2 in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, bigAdd res (mulByDigit (x*List.length res) list1)) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (list1,res) ->\n        (list1, (bigAdd res (mulByDigit (x * (List.length res)) list1))) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n","type":"","out":""}],"event":{"region":{"start":3593,"stop":3817},"type":"eval"},"cursor":3703,"time":1.399070572162841e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-1) l) (l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = match a with\n    | (list1, res) -> (list1, bigAdd res (mulByDigit (x*List.length res) list1)) in\n  let base = (l1,[]) in\n  let args = List.rev l2 in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = bigMul [9;9;9;9] [9;9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (list1,res) ->\n        (list1, (bigAdd res (mulByDigit (x * (List.length res)) list1))) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n","type":"","out":""}],"event":{"region":{"start":3817,"stop":3897},"type":"eval"},"cursor":3897,"time":1.399070574506576e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-1) l) (l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = match a with\n    | (list1, res) -> (list1, bigAdd res (mulByDigit (x*List.length res) list1)) in\n  let base = (l1,[]) in\n  let args = List.rev l2 in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (list1,res) ->\n        (list1, (bigAdd res (mulByDigit (x * (List.length res)) list1))) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9; 9] [9; 9; 9; 9; 9];;\n","type":"","out":""}],"event":{"region":{"start":3897,"stop":3936},"type":"eval"},"cursor":3937,"time":1.399070575498106e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-1) l) (l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = match a with\n    | (list1, res) -> (list1, bigAdd res (mulByDigit (x*List.length res) list1)) in\n  let base = (l1,[]) in\n  let args = List.rev l2 in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, bigAdd res (mulByDigit (x*10) list1)) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (list1,res) -> (list1, (bigAdd res (mulByDigit (x * 10) list1))) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n","type":"","out":""}],"event":{"region":{"start":3593,"stop":3804},"type":"eval"},"cursor":3695,"time":1.399070649761425e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-1) l) (l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = match a with\n    | (list1, res) -> (list1, bigAdd res (mulByDigit (x*10) list1)) in\n  let base = (l1,[]) in\n  let args = List.rev l2 in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = bigMul [9;9;9;9] [9;9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (list1,res) -> (list1, (bigAdd res (mulByDigit (x * 10) list1))) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (list1,res) -> (list1, (bigAdd res (mulByDigit (x * 10) list1))) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9; 9] [9; 9; 9; 9; 9];;\n","type":"","out":""}],"event":{"region":{"start":3804,"stop":3923},"type":"eval"},"cursor":3924,"time":1.399070652355328e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-1) l) (l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = match a with\n    | (list1, res) -> (list1, bigAdd res (mulByDigit (x*10) list1)) in\n  let base = (l1,[]) in\n  let args = List.rev l2 in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, bigAdd res (mulByDigit x list1)) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (list1,res) -> (list1, (bigAdd res (mulByDigit x list1))) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n","type":"","out":""},{"in":"let _ = bigMul [9;9;9;9] [9;9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (list1,res) -> (list1, (bigAdd res (mulByDigit x list1))) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (list1,res) -> (list1, (bigAdd res (mulByDigit x list1))) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9; 9] [9; 9; 9; 9; 9];;\n","type":"","out":""}],"event":{"region":{"start":3593,"stop":3918},"type":"eval"},"cursor":3919,"time":1.39907066720432e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-1) l) (l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = match a with\n    | (list1, res) -> (list1, bigAdd res (mulByDigit x list1)) in\n  let base = (l1,[]) in\n  let args = List.rev l2 in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, bigAdd res (mulByDigit x*int_of_float (10.**List.length res) list1)) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres","min":"","type":"scope","out":"Error: This expression has type int list -> int list\n       but an expression was expected of type int\nError: Unbound value bigAdd\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 83-95:\n  | (list1, res) -> (list1, bigAdd res (mulByDigit x*int_of_float (10.**List.length res) list1)) in\n                                        ^^^^^^^^^^^^\nError: This expression has type int list -> int list\n       but an expression was expected of type int\n"},{"in":"let _ = bigMul [9;9;9;9] [9;9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (list1,res) -> (list1, (bigAdd res (mulByDigit x list1))) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (list1,res) -> (list1, (bigAdd res (mulByDigit x list1))) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9; 9] [9; 9; 9; 9; 9];;\n","type":"","out":""}],"event":{"region":{"start":3593,"stop":3954},"type":"eval"},"cursor":3956,"time":1.399070738316096e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-1) l) (l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = match a with\n    | (list1, res) -> (list1, bigAdd res (mulByDigit x*int_of_float (10.**List.length res) list1)) in\n  let base = (l1,[]) in\n  let args = List.rev l2 in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, bigAdd res (mulByDigit x*(int_of_float (10.**List.length res)) list1)) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres","min":"","type":"scope","out":"Error: This expression has type int list -> int list\n       but an expression was expected of type int\nError: Unbound value bigAdd\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 83-95:\n  | (list1, res) -> (list1, bigAdd res (mulByDigit x*(int_of_float (10.**List.length res)) list1)) in\n                                        ^^^^^^^^^^^^\nError: This expression has type int list -> int list\n       but an expression was expected of type int\n"}],"event":{"region":{"start":3593,"stop":3837},"type":"eval"},"cursor":3729,"time":1.399070749297369e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-1) l) (l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = match a with\n    | (list1, res) -> (list1, bigAdd res (mulByDigit x*(int_of_float (10.**List.length res)) list1)) in\n  let base = (l1,[]) in\n  let args = List.rev l2 in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, bigAdd res (mulByDigit (x*(int_of_float (10.**List.length res))) list1)) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres","min":"","type":"scope","out":"Error: This expression has type int but an expression was expected of type\n         float\nError: Unbound value bigAdd\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 117-132:\n  | (list1, res) -> (list1, bigAdd res (mulByDigit (x*(int_of_float (10.**List.length res))) list1)) in\n                                                                          ^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         float\n"}],"event":{"region":{"start":3593,"stop":3839},"type":"eval"},"cursor":3731,"time":1.399070763579097e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-1) l) (l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = match a with\n    | (list1, res) -> (list1, bigAdd res (mulByDigit (x*(int_of_float (10.**List.length res))) list1)) in\n  let base = (l1,[]) in\n  let args = List.rev l2 in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, bigAdd res (mulByDigit (x*(int_of_float (10.**float_of_int List.length res))) list1)) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres","min":"","type":"scope","out":"Error: This function has type int -> float\n       It is applied to too many arguments; maybe you forgot a `;'.\nError: Unbound value bigAdd\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 117-129:\n  | (list1, res) -> (list1, bigAdd res (mulByDigit (x*(int_of_float (10.**float_of_int List.length res))) list1)) in\n                                                                          ^^^^^^^^^^^^\nError: This function has type int -> float\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}],"event":{"region":{"start":3593,"stop":3852},"type":"eval"},"cursor":3726,"time":1.399070833522772e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-1) l) (l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = match a with\n    | (list1, res) -> (list1, bigAdd res (mulByDigit (x*(int_of_float (10.**float_of_int List.length res))) list1)) in\n  let base = (l1,[]) in\n  let args = List.rev l2 in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, bigAdd res (mulByDigit (x*(int_of_float (10.**float_of_int (List.length res)))) list1)) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (list1,res) ->\n        (list1,\n          (bigAdd res\n             (mulByDigit\n                (x * (int_of_float (10. ** (float_of_int (List.length res)))))\n                list1))) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n","type":"","out":""}],"event":{"region":{"start":3593,"stop":3854},"type":"eval"},"cursor":3743,"time":1.399070841509289e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-1) l) (l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = match a with\n    | (list1, res) -> (list1, bigAdd res (mulByDigit (x*(int_of_float (10.**float_of_int (List.length res)))) list1)) in\n  let base = (l1,[]) in\n  let args = List.rev l2 in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = bigMul [9;9;9;9] [9;9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (list1,res) ->\n        (list1,\n          (bigAdd res\n             (mulByDigit\n                (x * (int_of_float (10. ** (float_of_int (List.length res)))))\n                list1))) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (list1,res) ->\n        (list1,\n          (bigAdd res\n             (mulByDigit\n                (x * (int_of_float (10. ** (float_of_int (List.length res)))))\n                list1))) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9; 9] [9; 9; 9; 9; 9];;\n","type":"","out":""}],"event":{"region":{"start":3854,"stop":3973},"type":"eval"},"cursor":3961,"time":1.399070843812086e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-1) l) (l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = match a with\n    | (list1, res) -> (list1, bigAdd res (mulByDigit (x*(int_of_float (10.**float_of_int (List.length res)))) list1)) in\n  let base = (l1,[]) in\n  let args = List.rev l2 in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, bigAdd res (mulByDigit x list1)) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (list1,res) -> (list1, (bigAdd res (mulByDigit x list1))) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n","type":"","out":""},{"in":"let _ = bigMul [9;9;9;9] [9;9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (list1,res) -> (list1, (bigAdd res (mulByDigit x list1))) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (list1,res) -> (list1, (bigAdd res (mulByDigit x list1))) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9; 9] [9; 9; 9; 9; 9];;\n","type":"","out":""}],"event":{"region":{"start":3593,"stop":3918},"type":"eval"},"cursor":3919,"time":1.39907086398148e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-1) l) (l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = match a with\n    | (list1, res) -> (list1, bigAdd res (mulByDigit x list1)) in\n  let base = (l1,[]) in\n  let args = List.rev l2 in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = List.length []","min":"\nlet _ = List.length [];;\n","type":"","out":""}],"event":{"region":{"start":3593,"stop":3618},"type":"eval"},"cursor":3618,"time":1.399070961269469e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-1) l) (l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet _ = List.length []\n\n\n\nlet bigMul l1 l2 = \n  let f a x = match a with\n    | (list1, res) -> (list1, bigAdd res (mulByDigit x list1)) in\n  let base = (l1,[]) in\n  let args = List.rev l2 in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = clone clone (-3)","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet _ = clone clone (-3);;\n","type":"","out":""}],"event":{"region":{"start":2146,"stop":2170},"type":"eval"},"cursor":2172,"time":1.399071221408615e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-1) l) (l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\n\nlet bigMul l1 l2 = \n  let f a x = match a with\n    | (list1, res) -> (list1, bigAdd res (mulByDigit x list1)) in\n  let base = (l1,[]) in\n  let args = List.rev l2 in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = clone 3 5","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet _ = clone 3 5;;\n","type":"","out":""}],"event":{"region":{"start":2101,"stop":2118},"type":"eval"},"cursor":2120,"time":1.399071224781529e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-1) l) (l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\n\nlet bigMul l1 l2 = \n  let f a x = match a with\n    | (list1, res) -> (list1, bigAdd res (mulByDigit x list1)) in\n  let base = (l1,[]) in\n  let args = List.rev l2 in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = clone \"foo\" 2","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet _ = clone \"foo\" 2;;\n","type":"","out":""},{"in":"let _ = clone clone (-3)","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet _ = clone clone (-3);;\n","type":"","out":""},{"in":"let padZero l1 l2 = if List.length l1 > List.length l2 then\n(l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \nelse \n(List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n","type":"","out":""},{"in":"let _ = padZero [9;9] [1;0;0;2]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet _ = padZero [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = padZero [1;0;0;2] [9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet _ = padZero [1; 0; 0; 2] [9; 9];;\n","type":"","out":""},{"in":"let rec removeZero l = match l with\n| [] -> []\n| h::t -> if h != 0 then l\nelse removeZero t","min":"\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet t = bigAdd x z;;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;1;0;0;2]","min":"\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet t = bigAdd x z;;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet _ = removeZero [0; 0; 0; 1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = removeZero [9;9]","min":"\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet t = bigAdd x z;;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet _ = removeZero [9; 9];;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;0]","min":"\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet t = bigAdd x z;;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet _ = removeZero [0; 0; 0; 0];;\n","type":"","out":""},{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (list2, res) -> match list2 with \n| [] -> ([],res)\n| h::t -> match res with\n| [] -> (t,(h+x)::res)\n| h2::t2 -> if h2 >= 10 \nthen \n(t,if t != [] then (h+x+1)::(h2 mod 10)::t2\nelse \nif (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\nelse (h+x+1)::(h2 mod 10)::t2)\nelse \n(t,if t != [] then (h+x)::res\nelse if (h+x) >= 10 then 1::(h+x) mod 10::res\nelse (h+x)::res)\nin\nlet base = (List.rev l2, []) in\nlet args = List.rev l1 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9] [1;0;0;2]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9;9;9] [9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n","type":"","out":""},{"in":"let rec mulByDigit i l = \nif i = 0 then []\nelse if i = 1 then l\nelse bigAdd (mulByDigit (i-1) l) (l)","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n","type":"","out":""},{"in":"let _ = mulByDigit 9 [9;9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, bigAdd res (mulByDigit x list1)) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (list1,res) -> (list1, (bigAdd res (mulByDigit x list1))) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n","type":"","out":""},{"in":"let _ = bigMul [9;9;9;9] [9;9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (list1,res) -> (list1, (bigAdd res (mulByDigit x list1))) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (list1,res) -> (list1, (bigAdd res (mulByDigit x list1))) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9; 9] [9; 9; 9; 9; 9];;\n","type":"","out":""},{"in":"let key = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130 = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ ((Printexc.to_string e) ^ \"\\n\"));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n","type":"","out":""},{"in":"let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","min":"\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n","type":"","out":""},{"in":"let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n\nlet drop_paren s =\n  implode\n    (List.filter (fun c  -> not (List.mem c ['('; ' '; ')'])) (explode s));;\n","type":"","out":""},{"in":"let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","min":"\nlet eq_real p (r1,r2) = ((r1 -. r2) < p) || ((r2 -. r1) < p);;\n","type":"","out":""},{"in":"let wrap_curried_2 f (a,b) = f a b","min":"\nlet wrap_curried_2 f (a,b) = f a b;;\n","type":"","out":""}],"event":{"region":{"start":2118,"stop":7916},"type":"eval"},"cursor":3616,"time":1.399071332799841e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-1) l) (l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\n\nlet bigMul l1 l2 = \n  let f a x = match a with\n    | (list1, res) -> (list1, bigAdd res (mulByDigit x list1)) in\n  let base = (l1,[]) in\n  let args = List.rev l2 in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec power_10 x = if x = 0 then 1\nelse if x = 1 then 10\nelse power_10 10*x-1","min":"\nlet rec power_10 x =\n  if x = 0 then 1 else if x = 1 then 10 else ((power_10 10) * x) - 1;;\n","type":"","out":""},{"in":"let _ = power_10 5","min":"\nlet rec power_10 x =\n  if x = 0 then 1 else if x = 1 then 10 else ((power_10 10) * x) - 1;;\n\nlet _ = power_10 5;;\n","type":"","out":""}],"event":{"region":{"start":3593,"stop":3696},"type":"eval"},"cursor":3686,"time":1.399071688598919e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-1) l) (l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\nlet rec power_10 x = if x = 0 then 1\n  else if x = 1 then 10\n  else power_10 10*x-1\n\n\n\nlet _ = power_10 5\n\nlet bigMul l1 l2 = \n  let f a x = match a with\n    | (list1, res) -> (list1, bigAdd res (mulByDigit x list1)) in\n  let base = (l1,[]) in\n  let args = List.rev l2 in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec power_10 x = if x = 0 then 1\nelse if x = 1 then 10\nelse 10 * power_10 (x-1)","min":"\nlet rec power_10 x =\n  if x = 0 then 1 else if x = 1 then 10 else 10 * (power_10 (x - 1));;\n","type":"","out":""}],"event":{"region":{"start":3593,"stop":3678},"type":"eval"},"cursor":3679,"time":1.399071724369259e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-1) l) (l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\nlet rec power_10 x = if x = 0 then 1\n  else if x = 1 then 10\n  else 10 * power_10 (x-1)\n\n\n\nlet _ = power_10 5\n\nlet bigMul l1 l2 = \n  let f a x = match a with\n    | (list1, res) -> (list1, bigAdd res (mulByDigit x list1)) in\n  let base = (l1,[]) in\n  let args = List.rev l2 in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = power_10 5","min":"\nlet rec power_10 x =\n  if x = 0 then 1 else if x = 1 then 10 else 10 * (power_10 (x - 1));;\n\nlet _ = power_10 5;;\n","type":"","out":""}],"event":{"region":{"start":3678,"stop":3700},"type":"eval"},"cursor":3693,"time":1.399071726355377e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-1) l) (l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\nlet rec power_10 x = if x = 0 then 1\n  else if x = 1 then 10\n  else 10 * power_10 (x-1)\n\n\n\nlet _ = power_10 5\n\nlet bigMul l1 l2 = \n  let f a x = match a with\n    | (list1, res) -> (list1, bigAdd res (mulByDigit x list1)) in\n  let base = (l1,[]) in\n  let args = List.rev l2 in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec power_10 x = if x = 0 then 1\nelse if x = 1 then 10\nelse 10 * power_10 (x-1)","min":"\nlet rec power_10 x =\n  if x = 0 then 1 else if x = 1 then 10 else 10 * (power_10 (x - 1));;\n","type":"","out":""},{"in":"let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, bigAdd res (mulByDigit x*power_10 (List.length res) list1)) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres","min":"","type":"scope","out":"Error: This expression has type int list -> int list\n       but an expression was expected of type int\nError: Unbound value bigAdd\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 83-95:\n  | (list1, res) -> (list1, bigAdd res (mulByDigit x*power_10 (List.length res) list1)) in\n                                        ^^^^^^^^^^^^\nError: This expression has type int list -> int list\n       but an expression was expected of type int\n"},{"in":"let _ = bigMul [9;9;9;9] [9;9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (list1,res) -> (list1, (bigAdd res (mulByDigit x list1))) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (list1,res) -> (list1, (bigAdd res (mulByDigit x list1))) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9; 9] [9; 9; 9; 9; 9];;\n","type":"","out":""}],"event":{"region":{"start":3593,"stop":4029},"type":"eval"},"cursor":4030,"time":1.399071779499456e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-1) l) (l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\nlet rec power_10 x = if x = 0 then 1\n  else if x = 1 then 10\n  else 10 * power_10 (x-1)\n\nlet bigMul l1 l2 = \n  let f a x = match a with\n    | (list1, res) -> (list1, bigAdd res (mulByDigit x*power_10 (List.length res) list1)) in\n  let base = (l1,[]) in\n  let args = List.rev l2 in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigMul l1 l2 = \nlet f a x = match a with\n| (number, res) -> (number - 1, bigAdd res (mulByDigit (x*power_10 (List.length l1 - number)) list1)) in\nlet base = (List.length l2,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres","min":"","type":"scope","out":"Error: Unbound value list1\nError: Unbound value bigAdd\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 139-144:\n  | (number, res) -> (number - 1, bigAdd res (mulByDigit (x*power_10 (List.length l1 - number)) list1)) in\n                                                                                                ^^^^^\nError: Unbound value list1\n"},{"in":"let _ = bigMul [9;9;9;9] [9;9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (list1,res) -> (list1, (bigAdd res (mulByDigit x list1))) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (list1,res) -> (list1, (bigAdd res (mulByDigit x list1))) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9; 9] [9; 9; 9; 9; 9];;\n","type":"","out":""}],"event":{"region":{"start":3678,"stop":4057},"type":"eval"},"cursor":4036,"time":1.399072456646186e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-1) l) (l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\nlet rec power_10 x = if x = 0 then 1\n  else if x = 1 then 10\n  else 10 * power_10 (x-1)\n\nlet bigMul l1 l2 = \n  let f a x = match a with\n    | (number, res) -> (number - 1, bigAdd res (mulByDigit (x*power_10 (List.length l1 - number)) list1)) in\n  let base = (List.length l2,[]) in\n  let args = List.rev l2 in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigMul l1 l2 = \nlet f a x = match a with\n| (number, res) -> (number - 1, bigAdd res (mulByDigit (x*power_10 (List.length l1 - number)) l1)) in\nlet base = (List.length l2,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet rec power_10 x =\n  if x = 0 then 1 else if x = 1 then 10 else 10 * (power_10 (x - 1));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (number,res) ->\n        ((number - 1),\n          (bigAdd res\n             (mulByDigit (x * (power_10 ((List.length l1) - number))) l1))) in\n  let base = ((List.length l2), []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n","type":"","out":""},{"in":"let _ = bigMul [9;9;9;9] [9;9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet rec power_10 x =\n  if x = 0 then 1 else if x = 1 then 10 else 10 * (power_10 (x - 1));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (number,res) ->\n        ((number - 1),\n          (bigAdd res\n             (mulByDigit (x * (power_10 ((List.length l1) - number))) l1))) in\n  let base = ((List.length l2), []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet rec power_10 x =\n  if x = 0 then 1 else if x = 1 then 10 else 10 * (power_10 (x - 1));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (number,res) ->\n        ((number - 1),\n          (bigAdd res\n             (mulByDigit (x * (power_10 ((List.length l1) - number))) l1))) in\n  let base = ((List.length l2), []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9; 9] [9; 9; 9; 9; 9];;\n","type":"","out":""}],"event":{"region":{"start":3678,"stop":4054},"type":"eval"},"cursor":4036,"time":1.399072472701671e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-1) l) (l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\nlet rec power_10 x = if x = 0 then 1\n  else if x = 1 then 10\n  else 10 * power_10 (x-1)\n\nlet bigMul l1 l2 = \n  let f a x = match a with\n    | (number, res) -> (number - 1, bigAdd res (mulByDigit (x*power_10 (List.length l1 - number)) l1)) in\n  let base = (List.length l2,[]) in\n  let args = List.rev l2 in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet rec power_10 x =\n  if x = 0 then 1 else if x = 1 then 10 else 10 * (power_10 (x - 1));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (number,res) ->\n        ((number - 1),\n          (bigAdd res\n             (mulByDigit (x * (power_10 ((List.length l1) - number))) l1))) in\n  let base = ((List.length l2), []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9; 9] [9; 9; 9; 9; 9];;\n","type":"","out":""},{"in":"let key = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130 = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ ((Printexc.to_string e) ^ \"\\n\"));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n","type":"","out":""},{"in":"let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","min":"\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n","type":"","out":""},{"in":"let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n\nlet drop_paren s =\n  implode\n    (List.filter (fun c  -> not (List.mem c ['('; ' '; ')'])) (explode s));;\n","type":"","out":""},{"in":"let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","min":"\nlet eq_real p (r1,r2) = ((r1 -. r2) < p) || ((r2 -. r1) < p);;\n","type":"","out":""},{"in":"let wrap_curried_2 f (a,b) = f a b","min":"\nlet wrap_curried_2 f (a,b) = f a b;;\n","type":"","out":""}],"event":{"region":{"start":4016,"stop":8051},"type":"eval"},"cursor":4036,"time":1.399072523712286e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-1) l) (l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\nlet rec power_10 x = if x = 0 then 1\n  else if x = 1 then 10\n  else 10 * power_10 (x-1)\n\nlet bigMul l1 l2 = \n  let f a x = match a with\n    | (number, res) -> (number - 1, bigAdd res (mulByDigit (x*power_10 (List.length l1 - number)) l1)) in\n  let base = (List.length l2,[]) in\n  let args = List.rev l2 in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let sqsum xs = \nlet f a x = x * x + a in\nlet base = 0 in\nList.fold_left f base xs","min":"\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n","type":"","out":""},{"in":"let _ = sqsum []","min":"\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [];;\n","type":"","out":""},{"in":"let _ = sqsum [1;2;3;4]","min":"\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sqsum [(-1); (-2); (-3); (-4)]","min":"\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [(-1); (-2); (-3); (-4)];;\n","type":"","out":""},{"in":"let pipe fs =  \nlet f a x = x a  in\nfun base -> \nList.fold_left f base fs","min":"\nlet pipe fs = let f a x = x a in fun base  -> List.fold_left f base fs;;\n","type":"","out":""},{"in":"let _ = pipe [] 3","min":"\nlet pipe fs = let f a x = x a in fun base  -> List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n","type":"","out":""},{"in":"let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3","min":"\nlet pipe fs = let f a x = x a in fun base  -> List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n","type":"","out":""},{"in":"let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3","min":"\nlet pipe fs = let f a x = x a in fun base  -> List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n","type":"","out":""},{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l","min":"\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet t = bigAdd x z;;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n","type":"","out":""},{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet t = bigAdd x z;;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"---\" []","min":"\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet t = bigAdd x z;;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"---\" [];;\n","type":"","out":""},{"in":"let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]","min":"\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet t = bigAdd x z;;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"\" [\"a\"; \"b\"; \"c\"; \"d\"; \"e\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"X\" [\"hello\"]","min":"\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet t = bigAdd x z;;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"X\" [\"hello\"];;\n","type":"","out":""},{"in":"let stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"","min":"\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet t = bigAdd x z;;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n","type":"","out":""},{"in":"let _ = stringOfList string_of_int [1;2;3;4;5;6]","min":"\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet t = bigAdd x z;;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n\nlet _ = stringOfList string_of_int [1; 2; 3; 4; 5; 6];;\n","type":"","out":""},{"in":"let _ = stringOfList (fun x -> x) [\"foo\"]","min":"\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet t = bigAdd x z;;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n\nlet _ = stringOfList (fun x  -> x) [\"foo\"];;\n","type":"","out":""},{"in":"let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]","min":"\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet t = bigAdd x z;;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n\nlet _ =\n  stringOfList (stringOfList string_of_int) [[1; 2; 3]; [4; 5]; [6]; []];;\n","type":"","out":""},{"in":"let rec clone x n = if n > 0 then x :: clone x (n-1) else []","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n","type":"","out":""},{"in":"let _ = clone 3 5","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet _ = clone 3 5;;\n","type":"","out":""},{"in":"let _ = clone \"foo\" 2","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet _ = clone \"foo\" 2;;\n","type":"","out":""},{"in":"let _ = clone clone (-3)","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet _ = clone clone (-3);;\n","type":"","out":""},{"in":"let padZero l1 l2 = if List.length l1 > List.length l2 then\n(l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \nelse \n(List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n","type":"","out":""},{"in":"let _ = padZero [9;9] [1;0;0;2]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet _ = padZero [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = padZero [1;0;0;2] [9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet _ = padZero [1; 0; 0; 2] [9; 9];;\n","type":"","out":""},{"in":"let rec removeZero l = match l with\n| [] -> []\n| h::t -> if h != 0 then l\nelse removeZero t","min":"\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet t = bigAdd x z;;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;1;0;0;2]","min":"\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet t = bigAdd x z;;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet _ = removeZero [0; 0; 0; 1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = removeZero [9;9]","min":"\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet t = bigAdd x z;;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet _ = removeZero [9; 9];;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;0]","min":"\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet t = bigAdd x z;;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet _ = removeZero [0; 0; 0; 0];;\n","type":"","out":""},{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (list2, res) -> match list2 with \n| [] -> ([],res)\n| h::t -> match res with\n| [] -> (t,(h+x)::res)\n| h2::t2 -> if h2 >= 10 \nthen \n(t,if t != [] then (h+x+1)::(h2 mod 10)::t2\nelse \nif (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\nelse (h+x+1)::(h2 mod 10)::t2)\nelse \n(t,if t != [] then (h+x)::res\nelse if (h+x) >= 10 then 1::(h+x) mod 10::res\nelse (h+x)::res)\nin\nlet base = (List.rev l2, []) in\nlet args = List.rev l1 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9] [1;0;0;2]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9;9;9] [9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n","type":"","out":""},{"in":"let rec mulByDigit i l = \nif i = 0 then []\nelse if i = 1 then l\nelse bigAdd (mulByDigit (i-1) l) (l)","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n","type":"","out":""},{"in":"let _ = mulByDigit 9 [9;9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let rec power_10 x = if x = 0 then 1\nelse if x = 1 then 10\nelse 10 * power_10 (x-1)","min":"\nlet rec power_10 x =\n  if x = 0 then 1 else if x = 1 then 10 else 10 * (power_10 (x - 1));;\n","type":"","out":""},{"in":"let bigMul l1 l2 = \nlet f a x = match a with\n| (number, res) -> (number - 1, bigAdd res (mulByDigit (x*power_10 (List.length l1 - number)) l1)) in\nlet base = (List.length l2,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet rec power_10 x =\n  if x = 0 then 1 else if x = 1 then 10 else 10 * (power_10 (x - 1));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (number,res) ->\n        ((number - 1),\n          (bigAdd res\n             (mulByDigit (x * (power_10 ((List.length l1) - number))) l1))) in\n  let base = ((List.length l2), []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n","type":"","out":""},{"in":"let _ = bigMul [9;9;9;9] [9;9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet rec power_10 x =\n  if x = 0 then 1 else if x = 1 then 10 else 10 * (power_10 (x - 1));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (number,res) ->\n        ((number - 1),\n          (bigAdd res\n             (mulByDigit (x * (power_10 ((List.length l1) - number))) l1))) in\n  let base = ((List.length l2), []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet rec power_10 x =\n  if x = 0 then 1 else if x = 1 then 10 else 10 * (power_10 (x - 1));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (number,res) ->\n        ((number - 1),\n          (bigAdd res\n             (mulByDigit (x * (power_10 ((List.length l1) - number))) l1))) in\n  let base = ((List.length l2), []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9; 9] [9; 9; 9; 9; 9];;\n","type":"","out":""},{"in":"let key = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130 = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ ((Printexc.to_string e) ^ \"\\n\"));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n","type":"","out":""},{"in":"let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","min":"\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n","type":"","out":""},{"in":"let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n\nlet drop_paren s =\n  implode\n    (List.filter (fun c  -> not (List.mem c ['('; ' '; ')'])) (explode s));;\n","type":"","out":""},{"in":"let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","min":"\nlet eq_real p (r1,r2) = ((r1 -. r2) < p) || ((r2 -. r1) < p);;\n","type":"","out":""},{"in":"let wrap_curried_2 f (a,b) = f a b","min":"\nlet wrap_curried_2 f (a,b) = f a b;;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":8051},"type":"eval"},"cursor":0,"time":1.399072639459607e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\nlet sqsum xs = \n  let f a x = x * x + a in\n  let base = 0 in\n    List.fold_left f base xs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\nlet pipe fs =  \n  let f a x = x a  in\n    fun base -> \n      List.fold_left f base fs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n > 0 then x :: clone x (n-1) else [];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2) \n  else \n    (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\n;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::t -> if h != 0 then l\n      else removeZero t\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match a with\n      | (list2, res) -> match list2 with \n        | [] -> ([],res)\n        | h::t -> match res with\n          | [] -> (t,(h+x)::res)\n          | h2::t2 -> if h2 >= 10 \n              then \n                (t,if t != [] then (h+x+1)::(h2 mod 10)::t2\n                 else \n                 if (h+x+1) >= 10 then 1::(h+x+1)mod 10::(h2 mod 10)::t2\n                 else (h+x+1)::(h2 mod 10)::t2)\n              else \n                (t,if t != [] then (h+x)::res\n                 else if (h+x) >= 10 then 1::(h+x) mod 10::res\n                 else (h+x)::res)\n    in\n    let base = (List.rev l2, []) in\n    let args = List.rev l1 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\n\nlet rec mulByDigit i l = \n  if i = 0 then []\n  else if i = 1 then l\n  else bigAdd (mulByDigit (i-1) l) (l)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = mulByDigit 9 [9;9;9;9]\n\nlet rec power_10 x = if x = 0 then 1\n  else if x = 1 then 10\n  else 10 * power_10 (x-1)\n\nlet bigMul l1 l2 = \n  let f a x = match a with\n    | (number, res) -> (number - 1, bigAdd res (mulByDigit (x*power_10 (List.length l1 - number)) l1)) in\n  let base = (List.length l2,[]) in\n  let args = List.rev l2 in\n  let (_, res) = List.fold_left f base args in\n    res\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\nexception ErrorCode of string\ntype result = Pass | Fail | ErrorCode of string\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\nlet wrap_curried_2 f (a,b) = f a b\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
