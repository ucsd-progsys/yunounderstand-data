{"ocaml":[{"in":"let rec sumList xs = failwith \"TBD:sumList\"","min":"\nlet rec sumList xs = failwith \"TBD:sumList\";;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":127},"type":"eval"},"cursor":127,"time":1.396583182358749e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = failwith \"TBD:sumList\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = failwith \"TBD:sumList\";;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = failwith \"TBD:sumList\";;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = failwith \"TBD:sumList\";;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""}],"event":{"region":{"start":127,"stop":282},"type":"eval"},"cursor":282,"time":1.396583204260019e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = failwith \"TBD:sumList\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = failwith \"TBD:sumList\" match xs [] -> 0 | f::b -> f + sumList (tl xs)","min":"","type":"syntax","out":"Characters 44-49:\n  let rec sumList xs = failwith \"TBD:sumList\" match xs [] -> 0 | f::b -> f + sumList (tl xs);;\n                                              ^^^^^\nError: Syntax error\n"}],"event":{"region":{"start":0,"stop":174},"type":"eval"},"cursor":176,"time":1.396584403042274e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = failwith \"TBD:sumList\" match xs [] -> 0 | f::b -> f + sumList (tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = match xs [] -> 0 | f::b -> f + sumList (tl xs)","min":"","type":"syntax","out":"Characters 33-35:\n  let rec sumList xs = match xs [] -> 0 | f::b -> f + sumList (tl xs);;\n                                   ^^\nError: Syntax error\n"}],"event":{"region":{"start":0,"stop":151},"type":"eval"},"cursor":153,"time":1.396584427838606e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs [] -> 0 | f::b -> f + sumList (tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (tl xs)","min":"\nlet rec sumList xs = match xs with | [] -> 0 | f::b -> f + (sumList (tl xs));;\n","type":"scope","out":"Characters 66-68:\n  let rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (tl xs);;\n                                                                    ^^\nError: Unbound value tl\n"}],"event":{"region":{"start":0,"stop":156},"type":"eval"},"cursor":158,"time":1.396584465574078e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"tl [1;2;3]","min":"\nlet _ = tl [1; 2; 3];;\n","type":"scope","out":"Characters 0-2:\n  tl [1;2;3];;\n  ^^\nError: Unbound value tl\n"}],"event":{"region":{"start":0,"stop":60},"type":"eval"},"cursor":62,"time":1.396584509915251e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\ntl [1;2;3];;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"List.tl [1;2;3]","min":"\nlet _ = List.tl [1; 2; 3];;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":65},"type":"eval"},"cursor":55,"time":1.396584523929252e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\nList.tl [1;2;3];;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"List.tl [1;2;3];\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (tl xs)","min":"","type":"syntax","out":"Characters 91-93:\n  let rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (tl xs);;\n                                                                          ^^\nError: Syntax error\n"}],"event":{"region":{"start":0,"stop":172},"type":"eval"},"cursor":66,"time":1.396584548979625e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\nList.tl [1;2;3];\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"List.tl [1;2;3];\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (tl xs)","min":"","type":"syntax","out":"Characters 91-93:\n  let rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (tl xs);;\n                                                                          ^^\nError: Syntax error\n"}],"event":{"region":{"start":0,"stop":172},"type":"eval"},"cursor":63,"time":1.39658457011424e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\nList.tl [1;2;3];\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"List.tl [1;2;3]","min":"\nlet _ = List.tl [1; 2; 3];;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":65},"type":"eval"},"cursor":67,"time":1.396584581647612e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\nList.tl [1;2;3];;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs)","min":"\nlet rec sumList xs =\n  match xs with | [] -> 0 | f::b -> f + (sumList (List.tl xs));;\n","type":"","out":""}],"event":{"region":{"start":65,"stop":178},"type":"eval"},"cursor":172,"time":1.396584601014415e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\nList.tl [1;2;3];;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs =\n  match xs with | [] -> 0 | f::b -> f + (sumList (List.tl xs));;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs =\n  match xs with | [] -> 0 | f::b -> f + (sumList (List.tl xs));;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs =\n  match xs with | [] -> 0 | f::b -> f + (sumList (List.tl xs));;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""}],"event":{"region":{"start":178,"stop":335},"type":"eval"},"cursor":335,"time":1.396584605769257e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\nList.tl [1;2;3];;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = sumList []","min":"\nlet rec sumList xs =\n  match xs with | [] -> 0 | f::b -> f + (sumList (List.tl xs));;\n\nlet _ = sumList [];;\n","type":"","out":""}],"event":{"region":{"start":335,"stop":354},"type":"eval"},"cursor":354,"time":1.396584646731713e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\nList.tl [1;2;3];;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\nlet _ = sumList []\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = sumList [-1]","min":"\nlet rec sumList xs =\n  match xs with | [] -> 0 | f::b -> f + (sumList (List.tl xs));;\n\nlet _ = sumList [(-1)];;\n","type":"","out":""}],"event":{"region":{"start":335,"stop":356},"type":"eval"},"cursor":355,"time":1.396584656509083e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\nList.tl [1;2;3];;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\nlet _ = sumList [-1]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = sumList [-1;2;3]","min":"\nlet rec sumList xs =\n  match xs with | [] -> 0 | f::b -> f + (sumList (List.tl xs));;\n\nlet _ = sumList [(-1); 2; 3];;\n","type":"","out":""}],"event":{"region":{"start":335,"stop":360},"type":"eval"},"cursor":359,"time":1.396584673381497e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\nList.tl [1;2;3];;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\nlet _ = sumList [-1;2;3]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList List.tl xs","min":"\nlet rec sumList xs =\n  match xs with | [] -> 0 | f::b -> f + (sumList List.tl xs);;\n","type":"type","out":"Characters 57-64:\n  let rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList List.tl xs;;\n                                                           ^^^^^^^\nError: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}],"event":{"region":{"start":0,"stop":158},"type":"eval"},"cursor":158,"time":1.39658473680275e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList List.tl xs;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs)","min":"\nlet rec sumList xs =\n  match xs with | [] -> 0 | f::b -> f + (sumList (List.tl xs));;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":160},"type":"eval"},"cursor":149,"time":1.396584747799621e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs =\n  match xs with | [] -> 0 | f::b -> f + (sumList (List.tl xs));;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs =\n  match xs with | [] -> 0 | f::b -> f + (sumList (List.tl xs));;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs =\n  match xs with | [] -> 0 | f::b -> f + (sumList (List.tl xs));;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""}],"event":{"region":{"start":160,"stop":317},"type":"eval"},"cursor":317,"time":1.396584759347946e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec digitsOfInt n = if n<0 [] else match n with f::b -> f","min":"","type":"syntax","out":"Characters 34-38:\n  let rec digitsOfInt n = if n<0 [] else match n with f::b -> f;;\n                                    ^^^^\nError: Syntax error\n"}],"event":{"region":{"start":317,"stop":419},"type":"eval"},"cursor":421,"time":1.396585349051516e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 [] else match n with f::b -> f;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec digitsOfInt n = if n<0 then [] else match n with f::b -> f","min":"\nlet rec digitsOfInt n = if n < 0 then [] else (match n with | f::b -> f);;\n","type":"type","out":"Characters 57-61:\n  let rec digitsOfInt n = if n<0 then [] else match n with f::b -> f;;\n                                                           ^^^^\nError: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type int\n"}],"event":{"region":{"start":317,"stop":424},"type":"eval"},"cursor":426,"time":1.396585384293037e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else match n with f::b -> f;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec digitsOfInt n = if n<0 then [] else (n mod 10)::digitsOfInt n*10","min":"\nlet rec digitsOfInt n =\n  if n < 0 then [] else (n mod 10) :: ((digitsOfInt n) * 10);;\n","type":"type","out":"Characters 56-69:\n  let rec digitsOfInt n = if n<0 then [] else (n mod 10)::digitsOfInt n*10;;\n                                                          ^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n"}],"event":{"region":{"start":317,"stop":430},"type":"eval"},"cursor":430,"time":1.396586155270858e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else (n mod 10)::digitsOfInt n*10;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec digitsOfInt n = if n<0 then [] else (n mod 10)::(digitsOfInt n*10)","min":"\nlet rec digitsOfInt n =\n  if n < 0 then [] else (n mod 10) :: ((digitsOfInt n) * 10);;\n","type":"type","out":"Characters 57-70:\n  let rec digitsOfInt n = if n<0 then [] else (n mod 10)::(digitsOfInt n*10);;\n                                                           ^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n"}],"event":{"region":{"start":317,"stop":432},"type":"eval"},"cursor":415,"time":1.396586198041666e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else (n mod 10)::(digitsOfInt n*10);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec digitsOfInt n = if n<0 then [] else (n mod 10)::(digitsOfInt n)","min":"\nlet rec digitsOfInt n = if n < 0 then [] else (n mod 10) :: (digitsOfInt n);;\n","type":"","out":""}],"event":{"region":{"start":317,"stop":429},"type":"eval"},"cursor":428,"time":1.396586310614582e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else (n mod 10)::(digitsOfInt n);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec digitsOfInt n = if n<0 then [] else (n mod 10)::(digitsOfInt (n*10))","min":"\nlet rec digitsOfInt n =\n  if n < 0 then [] else (n mod 10) :: (digitsOfInt (n * 10));;\n","type":"","out":""}],"event":{"region":{"start":317,"stop":434},"type":"eval"},"cursor":428,"time":1.396586396264266e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else (n mod 10)::(digitsOfInt (n*10));;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = digitsOfInt 3124","min":"\nlet rec digitsOfInt n =\n  if n < 0 then [] else (n mod 10) :: (digitsOfInt (n * 10));;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec digitsOfInt n =\n  if n < 0 then [] else (n mod 10) :: (digitsOfInt (n * 10));;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""}],"event":{"region":{"start":434,"stop":554},"type":"eval"},"cursor":554,"time":1.39658641103174e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else (n mod 10)::(digitsOfInt (n*10));;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec digitsOfInt n = if n<0 then [] else (n mod 10)::(digitsOfInt (n/10))","min":"\nlet rec digitsOfInt n =\n  if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec digitsOfInt n =\n  if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec digitsOfInt n =\n  if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""}],"event":{"region":{"start":317,"stop":554},"type":"eval"},"cursor":554,"time":1.396586444632956e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else (n mod 10)::(digitsOfInt (n/10));;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec digitsOfInt n = if n<0 then [] else (if n<1 then [] else (n mod 10)::(digitsOfInt (n/10)))","min":"\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n < 1 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n","type":"","out":""}],"event":{"region":{"start":317,"stop":456},"type":"eval"},"cursor":458,"time":1.396586575374071e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else (if n<1 then [] else (n mod 10)::(digitsOfInt (n/10)));;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = digitsOfInt 3124","min":"\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n < 1 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n < 1 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""}],"event":{"region":{"start":456,"stop":576},"type":"eval"},"cursor":576,"time":1.396586577278287e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else (if n<1 then [] else (n mod 10)::(digitsOfInt (n/10)));;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = digitsOfInt 0352663","min":"\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n < 1 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""}],"event":{"region":{"start":549,"stop":577},"type":"eval"},"cursor":571,"time":1.396586650586488e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else (if n<1 then [] else (n mod 10)::(digitsOfInt (n/10)));;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 0352663\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec digitsOfInt n = if n<0 then [] else (if n<1 then [] else (if n=0 then [0] else (n mod 10)::(digitsOfInt (n/10))))","min":"\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 1\n    then []\n    else if n = 0 then [0] else (n mod 10) :: (digitsOfInt (n / 10));;\n","type":"","out":""}],"event":{"region":{"start":317,"stop":479},"type":"eval"},"cursor":481,"time":1.396586743632714e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else (if n<1 then [] else (if n=0 then [0] else (n mod 10)::(digitsOfInt (n/10))));;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 0352663\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = digitsOfInt 3124","min":"\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 1\n    then []\n    else if n = 0 then [0] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 0352663","min":"\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 1\n    then []\n    else if n = 0 then [0] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""}],"event":{"region":{"start":479,"stop":600},"type":"eval"},"cursor":600,"time":1.396586746149807e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else (if n<1 then [] else (if n=0 then [0] else (n mod 10)::(digitsOfInt (n/10))));;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 0352663\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec digitsOfInt n = if n<0 then [] else (if n=0 then [0] else (if n<1 then [] else (n mod 10)::(digitsOfInt (n/10))))","min":"\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n = 0\n    then [0]\n    else if n < 1 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n","type":"","out":""}],"event":{"region":{"start":317,"stop":479},"type":"eval"},"cursor":481,"time":1.396586809888054e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else (if n=0 then [0] else (if n<1 then [] else (n mod 10)::(digitsOfInt (n/10))));;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 0352663\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = digitsOfInt 3124","min":"\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n = 0\n    then [0]\n    else if n < 1 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 0352663","min":"\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n = 0\n    then [0]\n    else if n < 1 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""}],"event":{"region":{"start":479,"stop":600},"type":"eval"},"cursor":600,"time":1.396586812731679e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else (if n=0 then [0] else (if n<1 then [] else (n mod 10)::(digitsOfInt (n/10))));;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 0352663\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec digitsOfInt n = if n<0 then [] else (if n<1 then [] else (if n=0 then [0] else (n mod 10)::(digitsOfInt (n/10))))","min":"\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 1\n    then []\n    else if n = 0 then [0] else (n mod 10) :: (digitsOfInt (n / 10));;\n","type":"","out":""}],"event":{"region":{"start":317,"stop":479},"type":"eval"},"cursor":408,"time":1.396586866248831e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else (if n<1 then [] else (if n=0 then [0] else (n mod 10)::(digitsOfInt (n/10))));;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 0352663\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec digitsOfInt n = if n<0 then [] else (if n<1 then [] else (if n=0 then [0] else (n mod 10)::(digitsOfInt (n/10))))","min":"\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 1\n    then []\n    else if n = 0 then [0] else (n mod 10) :: (digitsOfInt (n / 10));;\n","type":"","out":""}],"event":{"region":{"start":358,"stop":479},"type":"eval"},"cursor":481,"time":1.396586867583687e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else (if n<1 then [] else (if n=0 then [0] else (n mod 10)::(digitsOfInt (n/10))));;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 0352663\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = digitsOfInt 3124","min":"\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 1\n    then []\n    else if n = 0 then [0] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 0352663","min":"\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 1\n    then []\n    else if n = 0 then [0] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""}],"event":{"region":{"start":479,"stop":600},"type":"eval"},"cursor":600,"time":1.396586868855923e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else (if n<1 then [] else (if n=0 then [0] else (n mod 10)::(digitsOfInt (n/10))));;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 0352663\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec digitsOfInt n = if n<0 then [] else (n mod 10)::(digitsOfInt (n/10))","min":"\nlet rec digitsOfInt n =\n  if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n","type":"","out":""}],"event":{"region":{"start":317,"stop":434},"type":"eval"},"cursor":402,"time":1.396587005591655e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else (n mod 10)::(digitsOfInt (n/10));;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = digitsOfInt 3124","min":"\nlet rec digitsOfInt n =\n  if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec digitsOfInt n =\n  if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""}],"event":{"region":{"start":434,"stop":554},"type":"eval"},"cursor":554,"time":1.396587007660229e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else (n mod 10)::(digitsOfInt (n/10));;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec digitsOfInt n = if n<0 then [] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x","min":"\nlet rec digitsOfInt n =\n  if n < 0 then [] else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n","type":"","out":""}],"event":{"region":{"start":317,"stop":450},"type":"eval"},"cursor":452,"time":1.396587233243801e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x)","min":"\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n","type":"","out":""}],"event":{"region":{"start":317,"stop":473},"type":"eval"},"cursor":424,"time":1.396587350008826e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x)","min":"\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n","type":"","out":""}],"event":{"region":{"start":358,"stop":473},"type":"eval"},"cursor":475,"time":1.39658735231249e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = digitsOfInt 3124","min":"\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""}],"event":{"region":{"start":473,"stop":593},"type":"eval"},"cursor":593,"time":1.396587354722239e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = digitsOfInt 0352663","min":"\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""}],"event":{"region":{"start":566,"stop":594},"type":"eval"},"cursor":588,"time":1.396587361630965e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 0352663\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = digitsOfInt 3526630","min":"\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n\nlet _ = digitsOfInt 3526630;;\n","type":"","out":""}],"event":{"region":{"start":566,"stop":594},"type":"eval"},"cursor":594,"time":1.396587462669585e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 3526630\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x)","min":"\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""}],"event":{"region":{"start":317,"stop":926},"type":"eval"},"cursor":926,"time":1.396587720748024e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs =\n  match xs with | [] -> 0 | f::b -> f + (sumList (List.tl xs));;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""}],"event":{"region":{"start":282,"stop":317},"type":"eval"},"cursor":317,"time":1.396587982229071e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs =\n  match xs with | [] -> 0 | f::b -> f + (sumList (List.tl xs));;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""}],"event":{"region":{"start":282,"stop":317},"type":"eval"},"cursor":317,"time":1.396587983530505e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs)","min":"\nlet rec sumList xs =\n  match xs with | [] -> 0 | f::b -> f + (sumList (List.tl xs));;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs =\n  match xs with | [] -> 0 | f::b -> f + (sumList (List.tl xs));;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs =\n  match xs with | [] -> 0 | f::b -> f + (sumList (List.tl xs));;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs =\n  match xs with | [] -> 0 | f::b -> f + (sumList (List.tl xs));;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x)","min":"\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":1205},"type":"eval"},"cursor":1205,"time":1.396588123268435e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec persistenceHelper q = let x = sumList q in","min":"","type":"syntax","out":"Characters 50-52:\n  let rec persistenceHelper q = let x = sumList q in;;\n                                                    ^^\nError: Syntax error\n"}],"event":{"region":{"start":1205,"stop":1903},"type":"eval"},"cursor":1904,"time":1.39658929488263e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec persistenceHelper q = let x = sumList q in ;;\nlet additivePersistence n = let x = (digits n) in persistenceHelper x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x))","min":"\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | f::b -> f + (sumList (List.tl xs));;\n\nlet rec persistenceHelper q =\n  let x = sumList q in\n  if x < 10 then 1 else 1 + (persistenceHelper (digits x));;\n","type":"","out":""}],"event":{"region":{"start":1205,"stop":1956},"type":"eval"},"cursor":1958,"time":1.396589440382776e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x));;\nlet additivePersistence n = let x = (digits n) in persistenceHelper x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let additivePersistence n = let x = (digits n) in persistenceHelper x","min":"\nlet rec sumList xs =\n  match xs with | [] -> 0 | f::b -> f + (sumList (List.tl xs));;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec persistenceHelper q =\n  let x = sumList q in\n  if x < 10 then 1 else 1 + (persistenceHelper (digits x));;\n\nlet additivePersistence n = let x = digits n in persistenceHelper x;;\n","type":"","out":""}],"event":{"region":{"start":1956,"stop":2028},"type":"eval"},"cursor":2028,"time":1.396589451830648e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x));;\nlet additivePersistence n = let x = (digits n) in persistenceHelper x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = additivePersistence 9876","min":"\nlet rec sumList xs =\n  match xs with | [] -> 0 | f::b -> f + (sumList (List.tl xs));;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec persistenceHelper q =\n  let x = sumList q in\n  if x < 10 then 1 else 1 + (persistenceHelper (digits x));;\n\nlet additivePersistence n = let x = digits n in persistenceHelper x;;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""}],"event":{"region":{"start":2028,"stop":2135},"type":"eval"},"cursor":2135,"time":1.396589467454815e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x));;\nlet additivePersistence n = let x = (digits n) in persistenceHelper x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\nlet _ = additivePersistence 9876\n\n\n\nlet digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = additivePersistence 0","min":"\nlet rec sumList xs =\n  match xs with | [] -> 0 | f::b -> f + (sumList (List.tl xs));;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec persistenceHelper q =\n  let x = sumList q in\n  if x < 10 then 1 else 1 + (persistenceHelper (digits x));;\n\nlet additivePersistence n = let x = digits n in persistenceHelper x;;\n\nlet _ = additivePersistence 0;;\n","type":"","out":""}],"event":{"region":{"start":2135,"stop":2165},"type":"eval"},"cursor":2165,"time":1.396589497215649e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x));;\nlet additivePersistence n = let x = (digits n) in persistenceHelper x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 0\n\n\nlet digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = additivePersistence 2","min":"\nlet rec sumList xs =\n  match xs with | [] -> 0 | f::b -> f + (sumList (List.tl xs));;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec persistenceHelper q =\n  let x = sumList q in\n  if x < 10 then 1 else 1 + (persistenceHelper (digits x));;\n\nlet additivePersistence n = let x = digits n in persistenceHelper x;;\n\nlet _ = additivePersistence 2;;\n","type":"","out":""}],"event":{"region":{"start":2135,"stop":2165},"type":"eval"},"cursor":2165,"time":1.396589514138877e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x));;\nlet additivePersistence n = let x = (digits n) in persistenceHelper x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 2\n\n\nlet digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = additivePersistence 23","min":"\nlet rec sumList xs =\n  match xs with | [] -> 0 | f::b -> f + (sumList (List.tl xs));;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec persistenceHelper q =\n  let x = sumList q in\n  if x < 10 then 1 else 1 + (persistenceHelper (digits x));;\n\nlet additivePersistence n = let x = digits n in persistenceHelper x;;\n\nlet _ = additivePersistence 23;;\n","type":"","out":""}],"event":{"region":{"start":2135,"stop":2166},"type":"eval"},"cursor":2166,"time":1.396589518273907e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x));;\nlet additivePersistence n = let x = (digits n) in persistenceHelper x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 23\n\n\nlet digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x))","min":"\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | f::b -> f + (sumList (List.tl xs));;\n\nlet rec persistenceHelper q =\n  let x = sumList q in\n  if x < 10 then 1 else 1 + (persistenceHelper (digits x));;\n","type":"","out":""},{"in":"let additivePersistence n = let x = (digits n) in if n<10 then 0 else persistenceHelper x","min":"\nlet rec sumList xs =\n  match xs with | [] -> 0 | f::b -> f + (sumList (List.tl xs));;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec persistenceHelper q =\n  let x = sumList q in\n  if x < 10 then 1 else 1 + (persistenceHelper (digits x));;\n\nlet additivePersistence n =\n  let x = digits n in if n < 10 then 0 else persistenceHelper x;;\n","type":"","out":""}],"event":{"region":{"start":1205,"stop":2048},"type":"eval"},"cursor":2048,"time":1.396589671458898e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x));;\nlet additivePersistence n = let x = (digits n) in if n<10 then 0 else persistenceHelper x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 23\n\n\nlet digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = additivePersistence 9876","min":"\nlet rec sumList xs =\n  match xs with | [] -> 0 | f::b -> f + (sumList (List.tl xs));;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec persistenceHelper q =\n  let x = sumList q in\n  if x < 10 then 1 else 1 + (persistenceHelper (digits x));;\n\nlet additivePersistence n =\n  let x = digits n in if n < 10 then 0 else persistenceHelper x;;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""},{"in":"let _ = additivePersistence 23","min":"\nlet rec sumList xs =\n  match xs with | [] -> 0 | f::b -> f + (sumList (List.tl xs));;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec persistenceHelper q =\n  let x = sumList q in\n  if x < 10 then 1 else 1 + (persistenceHelper (digits x));;\n\nlet additivePersistence n =\n  let x = digits n in if n < 10 then 0 else persistenceHelper x;;\n\nlet _ = additivePersistence 23;;\n","type":"","out":""}],"event":{"region":{"start":2048,"stop":2186},"type":"eval"},"cursor":2186,"time":1.396589678462326e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x));;\nlet additivePersistence n = let x = (digits n) in if n<10 then 0 else persistenceHelper x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 23\n\n\nlet digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = additivePersistence 9","min":"\nlet rec sumList xs =\n  match xs with | [] -> 0 | f::b -> f + (sumList (List.tl xs));;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec persistenceHelper q =\n  let x = sumList q in\n  if x < 10 then 1 else 1 + (persistenceHelper (digits x));;\n\nlet additivePersistence n =\n  let x = digits n in if n < 10 then 0 else persistenceHelper x;;\n\nlet _ = additivePersistence 9;;\n","type":"","out":""}],"event":{"region":{"start":2155,"stop":2185},"type":"eval"},"cursor":2185,"time":1.396589683572694e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x));;\nlet additivePersistence n = let x = (digits n) in if n<10 then 0 else persistenceHelper x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 9\n\n\nlet digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = additivePersistence 0","min":"\nlet rec sumList xs =\n  match xs with | [] -> 0 | f::b -> f + (sumList (List.tl xs));;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec persistenceHelper q =\n  let x = sumList q in\n  if x < 10 then 1 else 1 + (persistenceHelper (digits x));;\n\nlet additivePersistence n =\n  let x = digits n in if n < 10 then 0 else persistenceHelper x;;\n\nlet _ = additivePersistence 0;;\n","type":"","out":""}],"event":{"region":{"start":2155,"stop":2185},"type":"eval"},"cursor":2185,"time":1.39658969379372e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x));;\nlet additivePersistence n = let x = (digits n) in if n<10 then 0 else persistenceHelper x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 0\n\n\nlet digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = additivePersistence 3","min":"\nlet rec sumList xs =\n  match xs with | [] -> 0 | f::b -> f + (sumList (List.tl xs));;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec persistenceHelper q =\n  let x = sumList q in\n  if x < 10 then 1 else 1 + (persistenceHelper (digits x));;\n\nlet additivePersistence n =\n  let x = digits n in if n < 10 then 0 else persistenceHelper x;;\n\nlet _ = additivePersistence 3;;\n","type":"","out":""}],"event":{"region":{"start":2155,"stop":2185},"type":"eval"},"cursor":2185,"time":1.396589697008059e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x));;\nlet additivePersistence n = let x = (digits n) in if n<10 then 0 else persistenceHelper x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 3\n\n\nlet digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = additivePersistence 10","min":"\nlet rec sumList xs =\n  match xs with | [] -> 0 | f::b -> f + (sumList (List.tl xs));;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec persistenceHelper q =\n  let x = sumList q in\n  if x < 10 then 1 else 1 + (persistenceHelper (digits x));;\n\nlet additivePersistence n =\n  let x = digits n in if n < 10 then 0 else persistenceHelper x;;\n\nlet _ = additivePersistence 10;;\n","type":"","out":""}],"event":{"region":{"start":2155,"stop":2186},"type":"eval"},"cursor":2186,"time":1.396589699202413e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x));;\nlet additivePersistence n = let x = (digits n) in if n<10 then 0 else persistenceHelper x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 10\n\n\nlet digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = additivePersistence 100","min":"\nlet rec sumList xs =\n  match xs with | [] -> 0 | f::b -> f + (sumList (List.tl xs));;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec persistenceHelper q =\n  let x = sumList q in\n  if x < 10 then 1 else 1 + (persistenceHelper (digits x));;\n\nlet additivePersistence n =\n  let x = digits n in if n < 10 then 0 else persistenceHelper x;;\n\nlet _ = additivePersistence 100;;\n","type":"","out":""}],"event":{"region":{"start":2155,"stop":2187},"type":"eval"},"cursor":2187,"time":1.396589710218758e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x));;\nlet additivePersistence n = let x = (digits n) in if n<10 then 0 else persistenceHelper x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 100\n\n\nlet digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = additivePersistence 98754","min":"\nlet rec sumList xs =\n  match xs with | [] -> 0 | f::b -> f + (sumList (List.tl xs));;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec persistenceHelper q =\n  let x = sumList q in\n  if x < 10 then 1 else 1 + (persistenceHelper (digits x));;\n\nlet additivePersistence n =\n  let x = digits n in if n < 10 then 0 else persistenceHelper x;;\n\nlet _ = additivePersistence 98754;;\n","type":"","out":""}],"event":{"region":{"start":2155,"stop":2189},"type":"eval"},"cursor":2189,"time":1.396589721980083e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x));;\nlet additivePersistence n = let x = (digits n) in if n<10 then 0 else persistenceHelper x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 98754\n\n\nlet digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = additivePersistence 987549","min":"\nlet rec sumList xs =\n  match xs with | [] -> 0 | f::b -> f + (sumList (List.tl xs));;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec persistenceHelper q =\n  let x = sumList q in\n  if x < 10 then 1 else 1 + (persistenceHelper (digits x));;\n\nlet additivePersistence n =\n  let x = digits n in if n < 10 then 0 else persistenceHelper x;;\n\nlet _ = additivePersistence 987549;;\n","type":"","out":""}],"event":{"region":{"start":2155,"stop":2190},"type":"eval"},"cursor":2190,"time":1.396589754312675e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x));;\nlet additivePersistence n = let x = (digits n) in if n<10 then 0 else persistenceHelper x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 987549\n\n\nlet digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = additivePersistence 987549999999","min":"\nlet rec sumList xs =\n  match xs with | [] -> 0 | f::b -> f + (sumList (List.tl xs));;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec persistenceHelper q =\n  let x = sumList q in\n  if x < 10 then 1 else 1 + (persistenceHelper (digits x));;\n\nlet additivePersistence n =\n  let x = digits n in if n < 10 then 0 else persistenceHelper x;;\n\nlet _ = additivePersistence 987549999999;;\n","type":"","out":""}],"event":{"region":{"start":2155,"stop":2196},"type":"eval"},"cursor":2196,"time":1.396589777265474e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x));;\nlet additivePersistence n = let x = (digits n) in if n<10 then 0 else persistenceHelper x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 987549999999\n\n\nlet digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = additivePersistence 9875499999","min":"\nlet rec sumList xs =\n  match xs with | [] -> 0 | f::b -> f + (sumList (List.tl xs));;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec persistenceHelper q =\n  let x = sumList q in\n  if x < 10 then 1 else 1 + (persistenceHelper (digits x));;\n\nlet additivePersistence n =\n  let x = digits n in if n < 10 then 0 else persistenceHelper x;;\n\nlet _ = additivePersistence 9875499999;;\n","type":"","out":""}],"event":{"region":{"start":2155,"stop":2194},"type":"eval"},"cursor":2194,"time":1.396589784649371e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x));;\nlet additivePersistence n = let x = (digits n) in if n<10 then 0 else persistenceHelper x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 9875499999\n\n\nlet digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = additivePersistence 98754999","min":"\nlet rec sumList xs =\n  match xs with | [] -> 0 | f::b -> f + (sumList (List.tl xs));;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec persistenceHelper q =\n  let x = sumList q in\n  if x < 10 then 1 else 1 + (persistenceHelper (digits x));;\n\nlet additivePersistence n =\n  let x = digits n in if n < 10 then 0 else persistenceHelper x;;\n\nlet _ = additivePersistence 98754999;;\n","type":"","out":""}],"event":{"region":{"start":2155,"stop":2192},"type":"eval"},"cursor":2192,"time":1.396589787348421e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x));;\nlet additivePersistence n = let x = (digits n) in if n<10 then 0 else persistenceHelper x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 98754999\n\n\nlet digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = additivePersistence 98","min":"\nlet rec sumList xs =\n  match xs with | [] -> 0 | f::b -> f + (sumList (List.tl xs));;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec persistenceHelper q =\n  let x = sumList q in\n  if x < 10 then 1 else 1 + (persistenceHelper (digits x));;\n\nlet additivePersistence n =\n  let x = digits n in if n < 10 then 0 else persistenceHelper x;;\n\nlet _ = additivePersistence 98;;\n","type":"","out":""}],"event":{"region":{"start":2155,"stop":2186},"type":"eval"},"cursor":2186,"time":1.396589806634917e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x));;\nlet additivePersistence n = let x = (digits n) in if n<10 then 0 else persistenceHelper x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 98\n\n\nlet digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = additivePersistence 17","min":"\nlet rec sumList xs =\n  match xs with | [] -> 0 | f::b -> f + (sumList (List.tl xs));;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec persistenceHelper q =\n  let x = sumList q in\n  if x < 10 then 1 else 1 + (persistenceHelper (digits x));;\n\nlet additivePersistence n =\n  let x = digits n in if n < 10 then 0 else persistenceHelper x;;\n\nlet _ = additivePersistence 17;;\n","type":"","out":""}],"event":{"region":{"start":2155,"stop":2186},"type":"eval"},"cursor":2186,"time":1.39658982195578e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x));;\nlet additivePersistence n = let x = (digits n) in if n<10 then 0 else persistenceHelper x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 17\n\n\nlet digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x))","min":"\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | f::b -> f + (sumList (List.tl xs));;\n\nlet rec persistenceHelper q =\n  let x = sumList q in\n  if x < 10 then 1 else 1 + (persistenceHelper (digits x));;\n","type":"","out":""},{"in":"let additivePersistence n = let x = (digits n) in if n<10 then 0 else persistenceHelper x","min":"\nlet rec sumList xs =\n  match xs with | [] -> 0 | f::b -> f + (sumList (List.tl xs));;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec persistenceHelper q =\n  let x = sumList q in\n  if x < 10 then 1 else 1 + (persistenceHelper (digits x));;\n\nlet additivePersistence n =\n  let x = digits n in if n < 10 then 0 else persistenceHelper x;;\n","type":"","out":""}],"event":{"region":{"start":1205,"stop":2355},"type":"eval"},"cursor":2355,"time":1.396590338722002e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\nlet rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x));;\nlet additivePersistence n = let x = (digits n) in if n<10 then 0 else persistenceHelper x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\nlet _ = additivePersistence 9876\n\n\nlet digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let additivePersistence n = let x = (digits n) in if (abs n)<10 then 0 else persistenceHelper x","min":"\nlet rec sumList xs =\n  match xs with | [] -> 0 | f::b -> f + (sumList (List.tl xs));;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec persistenceHelper q =\n  let x = sumList q in\n  if x < 10 then 1 else 1 + (persistenceHelper (digits x));;\n\nlet additivePersistence n =\n  let x = digits n in if (abs n) < 10 then 0 else persistenceHelper x;;\n","type":"","out":""}],"event":{"region":{"start":2263,"stop":2586},"type":"eval"},"cursor":2586,"time":1.396590601471199e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\nlet rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x));;\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet additivePersistence n = let x = (digits n) in if (abs n)<10 then 0 else persistenceHelper x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\nlet _ = additivePersistence 9876\n\n\nlet digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = additivePersistence 9876","min":"\nlet rec sumList xs =\n  match xs with | [] -> 0 | f::b -> f + (sumList (List.tl xs));;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec persistenceHelper q =\n  let x = sumList q in\n  if x < 10 then 1 else 1 + (persistenceHelper (digits x));;\n\nlet additivePersistence n =\n  let x = digits n in if (abs n) < 10 then 0 else persistenceHelper x;;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""}],"event":{"region":{"start":2586,"stop":2693},"type":"eval"},"cursor":2693,"time":1.396590606652786e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\nlet rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x));;\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet additivePersistence n = let x = (digits n) in if (abs n)<10 then 0 else persistenceHelper x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\nlet _ = additivePersistence 9876\n\n\nlet digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = additivePersistence -9876","min":"\nlet rec sumList xs =\n  match xs with | [] -> 0 | f::b -> f + (sumList (List.tl xs));;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec persistenceHelper q =\n  let x = sumList q in\n  if x < 10 then 1 else 1 + (persistenceHelper (digits x));;\n\nlet additivePersistence n =\n  let x = digits n in if (abs n) < 10 then 0 else persistenceHelper x;;\n\nlet _ = additivePersistence - 9876;;\n","type":"type","out":"Characters 8-27:\n  let _ = additivePersistence -9876;;\n          ^^^^^^^^^^^^^^^^^^^\nError: This expression has type int -> int\n       but an expression was expected of type int\n"}],"event":{"region":{"start":2693,"stop":2727},"type":"eval"},"cursor":2723,"time":1.396590617128631e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\nlet rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x));;\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet additivePersistence n = let x = (digits n) in if (abs n)<10 then 0 else persistenceHelper x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence -9876\n\nlet digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = additivePersistence 9876","min":"\nlet rec sumList xs =\n  match xs with | [] -> 0 | f::b -> f + (sumList (List.tl xs));;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec persistenceHelper q =\n  let x = sumList q in\n  if x < 10 then 1 else 1 + (persistenceHelper (digits x));;\n\nlet additivePersistence n =\n  let x = digits n in if (abs n) < 10 then 0 else persistenceHelper x;;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""}],"event":{"region":{"start":2693,"stop":2726},"type":"eval"},"cursor":2722,"time":1.396590757665712e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\nlet rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x));;\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet additivePersistence n = let x = (digits n) in if (abs n)<10 then 0 else persistenceHelper x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 9876\n\nlet digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = additivePersistence -9876","min":"\nlet rec sumList xs =\n  match xs with | [] -> 0 | f::b -> f + (sumList (List.tl xs));;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec persistenceHelper q =\n  let x = sumList q in\n  if x < 10 then 1 else 1 + (persistenceHelper (digits x));;\n\nlet additivePersistence n =\n  let x = digits n in if (abs n) < 10 then 0 else persistenceHelper x;;\n\nlet _ = additivePersistence - 9876;;\n","type":"type","out":"Characters 8-27:\n  let _ = additivePersistence -9876;;\n          ^^^^^^^^^^^^^^^^^^^\nError: This expression has type int -> int\n       but an expression was expected of type int\n"}],"event":{"region":{"start":2693,"stop":2727},"type":"eval"},"cursor":2723,"time":1.396590763105964e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\nlet rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x));;\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet additivePersistence n = let x = (digits n) in if (abs n)<10 then 0 else persistenceHelper x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence -9876\n\nlet digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = additivePersistence 9","min":"\nlet rec sumList xs =\n  match xs with | [] -> 0 | f::b -> f + (sumList (List.tl xs));;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec persistenceHelper q =\n  let x = sumList q in\n  if x < 10 then 1 else 1 + (persistenceHelper (digits x));;\n\nlet additivePersistence n =\n  let x = digits n in if (abs n) < 10 then 0 else persistenceHelper x;;\n\nlet _ = additivePersistence 9;;\n","type":"","out":""}],"event":{"region":{"start":2693,"stop":2723},"type":"eval"},"cursor":2723,"time":1.39659080710681e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\nlet rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x));;\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet additivePersistence n = let x = (digits n) in if (abs n)<10 then 0 else persistenceHelper x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 9\n\nlet digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = additivePersistence -9","min":"\nlet rec sumList xs =\n  match xs with | [] -> 0 | f::b -> f + (sumList (List.tl xs));;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec persistenceHelper q =\n  let x = sumList q in\n  if x < 10 then 1 else 1 + (persistenceHelper (digits x));;\n\nlet additivePersistence n =\n  let x = digits n in if (abs n) < 10 then 0 else persistenceHelper x;;\n\nlet _ = additivePersistence - 9;;\n","type":"type","out":"Characters 8-27:\n  let _ = additivePersistence -9;;\n          ^^^^^^^^^^^^^^^^^^^\nError: This expression has type int -> int\n       but an expression was expected of type int\n"}],"event":{"region":{"start":2693,"stop":2724},"type":"eval"},"cursor":2723,"time":1.396590810339925e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\nlet rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x));;\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet additivePersistence n = let x = (digits n) in if (abs n)<10 then 0 else persistenceHelper x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence -9\n\nlet digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec adder a = if (sumList a)<10 then (sumList a) else adder (digit (sumList a))","min":"\nlet rec sumList xs =\n  match xs with | [] -> 0 | f::b -> f + (sumList (List.tl xs));;\n\nlet rec adder a =\n  if (sumList a) < 10 then sumList a else adder (digit (sumList a));;\n","type":"scope","out":"Characters 65-70:\n  let rec adder a = if (sumList a)<10 then (sumList a) else adder (digit (sumList a));;\n                                                                   ^^^^^\nError: Unbound value digit\n"},{"in":"let digitalRoot n = let x = (digits n) in if (abs n)<10 then n else adder x","min":"\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet digitalRoot n = let x = digits n in if (abs n) < 10 then n else adder x;;\n","type":"scope","out":"Characters 68-73:\n  let digitalRoot n = let x = (digits n) in if (abs n)<10 then n else adder x;;\n                                                                      ^^^^^\nError: Unbound value adder\n"}],"event":{"region":{"start":2693,"stop":2910},"type":"eval"},"cursor":2910,"time":1.396591842155927e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\nlet rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x));;\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet additivePersistence n = let x = (digits n) in if (abs n)<10 then 0 else persistenceHelper x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec adder a = if (sumList a)<10 then (sumList a) else adder (digit (sumList a))\nlet digitalRoot n = let x = (digits n) in if (abs n)<10 then n else adder x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec adder a = if (sumList a)<10 then (sumList a) else adder (digits (sumList a))","min":"\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | f::b -> f + (sumList (List.tl xs));;\n\nlet rec adder a =\n  if (sumList a) < 10 then sumList a else adder (digits (sumList a));;\n","type":"","out":""}],"event":{"region":{"start":2693,"stop":2835},"type":"eval"},"cursor":2822,"time":1.396591859170766e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\nlet rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x));;\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet additivePersistence n = let x = (digits n) in if (abs n)<10 then 0 else persistenceHelper x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec adder a = if (sumList a)<10 then (sumList a) else adder (digits (sumList a))\nlet digitalRoot n = let x = (digits n) in if (abs n)<10 then n else adder x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let digitalRoot n = let x = (digits n) in if (abs n)<10 then n else adder x","min":"\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | f::b -> f + (sumList (List.tl xs));;\n\nlet rec adder a =\n  if (sumList a) < 10 then sumList a else adder (digits (sumList a));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet digitalRoot n = let x = digits n in if (abs n) < 10 then n else adder x;;\n","type":"","out":""}],"event":{"region":{"start":2835,"stop":2911},"type":"eval"},"cursor":2911,"time":1.396591861799079e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\nlet rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x));;\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet additivePersistence n = let x = (digits n) in if (abs n)<10 then 0 else persistenceHelper x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec adder a = if (sumList a)<10 then (sumList a) else adder (digits (sumList a))\nlet digitalRoot n = let x = (digits n) in if (abs n)<10 then n else adder x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = digitalRoot 9876","min":"\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | f::b -> f + (sumList (List.tl xs));;\n\nlet rec adder a =\n  if (sumList a) < 10 then sumList a else adder (digits (sumList a));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet digitalRoot n = let x = digits n in if (abs n) < 10 then n else adder x;;\n\nlet _ = digitalRoot 9876;;\n","type":"","out":""}],"event":{"region":{"start":2911,"stop":3001},"type":"eval"},"cursor":3001,"time":1.396591907292981e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\nlet rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x));;\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet additivePersistence n = let x = (digits n) in if (abs n)<10 then 0 else persistenceHelper x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec adder a = if (sumList a)<10 then (sumList a) else adder (digits (sumList a))\nlet digitalRoot n = let x = (digits n) in if (abs n)<10 then n else adder x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = digitalRoot 9","min":"\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | f::b -> f + (sumList (List.tl xs));;\n\nlet rec adder a =\n  if (sumList a) < 10 then sumList a else adder (digits (sumList a));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet digitalRoot n = let x = digits n in if (abs n) < 10 then n else adder x;;\n\nlet _ = digitalRoot 9;;\n","type":"","out":""}],"event":{"region":{"start":3001,"stop":3023},"type":"eval"},"cursor":3023,"time":1.39659192755322e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\nlet rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x));;\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet additivePersistence n = let x = (digits n) in if (abs n)<10 then 0 else persistenceHelper x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec adder a = if (sumList a)<10 then (sumList a) else adder (digits (sumList a))\nlet digitalRoot n = let x = (digits n) in if (abs n)<10 then n else adder x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot 9\n\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = digitalRoot 10","min":"\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | f::b -> f + (sumList (List.tl xs));;\n\nlet rec adder a =\n  if (sumList a) < 10 then sumList a else adder (digits (sumList a));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet digitalRoot n = let x = digits n in if (abs n) < 10 then n else adder x;;\n\nlet _ = digitalRoot 10;;\n","type":"","out":""}],"event":{"region":{"start":3001,"stop":3024},"type":"eval"},"cursor":3024,"time":1.39659193546532e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\nlet rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x));;\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet additivePersistence n = let x = (digits n) in if (abs n)<10 then 0 else persistenceHelper x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec adder a = if (sumList a)<10 then (sumList a) else adder (digits (sumList a))\nlet digitalRoot n = let x = (digits n) in if (abs n)<10 then n else adder x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot 10\n\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = digitalRoot 0","min":"\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | f::b -> f + (sumList (List.tl xs));;\n\nlet rec adder a =\n  if (sumList a) < 10 then sumList a else adder (digits (sumList a));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet digitalRoot n = let x = digits n in if (abs n) < 10 then n else adder x;;\n\nlet _ = digitalRoot 0;;\n","type":"","out":""}],"event":{"region":{"start":3001,"stop":3023},"type":"eval"},"cursor":3023,"time":1.396591940687599e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\nlet rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x));;\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet additivePersistence n = let x = (digits n) in if (abs n)<10 then 0 else persistenceHelper x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec adder a = if (sumList a)<10 then (sumList a) else adder (digits (sumList a))\nlet digitalRoot n = let x = (digits n) in if (abs n)<10 then n else adder x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot 0\n\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = digitalRoot -4","min":"","type":"scope","out":"Error: This expression has type int -> int\n       but an expression was expected of type int\nError: Unbound value digits\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 8-19:\n  let _ = digitalRoot -4;;\n          ^^^^^^^^^^^\nError: This expression has type int -> int\n       but an expression was expected of type int\n"}],"event":{"region":{"start":3001,"stop":3024},"type":"eval"},"cursor":3024,"time":1.396591943473429e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\nlet rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x));;\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet additivePersistence n = let x = (digits n) in if (abs n)<10 then 0 else persistenceHelper x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec adder a = if (sumList a)<10 then (sumList a) else adder (digits (sumList a))\nlet digitalRoot n = let x = (digits n) in if (abs n)<10 then n else adder x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot -4\n\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = digitalRoot -434","min":"","type":"scope","out":"Error: This expression has type int -> int\n       but an expression was expected of type int\nError: Unbound value digits\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 8-19:\n  let _ = digitalRoot -434;;\n          ^^^^^^^^^^^\nError: This expression has type int -> int\n       but an expression was expected of type int\n"}],"event":{"region":{"start":3001,"stop":3026},"type":"eval"},"cursor":3026,"time":1.39659194679502e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\nlet rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x));;\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet additivePersistence n = let x = (digits n) in if (abs n)<10 then 0 else persistenceHelper x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec adder a = if (sumList a)<10 then (sumList a) else adder (digits (sumList a))\nlet digitalRoot n = let x = (digits n) in if (abs n)<10 then n else adder x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot -434\n\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = digitalRoot (-45)","min":"\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | f::b -> f + (sumList (List.tl xs));;\n\nlet rec adder a =\n  if (sumList a) < 10 then sumList a else adder (digits (sumList a));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet digitalRoot n = let x = digits n in if (abs n) < 10 then n else adder x;;\n\nlet _ = digitalRoot (-45);;\n","type":"","out":""}],"event":{"region":{"start":3001,"stop":3027},"type":"eval"},"cursor":3023,"time":1.396591959327831e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\nlet rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x));;\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet additivePersistence n = let x = (digits n) in if (abs n)<10 then 0 else persistenceHelper x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec adder a = if (sumList a)<10 then (sumList a) else adder (digits (sumList a))\nlet digitalRoot n = let x = (digits n) in if (abs n)<10 then n else adder x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot (-45)\n\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = digitalRoot -459","min":"","type":"scope","out":"Error: This expression has type int -> int\n       but an expression was expected of type int\nError: Unbound value digits\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 8-19:\n  let _ = digitalRoot -459;;\n          ^^^^^^^^^^^\nError: This expression has type int -> int\n       but an expression was expected of type int\n"}],"event":{"region":{"start":3001,"stop":3026},"type":"eval"},"cursor":3026,"time":1.396592021536362e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\nlet rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x));;\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet additivePersistence n = let x = (digits n) in if (abs n)<10 then 0 else persistenceHelper x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec adder a = if (sumList a)<10 then (sumList a) else adder (digits (sumList a))\nlet digitalRoot n = let x = (digits n) in if (abs n)<10 then n else adder x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot -459\n\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = digitalRoot 459","min":"\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | f::b -> f + (sumList (List.tl xs));;\n\nlet rec adder a =\n  if (sumList a) < 10 then sumList a else adder (digits (sumList a));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet digitalRoot n = let x = digits n in if (abs n) < 10 then n else adder x;;\n\nlet _ = digitalRoot 459;;\n","type":"","out":""}],"event":{"region":{"start":3001,"stop":3025},"type":"eval"},"cursor":3022,"time":1.396592025586568e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\nlet rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x));;\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet additivePersistence n = let x = (digits n) in if (abs n)<10 then 0 else persistenceHelper x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec adder a = if (sumList a)<10 then (sumList a) else adder (digits (sumList a))\nlet digitalRoot n = let x = (digits n) in if (abs n)<10 then n else adder x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot 459\n\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let x = 555646","min":"\nlet x = 555646;;\n","type":"","out":""},{"in":"x.[3]","min":"\nlet x = 555646;;\n\nlet _ = x.[3];;\n","type":"type","out":"Characters 0-1:\n  x.[3];;\n  ^\nError: This expression has type int but an expression was expected of type\n         string\n"}],"event":{"region":{"start":317,"stop":341},"type":"eval"},"cursor":343,"time":1.396594038992316e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\nlet x = 555646;;\nx.[3];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\nlet rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x));;\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet additivePersistence n = let x = (digits n) in if (abs n)<10 then 0 else persistenceHelper x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec adder a = if (sumList a)<10 then (sumList a) else adder (digits (sumList a))\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\n*)\nlet digitalRoot n = let x = (digits n) in if (abs n)<10 then n else adder x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"x[3]","min":"\nlet x = 555646;;\n\nlet _ = x [3];;\n","type":"type","out":"Characters 0-1:\n  x[3];;\n  ^\nError: This expression has type int\n       This is not a function; it cannot be applied.\n"}],"event":{"region":{"start":333,"stop":340},"type":"eval"},"cursor":337,"time":1.396594061463897e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\nlet x = 555646;;\nx[3];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\nlet rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x));;\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet additivePersistence n = let x = (digits n) in if (abs n)<10 then 0 else persistenceHelper x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec adder a = if (sumList a)<10 then (sumList a) else adder (digits (sumList a))\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\n*)\nlet digitalRoot n = let x = (digits n) in if (abs n)<10 then n else adder x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs =\n  match xs with | [] -> 0 | f::b -> f + (sumList (List.tl xs));;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let li = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs =\n  match xs with | [] -> 0 | f::b -> f + (sumList (List.tl xs));;\n\nlet li = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"match li with f::b -> b","min":"\nlet rec sumList xs =\n  match xs with | [] -> 0 | f::b -> f + (sumList (List.tl xs));;\n\nlet li = sumList [1; 2; 3; 4];;\n\nlet _ = match li with | f::b -> b;;\n","type":"type","out":"Characters 14-18:\n  match li with f::b -> b;;\n                ^^^^\nError: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type int\n"}],"event":{"region":{"start":281,"stop":374},"type":"eval"},"cursor":376,"time":1.396594383267412e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\nlet li = sumList [1; 2; 3; 4];;\nmatch li with f::b -> b;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\nlet rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x));;\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet additivePersistence n = let x = (digits n) in if (abs n)<10 then 0 else persistenceHelper x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec adder a = if (sumList a)<10 then (sumList a) else adder (digits (sumList a))\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\n*)\nlet digitalRoot n = let x = (digits n) in if (abs n)<10 then n else adder x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let li = [1; 2; 3; 4]","min":"\nlet li = [1; 2; 3; 4];;\n","type":"","out":""},{"in":"match li with f::b -> b","min":"\nlet li = [1; 2; 3; 4];;\n\nlet _ = match li with | f::b -> b;;\n","type":"","out":""}],"event":{"region":{"start":317,"stop":366},"type":"eval"},"cursor":368,"time":1.396594406311896e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\nlet li = [1; 2; 3; 4];;\nmatch li with f::b -> b;;\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\nlet rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x));;\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet additivePersistence n = let x = (digits n) in if (abs n)<10 then 0 else persistenceHelper x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec adder a = if (sumList a)<10 then (sumList a) else adder (digits (sumList a))\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\n*)\nlet digitalRoot n = let x = (digits n) in if (abs n)<10 then n else adder x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (b)","min":"\nlet rec sumList xs = match xs with | [] -> 0 | f::b -> f + (sumList b);;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":151},"type":"eval"},"cursor":150,"time":1.396594481624097e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (b);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\nlet rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x));;\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet additivePersistence n = let x = (digits n) in if (abs n)<10 then 0 else persistenceHelper x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec adder a = if (sumList a)<10 then (sumList a) else adder (digits (sumList a))\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\n*)\nlet digitalRoot n = let x = (digits n) in if (abs n)<10 then n else adder x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | f::b -> f + (sumList b);;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | f::b -> f + (sumList b);;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | f::b -> f + (sumList b);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""}],"event":{"region":{"start":151,"stop":308},"type":"eval"},"cursor":308,"time":1.396594485304223e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (b);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\nlet rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x));;\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet additivePersistence n = let x = (digits n) in if (abs n)<10 then 0 else persistenceHelper x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec adder a = if (sumList a)<10 then (sumList a) else adder (digits (sumList a))\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\n*)\nlet digitalRoot n = let x = (digits n) in if (abs n)<10 then n else adder x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = sumList [1;]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | f::b -> f + (sumList b);;\n\nlet _ = sumList [1];;\n","type":"","out":""}],"event":{"region":{"start":308,"stop":329},"type":"eval"},"cursor":328,"time":1.396594616116966e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (b);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\nlet _ = sumList [1;]\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\nlet rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x));;\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet additivePersistence n = let x = (digits n) in if (abs n)<10 then 0 else persistenceHelper x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec adder a = if (sumList a)<10 then (sumList a) else adder (digits (sumList a))\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\n*)\nlet digitalRoot n = let x = (digits n) in if (abs n)<10 then n else adder x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = sumList [1]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | f::b -> f + (sumList b);;\n\nlet _ = sumList [1];;\n","type":"","out":""}],"event":{"region":{"start":308,"stop":328},"type":"eval"},"cursor":327,"time":1.396594620638412e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (b);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\nlet _ = sumList [1]\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\nlet rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x));;\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet additivePersistence n = let x = (digits n) in if (abs n)<10 then 0 else persistenceHelper x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec adder a = if (sumList a)<10 then (sumList a) else adder (digits (sumList a))\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\n*)\nlet digitalRoot n = let x = (digits n) in if (abs n)<10 then n else adder x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = sumList [1;2;]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | f::b -> f + (sumList b);;\n\nlet _ = sumList [1; 2];;\n","type":"","out":""}],"event":{"region":{"start":308,"stop":331},"type":"eval"},"cursor":330,"time":1.396594624360751e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (b);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\nlet _ = sumList [1;2;]\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\nlet rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x));;\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet additivePersistence n = let x = (digits n) in if (abs n)<10 then 0 else persistenceHelper x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec adder a = if (sumList a)<10 then (sumList a) else adder (digits (sumList a))\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\n*)\nlet digitalRoot n = let x = (digits n) in if (abs n)<10 then n else adder x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = sumList [1;2;3;]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | f::b -> f + (sumList b);;\n\nlet _ = sumList [1; 2; 3];;\n","type":"","out":""}],"event":{"region":{"start":308,"stop":333},"type":"eval"},"cursor":332,"time":1.39659462816986e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (b);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\nlet _ = sumList [1;2;3;]\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\nlet rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x));;\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet additivePersistence n = let x = (digits n) in if (abs n)<10 then 0 else persistenceHelper x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec adder a = if (sumList a)<10 then (sumList a) else adder (digits (sumList a))\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\n*)\nlet digitalRoot n = let x = (digits n) in if (abs n)<10 then n else adder x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = sumList []","min":"\nlet rec sumList xs = match xs with | [] -> 0 | f::b -> f + (sumList b);;\n\nlet _ = sumList [];;\n","type":"","out":""}],"event":{"region":{"start":308,"stop":327},"type":"eval"},"cursor":326,"time":1.396594633085411e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (b);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\nlet _ = sumList []\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\nlet rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x));;\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet additivePersistence n = let x = (digits n) in if (abs n)<10 then 0 else persistenceHelper x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec adder a = if (sumList a)<10 then (sumList a) else adder (digits (sumList a))\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\n*)\nlet digitalRoot n = let x = (digits n) in if (abs n)<10 then n else adder x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n\n\nlet listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (b)","min":"\nlet rec sumList xs = match xs with | [] -> 0 | f::b -> f + (sumList b);;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | f::b -> f + (sumList b);;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | f::b -> f + (sumList b);;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | f::b -> f + (sumList b);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x)","min":"\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x))","min":"\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | f::b -> f + (sumList b);;\n\nlet rec persistenceHelper q =\n  let x = sumList q in\n  if x < 10 then 1 else 1 + (persistenceHelper (digits x));;\n","type":"","out":""},{"in":"let additivePersistence n = let x = (digits n) in if (abs n)<10 then 0 else persistenceHelper x","min":"\nlet rec sumList xs = match xs with | [] -> 0 | f::b -> f + (sumList b);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec persistenceHelper q =\n  let x = sumList q in\n  if x < 10 then 1 else 1 + (persistenceHelper (digits x));;\n\nlet additivePersistence n =\n  let x = digits n in if (abs n) < 10 then 0 else persistenceHelper x;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9876","min":"\nlet rec sumList xs = match xs with | [] -> 0 | f::b -> f + (sumList b);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec persistenceHelper q =\n  let x = sumList q in\n  if x < 10 then 1 else 1 + (persistenceHelper (digits x));;\n\nlet additivePersistence n =\n  let x = digits n in if (abs n) < 10 then 0 else persistenceHelper x;;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""},{"in":"let rec adder a = if (sumList a)<10 then (sumList a) else adder (digits (sumList a))","min":"\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | f::b -> f + (sumList b);;\n\nlet rec adder a =\n  if (sumList a) < 10 then sumList a else adder (digits (sumList a));;\n","type":"","out":""},{"in":"let digitalRoot n = let x = (digits n) in if (abs n)<10 then n else adder x","min":"\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n\nlet rec sumList xs = match xs with | [] -> 0 | f::b -> f + (sumList b);;\n\nlet rec adder a =\n  if (sumList a) < 10 then sumList a else adder (digits (sumList a));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet digitalRoot n = let x = digits n in if (abs n) < 10 then n else adder x;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9876","min":"\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n\nlet rec sumList xs = match xs with | [] -> 0 | f::b -> f + (sumList b);;\n\nlet rec adder a =\n  if (sumList a) < 10 then sumList a else adder (digits (sumList a));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet digitalRoot n = let x = digits n in if (abs n) < 10 then n else adder x;;\n\nlet _ = digitalRoot 9876;;\n","type":"","out":""},{"in":"let rec listReverse l = match l with []->[] | h::t -> listReverse (t)@h","min":"\nlet rec listReverse l = match l with | [] -> [] | h::t -> (listReverse t) @ h;;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":3447},"type":"eval"},"cursor":3449,"time":1.396640135255728e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (b);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\nlet rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x));;\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet additivePersistence n = let x = (digits n) in if (abs n)<10 then 0 else persistenceHelper x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec adder a = if (sumList a)<10 then (sumList a) else adder (digits (sumList a))\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\n*)\nlet digitalRoot n = let x = (digits n) in if (abs n)<10 then n else adder x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n\n\nlet rec listReverse l = match l with []->[] | h::t -> listReverse (t)@h;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec listReverse l = match l with []->[] | h::t -> (listReverse (t))@h","min":"\nlet rec listReverse l = match l with | [] -> [] | h::t -> (listReverse t) @ h;;\n","type":"","out":""}],"event":{"region":{"start":3372,"stop":3449},"type":"eval"},"cursor":3447,"time":1.396640191971096e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (b);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\nlet rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x));;\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet additivePersistence n = let x = (digits n) in if (abs n)<10 then 0 else persistenceHelper x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec adder a = if (sumList a)<10 then (sumList a) else adder (digits (sumList a))\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\n*)\nlet digitalRoot n = let x = (digits n) in if (abs n)<10 then n else adder x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n\n\nlet rec listReverse l = match l with []->[] | h::t -> (listReverse (t))@h;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = listReverse [1; 2; 3; 4]","min":"\nlet rec listReverse l = match l with | [] -> [] | h::t -> (listReverse t) @ h;;\n\nlet _ = listReverse [1; 2; 3; 4];;\n","type":"type","out":"Characters 21-22:\n  let _ = listReverse [1; 2; 3; 4];;\n                       ^\nError: This expression has type int but an expression was expected of type\n         'a list\n"},{"in":"let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]","min":"\nlet rec listReverse l = match l with | [] -> [] | h::t -> (listReverse t) @ h;;\n\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n","type":"type","out":"Characters 21-24:\n  let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n                       ^^^\nError: This expression has type string but an expression was expected of type\n         'a list\n"}],"event":{"region":{"start":3449,"stop":3589},"type":"eval"},"cursor":3589,"time":1.396640238462879e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (b);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\nlet rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x));;\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet additivePersistence n = let x = (digits n) in if (abs n)<10 then 0 else persistenceHelper x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec adder a = if (sumList a)<10 then (sumList a) else adder (digits (sumList a))\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\n*)\nlet digitalRoot n = let x = (digits n) in if (abs n)<10 then n else adder x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n\n\nlet rec listReverse l = match l with []->[] | h::t -> (listReverse (t))@h;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let poop = [1; 2; 3; 4]\nmatch poop with h::t","min":"","type":"syntax","out":"Characters 24-29:\n  match poop with h::t;;\n  ^^^^^\nError: Syntax error\n"}],"event":{"region":{"start":3372,"stop":3417},"type":"eval"},"cursor":3419,"time":1.396640413783233e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (b);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\nlet rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x));;\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet additivePersistence n = let x = (digits n) in if (abs n)<10 then 0 else persistenceHelper x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec adder a = if (sumList a)<10 then (sumList a) else adder (digits (sumList a))\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\n*)\nlet digitalRoot n = let x = (digits n) in if (abs n)<10 then n else adder x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\nlet poop = [1; 2; 3; 4]\n             match poop with h::t;;\n\nlet rec listReverse l = match l with []->[] | h::t -> (listReverse (t))@h;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let poop = [1; 2; 3; 4]","min":"\nlet poop = [1; 2; 3; 4];;\n","type":"","out":""},{"in":"match poop with h::t","min":"","type":"syntax","out":"Characters 20-22:\n  match poop with h::t;;\n                      ^^\nError: Syntax error: pattern expected.\n"}],"event":{"region":{"start":3372,"stop":3419},"type":"eval"},"cursor":3417,"time":1.396640429413334e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (b);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\nlet rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x));;\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet additivePersistence n = let x = (digits n) in if (abs n)<10 then 0 else persistenceHelper x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec adder a = if (sumList a)<10 then (sumList a) else adder (digits (sumList a))\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\n*)\nlet digitalRoot n = let x = (digits n) in if (abs n)<10 then n else adder x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\nlet poop = [1; 2; 3; 4];;\nmatch poop with h::t;;\n\nlet rec listReverse l = match l with []->[] | h::t -> (listReverse (t))@h;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"match poop with h::t->h","min":"\nlet poop = [1; 2; 3; 4];;\n\nlet _ = match poop with | h::t -> h;;\n","type":"","out":""}],"event":{"region":{"start":3396,"stop":3422},"type":"eval"},"cursor":3422,"time":1.396640441079848e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (b);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\nlet rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x));;\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet additivePersistence n = let x = (digits n) in if (abs n)<10 then 0 else persistenceHelper x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec adder a = if (sumList a)<10 then (sumList a) else adder (digits (sumList a))\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\n*)\nlet digitalRoot n = let x = (digits n) in if (abs n)<10 then n else adder x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\nlet poop = [1; 2; 3; 4];;\nmatch poop with h::t->h;;\n\nlet rec listReverse l = match l with []->[] | h::t -> (listReverse (t))@h;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"match poop with h::t->t","min":"\nlet poop = [1; 2; 3; 4];;\n\nlet _ = match poop with | h::t -> t;;\n","type":"","out":""}],"event":{"region":{"start":3396,"stop":3422},"type":"eval"},"cursor":3422,"time":1.396640451779793e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (b);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\nlet rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x));;\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet additivePersistence n = let x = (digits n) in if (abs n)<10 then 0 else persistenceHelper x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec adder a = if (sumList a)<10 then (sumList a) else adder (digits (sumList a))\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\n*)\nlet digitalRoot n = let x = (digits n) in if (abs n)<10 then n else adder x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\nlet poop = [1; 2; 3; 4];;\nmatch poop with h::t->t;;\n\nlet rec listReverse l = match l with []->[] | h::t -> (listReverse (t))@h;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = digitalRoot 9876","min":"\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n\nlet rec sumList xs = match xs with | [] -> 0 | f::b -> f + (sumList b);;\n\nlet rec adder a =\n  if (sumList a) < 10 then sumList a else adder (digits (sumList a));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet digitalRoot n = let x = digits n in if (abs n) < 10 then n else adder x;;\n\nlet _ = digitalRoot 9876;;\n","type":"","out":""},{"in":"let rec listReverse l = match l with []->[] | h::t -> let x = [h] in (listReverse (t))@x","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> let x = [h] in (listReverse t) @ x;;\n","type":"","out":""}],"event":{"region":{"start":3282,"stop":3463},"type":"eval"},"cursor":3465,"time":1.396640514543967e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (b);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\nlet rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x));;\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet additivePersistence n = let x = (digits n) in if (abs n)<10 then 0 else persistenceHelper x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec adder a = if (sumList a)<10 then (sumList a) else adder (digits (sumList a))\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\n*)\nlet digitalRoot n = let x = (digits n) in if (abs n)<10 then n else adder x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n\nlet rec listReverse l = match l with []->[] | h::t -> let x = [h] in (listReverse (t))@x;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = listReverse [1; 2; 3; 4]","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> let x = [h] in (listReverse t) @ x;;\n\nlet _ = listReverse [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> let x = [h] in (listReverse t) @ x;;\n\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n","type":"","out":""}],"event":{"region":{"start":3463,"stop":3603},"type":"eval"},"cursor":3603,"time":1.396640520319748e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (b);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\nlet rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x));;\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet additivePersistence n = let x = (digits n) in if (abs n)<10 then 0 else persistenceHelper x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec adder a = if (sumList a)<10 then (sumList a) else adder (digits (sumList a))\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\n*)\nlet digitalRoot n = let x = (digits n) in if (abs n)<10 then n else adder x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n\nlet rec listReverse l = match l with []->[] | h::t -> let x = [h] in (listReverse (t))@x;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec listReverse l = match l with []->[] | h::t -> let x = [h] in (listReverse (t))@x","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> let x = [h] in (listReverse t) @ x;;\n","type":"","out":""},{"in":"let _ = listReverse [1; 2; 3; 4]","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> let x = [h] in (listReverse t) @ x;;\n\nlet _ = listReverse [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> let x = [h] in (listReverse t) @ x;;\n\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n","type":"","out":""},{"in":"let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n","type":"","out":""},{"in":"let palindrome w = let x = listReverse (explode w) in if(x=explode w) then true","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> let x = [h] in (listReverse t) @ x;;\n\nlet palindrome w =\n  let x = listReverse (explode w) in if x = (explode w) then true;;\n","type":"type","out":"Characters 75-79:\n  let palindrome w = let x = listReverse (explode w) in if(x=explode w) then true;;\n                                                                             ^^^^\nError: This variant expression is expected to have type unit\n       The constructor true does not belong to type unit\n"}],"event":{"region":{"start":3372,"stop":4414},"type":"eval"},"cursor":4416,"time":1.396641065664559e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (b);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\nlet rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x));;\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet additivePersistence n = let x = (digits n) in if (abs n)<10 then 0 else persistenceHelper x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec adder a = if (sumList a)<10 then (sumList a) else adder (digits (sumList a))\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\n*)\nlet digitalRoot n = let x = (digits n) in if (abs n)<10 then n else adder x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec listReverse l = match l with []->[] | h::t -> let x = [h] in (listReverse (t))@x;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = let x = listReverse (explode w) in if(x=explode w) then true;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let palindrome w = let x = listReverse (explode w) in if(x=(explode (w))) then true esle false","min":"","type":"syntax","out":"Characters 89-94:\n  let palindrome w = let x = listReverse (explode w) in if(x=(explode (w))) then true esle false;;\n                                                                                           ^^^^^\nError: Syntax error\n"}],"event":{"region":{"start":4333,"stop":4429},"type":"eval"},"cursor":4407,"time":1.396641139831216e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (b);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\nlet rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x));;\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet additivePersistence n = let x = (digits n) in if (abs n)<10 then 0 else persistenceHelper x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec adder a = if (sumList a)<10 then (sumList a) else adder (digits (sumList a))\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\n*)\nlet digitalRoot n = let x = (digits n) in if (abs n)<10 then n else adder x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec listReverse l = match l with []->[] | h::t -> let x = [h] in (listReverse (t))@x;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = let x = listReverse (explode w) in if(x=(explode (w))) then true esle false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let palindrome w = let x = listReverse (explode w) in if(x=(explode (w))) then true else false","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> let x = [h] in (listReverse t) @ x;;\n\nlet palindrome w =\n  let x = listReverse (explode w) in if x = (explode w) then true else false;;\n","type":"","out":""}],"event":{"region":{"start":4333,"stop":4429},"type":"eval"},"cursor":4423,"time":1.396641154536969e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (b);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\nlet rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x));;\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet additivePersistence n = let x = (digits n) in if (abs n)<10 then 0 else persistenceHelper x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec adder a = if (sumList a)<10 then (sumList a) else adder (digits (sumList a))\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\n*)\nlet digitalRoot n = let x = (digits n) in if (abs n)<10 then n else adder x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec listReverse l = match l with []->[] | h::t -> let x = [h] in (listReverse (t))@x;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = let x = listReverse (explode w) in if(x=(explode (w))) then true else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = palindrome \"malayalam\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> let x = [h] in (listReverse t) @ x;;\n\nlet palindrome w =\n  let x = listReverse (explode w) in if x = (explode w) then true else false;;\n\nlet _ = palindrome \"malayalam\";;\n","type":"","out":""},{"in":"let _ = palindrome \"myxomatosis\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> let x = [h] in (listReverse t) @ x;;\n\nlet palindrome w =\n  let x = listReverse (explode w) in if x = (explode w) then true else false;;\n\nlet _ = palindrome \"myxomatosis\";;\n","type":"","out":""}],"event":{"region":{"start":4429,"stop":4561},"type":"eval"},"cursor":4561,"time":1.396641166900932e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (b);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\nlet rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x));;\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet additivePersistence n = let x = (digits n) in if (abs n)<10 then 0 else persistenceHelper x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec adder a = if (sumList a)<10 then (sumList a) else adder (digits (sumList a))\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\n*)\nlet digitalRoot n = let x = (digits n) in if (abs n)<10 then n else adder x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec listReverse l = match l with []->[] | h::t -> let x = [h] in (listReverse (t))@x;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = let x = listReverse (explode w) in if(x=(explode (w))) then true else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (b)","min":"\nlet rec sumList xs = match xs with | [] -> 0 | f::b -> f + (sumList b);;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | f::b -> f + (sumList b);;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | f::b -> f + (sumList b);;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | f::b -> f + (sumList b);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x)","min":"\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x))","min":"\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | f::b -> f + (sumList b);;\n\nlet rec persistenceHelper q =\n  let x = sumList q in\n  if x < 10 then 1 else 1 + (persistenceHelper (digits x));;\n","type":"","out":""},{"in":"let additivePersistence n = let x = (digits n) in if (abs n)<10 then 0 else persistenceHelper x","min":"\nlet rec sumList xs = match xs with | [] -> 0 | f::b -> f + (sumList b);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec persistenceHelper q =\n  let x = sumList q in\n  if x < 10 then 1 else 1 + (persistenceHelper (digits x));;\n\nlet additivePersistence n =\n  let x = digits n in if (abs n) < 10 then 0 else persistenceHelper x;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9876","min":"\nlet rec sumList xs = match xs with | [] -> 0 | f::b -> f + (sumList b);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec persistenceHelper q =\n  let x = sumList q in\n  if x < 10 then 1 else 1 + (persistenceHelper (digits x));;\n\nlet additivePersistence n =\n  let x = digits n in if (abs n) < 10 then 0 else persistenceHelper x;;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""},{"in":"let rec adder a = if (sumList a)<10 then (sumList a) else adder (digits (sumList a))","min":"\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | f::b -> f + (sumList b);;\n\nlet rec adder a =\n  if (sumList a) < 10 then sumList a else adder (digits (sumList a));;\n","type":"","out":""},{"in":"let digitalRoot n = let x = (digits n) in if (abs n)<10 then n else adder x","min":"\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n\nlet rec sumList xs = match xs with | [] -> 0 | f::b -> f + (sumList b);;\n\nlet rec adder a =\n  if (sumList a) < 10 then sumList a else adder (digits (sumList a));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet digitalRoot n = let x = digits n in if (abs n) < 10 then n else adder x;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9876","min":"\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n\nlet rec sumList xs = match xs with | [] -> 0 | f::b -> f + (sumList b);;\n\nlet rec adder a =\n  if (sumList a) < 10 then sumList a else adder (digits (sumList a));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet digitalRoot n = let x = digits n in if (abs n) < 10 then n else adder x;;\n\nlet _ = digitalRoot 9876;;\n","type":"","out":""},{"in":"let rec listReverse l = match l with []->[] | h::t -> let x = [h] in (listReverse (t))@x","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> let x = [h] in (listReverse t) @ x;;\n","type":"","out":""},{"in":"let _ = listReverse [1; 2; 3; 4]","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> let x = [h] in (listReverse t) @ x;;\n\nlet _ = listReverse [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> let x = [h] in (listReverse t) @ x;;\n\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n","type":"","out":""},{"in":"let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n","type":"","out":""},{"in":"let palindrome w = let x = listReverse (explode w) in if(x=(explode (w))) then true else false","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> let x = [h] in (listReverse t) @ x;;\n\nlet palindrome w =\n  let x = listReverse (explode w) in if x = (explode w) then true else false;;\n","type":"","out":""},{"in":"let _ = palindrome \"malayalam\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> let x = [h] in (listReverse t) @ x;;\n\nlet palindrome w =\n  let x = listReverse (explode w) in if x = (explode w) then true else false;;\n\nlet _ = palindrome \"malayalam\";;\n","type":"","out":""},{"in":"let _ = palindrome \"myxomatosis\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> let x = [h] in (listReverse t) @ x;;\n\nlet palindrome w =\n  let x = listReverse (explode w) in if x = (explode w) then true else false;;\n\nlet _ = palindrome \"myxomatosis\";;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key        = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130  = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":7944},"type":"eval"},"cursor":4925,"time":1.396641611102479e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (b);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\nlet rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x));;\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet additivePersistence n = let x = (digits n) in if (abs n)<10 then 0 else persistenceHelper x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec adder a = if (sumList a)<10 then (sumList a) else adder (digits (sumList a))\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\n*)\nlet digitalRoot n = let x = (digits n) in if (abs n)<10 then n else adder x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec listReverse l = match l with []->[] | h::t -> let x = [h] in (listReverse (t))@x;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet palindrome w = let x = listReverse (explode w) in if(x=(explode (w))) then true else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (b)","min":"\nlet rec sumList xs = match xs with | [] -> 0 | f::b -> f + (sumList b);;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | f::b -> f + (sumList b);;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | f::b -> f + (sumList b);;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | f::b -> f + (sumList b);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x)","min":"\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x))","min":"\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | f::b -> f + (sumList b);;\n\nlet rec persistenceHelper q =\n  let x = sumList q in\n  if x < 10 then 1 else 1 + (persistenceHelper (digits x));;\n","type":"","out":""},{"in":"let additivePersistence n = let x = (digits n) in if (abs n)<10 then 0 else persistenceHelper x","min":"\nlet rec sumList xs = match xs with | [] -> 0 | f::b -> f + (sumList b);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec persistenceHelper q =\n  let x = sumList q in\n  if x < 10 then 1 else 1 + (persistenceHelper (digits x));;\n\nlet additivePersistence n =\n  let x = digits n in if (abs n) < 10 then 0 else persistenceHelper x;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9876","min":"\nlet rec sumList xs = match xs with | [] -> 0 | f::b -> f + (sumList b);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec persistenceHelper q =\n  let x = sumList q in\n  if x < 10 then 1 else 1 + (persistenceHelper (digits x));;\n\nlet additivePersistence n =\n  let x = digits n in if (abs n) < 10 then 0 else persistenceHelper x;;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""},{"in":"let rec adder a = if (sumList a)<10 then (sumList a) else adder (digits (sumList a))","min":"\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | f::b -> f + (sumList b);;\n\nlet rec adder a =\n  if (sumList a) < 10 then sumList a else adder (digits (sumList a));;\n","type":"","out":""},{"in":"let digitalRoot n = let x = (digits n) in if (abs n)<10 then n else adder x","min":"\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n\nlet rec sumList xs = match xs with | [] -> 0 | f::b -> f + (sumList b);;\n\nlet rec adder a =\n  if (sumList a) < 10 then sumList a else adder (digits (sumList a));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet digitalRoot n = let x = digits n in if (abs n) < 10 then n else adder x;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9876","min":"\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in (digitsOfInt (n / 10)) @ x);;\n\nlet rec sumList xs = match xs with | [] -> 0 | f::b -> f + (sumList b);;\n\nlet rec adder a =\n  if (sumList a) < 10 then sumList a else adder (digits (sumList a));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet digitalRoot n = let x = digits n in if (abs n) < 10 then n else adder x;;\n\nlet _ = digitalRoot 9876;;\n","type":"","out":""},{"in":"let rec listReverse l = match l with []->[] | h::t -> let x = [h] in (listReverse (t))@x","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> let x = [h] in (listReverse t) @ x;;\n","type":"","out":""},{"in":"let _ = listReverse [1; 2; 3; 4]","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> let x = [h] in (listReverse t) @ x;;\n\nlet _ = listReverse [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> let x = [h] in (listReverse t) @ x;;\n\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n","type":"","out":""},{"in":"let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n","type":"","out":""},{"in":"let palindrome w = let x = listReverse (explode w) in if(x=(explode (w))) then true else false","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> let x = [h] in (listReverse t) @ x;;\n\nlet palindrome w =\n  let x = listReverse (explode w) in if x = (explode w) then true else false;;\n","type":"","out":""},{"in":"let _ = palindrome \"malayalam\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> let x = [h] in (listReverse t) @ x;;\n\nlet palindrome w =\n  let x = listReverse (explode w) in if x = (explode w) then true else false;;\n\nlet _ = palindrome \"malayalam\";;\n","type":"","out":""},{"in":"let _ = palindrome \"myxomatosis\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> let x = [h] in (listReverse t) @ x;;\n\nlet palindrome w =\n  let x = listReverse (explode w) in if x = (explode w) then true else false;;\n\nlet _ = palindrome \"myxomatosis\";;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key        = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130  = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":7944},"type":"eval"},"cursor":4925,"time":1.396641830717694e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (b);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\nlet rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x));;\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet additivePersistence n = let x = (digits n) in if (abs n)<10 then 0 else persistenceHelper x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec adder a = if (sumList a)<10 then (sumList a) else adder (digits (sumList a))\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\n*)\nlet digitalRoot n = let x = (digits n) in if (abs n)<10 then n else adder x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec listReverse l = match l with []->[] | h::t -> let x = [h] in (listReverse (t))@x;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet palindrome w = let x = listReverse (explode w) in if(x=(explode (w))) then true else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec @ list1 list2 = match list1 with [] -> list2 | a::b -> a::(@ b list2)","min":"","type":"syntax","out":"Characters 8-9:\n  let rec @ list1 list2 = match list1 with [] -> list2 | a::b -> a::(@ b list2);;\n          ^\nError: Syntax error\n"}],"event":{"region":{"start":0,"stop":196},"type":"eval"},"cursor":198,"time":1.397010819765166e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec @ list1 list2 = match list1 with [] -> list2 | a::b -> a::(@ b list2);;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (b);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\nlet rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x));;\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet additivePersistence n = let x = (digits n) in if (abs n)<10 then 0 else persistenceHelper x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec adder a = if (sumList a)<10 then (sumList a) else adder (digits (sumList a))\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\n*)\nlet digitalRoot n = let x = (digits n) in if (abs n)<10 then n else adder x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec listReverse l = match l with []->[] | h::t -> let x = [h] in (listReverse (t))@x;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet palindrome w = let x = listReverse (explode w) in if(x=(explode (w))) then true else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec append list1 list2 = match list1 with [] -> list2 | a::b -> a::(@ b list2)","min":"","type":"syntax","out":"Characters 71-72:\n  let rec append list1 list2 = match list1 with [] -> list2 | a::b -> a::(@ b list2);;\n                                                                         ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n"}],"event":{"region":{"start":0,"stop":201},"type":"eval"},"cursor":203,"time":1.397010846587553e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec append list1 list2 = match list1 with [] -> list2 | a::b -> a::(@ b list2);;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (b);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\nlet rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x));;\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet additivePersistence n = let x = (digits n) in if (abs n)<10 then 0 else persistenceHelper x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec adder a = if (sumList a)<10 then (sumList a) else adder (digits (sumList a))\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\n*)\nlet digitalRoot n = let x = (digits n) in if (abs n)<10 then n else adder x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec listReverse l = match l with []->[] | h::t -> let x = [h] in (listReverse (t))@x;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet palindrome w = let x = listReverse (explode w) in if(x=(explode (w))) then true else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec append list1 list2 = match list1 with [] -> list2 | a::b -> a::(append b list2)","min":"\nlet rec append list1 list2 =\n  match list1 with | [] -> list2 | a::b -> a :: (append b list2);;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":206},"type":"eval"},"cursor":197,"time":1.397010869090668e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec append list1 list2 = match list1 with [] -> list2 | a::b -> a::(append b list2);;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (b);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in (digitsOfInt (n/10))@x);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\nlet rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x));;\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet additivePersistence n = let x = (digits n) in if (abs n)<10 then 0 else persistenceHelper x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec adder a = if (sumList a)<10 then (sumList a) else adder (digits (sumList a))\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\n*)\nlet digitalRoot n = let x = (digits n) in if (abs n)<10 then n else adder x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec listReverse l = match l with []->[] | h::t -> let x = [h] in (listReverse (t))@x;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet palindrome w = let x = listReverse (explode w) in if(x=(explode (w))) then true else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (b)","min":"\nlet rec sumList xs = match xs with | [] -> 0 | f::b -> f + (sumList b);;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | f::b -> f + (sumList b);;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | f::b -> f + (sumList b);;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | f::b -> f + (sumList b);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in append (digitsOfInt (n/10)) x)","min":"\nlet rec append list1 list2 =\n  match list1 with | [] -> list2 | a::b -> a :: (append b list2);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in append (digitsOfInt (n / 10)) x);;\n","type":"","out":""}],"event":{"region":{"start":206,"stop":966},"type":"eval"},"cursor":968,"time":1.397011051729481e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec append list1 list2 = match list1 with [] -> list2 | a::b -> a::(append b list2);;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (b);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in append (digitsOfInt (n/10)) x);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\nlet rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x));;\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet additivePersistence n = let x = (digits n) in if (abs n)<10 then 0 else persistenceHelper x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec adder a = if (sumList a)<10 then (sumList a) else adder (digits (sumList a))\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\n*)\nlet digitalRoot n = let x = (digits n) in if (abs n)<10 then n else adder x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec listReverse l = match l with []->[] | h::t -> let x = [h] in (listReverse (t))@x;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet palindrome w = let x = listReverse (explode w) in if(x=(explode (w))) then true else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = digitsOfInt 3124","min":"\nlet rec append list1 list2 =\n  match list1 with | [] -> list2 | a::b -> a :: (append b list2);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in append (digitsOfInt (n / 10)) x);;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec append list1 list2 =\n  match list1 with | [] -> list2 | a::b -> a :: (append b list2);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in append (digitsOfInt (n / 10)) x);;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""}],"event":{"region":{"start":966,"stop":1086},"type":"eval"},"cursor":1086,"time":1.397011059831863e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec append list1 list2 = match list1 with [] -> list2 | a::b -> a::(append b list2);;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (b);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in append (digitsOfInt (n/10)) x);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\nlet rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x));;\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet additivePersistence n = let x = (digits n) in if (abs n)<10 then 0 else persistenceHelper x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec adder a = if (sumList a)<10 then (sumList a) else adder (digits (sumList a))\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\n*)\nlet digitalRoot n = let x = (digits n) in if (abs n)<10 then n else adder x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec listReverse l = match l with []->[] | h::t -> let x = [h] in (listReverse (t))@x;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet palindrome w = let x = listReverse (explode w) in if(x=(explode (w))) then true else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec append list1 list2 =\n  match list1 with | [] -> list2 | a::b -> a :: (append b list2);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in append (digitsOfInt (n / 10)) x);;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x))","min":"\nlet rec append list1 list2 =\n  match list1 with | [] -> list2 | a::b -> a :: (append b list2);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in append (digitsOfInt (n / 10)) x);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | f::b -> f + (sumList b);;\n\nlet rec persistenceHelper q =\n  let x = sumList q in\n  if x < 10 then 1 else 1 + (persistenceHelper (digits x));;\n","type":"","out":""},{"in":"let additivePersistence n = let x = (digits n) in if (abs n)<10 then 0 else persistenceHelper x","min":"\nlet rec sumList xs = match xs with | [] -> 0 | f::b -> f + (sumList b);;\n\nlet rec append list1 list2 =\n  match list1 with | [] -> list2 | a::b -> a :: (append b list2);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in append (digitsOfInt (n / 10)) x);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec persistenceHelper q =\n  let x = sumList q in\n  if x < 10 then 1 else 1 + (persistenceHelper (digits x));;\n\nlet additivePersistence n =\n  let x = digits n in if (abs n) < 10 then 0 else persistenceHelper x;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9876","min":"\nlet rec sumList xs = match xs with | [] -> 0 | f::b -> f + (sumList b);;\n\nlet rec append list1 list2 =\n  match list1 with | [] -> list2 | a::b -> a :: (append b list2);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in append (digitsOfInt (n / 10)) x);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec persistenceHelper q =\n  let x = sumList q in\n  if x < 10 then 1 else 1 + (persistenceHelper (digits x));;\n\nlet additivePersistence n =\n  let x = digits n in if (abs n) < 10 then 0 else persistenceHelper x;;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""},{"in":"let rec adder a = if (sumList a)<10 then (sumList a) else adder (digits (sumList a))","min":"\nlet rec append list1 list2 =\n  match list1 with | [] -> list2 | a::b -> a :: (append b list2);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in append (digitsOfInt (n / 10)) x);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | f::b -> f + (sumList b);;\n\nlet rec adder a =\n  if (sumList a) < 10 then sumList a else adder (digits (sumList a));;\n","type":"","out":""},{"in":"let digitalRoot n = let x = (digits n) in if (abs n)<10 then n else adder x","min":"\nlet rec append list1 list2 =\n  match list1 with | [] -> list2 | a::b -> a :: (append b list2);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in append (digitsOfInt (n / 10)) x);;\n\nlet rec sumList xs = match xs with | [] -> 0 | f::b -> f + (sumList b);;\n\nlet rec adder a =\n  if (sumList a) < 10 then sumList a else adder (digits (sumList a));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet digitalRoot n = let x = digits n in if (abs n) < 10 then n else adder x;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9876","min":"\nlet rec append list1 list2 =\n  match list1 with | [] -> list2 | a::b -> a :: (append b list2);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in append (digitsOfInt (n / 10)) x);;\n\nlet rec sumList xs = match xs with | [] -> 0 | f::b -> f + (sumList b);;\n\nlet rec adder a =\n  if (sumList a) < 10 then sumList a else adder (digits (sumList a));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet digitalRoot n = let x = digits n in if (abs n) < 10 then n else adder x;;\n\nlet _ = digitalRoot 9876;;\n","type":"","out":""},{"in":"let rec listReverse l = match l with []->[] | h::t -> let x = [h] in append (listReverse (t)) x","min":"\nlet rec append list1 list2 =\n  match list1 with | [] -> list2 | a::b -> a :: (append b list2);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> let x = [h] in append (listReverse t) x;;\n","type":"","out":""}],"event":{"region":{"start":1086,"stop":4082},"type":"eval"},"cursor":4084,"time":1.397011172066e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec append list1 list2 = match list1 with [] -> list2 | a::b -> a::(append b list2);;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (b);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in append (digitsOfInt (n/10)) x);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\nlet rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x));;\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet additivePersistence n = let x = (digits n) in if (abs n)<10 then 0 else persistenceHelper x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec adder a = if (sumList a)<10 then (sumList a) else adder (digits (sumList a))\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\n*)\nlet digitalRoot n = let x = (digits n) in if (abs n)<10 then n else adder x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec listReverse l = match l with []->[] | h::t -> let x = [h] in append (listReverse (t)) x;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet palindrome w = let x = listReverse (explode w) in if(x=(explode (w))) then true else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = listReverse [1; 2; 3; 4]","min":"\nlet rec append list1 list2 =\n  match list1 with | [] -> list2 | a::b -> a :: (append b list2);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> let x = [h] in append (listReverse t) x;;\n\nlet _ = listReverse [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]","min":"\nlet rec append list1 list2 =\n  match list1 with | [] -> list2 | a::b -> a :: (append b list2);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> let x = [h] in append (listReverse t) x;;\n\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n","type":"","out":""}],"event":{"region":{"start":4082,"stop":4222},"type":"eval"},"cursor":4223,"time":1.397011176268347e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec append list1 list2 = match list1 with [] -> list2 | a::b -> a::(append b list2);;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (b);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in append (digitsOfInt (n/10)) x);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\nlet rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x));;\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet additivePersistence n = let x = (digits n) in if (abs n)<10 then 0 else persistenceHelper x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec adder a = if (sumList a)<10 then (sumList a) else adder (digits (sumList a))\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\n*)\nlet digitalRoot n = let x = (digits n) in if (abs n)<10 then n else adder x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec listReverse l = match l with []->[] | h::t -> let x = [h] in append (listReverse (t)) x;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet palindrome w = let x = listReverse (explode w) in if(x=(explode (w))) then true else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec append list1 list2 = match list1 with [] -> list2 | a::b -> a::(append b list2)","min":"\nlet rec append list1 list2 =\n  match list1 with | [] -> list2 | a::b -> a :: (append b list2);;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":250},"type":"eval"},"cursor":253,"time":1.397011360323867e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec append list1 list2 = match list1 with [] -> list2 | a::b -> a::(append b list2);;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (b);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in append (digitsOfInt (n/10)) x);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\nlet rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x));;\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet additivePersistence n = let x = (digits n) in if (abs n)<10 then 0 else persistenceHelper x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec adder a = if (sumList a)<10 then (sumList a) else adder (digits (sumList a))\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\n*)\nlet digitalRoot n = let x = (digits n) in if (abs n)<10 then n else adder x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec listReverse l = match l with []->[] | h::t -> let x = [h] in append (listReverse (t)) x;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet palindrome w = let x = listReverse (explode w) in if(x=(explode (w))) then true else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec append list1 list2 = match list1 with [] -> list2 | a::b -> a::(append b list2)","min":"\nlet rec append list1 list2 =\n  match list1 with | [] -> list2 | a::b -> a :: (append b list2);;\n","type":"","out":""}],"event":{"region":{"start":163,"stop":250},"type":"eval"},"cursor":254,"time":1.397011457069976e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec append list1 list2 = match list1 with [] -> list2 | a::b -> a::(append b list2);;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (b);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in append (digitsOfInt (n/10)) x);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\nlet rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x));;\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet additivePersistence n = let x = (digits n) in if (abs n)<10 then 0 else persistenceHelper x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec adder a = if (sumList a)<10 then (sumList a) else adder (digits (sumList a))\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\n*)\nlet digitalRoot n = let x = (digits n) in if (abs n)<10 then n else adder x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec listReverse l = match l with []->[] | h::t -> let x = [h] in append (listReverse (t)) x;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet palindrome w = let x = listReverse (explode w) in if(x=(explode (w))) then true else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec append list1 list2 = match list1 with [] -> list2 | a::b -> a::(append b list2)","min":"\nlet rec append list1 list2 =\n  match list1 with | [] -> list2 | a::b -> a :: (append b list2);;\n","type":"","out":""},{"in":"let rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (b)","min":"\nlet rec sumList xs = match xs with | [] -> 0 | f::b -> f + (sumList b);;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | f::b -> f + (sumList b);;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | f::b -> f + (sumList b);;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | f::b -> f + (sumList b);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in append (digitsOfInt (n/10)) x)","min":"\nlet rec append list1 list2 =\n  match list1 with | [] -> list2 | a::b -> a :: (append b list2);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in append (digitsOfInt (n / 10)) x);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec append list1 list2 =\n  match list1 with | [] -> list2 | a::b -> a :: (append b list2);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in append (digitsOfInt (n / 10)) x);;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec append list1 list2 =\n  match list1 with | [] -> list2 | a::b -> a :: (append b list2);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in append (digitsOfInt (n / 10)) x);;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec append list1 list2 =\n  match list1 with | [] -> list2 | a::b -> a :: (append b list2);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in append (digitsOfInt (n / 10)) x);;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x))","min":"\nlet rec append list1 list2 =\n  match list1 with | [] -> list2 | a::b -> a :: (append b list2);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in append (digitsOfInt (n / 10)) x);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | f::b -> f + (sumList b);;\n\nlet rec persistenceHelper q =\n  let x = sumList q in\n  if x < 10 then 1 else 1 + (persistenceHelper (digits x));;\n","type":"","out":""},{"in":"let additivePersistence n = let x = (digits n) in if (abs n)<10 then 0 else persistenceHelper x","min":"\nlet rec sumList xs = match xs with | [] -> 0 | f::b -> f + (sumList b);;\n\nlet rec append list1 list2 =\n  match list1 with | [] -> list2 | a::b -> a :: (append b list2);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in append (digitsOfInt (n / 10)) x);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec persistenceHelper q =\n  let x = sumList q in\n  if x < 10 then 1 else 1 + (persistenceHelper (digits x));;\n\nlet additivePersistence n =\n  let x = digits n in if (abs n) < 10 then 0 else persistenceHelper x;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9876","min":"\nlet rec sumList xs = match xs with | [] -> 0 | f::b -> f + (sumList b);;\n\nlet rec append list1 list2 =\n  match list1 with | [] -> list2 | a::b -> a :: (append b list2);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in append (digitsOfInt (n / 10)) x);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec persistenceHelper q =\n  let x = sumList q in\n  if x < 10 then 1 else 1 + (persistenceHelper (digits x));;\n\nlet additivePersistence n =\n  let x = digits n in if (abs n) < 10 then 0 else persistenceHelper x;;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""},{"in":"let rec adder a = if (sumList a)<10 then (sumList a) else adder (digits (sumList a))","min":"\nlet rec append list1 list2 =\n  match list1 with | [] -> list2 | a::b -> a :: (append b list2);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in append (digitsOfInt (n / 10)) x);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | f::b -> f + (sumList b);;\n\nlet rec adder a =\n  if (sumList a) < 10 then sumList a else adder (digits (sumList a));;\n","type":"","out":""},{"in":"let digitalRoot n = let x = (digits n) in if (abs n)<10 then n else adder x","min":"\nlet rec append list1 list2 =\n  match list1 with | [] -> list2 | a::b -> a :: (append b list2);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in append (digitsOfInt (n / 10)) x);;\n\nlet rec sumList xs = match xs with | [] -> 0 | f::b -> f + (sumList b);;\n\nlet rec adder a =\n  if (sumList a) < 10 then sumList a else adder (digits (sumList a));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet digitalRoot n = let x = digits n in if (abs n) < 10 then n else adder x;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9876","min":"\nlet rec append list1 list2 =\n  match list1 with | [] -> list2 | a::b -> a :: (append b list2);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in append (digitsOfInt (n / 10)) x);;\n\nlet rec sumList xs = match xs with | [] -> 0 | f::b -> f + (sumList b);;\n\nlet rec adder a =\n  if (sumList a) < 10 then sumList a else adder (digits (sumList a));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet digitalRoot n = let x = digits n in if (abs n) < 10 then n else adder x;;\n\nlet _ = digitalRoot 9876;;\n","type":"","out":""},{"in":"let rec listReverse l = match l with []->[] | h::t -> let x = [h] in append (listReverse (t)) x","min":"\nlet rec append list1 list2 =\n  match list1 with | [] -> list2 | a::b -> a :: (append b list2);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> let x = [h] in append (listReverse t) x;;\n","type":"","out":""},{"in":"let _ = listReverse [1; 2; 3; 4]","min":"\nlet rec append list1 list2 =\n  match list1 with | [] -> list2 | a::b -> a :: (append b list2);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> let x = [h] in append (listReverse t) x;;\n\nlet _ = listReverse [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]","min":"\nlet rec append list1 list2 =\n  match list1 with | [] -> list2 | a::b -> a :: (append b list2);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> let x = [h] in append (listReverse t) x;;\n\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n","type":"","out":""},{"in":"let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n","type":"","out":""},{"in":"let palindrome w = let x = listReverse (explode w) in if(x=(explode (w))) then true else false","min":"\nlet rec append list1 list2 =\n  match list1 with | [] -> list2 | a::b -> a :: (append b list2);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> let x = [h] in append (listReverse t) x;;\n\nlet palindrome w =\n  let x = listReverse (explode w) in if x = (explode w) then true else false;;\n","type":"","out":""},{"in":"let _ = palindrome \"malayalam\"","min":"\nlet rec append list1 list2 =\n  match list1 with | [] -> list2 | a::b -> a :: (append b list2);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> let x = [h] in append (listReverse t) x;;\n\nlet palindrome w =\n  let x = listReverse (explode w) in if x = (explode w) then true else false;;\n\nlet _ = palindrome \"malayalam\";;\n","type":"","out":""},{"in":"let _ = palindrome \"myxomatosis\"","min":"\nlet rec append list1 list2 =\n  match list1 with | [] -> list2 | a::b -> a :: (append b list2);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> let x = [h] in append (listReverse t) x;;\n\nlet palindrome w =\n  let x = listReverse (explode w) in if x = (explode w) then true else false;;\n\nlet _ = palindrome \"myxomatosis\";;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key        = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130  = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":8166},"type":"eval"},"cursor":254,"time":1.397011463654802e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec append list1 list2 = match list1 with [] -> list2 | a::b -> a::(append b list2);;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (b);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in append (digitsOfInt (n/10)) x);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\nlet rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x));;\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet additivePersistence n = let x = (digits n) in if (abs n)<10 then 0 else persistenceHelper x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec adder a = if (sumList a)<10 then (sumList a) else adder (digits (sumList a))\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\n*)\nlet digitalRoot n = let x = (digits n) in if (abs n)<10 then n else adder x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec listReverse l = match l with []->[] | h::t -> let x = [h] in append (listReverse (t)) x;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet palindrome w = let x = listReverse (explode w) in if(x=(explode (w))) then true else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec append list1 list2 = match list1 with [] -> list2 | a::b -> a::(append b list2)","min":"\nlet rec append list1 list2 =\n  match list1 with | [] -> list2 | a::b -> a :: (append b list2);;\n","type":"","out":""},{"in":"let rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (b)","min":"\nlet rec sumList xs = match xs with | [] -> 0 | f::b -> f + (sumList b);;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | f::b -> f + (sumList b);;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | f::b -> f + (sumList b);;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | f::b -> f + (sumList b);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in append (digitsOfInt (n/10)) x)","min":"\nlet rec append list1 list2 =\n  match list1 with | [] -> list2 | a::b -> a :: (append b list2);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in append (digitsOfInt (n / 10)) x);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec append list1 list2 =\n  match list1 with | [] -> list2 | a::b -> a :: (append b list2);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in append (digitsOfInt (n / 10)) x);;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec append list1 list2 =\n  match list1 with | [] -> list2 | a::b -> a :: (append b list2);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in append (digitsOfInt (n / 10)) x);;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec append list1 list2 =\n  match list1 with | [] -> list2 | a::b -> a :: (append b list2);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in append (digitsOfInt (n / 10)) x);;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x))","min":"\nlet rec append list1 list2 =\n  match list1 with | [] -> list2 | a::b -> a :: (append b list2);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in append (digitsOfInt (n / 10)) x);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | f::b -> f + (sumList b);;\n\nlet rec persistenceHelper q =\n  let x = sumList q in\n  if x < 10 then 1 else 1 + (persistenceHelper (digits x));;\n","type":"","out":""},{"in":"let additivePersistence n = let x = (digits n) in if (abs n)<10 then 0 else persistenceHelper x","min":"\nlet rec sumList xs = match xs with | [] -> 0 | f::b -> f + (sumList b);;\n\nlet rec append list1 list2 =\n  match list1 with | [] -> list2 | a::b -> a :: (append b list2);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in append (digitsOfInt (n / 10)) x);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec persistenceHelper q =\n  let x = sumList q in\n  if x < 10 then 1 else 1 + (persistenceHelper (digits x));;\n\nlet additivePersistence n =\n  let x = digits n in if (abs n) < 10 then 0 else persistenceHelper x;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9876","min":"\nlet rec sumList xs = match xs with | [] -> 0 | f::b -> f + (sumList b);;\n\nlet rec append list1 list2 =\n  match list1 with | [] -> list2 | a::b -> a :: (append b list2);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in append (digitsOfInt (n / 10)) x);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec persistenceHelper q =\n  let x = sumList q in\n  if x < 10 then 1 else 1 + (persistenceHelper (digits x));;\n\nlet additivePersistence n =\n  let x = digits n in if (abs n) < 10 then 0 else persistenceHelper x;;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""},{"in":"let rec adder a = if (sumList a)<10 then (sumList a) else adder (digits (sumList a))","min":"\nlet rec append list1 list2 =\n  match list1 with | [] -> list2 | a::b -> a :: (append b list2);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in append (digitsOfInt (n / 10)) x);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | f::b -> f + (sumList b);;\n\nlet rec adder a =\n  if (sumList a) < 10 then sumList a else adder (digits (sumList a));;\n","type":"","out":""},{"in":"let digitalRoot n = let x = (digits n) in if (abs n)<10 then n else adder x","min":"\nlet rec append list1 list2 =\n  match list1 with | [] -> list2 | a::b -> a :: (append b list2);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in append (digitsOfInt (n / 10)) x);;\n\nlet rec sumList xs = match xs with | [] -> 0 | f::b -> f + (sumList b);;\n\nlet rec adder a =\n  if (sumList a) < 10 then sumList a else adder (digits (sumList a));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet digitalRoot n = let x = digits n in if (abs n) < 10 then n else adder x;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9876","min":"\nlet rec append list1 list2 =\n  match list1 with | [] -> list2 | a::b -> a :: (append b list2);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let x = [n mod 10] in append (digitsOfInt (n / 10)) x);;\n\nlet rec sumList xs = match xs with | [] -> 0 | f::b -> f + (sumList b);;\n\nlet rec adder a =\n  if (sumList a) < 10 then sumList a else adder (digits (sumList a));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet digitalRoot n = let x = digits n in if (abs n) < 10 then n else adder x;;\n\nlet _ = digitalRoot 9876;;\n","type":"","out":""},{"in":"let rec listReverse l = match l with []->[] | h::t -> let x = [h] in append (listReverse (t)) x","min":"\nlet rec append list1 list2 =\n  match list1 with | [] -> list2 | a::b -> a :: (append b list2);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> let x = [h] in append (listReverse t) x;;\n","type":"","out":""},{"in":"let _ = listReverse [1; 2; 3; 4]","min":"\nlet rec append list1 list2 =\n  match list1 with | [] -> list2 | a::b -> a :: (append b list2);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> let x = [h] in append (listReverse t) x;;\n\nlet _ = listReverse [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]","min":"\nlet rec append list1 list2 =\n  match list1 with | [] -> list2 | a::b -> a :: (append b list2);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> let x = [h] in append (listReverse t) x;;\n\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n","type":"","out":""},{"in":"let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n","type":"","out":""},{"in":"let palindrome w = let x = listReverse (explode w) in if(x=(explode (w))) then true else false","min":"\nlet rec append list1 list2 =\n  match list1 with | [] -> list2 | a::b -> a :: (append b list2);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> let x = [h] in append (listReverse t) x;;\n\nlet palindrome w =\n  let x = listReverse (explode w) in if x = (explode w) then true else false;;\n","type":"","out":""},{"in":"let _ = palindrome \"malayalam\"","min":"\nlet rec append list1 list2 =\n  match list1 with | [] -> list2 | a::b -> a :: (append b list2);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> let x = [h] in append (listReverse t) x;;\n\nlet palindrome w =\n  let x = listReverse (explode w) in if x = (explode w) then true else false;;\n\nlet _ = palindrome \"malayalam\";;\n","type":"","out":""},{"in":"let _ = palindrome \"myxomatosis\"","min":"\nlet rec append list1 list2 =\n  match list1 with | [] -> list2 | a::b -> a :: (append b list2);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> let x = [h] in append (listReverse t) x;;\n\nlet palindrome w =\n  let x = listReverse (explode w) in if x = (explode w) then true else false;;\n\nlet _ = palindrome \"myxomatosis\";;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key        = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130  = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":8166},"type":"eval"},"cursor":0,"time":1.397460043259436e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec append list1 list2 = match list1 with [] -> list2 | a::b -> a::(append b list2);;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (b);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = if n<0 then [] else(if n<10 then [n] else let x = (n mod 10)::[] in append (digitsOfInt (n/10)) x);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\nlet rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x));;\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet additivePersistence n = let x = (digits n) in if (abs n)<10 then 0 else persistenceHelper x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec adder a = if (sumList a)<10 then (sumList a) else adder (digits (sumList a))\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXX\n*)\nlet digitalRoot n = let x = (digits n) in if (abs n)<10 then n else adder x\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec listReverse l = match l with []->[] | h::t -> let x = [h] in append (listReverse (t)) x;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet palindrome w = let x = listReverse (explode w) in if(x=(explode (w))) then true else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
