{"ocaml":[],"event":{"region":{"start":0,"stop":83},"type":"eval"},"cursor":83,"time":1.396992520557839e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = failwith \"TBD:sumList\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = failwith \"TBD:sumList\"","min":"\nlet rec sumList xs = failwith \"TBD:sumList\";;\n","type":"","out":""},{"in":"let rec digitsOfInt n = failwith \"TBD:digitsOfInt\"","min":"\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\";;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\";;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec additivePersistence n = failwith \"TBD\"","min":"\nlet rec additivePersistence n = failwith \"TBD\";;\n","type":"","out":""},{"in":"let rec digitalRoot n = failwith \"TBD\"","min":"\nlet rec digitalRoot n = failwith \"TBD\";;\n","type":"","out":""},{"in":"let rec listReverse l = failwith \"TBD\"","min":"\nlet rec listReverse l = failwith \"TBD\";;\n","type":"","out":""},{"in":"let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n","type":"","out":""},{"in":"let palindrome w = failwith \"TBD\"","min":"\nlet palindrome w = failwith \"TBD\";;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key        = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130  = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":5548},"type":"eval"},"cursor":83,"time":1.396992524212601e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = failwith \"TBD:sumList\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = match xs with\n| []     -> 0 \n| hd::tl -> hd + sumList tl","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec digithelper n l=\nlet x = n/10 in\nlet y = n mod 10 in\nif x <= 0\nthen y :: l\nelse digithelper x (y :: l)","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x <= 0 then y :: l else digithelper x (y :: l);;\n","type":"","out":""},{"in":"let digitsOfInt n =\nif n <= 0\nthen []\nelse \ndigithelper n []","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x <= 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x <= 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x <= 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":796},"type":"eval"},"cursor":800,"time":1.397515254484161e9,"body":"(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []     -> 0 \n  | hd::tl -> hd + sumList tl\n;;\n\nlet _ = sumList [1; 2; 3; 4];;\nlet _ = sumList [1; -2; 3; 5];;\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digithelper n l=\n  let x = n/10 in\n  let y = n mod 10 in\n    if x <= 0\n    then y :: l\n    else digithelper x (y :: l)\n;;\n\nlet digitsOfInt n =\n  if n <= 0\n  then []\n  else \n    digithelper n []\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 352663;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet listReverse l = \n  let rec helperFun l z = match l with\n    | [] -> z\n    | hd :: tl -> helperFun tl (hd :: z)\n  in\n    helperFun l []\n;;\n\nlet _ = listReverse [1; 2; 3; 4];;\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet palindrome w = \n  let z = explode w in\n  let y = listReverse z in\n    if z = y\n    then true\n    else false\n;;\n\nlet _ = palindrome \"malayalam\";;\nlet _ = palindrome \"myxomatosis\";;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = match xs with\n| []     -> 0 \n| hd::tl -> hd + sumList tl","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec digithelper n l=\nlet x = n/10 in\nlet y = n mod 10 in\nif x <= 0\nthen y :: l\nelse digithelper x (y :: l)","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x <= 0 then y :: l else digithelper x (y :: l);;\n","type":"","out":""},{"in":"let digitsOfInt n =\nif n <= 0\nthen []\nelse \ndigithelper n []","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x <= 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x <= 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x <= 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 0","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x <= 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 0;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 1","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x <= 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 1;;\n","type":"","out":""},{"in":"let _ = digitsOfInt -1234","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x <= 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt - 1234;;\n","type":"type","out":"Characters 8-19:\n  let _ = digitsOfInt -1234;;\n          ^^^^^^^^^^^\nError: This expression has type int -> int list\n       but an expression was expected of type int\n"}],"event":{"region":{"start":0,"stop":872},"type":"eval"},"cursor":874,"time":1.397515331867077e9,"body":"(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []     -> 0 \n  | hd::tl -> hd + sumList tl\n;;\n\nlet _ = sumList [1; 2; 3; 4];;\nlet _ = sumList [1; -2; 3; 5];;\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digithelper n l=\n  let x = n/10 in\n  let y = n mod 10 in\n    if x <= 0\n    then y :: l\n    else digithelper x (y :: l)\n;;\n\nlet digitsOfInt n =\n  if n <= 0\n  then []\n  else \n    digithelper n []\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 352663;;\nlet _ = digitsOfInt 0;;\nlet _ = digitsOfInt 1;;\nlet _ = digitsOfInt -1234;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet listReverse l = \n  let rec helperFun l z = match l with\n    | [] -> z\n    | hd :: tl -> helperFun tl (hd :: z)\n  in\n    helperFun l []\n;;\n\nlet _ = listReverse [1; 2; 3; 4];;\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet palindrome w = \n  let z = explode w in\n  let y = listReverse z in\n    if z = y\n    then true\n    else false\n;;\n\nlet _ = palindrome \"malayalam\";;\nlet _ = palindrome \"myxomatosis\";;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = match xs with\n| []     -> 0 \n| hd::tl -> hd + sumList tl","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec digithelper n l=\nlet x = n/10 in\nlet y = n mod 10 in\nif x <= 0\nthen y :: l\nelse digithelper x (y :: l)","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x <= 0 then y :: l else digithelper x (y :: l);;\n","type":"","out":""},{"in":"let digitsOfInt n =\nif n <= 0\nthen []\nelse \ndigithelper n []","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x <= 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x <= 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x <= 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 0","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x <= 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 0;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 1","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x <= 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 1;;\n","type":"","out":""},{"in":"let _ = digitsOfInt -1","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x <= 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt - 1;;\n","type":"type","out":"Characters 8-19:\n  let _ = digitsOfInt -1;;\n          ^^^^^^^^^^^\nError: This expression has type int -> int list\n       but an expression was expected of type int\n"}],"event":{"region":{"start":0,"stop":869},"type":"eval"},"cursor":871,"time":1.397515377125768e9,"body":"(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []     -> 0 \n  | hd::tl -> hd + sumList tl\n;;\n\nlet _ = sumList [1; 2; 3; 4];;\nlet _ = sumList [1; -2; 3; 5];;\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digithelper n l=\n  let x = n/10 in\n  let y = n mod 10 in\n    if x <= 0\n    then y :: l\n    else digithelper x (y :: l)\n;;\n\nlet digitsOfInt n =\n  if n <= 0\n  then []\n  else \n    digithelper n []\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 352663;;\nlet _ = digitsOfInt 0;;\nlet _ = digitsOfInt 1;;\nlet _ = digitsOfInt -1;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet listReverse l = \n  let rec helperFun l z = match l with\n    | [] -> z\n    | hd :: tl -> helperFun tl (hd :: z)\n  in\n    helperFun l []\n;;\n\nlet _ = listReverse [1; 2; 3; 4];;\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet palindrome w = \n  let z = explode w in\n  let y = listReverse z in\n    if z = y\n    then true\n    else false\n;;\n\nlet _ = palindrome \"malayalam\";;\nlet _ = palindrome \"myxomatosis\";;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = digitsOfInt -1","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x <= 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt - 1;;\n","type":"type","out":"Characters 8-19:\n  let _ = digitsOfInt -1;;\n          ^^^^^^^^^^^\nError: This expression has type int -> int list\n       but an expression was expected of type int\n"}],"event":{"region":{"start":844,"stop":869},"type":"eval"},"cursor":871,"time":1.39751546072625e9,"body":"(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []     -> 0 \n  | hd::tl -> hd + sumList tl\n;;\n\nlet _ = sumList [1; 2; 3; 4];;\nlet _ = sumList [1; -2; 3; 5];;\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digithelper n l=\n  let x = n/10 in\n  let y = n mod 10 in\n    if x <= 0\n    then y :: l\n    else digithelper x (y :: l)\n;;\n\nlet digitsOfInt n =\n  if n <= 0\n  then []\n  else \n    digithelper n []\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 352663;;\nlet _ = digitsOfInt 0;;\nlet _ = digitsOfInt 1;;\nlet _ = digitsOfInt -1;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet listReverse l = \n  let rec helperFun l z = match l with\n    | [] -> z\n    | hd :: tl -> helperFun tl (hd :: z)\n  in\n    helperFun l []\n;;\n\nlet _ = listReverse [1; 2; 3; 4];;\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet palindrome w = \n  let z = explode w in\n  let y = listReverse z in\n    if z = y\n    then true\n    else false\n;;\n\nlet _ = palindrome \"malayalam\";;\nlet _ = palindrome \"myxomatosis\";;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = digitsOfInt -1.5","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x <= 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt - 1.5;;\n","type":"type","out":"Characters 8-19:\n  let _ = digitsOfInt -1.5;;\n          ^^^^^^^^^^^\nError: This expression has type int -> int list\n       but an expression was expected of type int\n"}],"event":{"region":{"start":844,"stop":871},"type":"eval"},"cursor":873,"time":1.397515471251167e9,"body":"(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []     -> 0 \n  | hd::tl -> hd + sumList tl\n;;\n\nlet _ = sumList [1; 2; 3; 4];;\nlet _ = sumList [1; -2; 3; 5];;\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digithelper n l=\n  let x = n/10 in\n  let y = n mod 10 in\n    if x <= 0\n    then y :: l\n    else digithelper x (y :: l)\n;;\n\nlet digitsOfInt n =\n  if n <= 0\n  then []\n  else \n    digithelper n []\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 352663;;\nlet _ = digitsOfInt 0;;\nlet _ = digitsOfInt 1;;\nlet _ = digitsOfInt -1.5;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet listReverse l = \n  let rec helperFun l z = match l with\n    | [] -> z\n    | hd :: tl -> helperFun tl (hd :: z)\n  in\n    helperFun l []\n;;\n\nlet _ = listReverse [1; 2; 3; 4];;\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet palindrome w = \n  let z = explode w in\n  let y = listReverse z in\n    if z = y\n    then true\n    else false\n;;\n\nlet _ = palindrome \"malayalam\";;\nlet _ = palindrome \"myxomatosis\";;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = digitsOfInt -1","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x <= 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt - 1;;\n","type":"type","out":"Characters 8-19:\n  let _ = digitsOfInt -1;;\n          ^^^^^^^^^^^\nError: This expression has type int -> int list\n       but an expression was expected of type int\n"}],"event":{"region":{"start":820,"stop":845},"type":"eval"},"cursor":847,"time":1.397515488973936e9,"body":"(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []     -> 0 \n  | hd::tl -> hd + sumList tl\n;;\n\nlet _ = sumList [1; 2; 3; 4];;\nlet _ = sumList [1; -2; 3; 5];;\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digithelper n l=\n  let x = n/10 in\n  let y = n mod 10 in\n    if x <= 0\n    then y :: l\n    else digithelper x (y :: l)\n;;\n\nlet digitsOfInt n =\n  if n <= 0\n  then []\n  else \n    digithelper n []\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 352663;;\nlet _ = digitsOfInt 0;;\nlet _ = digitsOfInt -1;;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet listReverse l = \n  let rec helperFun l z = match l with\n    | [] -> z\n    | hd :: tl -> helperFun tl (hd :: z)\n  in\n    helperFun l []\n;;\n\nlet _ = listReverse [1; 2; 3; 4];;\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet palindrome w = \n  let z = explode w in\n  let y = listReverse z in\n    if z = y\n    then true\n    else false\n;;\n\nlet _ = palindrome \"malayalam\";;\nlet _ = palindrome \"myxomatosis\";;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = digitsOfInt 1","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x <= 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 1;;\n","type":"","out":""}],"event":{"region":{"start":820,"stop":844},"type":"eval"},"cursor":846,"time":1.397515498446225e9,"body":"(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []     -> 0 \n  | hd::tl -> hd + sumList tl\n;;\n\nlet _ = sumList [1; 2; 3; 4];;\nlet _ = sumList [1; -2; 3; 5];;\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digithelper n l=\n  let x = n/10 in\n  let y = n mod 10 in\n    if x <= 0\n    then y :: l\n    else digithelper x (y :: l)\n;;\n\nlet digitsOfInt n =\n  if n <= 0\n  then []\n  else \n    digithelper n []\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 352663;;\nlet _ = digitsOfInt 0;;\nlet _ = digitsOfInt 1;;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet listReverse l = \n  let rec helperFun l z = match l with\n    | [] -> z\n    | hd :: tl -> helperFun tl (hd :: z)\n  in\n    helperFun l []\n;;\n\nlet _ = listReverse [1; 2; 3; 4];;\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet palindrome w = \n  let z = explode w in\n  let y = listReverse z in\n    if z = y\n    then true\n    else false\n;;\n\nlet _ = palindrome \"malayalam\";;\nlet _ = palindrome \"myxomatosis\";;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = digitsOfInt 0","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x <= 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 0;;\n","type":"","out":""}],"event":{"region":{"start":799,"stop":820},"type":"eval"},"cursor":822,"time":1.397515502402575e9,"body":"(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []     -> 0 \n  | hd::tl -> hd + sumList tl\n;;\n\nlet _ = sumList [1; 2; 3; 4];;\nlet _ = sumList [1; -2; 3; 5];;\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digithelper n l=\n  let x = n/10 in\n  let y = n mod 10 in\n    if x <= 0\n    then y :: l\n    else digithelper x (y :: l)\n;;\n\nlet digitsOfInt n =\n  if n <= 0\n  then []\n  else \n    digithelper n []\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 352663;;\nlet _ = digitsOfInt 0;;\nlet _ = digitsOfInt 1;;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet listReverse l = \n  let rec helperFun l z = match l with\n    | [] -> z\n    | hd :: tl -> helperFun tl (hd :: z)\n  in\n    helperFun l []\n;;\n\nlet _ = listReverse [1; 2; 3; 4];;\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet palindrome w = \n  let z = explode w in\n  let y = listReverse z in\n    if z = y\n    then true\n    else false\n;;\n\nlet _ = palindrome \"malayalam\";;\nlet _ = palindrome \"myxomatosis\";;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let digitsOfInt n =\nif n < 0 | n = 0\nthen []\nelse \ndigithelper n []","min":"","type":"syntax","out":"Characters 29-30:\n  if n < 0 | n = 0\n           ^\nError: Syntax error\n"},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x <= 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x <= 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 0","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x <= 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 0;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 1","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x <= 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 1;;\n","type":"","out":""},{"in":"let _ = digitsOfInt -1","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x <= 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt - 1;;\n","type":"type","out":"Characters 8-19:\n  let _ = digitsOfInt -1;;\n          ^^^^^^^^^^^\nError: This expression has type int -> int list\n       but an expression was expected of type int\n"}],"event":{"region":{"start":673,"stop":876},"type":"eval"},"cursor":878,"time":1.397515643222463e9,"body":"(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []     -> 0 \n  | hd::tl -> hd + sumList tl\n;;\n\nlet _ = sumList [1; 2; 3; 4];;\nlet _ = sumList [1; -2; 3; 5];;\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digithelper n l=\n  let x = n/10 in\n  let y = n mod 10 in\n    if x <= 0\n    then y :: l\n    else digithelper x (y :: l)\n;;\n\nlet digitsOfInt n =\n  if n < 0 | n = 0\n  then []\n  else \n    digithelper n []\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 352663;;\nlet _ = digitsOfInt 0;;\nlet _ = digitsOfInt 1;;\nlet _ = digitsOfInt -1;;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet listReverse l = \n  let rec helperFun l z = match l with\n    | [] -> z\n    | hd :: tl -> helperFun tl (hd :: z)\n  in\n    helperFun l []\n;;\n\nlet _ = listReverse [1; 2; 3; 4];;\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet palindrome w = \n  let z = explode w in\n  let y = listReverse z in\n    if z = y\n    then true\n    else false\n;;\n\nlet _ = palindrome \"malayalam\";;\nlet _ = palindrome \"myxomatosis\";;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = match xs with\n| []     -> 0 \n| hd::tl -> hd + sumList tl","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec digithelper n l=\nlet x = n/10 in\nlet y = n mod 10 in\nif x <= 0\nthen y :: l\nelse digithelper x (y :: l)","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x <= 0 then y :: l else digithelper x (y :: l);;\n","type":"","out":""},{"in":"let digitsOfInt n =\nif n < 0 \nthen []\nelse if n = 0\nthen []\nelse \ndigithelper n []","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x <= 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n =\n  if n < 0 then [] else if n = 0 then [] else digithelper n [];;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x <= 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n =\n  if n < 0 then [] else if n = 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x <= 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n =\n  if n < 0 then [] else if n = 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 0","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x <= 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n =\n  if n < 0 then [] else if n = 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 0;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 1","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x <= 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n =\n  if n < 0 then [] else if n = 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 1;;\n","type":"","out":""},{"in":"let _ = digitsOfInt -1","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x <= 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n =\n  if n < 0 then [] else if n = 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt - 1;;\n","type":"type","out":"Characters 8-19:\n  let _ = digitsOfInt -1;;\n          ^^^^^^^^^^^\nError: This expression has type int -> int list\n       but an expression was expected of type int\n"}],"event":{"region":{"start":0,"stop":891},"type":"eval"},"cursor":893,"time":1.397515674953559e9,"body":"(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []     -> 0 \n  | hd::tl -> hd + sumList tl\n;;\n\nlet _ = sumList [1; 2; 3; 4];;\nlet _ = sumList [1; -2; 3; 5];;\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digithelper n l=\n  let x = n/10 in\n  let y = n mod 10 in\n    if x <= 0\n    then y :: l\n    else digithelper x (y :: l)\n;;\n\nlet digitsOfInt n =\n  if n < 0 \n  then []\n  else if n = 0\n  then []\n  else \n    digithelper n []\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 352663;;\nlet _ = digitsOfInt 0;;\nlet _ = digitsOfInt 1;;\nlet _ = digitsOfInt -1;;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet listReverse l = \n  let rec helperFun l z = match l with\n    | [] -> z\n    | hd :: tl -> helperFun tl (hd :: z)\n  in\n    helperFun l []\n;;\n\nlet _ = listReverse [1; 2; 3; 4];;\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet palindrome w = \n  let z = explode w in\n  let y = listReverse z in\n    if z = y\n    then true\n    else false\n;;\n\nlet _ = palindrome \"malayalam\";;\nlet _ = palindrome \"myxomatosis\";;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = match xs with\n| []     -> 0 \n| hd::tl -> hd + sumList tl","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec digithelper n l=\nlet x = n/10 in\nlet y = n mod 10 in\nif x <= 0\nthen y :: l\nelse digithelper x (y :: l)","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x <= 0 then y :: l else digithelper x (y :: l);;\n","type":"","out":""},{"in":"let digitsOfInt n =\nif n < 0 \nthen []\nelse \ndigithelper n []","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x <= 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n < 0 then [] else digithelper n [];;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x <= 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n < 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x <= 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n < 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 0","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x <= 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n < 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 0;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 1","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x <= 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n < 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 1;;\n","type":"","out":""},{"in":"let _ = digitsOfInt -1","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x <= 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n < 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt - 1;;\n","type":"type","out":"Characters 8-19:\n  let _ = digitsOfInt -1;;\n          ^^^^^^^^^^^\nError: This expression has type int -> int list\n       but an expression was expected of type int\n"}],"event":{"region":{"start":0,"stop":869},"type":"eval"},"cursor":871,"time":1.397515693397641e9,"body":"(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []     -> 0 \n  | hd::tl -> hd + sumList tl\n;;\n\nlet _ = sumList [1; 2; 3; 4];;\nlet _ = sumList [1; -2; 3; 5];;\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digithelper n l=\n  let x = n/10 in\n  let y = n mod 10 in\n    if x <= 0\n    then y :: l\n    else digithelper x (y :: l)\n;;\n\nlet digitsOfInt n =\n  if n < 0 \n  then []\n  else \n    digithelper n []\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 352663;;\nlet _ = digitsOfInt 0;;\nlet _ = digitsOfInt 1;;\nlet _ = digitsOfInt -1;;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet listReverse l = \n  let rec helperFun l z = match l with\n    | [] -> z\n    | hd :: tl -> helperFun tl (hd :: z)\n  in\n    helperFun l []\n;;\n\nlet _ = listReverse [1; 2; 3; 4];;\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet palindrome w = \n  let z = explode w in\n  let y = listReverse z in\n    if z = y\n    then true\n    else false\n;;\n\nlet _ = palindrome \"malayalam\";;\nlet _ = palindrome \"myxomatosis\";;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let digitsOfInt n =\nif n = 0 \nthen []\nelse \ndigithelper n []","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x <= 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n = 0 then [] else digithelper n [];;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x <= 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n = 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x <= 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n = 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 0","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x <= 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n = 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 0;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 1","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x <= 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n = 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 1;;\n","type":"","out":""},{"in":"let _ = digitsOfInt -1","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x <= 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n = 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt - 1;;\n","type":"type","out":"Characters 8-19:\n  let _ = digitsOfInt -1;;\n          ^^^^^^^^^^^\nError: This expression has type int -> int list\n       but an expression was expected of type int\n"},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x <= 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n = 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec additivePersistence n = failwith \"TBD\"","min":"\nlet rec additivePersistence n = failwith \"TBD\";;\n","type":"","out":""},{"in":"let rec digitalRoot n = failwith \"TBD\"","min":"\nlet rec digitalRoot n = failwith \"TBD\";;\n","type":"","out":""},{"in":"let listReverse l = \nlet rec helperFun l z = match l with\n| [] -> z\n| hd :: tl -> helperFun tl (hd :: z)\nin\nhelperFun l []","min":"\nlet listReverse l =\n  let rec helperFun l z =\n    match l with | [] -> z | hd::tl -> helperFun tl (hd :: z) in\n  helperFun l [];;\n","type":"","out":""},{"in":"let _ = listReverse [1; 2; 3; 4]","min":"\nlet listReverse l =\n  let rec helperFun l z =\n    match l with | [] -> z | hd::tl -> helperFun tl (hd :: z) in\n  helperFun l [];;\n\nlet _ = listReverse [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]","min":"\nlet listReverse l =\n  let rec helperFun l z =\n    match l with | [] -> z | hd::tl -> helperFun tl (hd :: z) in\n  helperFun l [];;\n\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n","type":"","out":""},{"in":"let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n","type":"","out":""},{"in":"let palindrome w = \nlet z = explode w in\nlet y = listReverse z in\nif z = y\nthen true\nelse false","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet listReverse l =\n  let rec helperFun l z =\n    match l with | [] -> z | hd::tl -> helperFun tl (hd :: z) in\n  helperFun l [];;\n\nlet palindrome w =\n  let z = explode w in let y = listReverse z in if z = y then true else false;;\n","type":"","out":""},{"in":"let _ = palindrome \"malayalam\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet listReverse l =\n  let rec helperFun l z =\n    match l with | [] -> z | hd::tl -> helperFun tl (hd :: z) in\n  helperFun l [];;\n\nlet palindrome w =\n  let z = explode w in let y = listReverse z in if z = y then true else false;;\n\nlet _ = palindrome \"malayalam\";;\n","type":"","out":""},{"in":"let _ = palindrome \"myxomatosis\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet listReverse l =\n  let rec helperFun l z =\n    match l with | [] -> z | hd::tl -> helperFun tl (hd :: z) in\n  helperFun l [];;\n\nlet palindrome w =\n  let z = explode w in let y = listReverse z in if z = y then true else false;;\n\nlet _ = palindrome \"myxomatosis\";;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key        = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130  = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"region":{"start":673,"stop":6133},"type":"eval"},"cursor":871,"time":1.397515774883528e9,"body":"(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []     -> 0 \n  | hd::tl -> hd + sumList tl\n;;\n\nlet _ = sumList [1; 2; 3; 4];;\nlet _ = sumList [1; -2; 3; 5];;\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digithelper n l=\n  let x = n/10 in\n  let y = n mod 10 in\n    if x <= 0\n    then y :: l\n    else digithelper x (y :: l)\n;;\n\nlet digitsOfInt n =\n  if n = 0 \n  then []\n  else \n    digithelper n []\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 352663;;\nlet _ = digitsOfInt 0;;\nlet _ = digitsOfInt 1;;\nlet _ = digitsOfInt -1;;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet listReverse l = \n  let rec helperFun l z = match l with\n    | [] -> z\n    | hd :: tl -> helperFun tl (hd :: z)\n  in\n    helperFun l []\n;;\n\nlet _ = listReverse [1; 2; 3; 4];;\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet palindrome w = \n  let z = explode w in\n  let y = listReverse z in\n    if z = y\n    then true\n    else false\n;;\n\nlet _ = palindrome \"malayalam\";;\nlet _ = palindrome \"myxomatosis\";;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = match xs with\n| []     -> 0 \n| hd::tl -> hd + sumList tl","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec digithelper n l=\nlet x = n/10 in\nlet y = n mod 10 in\nif x <= 0\nthen y :: l\nelse digithelper x (y :: l)","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x <= 0 then y :: l else digithelper x (y :: l);;\n","type":"","out":""},{"in":"let digitsOfInt n =\nif n = 0 \nthen []\nelse \ndigithelper n []","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x <= 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n = 0 then [] else digithelper n [];;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x <= 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n = 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x <= 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n = 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 0","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x <= 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n = 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 0;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 1","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x <= 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n = 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 1;;\n","type":"","out":""},{"in":"let _ = digitsOfInt -1","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x <= 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n = 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt - 1;;\n","type":"type","out":"Characters 8-19:\n  let _ = digitsOfInt -1;;\n          ^^^^^^^^^^^\nError: This expression has type int -> int list\n       but an expression was expected of type int\n"}],"event":{"region":{"start":0,"stop":869},"type":"eval"},"cursor":871,"time":1.397515775923158e9,"body":"(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []     -> 0 \n  | hd::tl -> hd + sumList tl\n;;\n\nlet _ = sumList [1; 2; 3; 4];;\nlet _ = sumList [1; -2; 3; 5];;\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digithelper n l=\n  let x = n/10 in\n  let y = n mod 10 in\n    if x <= 0\n    then y :: l\n    else digithelper x (y :: l)\n;;\n\nlet digitsOfInt n =\n  if n = 0 \n  then []\n  else \n    digithelper n []\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 352663;;\nlet _ = digitsOfInt 0;;\nlet _ = digitsOfInt 1;;\nlet _ = digitsOfInt -1;;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet listReverse l = \n  let rec helperFun l z = match l with\n    | [] -> z\n    | hd :: tl -> helperFun tl (hd :: z)\n  in\n    helperFun l []\n;;\n\nlet _ = listReverse [1; 2; 3; 4];;\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet palindrome w = \n  let z = explode w in\n  let y = listReverse z in\n    if z = y\n    then true\n    else false\n;;\n\nlet _ = palindrome \"malayalam\";;\nlet _ = palindrome \"myxomatosis\";;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = digitsOfInt -12","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x <= 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n = 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt - 12;;\n","type":"type","out":"Characters 8-19:\n  let _ = digitsOfInt -12;;\n          ^^^^^^^^^^^\nError: This expression has type int -> int list\n       but an expression was expected of type int\n"}],"event":{"region":{"start":844,"stop":870},"type":"eval"},"cursor":872,"time":1.397515896354516e9,"body":"(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []     -> 0 \n  | hd::tl -> hd + sumList tl\n;;\n\nlet _ = sumList [1; 2; 3; 4];;\nlet _ = sumList [1; -2; 3; 5];;\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digithelper n l=\n  let x = n/10 in\n  let y = n mod 10 in\n    if x <= 0\n    then y :: l\n    else digithelper x (y :: l)\n;;\n\nlet digitsOfInt n =\n  if n = 0 \n  then []\n  else \n    digithelper n []\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 352663;;\nlet _ = digitsOfInt 0;;\nlet _ = digitsOfInt 1;;\nlet _ = digitsOfInt -12;;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet listReverse l = \n  let rec helperFun l z = match l with\n    | [] -> z\n    | hd :: tl -> helperFun tl (hd :: z)\n  in\n    helperFun l []\n;;\n\nlet _ = listReverse [1; 2; 3; 4];;\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet palindrome w = \n  let z = explode w in\n  let y = listReverse z in\n    if z = y\n    then true\n    else false\n;;\n\nlet _ = palindrome \"malayalam\";;\nlet _ = palindrome \"myxomatosis\";;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = match xs with\n| []     -> 0 \n| hd::tl -> hd + sumList tl","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec digithelper n l=\nlet x = n/10 in\nlet y = n mod 10 in\nif x <= 0\nthen y :: l\nelse digithelper x (y :: l)","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x <= 0 then y :: l else digithelper x (y :: l);;\n","type":"","out":""},{"in":"let digitsOfInt n =\nif n =< 0 \nthen []\nelse \ndigithelper n []","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x <= 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n =< 0 then [] else digithelper n [];;\n","type":"scope","out":"Characters 25-27:\n  if n =< 0 \n       ^^\nError: Unbound value =<\n"},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x <= 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n = 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x <= 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n = 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 0","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x <= 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n = 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 0;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 1","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x <= 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n = 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 1;;\n","type":"","out":""},{"in":"let _ = digitsOfInt -12","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x <= 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n = 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt - 12;;\n","type":"type","out":"Characters 8-19:\n  let _ = digitsOfInt -12;;\n          ^^^^^^^^^^^\nError: This expression has type int -> int list\n       but an expression was expected of type int\n"}],"event":{"region":{"start":0,"stop":871},"type":"eval"},"cursor":873,"time":1.397515918987228e9,"body":"(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []     -> 0 \n  | hd::tl -> hd + sumList tl\n;;\n\nlet _ = sumList [1; 2; 3; 4];;\nlet _ = sumList [1; -2; 3; 5];;\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digithelper n l=\n  let x = n/10 in\n  let y = n mod 10 in\n    if x <= 0\n    then y :: l\n    else digithelper x (y :: l)\n;;\n\nlet digitsOfInt n =\n  if n =< 0 \n  then []\n  else \n    digithelper n []\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 352663;;\nlet _ = digitsOfInt 0;;\nlet _ = digitsOfInt 1;;\nlet _ = digitsOfInt -12;;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet listReverse l = \n  let rec helperFun l z = match l with\n    | [] -> z\n    | hd :: tl -> helperFun tl (hd :: z)\n  in\n    helperFun l []\n;;\n\nlet _ = listReverse [1; 2; 3; 4];;\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet palindrome w = \n  let z = explode w in\n  let y = listReverse z in\n    if z = y\n    then true\n    else false\n;;\n\nlet _ = palindrome \"malayalam\";;\nlet _ = palindrome \"myxomatosis\";;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = match xs with\n| []     -> 0 \n| hd::tl -> hd + sumList tl","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec digithelper n l=\nlet x = n/10 in\nlet y = n mod 10 in\nif x <= 0\nthen y :: l\nelse digithelper x (y :: l)","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x <= 0 then y :: l else digithelper x (y :: l);;\n","type":"","out":""},{"in":"let digitsOfInt n =\nif n < = 0 \nthen []\nelse \ndigithelper n []","min":"","type":"syntax","out":"Characters 27-28:\n  if n < = 0 \n         ^\nError: Syntax error\n"},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x <= 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n = 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x <= 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n = 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 0","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x <= 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n = 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 0;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 1","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x <= 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n = 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 1;;\n","type":"","out":""},{"in":"let _ = digitsOfInt -12","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x <= 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n = 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt - 12;;\n","type":"type","out":"Characters 8-19:\n  let _ = digitsOfInt -12;;\n          ^^^^^^^^^^^\nError: This expression has type int -> int list\n       but an expression was expected of type int\n"}],"event":{"region":{"start":0,"stop":872},"type":"eval"},"cursor":874,"time":1.397515930285312e9,"body":"(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []     -> 0 \n  | hd::tl -> hd + sumList tl\n;;\n\nlet _ = sumList [1; 2; 3; 4];;\nlet _ = sumList [1; -2; 3; 5];;\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digithelper n l=\n  let x = n/10 in\n  let y = n mod 10 in\n    if x <= 0\n    then y :: l\n    else digithelper x (y :: l)\n;;\n\nlet digitsOfInt n =\n  if n < = 0 \n  then []\n  else \n    digithelper n []\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 352663;;\nlet _ = digitsOfInt 0;;\nlet _ = digitsOfInt 1;;\nlet _ = digitsOfInt -12;;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet listReverse l = \n  let rec helperFun l z = match l with\n    | [] -> z\n    | hd :: tl -> helperFun tl (hd :: z)\n  in\n    helperFun l []\n;;\n\nlet _ = listReverse [1; 2; 3; 4];;\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet palindrome w = \n  let z = explode w in\n  let y = listReverse z in\n    if z = y\n    then true\n    else false\n;;\n\nlet _ = palindrome \"malayalam\";;\nlet _ = palindrome \"myxomatosis\";;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let digitsOfInt n =\nif n <= 0 \nthen []\nelse \ndigithelper n []","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x <= 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n","type":"","out":""}],"event":{"region":{"start":673,"stop":739},"type":"eval"},"cursor":742,"time":1.397515938515344e9,"body":"(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []     -> 0 \n  | hd::tl -> hd + sumList tl\n;;\n\nlet _ = sumList [1; 2; 3; 4];;\nlet _ = sumList [1; -2; 3; 5];;\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digithelper n l=\n  let x = n/10 in\n  let y = n mod 10 in\n    if x <= 0\n    then y :: l\n    else digithelper x (y :: l)\n;;\n\nlet digitsOfInt n =\n  if n <= 0 \n  then []\n  else \n    digithelper n []\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 352663;;\nlet _ = digitsOfInt 0;;\nlet _ = digitsOfInt 1;;\nlet _ = digitsOfInt -12;;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet listReverse l = \n  let rec helperFun l z = match l with\n    | [] -> z\n    | hd :: tl -> helperFun tl (hd :: z)\n  in\n    helperFun l []\n;;\n\nlet _ = listReverse [1; 2; 3; 4];;\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet palindrome w = \n  let z = explode w in\n  let y = listReverse z in\n    if z = y\n    then true\n    else false\n;;\n\nlet _ = palindrome \"malayalam\";;\nlet _ = palindrome \"myxomatosis\";;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = match xs with\n| []     -> 0 \n| hd::tl -> hd + sumList tl","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec digithelper n l=\nlet x = n/10 in\nlet y = n mod 10 in\nif x <= 0\nthen y :: l\nelse digithelper x (y :: l)","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x <= 0 then y :: l else digithelper x (y :: l);;\n","type":"","out":""},{"in":"let digitsOfInt n =\nif n <= 0 \nthen []\nelse \ndigithelper n []","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x <= 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":739},"type":"eval"},"cursor":742,"time":1.397515940343407e9,"body":"(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []     -> 0 \n  | hd::tl -> hd + sumList tl\n;;\n\nlet _ = sumList [1; 2; 3; 4];;\nlet _ = sumList [1; -2; 3; 5];;\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digithelper n l=\n  let x = n/10 in\n  let y = n mod 10 in\n    if x <= 0\n    then y :: l\n    else digithelper x (y :: l)\n;;\n\nlet digitsOfInt n =\n  if n <= 0 \n  then []\n  else \n    digithelper n []\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 352663;;\nlet _ = digitsOfInt 0;;\nlet _ = digitsOfInt 1;;\nlet _ = digitsOfInt -12;;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet listReverse l = \n  let rec helperFun l z = match l with\n    | [] -> z\n    | hd :: tl -> helperFun tl (hd :: z)\n  in\n    helperFun l []\n;;\n\nlet _ = listReverse [1; 2; 3; 4];;\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet palindrome w = \n  let z = explode w in\n  let y = listReverse z in\n    if z = y\n    then true\n    else false\n;;\n\nlet _ = palindrome \"malayalam\";;\nlet _ = palindrome \"myxomatosis\";;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = digitsOfInt 3124","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x <= 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x <= 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 0","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x <= 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 0;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 1","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x <= 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 1;;\n","type":"","out":""},{"in":"let _ = digitsOfInt -12","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x <= 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt - 12;;\n","type":"type","out":"Characters 8-19:\n  let _ = digitsOfInt -12;;\n          ^^^^^^^^^^^\nError: This expression has type int -> int list\n       but an expression was expected of type int\n"}],"event":{"region":{"start":739,"stop":871},"type":"eval"},"cursor":873,"time":1.397515945844459e9,"body":"(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []     -> 0 \n  | hd::tl -> hd + sumList tl\n;;\n\nlet _ = sumList [1; 2; 3; 4];;\nlet _ = sumList [1; -2; 3; 5];;\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digithelper n l=\n  let x = n/10 in\n  let y = n mod 10 in\n    if x <= 0\n    then y :: l\n    else digithelper x (y :: l)\n;;\n\nlet digitsOfInt n =\n  if n <= 0 \n  then []\n  else \n    digithelper n []\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 352663;;\nlet _ = digitsOfInt 0;;\nlet _ = digitsOfInt 1;;\nlet _ = digitsOfInt -12;;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet listReverse l = \n  let rec helperFun l z = match l with\n    | [] -> z\n    | hd :: tl -> helperFun tl (hd :: z)\n  in\n    helperFun l []\n;;\n\nlet _ = listReverse [1; 2; 3; 4];;\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet palindrome w = \n  let z = explode w in\n  let y = listReverse z in\n    if z = y\n    then true\n    else false\n;;\n\nlet _ = palindrome \"malayalam\";;\nlet _ = palindrome \"myxomatosis\";;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = match xs with\n| []     -> 0 \n| hd::tl -> hd + sumList tl","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec digithelper n l=\nlet x = n/10 in\nlet y = n mod 10 in\nif x < 0\nthen y :: l\nelse digithelper x (y :: l)","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x < 0 then y :: l else digithelper x (y :: l);;\n","type":"","out":""},{"in":"let digitsOfInt n =\nif n <= 0 \nthen []\nelse \ndigithelper n []","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x < 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x < 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x < 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 0","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x < 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 0;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 1","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x < 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 1;;\n","type":"","out":""},{"in":"let _ = digitsOfInt -12","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x < 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt - 12;;\n","type":"type","out":"Characters 8-19:\n  let _ = digitsOfInt -12;;\n          ^^^^^^^^^^^\nError: This expression has type int -> int list\n       but an expression was expected of type int\n"}],"event":{"region":{"start":0,"stop":870},"type":"eval"},"cursor":872,"time":1.397515970983644e9,"body":"(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []     -> 0 \n  | hd::tl -> hd + sumList tl\n;;\n\nlet _ = sumList [1; 2; 3; 4];;\nlet _ = sumList [1; -2; 3; 5];;\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digithelper n l=\n  let x = n/10 in\n  let y = n mod 10 in\n    if x < 0\n    then y :: l\n    else digithelper x (y :: l)\n;;\n\nlet digitsOfInt n =\n  if n <= 0 \n  then []\n  else \n    digithelper n []\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 352663;;\nlet _ = digitsOfInt 0;;\nlet _ = digitsOfInt 1;;\nlet _ = digitsOfInt -12;;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet listReverse l = \n  let rec helperFun l z = match l with\n    | [] -> z\n    | hd :: tl -> helperFun tl (hd :: z)\n  in\n    helperFun l []\n;;\n\nlet _ = listReverse [1; 2; 3; 4];;\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet palindrome w = \n  let z = explode w in\n  let y = listReverse z in\n    if z = y\n    then true\n    else false\n;;\n\nlet _ = palindrome \"malayalam\";;\nlet _ = palindrome \"myxomatosis\";;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec digithelper n l=\nlet x = n/10 in\nlet y = n mod 10 in\nif x = 0\nthen y :: l\nelse digithelper x (y :: l)","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n","type":"","out":""},{"in":"let digitsOfInt n =\nif n <= 0 \nthen []\nelse \ndigithelper n []","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 0","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 0;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 1","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 1;;\n","type":"","out":""},{"in":"let _ = digitsOfInt -12","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt - 12;;\n","type":"type","out":"Characters 8-19:\n  let _ = digitsOfInt -12;;\n          ^^^^^^^^^^^\nError: This expression has type int -> int list\n       but an expression was expected of type int\n"}],"event":{"region":{"start":300,"stop":870},"type":"eval"},"cursor":872,"time":1.397515985845354e9,"body":"(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []     -> 0 \n  | hd::tl -> hd + sumList tl\n;;\n\nlet _ = sumList [1; 2; 3; 4];;\nlet _ = sumList [1; -2; 3; 5];;\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digithelper n l=\n  let x = n/10 in\n  let y = n mod 10 in\n    if x = 0\n    then y :: l\n    else digithelper x (y :: l)\n;;\n\nlet digitsOfInt n =\n  if n <= 0 \n  then []\n  else \n    digithelper n []\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 352663;;\nlet _ = digitsOfInt 0;;\nlet _ = digitsOfInt 1;;\nlet _ = digitsOfInt -12;;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet listReverse l = \n  let rec helperFun l z = match l with\n    | [] -> z\n    | hd :: tl -> helperFun tl (hd :: z)\n  in\n    helperFun l []\n;;\n\nlet _ = listReverse [1; 2; 3; 4];;\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet palindrome w = \n  let z = explode w in\n  let y = listReverse z in\n    if z = y\n    then true\n    else false\n;;\n\nlet _ = palindrome \"malayalam\";;\nlet _ = palindrome \"myxomatosis\";;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = match xs with\n| []     -> 0 \n| hd::tl -> hd + sumList tl","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec digithelper n l=\nlet x = n/10 in\nlet y = n mod 10 in\nif x = 0\nthen y :: l\nelse digithelper x (y :: l)","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n","type":"","out":""},{"in":"let digitsOfInt n =\nif n <= 0 \nthen []\nelse \ndigithelper n []","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 0","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 0;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 1","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 1;;\n","type":"","out":""},{"in":"let _ = digitsOfInt (-12)","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt (-12);;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":872},"type":"eval"},"cursor":874,"time":1.397516087776246e9,"body":"(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []     -> 0 \n  | hd::tl -> hd + sumList tl\n;;\n\nlet _ = sumList [1; 2; 3; 4];;\nlet _ = sumList [1; -2; 3; 5];;\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digithelper n l=\n  let x = n/10 in\n  let y = n mod 10 in\n    if x = 0\n    then y :: l\n    else digithelper x (y :: l)\n;;\n\nlet digitsOfInt n =\n  if n <= 0 \n  then []\n  else \n    digithelper n []\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 352663;;\nlet _ = digitsOfInt 0;;\nlet _ = digitsOfInt 1;;\nlet _ = digitsOfInt (-12);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet listReverse l = \n  let rec helperFun l z = match l with\n    | [] -> z\n    | hd :: tl -> helperFun tl (hd :: z)\n  in\n    helperFun l []\n;;\n\nlet _ = listReverse [1; 2; 3; 4];;\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet palindrome w = \n  let z = explode w in\n  let y = listReverse z in\n    if z = y\n    then true\n    else false\n;;\n\nlet _ = palindrome \"malayalam\";;\nlet _ = palindrome \"myxomatosis\";;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":0,"stop":63},"type":"eval"},"cursor":63,"time":1.397516124932199e9,"body":"(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\nXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []     -> 0 \n  | hd::tl -> hd + sumList tl\n;;\n\nlet _ = sumList [1; 2; 3; 4];;\nlet _ = sumList [1; -2; 3; 5];;\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digithelper n l=\n  let x = n/10 in\n  let y = n mod 10 in\n    if x = 0\n    then y :: l\n    else digithelper x (y :: l)\n;;\n\nlet digitsOfInt n =\n  if n <= 0 \n  then []\n  else \n    digithelper n []\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 352663;;\nlet _ = digitsOfInt 0;;\nlet _ = digitsOfInt 1;;\nlet _ = digitsOfInt (-12);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet listReverse l = \n  let rec helperFun l z = match l with\n    | [] -> z\n    | hd :: tl -> helperFun tl (hd :: z)\n  in\n    helperFun l []\n;;\n\nlet _ = listReverse [1; 2; 3; 4];;\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet palindrome w = \n  let z = explode w in\n  let y = listReverse z in\n    if z = y\n    then true\n    else false\n;;\n\nlet _ = palindrome \"malayalam\";;\nlet _ = palindrome \"myxomatosis\";;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":0,"stop":63},"type":"eval"},"cursor":63,"time":1.397516126034677e9,"body":"(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\nXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []     -> 0 \n  | hd::tl -> hd + sumList tl\n;;\n\nlet _ = sumList [1; 2; 3; 4];;\nlet _ = sumList [1; -2; 3; 5];;\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digithelper n l=\n  let x = n/10 in\n  let y = n mod 10 in\n    if x = 0\n    then y :: l\n    else digithelper x (y :: l)\n;;\n\nlet digitsOfInt n =\n  if n <= 0 \n  then []\n  else \n    digithelper n []\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 352663;;\nlet _ = digitsOfInt 0;;\nlet _ = digitsOfInt 1;;\nlet _ = digitsOfInt (-12);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet listReverse l = \n  let rec helperFun l z = match l with\n    | [] -> z\n    | hd :: tl -> helperFun tl (hd :: z)\n  in\n    helperFun l []\n;;\n\nlet _ = listReverse [1; 2; 3; 4];;\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet palindrome w = \n  let z = explode w in\n  let y = listReverse z in\n    if z = y\n    then true\n    else false\n;;\n\nlet _ = palindrome \"malayalam\";;\nlet _ = palindrome \"myxomatosis\";;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = match xs with\n| []     -> 0 \n| hd::tl -> hd + sumList tl","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec digithelper n l=\nlet x = n/10 in\nlet y = n mod 10 in\nif x = 0\nthen y :: l\nelse digithelper x (y :: l)","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n","type":"","out":""},{"in":"let digitsOfInt n =\nif n <= 0 \nthen []\nelse \ndigithelper n []","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 0","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 0;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 1","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 1;;\n","type":"","out":""},{"in":"let _ = digitsOfInt (-12)","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt (-12);;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec additivePersistence n = failwith \"TBD\"","min":"\nlet rec additivePersistence n = failwith \"TBD\";;\n","type":"","out":""},{"in":"let rec digitalRoot n = failwith \"TBD\"","min":"\nlet rec digitalRoot n = failwith \"TBD\";;\n","type":"","out":""},{"in":"let listReverse l = \nlet rec helperFun l z = match l with\n| [] -> z\n| hd :: tl -> helperFun tl (hd :: z)\nin\nhelperFun l []","min":"\nlet listReverse l =\n  let rec helperFun l z =\n    match l with | [] -> z | hd::tl -> helperFun tl (hd :: z) in\n  helperFun l [];;\n","type":"","out":""},{"in":"let _ = listReverse [1; 2; 3; 4]","min":"\nlet listReverse l =\n  let rec helperFun l z =\n    match l with | [] -> z | hd::tl -> helperFun tl (hd :: z) in\n  helperFun l [];;\n\nlet _ = listReverse [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]","min":"\nlet listReverse l =\n  let rec helperFun l z =\n    match l with | [] -> z | hd::tl -> helperFun tl (hd :: z) in\n  helperFun l [];;\n\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n","type":"","out":""},{"in":"let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n","type":"","out":""},{"in":"let palindrome w = \nlet z = explode w in\nlet y = listReverse z in\nif z = y\nthen true\nelse false","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet listReverse l =\n  let rec helperFun l z =\n    match l with | [] -> z | hd::tl -> helperFun tl (hd :: z) in\n  helperFun l [];;\n\nlet palindrome w =\n  let z = explode w in let y = listReverse z in if z = y then true else false;;\n","type":"","out":""},{"in":"let _ = palindrome \"malayalam\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet listReverse l =\n  let rec helperFun l z =\n    match l with | [] -> z | hd::tl -> helperFun tl (hd :: z) in\n  helperFun l [];;\n\nlet palindrome w =\n  let z = explode w in let y = listReverse z in if z = y then true else false;;\n\nlet _ = palindrome \"malayalam\";;\n","type":"","out":""},{"in":"let _ = palindrome \"myxomatosis\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet listReverse l =\n  let rec helperFun l z =\n    match l with | [] -> z | hd::tl -> helperFun tl (hd :: z) in\n  helperFun l [];;\n\nlet palindrome w =\n  let z = explode w in let y = listReverse z in if z = y then true else false;;\n\nlet _ = palindrome \"myxomatosis\";;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key        = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130  = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":6113},"type":"eval"},"cursor":178,"time":1.397516132852853e9,"body":"(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\nXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []     -> 0 \n  | hd::tl -> hd + sumList tl\n;;\n\nlet _ = sumList [1; 2; 3; 4];;\nlet _ = sumList [1; -2; 3; 5];;\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digithelper n l=\n  let x = n/10 in\n  let y = n mod 10 in\n    if x = 0\n    then y :: l\n    else digithelper x (y :: l)\n;;\n\nlet digitsOfInt n =\n  if n <= 0 \n  then []\n  else \n    digithelper n []\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 352663;;\nlet _ = digitsOfInt 0;;\nlet _ = digitsOfInt 1;;\nlet _ = digitsOfInt (-12);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet listReverse l = \n  let rec helperFun l z = match l with\n    | [] -> z\n    | hd :: tl -> helperFun tl (hd :: z)\n  in\n    helperFun l []\n;;\n\nlet _ = listReverse [1; 2; 3; 4];;\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet palindrome w = \n  let z = explode w in\n  let y = listReverse z in\n    if z = y\n    then true\n    else false\n;;\n\nlet _ = palindrome \"malayalam\";;\nlet _ = palindrome \"myxomatosis\";;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = match xs with\n| []     -> 0 \n| hd::tl -> hd + sumList tl","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec digithelper n l=\nlet x = n/10 in\nlet y = n mod 10 in\nif x = 0\nthen y :: l\nelse digithelper x (y :: l)","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n","type":"","out":""},{"in":"let digitsOfInt n =\nif n <= 0 \nthen []\nelse \ndigithelper n []","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 0","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 0;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 1","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 1;;\n","type":"","out":""},{"in":"let _ = digitsOfInt (-12)","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt (-12);;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec additivePersistence n = failwith \"TBD\"","min":"\nlet rec additivePersistence n = failwith \"TBD\";;\n","type":"","out":""},{"in":"let rec digitalRoot n = \nlet n_pos = digits n in\nlet l_sum = sumList n_pos in\nif l_sum < 10\nthen l_sum\nelse digitalRoot l_sum","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let n_pos = digits n in\n  let l_sum = sumList n_pos in\n  if l_sum < 10 then l_sum else digitalRoot l_sum;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9876","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let n_pos = digits n in\n  let l_sum = sumList n_pos in\n  if l_sum < 10 then l_sum else digitalRoot l_sum;;\n\nlet _ = digitalRoot 9876;;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":2253},"type":"eval"},"cursor":2255,"time":1.397516368105531e9,"body":"(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\nXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []     -> 0 \n  | hd::tl -> hd + sumList tl\n;;\n\nlet _ = sumList [1; 2; 3; 4];;\nlet _ = sumList [1; -2; 3; 5];;\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digithelper n l=\n  let x = n/10 in\n  let y = n mod 10 in\n    if x = 0\n    then y :: l\n    else digithelper x (y :: l)\n;;\n\nlet digitsOfInt n =\n  if n <= 0 \n  then []\n  else \n    digithelper n []\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 352663;;\nlet _ = digitsOfInt 0;;\nlet _ = digitsOfInt 1;;\nlet _ = digitsOfInt (-12);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitalRoot n = \n  let n_pos = digits n in\n  let l_sum = sumList n_pos in\n    if l_sum < 10\n    then l_sum\n    else digitalRoot l_sum\n;;\n\n\nlet _ = digitalRoot 9876;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet listReverse l = \n  let rec helperFun l z = match l with\n    | [] -> z\n    | hd :: tl -> helperFun tl (hd :: z)\n  in\n    helperFun l []\n;;\n\nlet _ = listReverse [1; 2; 3; 4];;\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet palindrome w = \n  let z = explode w in\n  let y = listReverse z in\n    if z = y\n    then true\n    else false\n;;\n\nlet _ = palindrome \"malayalam\";;\nlet _ = palindrome \"myxomatosis\";;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = digitalRoot 12345","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let n_pos = digits n in\n  let l_sum = sumList n_pos in\n  if l_sum < 10 then l_sum else digitalRoot l_sum;;\n\nlet _ = digitalRoot 12345;;\n","type":"","out":""}],"event":{"region":{"start":2253,"stop":2281},"type":"eval"},"cursor":2283,"time":1.397516440203295e9,"body":"(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\nXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []     -> 0 \n  | hd::tl -> hd + sumList tl\n;;\n\nlet _ = sumList [1; 2; 3; 4];;\nlet _ = sumList [1; -2; 3; 5];;\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digithelper n l=\n  let x = n/10 in\n  let y = n mod 10 in\n    if x = 0\n    then y :: l\n    else digithelper x (y :: l)\n;;\n\nlet digitsOfInt n =\n  if n <= 0 \n  then []\n  else \n    digithelper n []\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 352663;;\nlet _ = digitsOfInt 0;;\nlet _ = digitsOfInt 1;;\nlet _ = digitsOfInt (-12);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitalRoot n = \n  let n_pos = digits n in\n  let l_sum = sumList n_pos in\n    if l_sum < 10\n    then l_sum\n    else digitalRoot l_sum\n;;\n\n\nlet _ = digitalRoot 9876;;\nlet _ = digitalRoot 12345;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet listReverse l = \n  let rec helperFun l z = match l with\n    | [] -> z\n    | hd :: tl -> helperFun tl (hd :: z)\n  in\n    helperFun l []\n;;\n\nlet _ = listReverse [1; 2; 3; 4];;\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet palindrome w = \n  let z = explode w in\n  let y = listReverse z in\n    if z = y\n    then true\n    else false\n;;\n\nlet _ = palindrome \"malayalam\";;\nlet _ = palindrome \"myxomatosis\";;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = match xs with\n| []     -> 0 \n| hd::tl -> hd + sumList tl","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec digithelper n l=\nlet x = n/10 in\nlet y = n mod 10 in\nif x = 0\nthen y :: l\nelse digithelper x (y :: l)","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n","type":"","out":""},{"in":"let digitsOfInt n =\nif n <= 0 \nthen []\nelse \ndigithelper n []","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 0","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 0;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 1","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 1;;\n","type":"","out":""},{"in":"let _ = digitsOfInt (-12)","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt (-12);;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec additivePersistence n = failwith \"TBD\"","min":"\nlet rec additivePersistence n = failwith \"TBD\";;\n","type":"","out":""},{"in":"let rec digitalRoot n = \nlet n_pos = digits n in\nlet l_sum = sumList n_pos in\nif l_sum < 10\nthen l_sum\nelse digitalRoot l_sum","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let n_pos = digits n in\n  let l_sum = sumList n_pos in\n  if l_sum < 10 then l_sum else digitalRoot l_sum;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9876","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let n_pos = digits n in\n  let l_sum = sumList n_pos in\n  if l_sum < 10 then l_sum else digitalRoot l_sum;;\n\nlet _ = digitalRoot 9876;;\n","type":"","out":""},{"in":"let _ = digitalRoot 12345","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let n_pos = digits n in\n  let l_sum = sumList n_pos in\n  if l_sum < 10 then l_sum else digitalRoot l_sum;;\n\nlet _ = digitalRoot 12345;;\n","type":"","out":""},{"in":"let listReverse l = \nlet rec helperFun l z = match l with\n| [] -> z\n| hd :: tl -> helperFun tl (hd :: z)\nin\nhelperFun l []","min":"\nlet listReverse l =\n  let rec helperFun l z =\n    match l with | [] -> z | hd::tl -> helperFun tl (hd :: z) in\n  helperFun l [];;\n","type":"","out":""},{"in":"let _ = listReverse [1; 2; 3; 4]","min":"\nlet listReverse l =\n  let rec helperFun l z =\n    match l with | [] -> z | hd::tl -> helperFun tl (hd :: z) in\n  helperFun l [];;\n\nlet _ = listReverse [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]","min":"\nlet listReverse l =\n  let rec helperFun l z =\n    match l with | [] -> z | hd::tl -> helperFun tl (hd :: z) in\n  helperFun l [];;\n\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n","type":"","out":""},{"in":"let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n","type":"","out":""},{"in":"let palindrome w = \nlet z = explode w in\nlet y = listReverse z in\nif z = y\nthen true\nelse false","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet listReverse l =\n  let rec helperFun l z =\n    match l with | [] -> z | hd::tl -> helperFun tl (hd :: z) in\n  helperFun l [];;\n\nlet palindrome w =\n  let z = explode w in let y = listReverse z in if z = y then true else false;;\n","type":"","out":""},{"in":"let _ = palindrome \"malayalam\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet listReverse l =\n  let rec helperFun l z =\n    match l with | [] -> z | hd::tl -> helperFun tl (hd :: z) in\n  helperFun l [];;\n\nlet palindrome w =\n  let z = explode w in let y = listReverse z in if z = y then true else false;;\n\nlet _ = palindrome \"malayalam\";;\n","type":"","out":""},{"in":"let _ = palindrome \"myxomatosis\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet listReverse l =\n  let rec helperFun l z =\n    match l with | [] -> z | hd::tl -> helperFun tl (hd :: z) in\n  helperFun l [];;\n\nlet palindrome w =\n  let z = explode w in let y = listReverse z in if z = y then true else false;;\n\nlet _ = palindrome \"myxomatosis\";;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key        = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130  = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":6033},"type":"eval"},"cursor":2227,"time":1.397516448596987e9,"body":"(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\nXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []     -> 0 \n  | hd::tl -> hd + sumList tl\n;;\n\nlet _ = sumList [1; 2; 3; 4];;\nlet _ = sumList [1; -2; 3; 5];;\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digithelper n l=\n  let x = n/10 in\n  let y = n mod 10 in\n    if x = 0\n    then y :: l\n    else digithelper x (y :: l)\n;;\n\nlet digitsOfInt n =\n  if n <= 0 \n  then []\n  else \n    digithelper n []\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 352663;;\nlet _ = digitsOfInt 0;;\nlet _ = digitsOfInt 1;;\nlet _ = digitsOfInt (-12);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitalRoot n = \n  let n_pos = digits n in\n  let l_sum = sumList n_pos in\n    if l_sum < 10\n    then l_sum\n    else digitalRoot l_sum\n;;\n\n\nlet _ = digitalRoot 9876;;\nlet _ = digitalRoot 12345;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet listReverse l = \n  let rec helperFun l z = match l with\n    | [] -> z\n    | hd :: tl -> helperFun tl (hd :: z)\n  in\n    helperFun l []\n;;\n\nlet _ = listReverse [1; 2; 3; 4];;\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet palindrome w = \n  let z = explode w in\n  let y = listReverse z in\n    if z = y\n    then true\n    else false\n;;\n\nlet _ = palindrome \"malayalam\";;\nlet _ = palindrome \"myxomatosis\";;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = match xs with\n| []     -> 0 \n| hd::tl -> hd + sumList tl","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec digithelper n l=\nlet x = n/10 in\nlet y = n mod 10 in\nif x = 0\nthen y :: l\nelse digithelper x (y :: l)","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n","type":"","out":""},{"in":"let digitsOfInt n =\nif n <= 0 \nthen []\nelse \ndigithelper n []","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 0","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 0;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 1","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 1;;\n","type":"","out":""},{"in":"let _ = digitsOfInt (-12)","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt (-12);;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec addPHelper n =\nlet lst = digitsOfInt n in\nlet sum = sumList s in \nif sum < 10\nthen sum\nelse addPHelper sum","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec addPHelper n =\n  let lst = digitsOfInt n in\n  let sum = sumList s in if sum < 10 then sum else addPHelper sum;;\n","type":"scope","out":"Characters 68-69:\n  let sum = sumList s in \n                    ^\nError: Unbound value s\n"},{"in":"let additivePersistence n = \nlet n_pos = digits n in\naddPHelper n_pos","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet additivePersistence n = let n_pos = digits n in addPHelper n_pos;;\n","type":"scope","out":"Characters 53-63:\n  addPHelper n_pos;;\n  ^^^^^^^^^^\nError: Unbound value addPHelper\n"},{"in":"let _ = additivePersistence 9876","min":"\nlet rec additivePersistence n = failwith \"TBD\";;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":2086},"type":"eval"},"cursor":2088,"time":1.397517733855208e9,"body":"(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\nXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []     -> 0 \n  | hd::tl -> hd + sumList tl\n;;\n\nlet _ = sumList [1; 2; 3; 4];;\nlet _ = sumList [1; -2; 3; 5];;\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digithelper n l=\n  let x = n/10 in\n  let y = n mod 10 in\n    if x = 0\n    then y :: l\n    else digithelper x (y :: l)\n;;\n\nlet digitsOfInt n =\n  if n <= 0 \n  then []\n  else \n    digithelper n []\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 352663;;\nlet _ = digitsOfInt 0;;\nlet _ = digitsOfInt 1;;\nlet _ = digitsOfInt (-12);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXX*)\nlet rec addPHelper n =\n  let lst = digitsOfInt n in\n  let sum = sumList s in \n    if sum < 10\n    then sum\n    else addPHelper sum\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet additivePersistence n = \n  let n_pos = digits n in\n    addPHelper n_pos \n;;\n\nlet _ = additivePersistence 9876;;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitalRoot n = \n  let n_pos = digits n in\n  let l_sum = sumList n_pos in\n    if l_sum < 10\n    then l_sum\n    else digitalRoot l_sum\n;;\n\n\nlet _ = digitalRoot 9876;;\nlet _ = digitalRoot 12345;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet listReverse l = \n  let rec helperFun l z = match l with\n    | [] -> z\n    | hd :: tl -> helperFun tl (hd :: z)\n  in\n    helperFun l []\n;;\n\nlet _ = listReverse [1; 2; 3; 4];;\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet palindrome w = \n  let z = explode w in\n  let y = listReverse z in\n    if z = y\n    then true\n    else false\n;;\n\nlet _ = palindrome \"malayalam\";;\nlet _ = palindrome \"myxomatosis\";;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = match xs with\n| []     -> 0 \n| hd::tl -> hd + sumList tl","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec digithelper n l=\nlet x = n/10 in\nlet y = n mod 10 in\nif x = 0\nthen y :: l\nelse digithelper x (y :: l)","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n","type":"","out":""},{"in":"let digitsOfInt n =\nif n <= 0 \nthen []\nelse \ndigithelper n []","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 0","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 0;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 1","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 1;;\n","type":"","out":""},{"in":"let _ = digitsOfInt (-12)","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt (-12);;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec addPHelper n =\nlet lst = digitsOfInt n in\nlet sum = sumList sum in \nif sum < 10\nthen sum\nelse addPHelper sum","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec addPHelper n =\n  let lst = digitsOfInt n in\n  let sum = sumList sum in if sum < 10 then sum else addPHelper sum;;\n","type":"scope","out":"Characters 68-71:\n  let sum = sumList sum in \n                    ^^^\nError: Unbound value sum\n"},{"in":"let additivePersistence n = \nlet n_pos = digits n in\naddPHelper n_pos","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet additivePersistence n = let n_pos = digits n in addPHelper n_pos;;\n","type":"scope","out":"Characters 53-63:\n  addPHelper n_pos;;\n  ^^^^^^^^^^\nError: Unbound value addPHelper\n"},{"in":"let _ = additivePersistence 9876","min":"\nlet rec additivePersistence n = failwith \"TBD\";;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":2088},"type":"eval"},"cursor":2090,"time":1.397517745335913e9,"body":"(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\nXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []     -> 0 \n  | hd::tl -> hd + sumList tl\n;;\n\nlet _ = sumList [1; 2; 3; 4];;\nlet _ = sumList [1; -2; 3; 5];;\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digithelper n l=\n  let x = n/10 in\n  let y = n mod 10 in\n    if x = 0\n    then y :: l\n    else digithelper x (y :: l)\n;;\n\nlet digitsOfInt n =\n  if n <= 0 \n  then []\n  else \n    digithelper n []\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 352663;;\nlet _ = digitsOfInt 0;;\nlet _ = digitsOfInt 1;;\nlet _ = digitsOfInt (-12);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXX*)\nlet rec addPHelper n =\n  let lst = digitsOfInt n in\n  let sum = sumList sum in \n    if sum < 10\n    then sum\n    else addPHelper sum\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet additivePersistence n = \n  let n_pos = digits n in\n    addPHelper n_pos \n;;\n\nlet _ = additivePersistence 9876;;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitalRoot n = \n  let n_pos = digits n in\n  let l_sum = sumList n_pos in\n    if l_sum < 10\n    then l_sum\n    else digitalRoot l_sum\n;;\n\n\nlet _ = digitalRoot 9876;;\nlet _ = digitalRoot 12345;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet listReverse l = \n  let rec helperFun l z = match l with\n    | [] -> z\n    | hd :: tl -> helperFun tl (hd :: z)\n  in\n    helperFun l []\n;;\n\nlet _ = listReverse [1; 2; 3; 4];;\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet palindrome w = \n  let z = explode w in\n  let y = listReverse z in\n    if z = y\n    then true\n    else false\n;;\n\nlet _ = palindrome \"malayalam\";;\nlet _ = palindrome \"myxomatosis\";;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = match xs with\n| []     -> 0 \n| hd::tl -> hd + sumList tl","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec digithelper n l=\nlet x = n/10 in\nlet y = n mod 10 in\nif x = 0\nthen y :: l\nelse digithelper x (y :: l)","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n","type":"","out":""},{"in":"let digitsOfInt n =\nif n <= 0 \nthen []\nelse \ndigithelper n []","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 0","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 0;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 1","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 1;;\n","type":"","out":""},{"in":"let _ = digitsOfInt (-12)","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt (-12);;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec addPHelper n =\nlet lst = digitsOfInt n in\nlet sum = sumList lst in \nif sum < 10\nthen sum\nelse addPHelper sum","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec addPHelper n =\n  let lst = digitsOfInt n in\n  let sum = sumList lst in if sum < 10 then sum else addPHelper sum;;\n","type":"","out":""},{"in":"let additivePersistence n = \nlet n_pos = digits n in\naddPHelper n_pos","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec addPHelper n =\n  let lst = digitsOfInt n in\n  let sum = sumList lst in if sum < 10 then sum else addPHelper sum;;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet additivePersistence n = let n_pos = digits n in addPHelper n_pos;;\n","type":"type","out":"Characters 64-69:\n  addPHelper n_pos;;\n             ^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n"},{"in":"let _ = additivePersistence 9876","min":"\nlet rec additivePersistence n = failwith \"TBD\";;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":2088},"type":"eval"},"cursor":2090,"time":1.397517756122795e9,"body":"(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\nXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []     -> 0 \n  | hd::tl -> hd + sumList tl\n;;\n\nlet _ = sumList [1; 2; 3; 4];;\nlet _ = sumList [1; -2; 3; 5];;\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digithelper n l=\n  let x = n/10 in\n  let y = n mod 10 in\n    if x = 0\n    then y :: l\n    else digithelper x (y :: l)\n;;\n\nlet digitsOfInt n =\n  if n <= 0 \n  then []\n  else \n    digithelper n []\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 352663;;\nlet _ = digitsOfInt 0;;\nlet _ = digitsOfInt 1;;\nlet _ = digitsOfInt (-12);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXX*)\nlet rec addPHelper n =\n  let lst = digitsOfInt n in\n  let sum = sumList lst in \n    if sum < 10\n    then sum\n    else addPHelper sum\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet additivePersistence n = \n  let n_pos = digits n in\n    addPHelper n_pos \n;;\n\nlet _ = additivePersistence 9876;;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitalRoot n = \n  let n_pos = digits n in\n  let l_sum = sumList n_pos in\n    if l_sum < 10\n    then l_sum\n    else digitalRoot l_sum\n;;\n\n\nlet _ = digitalRoot 9876;;\nlet _ = digitalRoot 12345;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet listReverse l = \n  let rec helperFun l z = match l with\n    | [] -> z\n    | hd :: tl -> helperFun tl (hd :: z)\n  in\n    helperFun l []\n;;\n\nlet _ = listReverse [1; 2; 3; 4];;\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet palindrome w = \n  let z = explode w in\n  let y = listReverse z in\n    if z = y\n    then true\n    else false\n;;\n\nlet _ = palindrome \"malayalam\";;\nlet _ = palindrome \"myxomatosis\";;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = match xs with\n| []     -> 0 \n| hd::tl -> hd + sumList tl","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec digithelper n l=\nlet x = n/10 in\nlet y = n mod 10 in\nif x = 0\nthen y :: l\nelse digithelper x (y :: l)","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n","type":"","out":""},{"in":"let digitsOfInt n =\nif n <= 0 \nthen []\nelse \ndigithelper n []","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 0","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 0;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 1","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 1;;\n","type":"","out":""},{"in":"let _ = digitsOfInt (-12)","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt (-12);;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec addPHelper n =\nlet lst = digitsOfInt n in\nlet sum = sumList lst in \nif sum < 10\nthen sum\nelse addPHelper sum","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec addPHelper n =\n  let lst = digitsOfInt n in\n  let sum = sumList lst in if sum < 10 then sum else addPHelper sum;;\n","type":"","out":""},{"in":"let additivePersistence n = \nlet pos = digits n in\naddPHelper pos","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec addPHelper n =\n  let lst = digitsOfInt n in\n  let sum = sumList lst in if sum < 10 then sum else addPHelper sum;;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet additivePersistence n = let pos = digits n in addPHelper pos;;\n","type":"type","out":"Characters 62-65:\n  addPHelper pos;;\n             ^^^\nError: This expression has type int list\n       but an expression was expected of type int\n"}],"event":{"region":{"start":0,"stop":2046},"type":"eval"},"cursor":2050,"time":1.397517798433728e9,"body":"(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\nXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []     -> 0 \n  | hd::tl -> hd + sumList tl\n;;\n\nlet _ = sumList [1; 2; 3; 4];;\nlet _ = sumList [1; -2; 3; 5];;\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digithelper n l=\n  let x = n/10 in\n  let y = n mod 10 in\n    if x = 0\n    then y :: l\n    else digithelper x (y :: l)\n;;\n\nlet digitsOfInt n =\n  if n <= 0 \n  then []\n  else \n    digithelper n []\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 352663;;\nlet _ = digitsOfInt 0;;\nlet _ = digitsOfInt 1;;\nlet _ = digitsOfInt (-12);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXX*)\nlet rec addPHelper n =\n  let lst = digitsOfInt n in\n  let sum = sumList lst in \n    if sum < 10\n    then sum\n    else addPHelper sum\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet additivePersistence n = \n  let pos = digits n in\n    addPHelper pos \n;;\n\nlet _ = additivePersistence 9876;;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitalRoot n = \n  let n_pos = digits n in\n  let l_sum = sumList n_pos in\n    if l_sum < 10\n    then l_sum\n    else digitalRoot l_sum\n;;\n\n\nlet _ = digitalRoot 9876;;\nlet _ = digitalRoot 12345;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet listReverse l = \n  let rec helperFun l z = match l with\n    | [] -> z\n    | hd :: tl -> helperFun tl (hd :: z)\n  in\n    helperFun l []\n;;\n\nlet _ = listReverse [1; 2; 3; 4];;\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet palindrome w = \n  let z = explode w in\n  let y = listReverse z in\n    if z = y\n    then true\n    else false\n;;\n\nlet _ = palindrome \"malayalam\";;\nlet _ = palindrome \"myxomatosis\";;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec addPHelper n pos =\nlet sum = sumList pos in \nif sum < 10\nthen sum\nelse addPHelper sum","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec addPHelper n pos =\n  let sum = sumList pos in if sum < 10 then sum else addPHelper sum;;\n","type":"type","out":"Characters 79-93:\n  else addPHelper sum;;\n       ^^^^^^^^^^^^^^\nError: This expression has type int list -> int\n       but an expression was expected of type int\n"},{"in":"let additivePersistence n = \nlet pos = digits n in\naddPHelper n pos","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec addPHelper n =\n  let lst = digitsOfInt n in\n  let sum = sumList lst in if sum < 10 then sum else addPHelper sum;;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet additivePersistence n = let pos = digits n in addPHelper n pos;;\n","type":"type","out":"Characters 51-61:\n  addPHelper n pos;;\n  ^^^^^^^^^^\nError: This function has type int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"},{"in":"let _ = additivePersistence 9876","min":"\nlet rec additivePersistence n = failwith \"TBD\";;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""}],"event":{"region":{"start":1142,"stop":2063},"type":"eval"},"cursor":2065,"time":1.397517971657472e9,"body":"(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\nXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []     -> 0 \n  | hd::tl -> hd + sumList tl\n;;\n\nlet _ = sumList [1; 2; 3; 4];;\nlet _ = sumList [1; -2; 3; 5];;\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digithelper n l=\n  let x = n/10 in\n  let y = n mod 10 in\n    if x = 0\n    then y :: l\n    else digithelper x (y :: l)\n;;\n\nlet digitsOfInt n =\n  if n <= 0 \n  then []\n  else \n    digithelper n []\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 352663;;\nlet _ = digitsOfInt 0;;\nlet _ = digitsOfInt 1;;\nlet _ = digitsOfInt (-12);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXX*)\nlet rec addPHelper n pos =\n  let sum = sumList pos in \n    if sum < 10\n    then sum\n    else addPHelper sum\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet additivePersistence n = \n  let pos = digits n in\n    addPHelper n pos \n;;\n\nlet _ = additivePersistence 9876;;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitalRoot n = \n  let n_pos = digits n in\n  let l_sum = sumList n_pos in\n    if l_sum < 10\n    then l_sum\n    else digitalRoot l_sum\n;;\n\n\nlet _ = digitalRoot 9876;;\nlet _ = digitalRoot 12345;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet listReverse l = \n  let rec helperFun l z = match l with\n    | [] -> z\n    | hd :: tl -> helperFun tl (hd :: z)\n  in\n    helperFun l []\n;;\n\nlet _ = listReverse [1; 2; 3; 4];;\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet palindrome w = \n  let z = explode w in\n  let y = listReverse z in\n    if z = y\n    then true\n    else false\n;;\n\nlet _ = palindrome \"malayalam\";;\nlet _ = palindrome \"myxomatosis\";;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec addPHelper n pos =\nlet sum = sumList pos in \nif sum < 10\nthen sum\nelse addPHelper sum pos","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec addPHelper n pos =\n  let sum = sumList pos in if sum < 10 then sum else addPHelper sum pos;;\n","type":"","out":""},{"in":"let additivePersistence n = \nlet pos = digits n in\naddPHelper n pos","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec addPHelper n pos =\n  let sum = sumList pos in if sum < 10 then sum else addPHelper sum pos;;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet additivePersistence n = let pos = digits n in addPHelper n pos;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9876","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec addPHelper n pos =\n  let sum = sumList pos in if sum < 10 then sum else addPHelper sum pos;;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet additivePersistence n = let pos = digits n in addPHelper n pos;;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""}],"event":{"region":{"start":1142,"stop":2067},"type":"eval"},"cursor":2069,"time":1.397517993474912e9,"body":"(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\nXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []     -> 0 \n  | hd::tl -> hd + sumList tl\n;;\n\nlet _ = sumList [1; 2; 3; 4];;\nlet _ = sumList [1; -2; 3; 5];;\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digithelper n l=\n  let x = n/10 in\n  let y = n mod 10 in\n    if x = 0\n    then y :: l\n    else digithelper x (y :: l)\n;;\n\nlet digitsOfInt n =\n  if n <= 0 \n  then []\n  else \n    digithelper n []\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 352663;;\nlet _ = digitsOfInt 0;;\nlet _ = digitsOfInt 1;;\nlet _ = digitsOfInt (-12);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXX*)\nlet rec addPHelper n pos =\n  let sum = sumList pos in \n    if sum < 10\n    then sum\n    else addPHelper sum pos\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet additivePersistence n = \n  let pos = digits n in\n    addPHelper n pos \n;;\n\nlet _ = additivePersistence 9876;;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitalRoot n = \n  let n_pos = digits n in\n  let l_sum = sumList n_pos in\n    if l_sum < 10\n    then l_sum\n    else digitalRoot l_sum\n;;\n\n\nlet _ = digitalRoot 9876;;\nlet _ = digitalRoot 12345;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet listReverse l = \n  let rec helperFun l z = match l with\n    | [] -> z\n    | hd :: tl -> helperFun tl (hd :: z)\n  in\n    helperFun l []\n;;\n\nlet _ = listReverse [1; 2; 3; 4];;\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet palindrome w = \n  let z = explode w in\n  let y = listReverse z in\n    if z = y\n    then true\n    else false\n;;\n\nlet _ = palindrome \"malayalam\";;\nlet _ = palindrome \"myxomatosis\";;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = match xs with\n| []     -> 0 \n| hd::tl -> hd + sumList tl","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec digithelper n l=\nlet x = n/10 in\nlet y = n mod 10 in\nif x = 0\nthen y :: l\nelse digithelper x (y :: l)","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n","type":"","out":""},{"in":"let digitsOfInt n =\nif n <= 0 \nthen []\nelse \ndigithelper n []","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 0","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 0;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 1","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 1;;\n","type":"","out":""},{"in":"let _ = digitsOfInt (-12)","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt (-12);;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec addPHelper n =\nlet n_pos = digits n in\nlet sum = sumList n_pos in \nif sum < 10\nthen sum\nelse addPHelper sum","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec addPHelper n =\n  let n_pos = digits n in\n  let sum = sumList n_pos in if sum < 10 then sum else addPHelper sum;;\n","type":"","out":""},{"in":"let additivePersistence n = \naddPHelper n","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec addPHelper n =\n  let n_pos = digits n in\n  let sum = sumList n_pos in if sum < 10 then sum else addPHelper sum;;\n\nlet additivePersistence n = addPHelper n;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9876","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec addPHelper n =\n  let n_pos = digits n in\n  let sum = sumList n_pos in if sum < 10 then sum else addPHelper sum;;\n\nlet additivePersistence n = addPHelper n;;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":2058},"type":"eval"},"cursor":2060,"time":1.397518075197224e9,"body":"(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\nXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []     -> 0 \n  | hd::tl -> hd + sumList tl\n;;\n\nlet _ = sumList [1; 2; 3; 4];;\nlet _ = sumList [1; -2; 3; 5];;\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digithelper n l=\n  let x = n/10 in\n  let y = n mod 10 in\n    if x = 0\n    then y :: l\n    else digithelper x (y :: l)\n;;\n\nlet digitsOfInt n =\n  if n <= 0 \n  then []\n  else \n    digithelper n []\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 352663;;\nlet _ = digitsOfInt 0;;\nlet _ = digitsOfInt 1;;\nlet _ = digitsOfInt (-12);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXX*)\nlet rec addPHelper n =\n  let n_pos = digits n in\n  let sum = sumList n_pos in \n    if sum < 10\n    then sum\n    else addPHelper sum\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet additivePersistence n = \n  addPHelper n\n;;\n\nlet _ = additivePersistence 9876;;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitalRoot n = \n  let n_pos = digits n in\n  let l_sum = sumList n_pos in\n    if l_sum < 10\n    then l_sum\n    else digitalRoot l_sum\n;;\n\n\nlet _ = digitalRoot 9876;;\nlet _ = digitalRoot 12345;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet listReverse l = \n  let rec helperFun l z = match l with\n    | [] -> z\n    | hd :: tl -> helperFun tl (hd :: z)\n  in\n    helperFun l []\n;;\n\nlet _ = listReverse [1; 2; 3; 4];;\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet palindrome w = \n  let z = explode w in\n  let y = listReverse z in\n    if z = y\n    then true\n    else false\n;;\n\nlet _ = palindrome \"malayalam\";;\nlet _ = palindrome \"myxomatosis\";;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec addPHelper n =\nlet n_pos = digits n in\nlet sum = sumList n_pos in \nlet count = count + 1 in\nif sum < 10\nthen count\nelse addPHelper sum and count = count + 1","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec addPHelper n =\n  let n_pos = digits n in\n  let sum = sumList n_pos in\n  let count = count + 1 in if sum < 10 then count else addPHelper sum\nand count = count + 1;;\n","type":"","out":""},{"in":"let additivePersistence n = \naddPHelper n","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec addPHelper n =\n  let n_pos = digits n in\n  let sum = sumList n_pos in\n  let count = count + 1 in if sum < 10 then count else addPHelper sum\nand count = count + 1;;\n\nlet additivePersistence n = addPHelper n;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9876","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec addPHelper n =\n  let n_pos = digits n in\n  let sum = sumList n_pos in\n  let count = count + 1 in if sum < 10 then count else addPHelper sum\nand count = count + 1;;\n\nlet additivePersistence n = addPHelper n;;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""}],"event":{"region":{"start":1142,"stop":2108},"type":"eval"},"cursor":2110,"time":1.397518292413484e9,"body":"(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\nXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []     -> 0 \n  | hd::tl -> hd + sumList tl\n;;\n\nlet _ = sumList [1; 2; 3; 4];;\nlet _ = sumList [1; -2; 3; 5];;\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digithelper n l=\n  let x = n/10 in\n  let y = n mod 10 in\n    if x = 0\n    then y :: l\n    else digithelper x (y :: l)\n;;\n\nlet digitsOfInt n =\n  if n <= 0 \n  then []\n  else \n    digithelper n []\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 352663;;\nlet _ = digitsOfInt 0;;\nlet _ = digitsOfInt 1;;\nlet _ = digitsOfInt (-12);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXX*)\nlet rec addPHelper n =\n  let n_pos = digits n in\n  let sum = sumList n_pos in \n  let count = count + 1 in\n    if sum < 10\n    then count\n    else addPHelper sum and count = count + 1\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet additivePersistence n = \n  addPHelper n \n;;\n\nlet _ = additivePersistence 9876;;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitalRoot n = \n  let n_pos = digits n in\n  let l_sum = sumList n_pos in\n    if l_sum < 10\n    then l_sum\n    else digitalRoot l_sum\n;;\n\n\nlet _ = digitalRoot 9876;;\nlet _ = digitalRoot 12345;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet listReverse l = \n  let rec helperFun l z = match l with\n    | [] -> z\n    | hd :: tl -> helperFun tl (hd :: z)\n  in\n    helperFun l []\n;;\n\nlet _ = listReverse [1; 2; 3; 4];;\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet palindrome w = \n  let z = explode w in\n  let y = listReverse z in\n    if z = y\n    then true\n    else false\n;;\n\nlet _ = palindrome \"malayalam\";;\nlet _ = palindrome \"myxomatosis\";;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec addPHelper n =\nlet n_pos = digits n in\nlet sum = sumList n_pos in \nlet count = count + 1 in\nif sum < 10\nthen count\nelse addPHelper sum","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet rec addPHelper n =\n  let n_pos = digits n in\n  let sum = sumList n_pos in\n  let count = count + 1 in if sum < 10 then count else addPHelper sum\nand count = count + 1;;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec addPHelper n =\n  let n_pos = digits n in\n  let sum = sumList n_pos in\n  let count = count + 1 in if sum < 10 then count else addPHelper sum;;\n","type":"","out":""}],"event":{"region":{"start":1142,"stop":1963},"type":"eval"},"cursor":1943,"time":1.397518303133006e9,"body":"(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\nXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []     -> 0 \n  | hd::tl -> hd + sumList tl\n;;\n\nlet _ = sumList [1; 2; 3; 4];;\nlet _ = sumList [1; -2; 3; 5];;\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digithelper n l=\n  let x = n/10 in\n  let y = n mod 10 in\n    if x = 0\n    then y :: l\n    else digithelper x (y :: l)\n;;\n\nlet digitsOfInt n =\n  if n <= 0 \n  then []\n  else \n    digithelper n []\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 352663;;\nlet _ = digitsOfInt 0;;\nlet _ = digitsOfInt 1;;\nlet _ = digitsOfInt (-12);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXX*)\nlet rec addPHelper n =\n  let n_pos = digits n in\n  let sum = sumList n_pos in \n  let count = count + 1 in\n    if sum < 10\n    then count\n    else addPHelper sum \n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet additivePersistence n = \n  addPHelper n \n;;\n\nlet _ = additivePersistence 9876;;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitalRoot n = \n  let n_pos = digits n in\n  let l_sum = sumList n_pos in\n    if l_sum < 10\n    then l_sum\n    else digitalRoot l_sum\n;;\n\n\nlet _ = digitalRoot 9876;;\nlet _ = digitalRoot 12345;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet listReverse l = \n  let rec helperFun l z = match l with\n    | [] -> z\n    | hd :: tl -> helperFun tl (hd :: z)\n  in\n    helperFun l []\n;;\n\nlet _ = listReverse [1; 2; 3; 4];;\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet palindrome w = \n  let z = explode w in\n  let y = listReverse z in\n    if z = y\n    then true\n    else false\n;;\n\nlet _ = palindrome \"malayalam\";;\nlet _ = palindrome \"myxomatosis\";;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = match xs with\n| []     -> 0 \n| hd::tl -> hd + sumList tl","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec digithelper n l=\nlet x = n/10 in\nlet y = n mod 10 in\nif x = 0\nthen y :: l\nelse digithelper x (y :: l)","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n","type":"","out":""},{"in":"let digitsOfInt n =\nif n <= 0 \nthen []\nelse \ndigithelper n []","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 0","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 0;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 1","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 1;;\n","type":"","out":""},{"in":"let _ = digitsOfInt (-12)","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt (-12);;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec addPHelper n c=\nlet n_pos = digits n in\nlet sum = sumList n_pos in \nlet c = c + 1 in\nif sum < 10\nthen c\nelse addPHelper sum","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec addPHelper n c =\n  let n_pos = digits n in\n  let sum = sumList n_pos in\n  let c = c + 1 in if sum < 10 then c else addPHelper sum;;\n","type":"type","out":"Characters 117-131:\n  else addPHelper sum;;\n       ^^^^^^^^^^^^^^\nError: This expression has type int -> int\n       but an expression was expected of type int\n"},{"in":"let additivePersistence n c = \naddPHelper n 0","min":"","type":"scope","out":"Error: This function has type int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\nError: Unbound value digits\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 31-41:\n  addPHelper n 0;;\n  ^^^^^^^^^^\nError: This function has type int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"},{"in":"let _ = additivePersistence 9876","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec addPHelper n =\n  let n_pos = digits n in\n  let sum = sumList n_pos in\n  let count = count + 1 in if sum < 10 then count else addPHelper sum\nand count = count + 1;;\n\nlet additivePersistence n = addPHelper n;;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":2079},"type":"eval"},"cursor":2081,"time":1.397518359477128e9,"body":"(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\nXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []     -> 0 \n  | hd::tl -> hd + sumList tl\n;;\n\nlet _ = sumList [1; 2; 3; 4];;\nlet _ = sumList [1; -2; 3; 5];;\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digithelper n l=\n  let x = n/10 in\n  let y = n mod 10 in\n    if x = 0\n    then y :: l\n    else digithelper x (y :: l)\n;;\n\nlet digitsOfInt n =\n  if n <= 0 \n  then []\n  else \n    digithelper n []\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 352663;;\nlet _ = digitsOfInt 0;;\nlet _ = digitsOfInt 1;;\nlet _ = digitsOfInt (-12);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXX*)\nlet rec addPHelper n c=\n  let n_pos = digits n in\n  let sum = sumList n_pos in \n  let c = c + 1 in\n    if sum < 10\n    then c\n    else addPHelper sum \n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet additivePersistence n c = \n  addPHelper n 0\n;;\n\nlet _ = additivePersistence 9876;;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitalRoot n = \n  let n_pos = digits n in\n  let l_sum = sumList n_pos in\n    if l_sum < 10\n    then l_sum\n    else digitalRoot l_sum\n;;\n\n\nlet _ = digitalRoot 9876;;\nlet _ = digitalRoot 12345;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet listReverse l = \n  let rec helperFun l z = match l with\n    | [] -> z\n    | hd :: tl -> helperFun tl (hd :: z)\n  in\n    helperFun l []\n;;\n\nlet _ = listReverse [1; 2; 3; 4];;\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet palindrome w = \n  let z = explode w in\n  let y = listReverse z in\n    if z = y\n    then true\n    else false\n;;\n\nlet _ = palindrome \"malayalam\";;\nlet _ = palindrome \"myxomatosis\";;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = match xs with\n| []     -> 0 \n| hd::tl -> hd + sumList tl","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec digithelper n l=\nlet x = n/10 in\nlet y = n mod 10 in\nif x = 0\nthen y :: l\nelse digithelper x (y :: l)","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n","type":"","out":""},{"in":"let digitsOfInt n =\nif n <= 0 \nthen []\nelse \ndigithelper n []","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 0","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 0;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 1","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 1;;\n","type":"","out":""},{"in":"let _ = digitsOfInt (-12)","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt (-12);;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec addPHelper n c=\nlet n_pos = digits n in\nlet sum = sumList n_pos in \nlet c = c + 1 in\nif sum < 10\nthen c\nelse addPHelper sum c","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec addPHelper n c =\n  let n_pos = digits n in\n  let sum = sumList n_pos in\n  let c = c + 1 in if sum < 10 then c else addPHelper sum c;;\n","type":"","out":""},{"in":"let additivePersistence n c = \naddPHelper n 0","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec addPHelper n c =\n  let n_pos = digits n in\n  let sum = sumList n_pos in\n  let c = c + 1 in if sum < 10 then c else addPHelper sum c;;\n\nlet additivePersistence n c = addPHelper n 0;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9876","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec addPHelper n c =\n  let n_pos = digits n in\n  let sum = sumList n_pos in\n  let c = c + 1 in if sum < 10 then c else addPHelper sum c;;\n\nlet additivePersistence n c = addPHelper n 0;;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":2080},"type":"eval"},"cursor":2082,"time":1.397518382517776e9,"body":"(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\nXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []     -> 0 \n  | hd::tl -> hd + sumList tl\n;;\n\nlet _ = sumList [1; 2; 3; 4];;\nlet _ = sumList [1; -2; 3; 5];;\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digithelper n l=\n  let x = n/10 in\n  let y = n mod 10 in\n    if x = 0\n    then y :: l\n    else digithelper x (y :: l)\n;;\n\nlet digitsOfInt n =\n  if n <= 0 \n  then []\n  else \n    digithelper n []\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 352663;;\nlet _ = digitsOfInt 0;;\nlet _ = digitsOfInt 1;;\nlet _ = digitsOfInt (-12);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXX*)\nlet rec addPHelper n c=\n  let n_pos = digits n in\n  let sum = sumList n_pos in \n  let c = c + 1 in\n    if sum < 10\n    then c\n    else addPHelper sum c\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet additivePersistence n c = \n  addPHelper n 0\n;;\n\nlet _ = additivePersistence 9876;;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitalRoot n = \n  let n_pos = digits n in\n  let l_sum = sumList n_pos in\n    if l_sum < 10\n    then l_sum\n    else digitalRoot l_sum\n;;\n\n\nlet _ = digitalRoot 9876;;\nlet _ = digitalRoot 12345;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet listReverse l = \n  let rec helperFun l z = match l with\n    | [] -> z\n    | hd :: tl -> helperFun tl (hd :: z)\n  in\n    helperFun l []\n;;\n\nlet _ = listReverse [1; 2; 3; 4];;\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet palindrome w = \n  let z = explode w in\n  let y = listReverse z in\n    if z = y\n    then true\n    else false\n;;\n\nlet _ = palindrome \"malayalam\";;\nlet _ = palindrome \"myxomatosis\";;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec addPHelper n c=\nlet n_pos = digits n in\nlet sum = sumList n_pos in \nlet c = c + 1 in\nif sum > 10\nthen c\nelse addPHelper sum c","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec addPHelper n c =\n  let n_pos = digits n in\n  let sum = sumList n_pos in\n  let c = c + 1 in if sum > 10 then c else addPHelper sum c;;\n","type":"","out":""},{"in":"let additivePersistence n c = \naddPHelper n 0","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec addPHelper n c =\n  let n_pos = digits n in\n  let sum = sumList n_pos in\n  let c = c + 1 in if sum > 10 then c else addPHelper sum c;;\n\nlet additivePersistence n c = addPHelper n 0;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9876","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec addPHelper n c =\n  let n_pos = digits n in\n  let sum = sumList n_pos in\n  let c = c + 1 in if sum > 10 then c else addPHelper sum c;;\n\nlet additivePersistence n c = addPHelper n 0;;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""}],"event":{"region":{"start":1142,"stop":2080},"type":"eval"},"cursor":2082,"time":1.397518426023617e9,"body":"(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\nXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []     -> 0 \n  | hd::tl -> hd + sumList tl\n;;\n\nlet _ = sumList [1; 2; 3; 4];;\nlet _ = sumList [1; -2; 3; 5];;\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digithelper n l=\n  let x = n/10 in\n  let y = n mod 10 in\n    if x = 0\n    then y :: l\n    else digithelper x (y :: l)\n;;\n\nlet digitsOfInt n =\n  if n <= 0 \n  then []\n  else \n    digithelper n []\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 352663;;\nlet _ = digitsOfInt 0;;\nlet _ = digitsOfInt 1;;\nlet _ = digitsOfInt (-12);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXX*)\nlet rec addPHelper n c=\n  let n_pos = digits n in\n  let sum = sumList n_pos in \n  let c = c + 1 in\n    if sum > 10\n    then c\n    else addPHelper sum c\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet additivePersistence n c = \n  addPHelper n 0\n;;\n\nlet _ = additivePersistence 9876;;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitalRoot n = \n  let n_pos = digits n in\n  let l_sum = sumList n_pos in\n    if l_sum < 10\n    then l_sum\n    else digitalRoot l_sum\n;;\n\n\nlet _ = digitalRoot 9876;;\nlet _ = digitalRoot 12345;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet listReverse l = \n  let rec helperFun l z = match l with\n    | [] -> z\n    | hd :: tl -> helperFun tl (hd :: z)\n  in\n    helperFun l []\n;;\n\nlet _ = listReverse [1; 2; 3; 4];;\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet palindrome w = \n  let z = explode w in\n  let y = listReverse z in\n    if z = y\n    then true\n    else false\n;;\n\nlet _ = palindrome \"malayalam\";;\nlet _ = palindrome \"myxomatosis\";;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec addPHelper n c=\nlet n_pos = digits n in\nlet sum = sumList n_pos in \nc + 1 \nif sum > 10\nthen c\nelse addPHelper sum c","min":"","type":"syntax","out":"Characters 83-85:\n  if sum > 10\n  ^^\nError: Syntax error\n"},{"in":"let additivePersistence n c = \naddPHelper n 0","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec addPHelper n c =\n  let n_pos = digits n in\n  let sum = sumList n_pos in\n  let c = c + 1 in if sum > 10 then c else addPHelper sum c;;\n\nlet additivePersistence n c = addPHelper n 0;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9876","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec addPHelper n c =\n  let n_pos = digits n in\n  let sum = sumList n_pos in\n  let c = c + 1 in if sum > 10 then c else addPHelper sum c;;\n\nlet additivePersistence n c = addPHelper n 0;;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""}],"event":{"region":{"start":1142,"stop":2070},"type":"eval"},"cursor":2072,"time":1.397518459277181e9,"body":"(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\nXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []     -> 0 \n  | hd::tl -> hd + sumList tl\n;;\n\nlet _ = sumList [1; 2; 3; 4];;\nlet _ = sumList [1; -2; 3; 5];;\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digithelper n l=\n  let x = n/10 in\n  let y = n mod 10 in\n    if x = 0\n    then y :: l\n    else digithelper x (y :: l)\n;;\n\nlet digitsOfInt n =\n  if n <= 0 \n  then []\n  else \n    digithelper n []\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 352663;;\nlet _ = digitsOfInt 0;;\nlet _ = digitsOfInt 1;;\nlet _ = digitsOfInt (-12);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXX*)\nlet rec addPHelper n c=\n  let n_pos = digits n in\n  let sum = sumList n_pos in \n    c + 1 \n          if sum > 10\n          then c\n          else addPHelper sum c\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet additivePersistence n c = \n  addPHelper n 0\n;;\n\nlet _ = additivePersistence 9876;;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitalRoot n = \n  let n_pos = digits n in\n  let l_sum = sumList n_pos in\n    if l_sum < 10\n    then l_sum\n    else digitalRoot l_sum\n;;\n\n\nlet _ = digitalRoot 9876;;\nlet _ = digitalRoot 12345;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet listReverse l = \n  let rec helperFun l z = match l with\n    | [] -> z\n    | hd :: tl -> helperFun tl (hd :: z)\n  in\n    helperFun l []\n;;\n\nlet _ = listReverse [1; 2; 3; 4];;\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet palindrome w = \n  let z = explode w in\n  let y = listReverse z in\n    if z = y\n    then true\n    else false\n;;\n\nlet _ = palindrome \"malayalam\";;\nlet _ = palindrome \"myxomatosis\";;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = match xs with\n| []     -> 0 \n| hd::tl -> hd + sumList tl","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec digithelper n l=\nlet x = n/10 in\nlet y = n mod 10 in\nif x = 0\nthen y :: l\nelse digithelper x (y :: l)","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n","type":"","out":""},{"in":"let digitsOfInt n =\nif n <= 0 \nthen []\nelse \ndigithelper n []","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 0","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 0;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 1","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 1;;\n","type":"","out":""},{"in":"let _ = digitsOfInt (-12)","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt (-12);;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec addPHelper n c=\nlet n_pos = digits n in\nlet sum = sumList n_pos in \nif sum < 10\nthen c\nelse addPHelper sum (c+1)","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec addPHelper n c =\n  let n_pos = digits n in\n  let sum = sumList n_pos in if sum < 10 then c else addPHelper sum (c + 1);;\n","type":"","out":""},{"in":"let additivePersistence n c = \naddPHelper n 0","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec addPHelper n c =\n  let n_pos = digits n in\n  let sum = sumList n_pos in if sum < 10 then c else addPHelper sum (c + 1);;\n\nlet additivePersistence n c = addPHelper n 0;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9876","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec addPHelper n c =\n  let n_pos = digits n in\n  let sum = sumList n_pos in if sum < 10 then c else addPHelper sum (c + 1);;\n\nlet additivePersistence n c = addPHelper n 0;;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":2067},"type":"eval"},"cursor":2069,"time":1.397518490826575e9,"body":"(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\nXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []     -> 0 \n  | hd::tl -> hd + sumList tl\n;;\n\nlet _ = sumList [1; 2; 3; 4];;\nlet _ = sumList [1; -2; 3; 5];;\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digithelper n l=\n  let x = n/10 in\n  let y = n mod 10 in\n    if x = 0\n    then y :: l\n    else digithelper x (y :: l)\n;;\n\nlet digitsOfInt n =\n  if n <= 0 \n  then []\n  else \n    digithelper n []\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 352663;;\nlet _ = digitsOfInt 0;;\nlet _ = digitsOfInt 1;;\nlet _ = digitsOfInt (-12);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXX*)\nlet rec addPHelper n c=\n  let n_pos = digits n in\n  let sum = sumList n_pos in \n    if sum < 10\n    then c\n    else addPHelper sum (c+1)\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet additivePersistence n c = \n  addPHelper n 0\n;;\n\nlet _ = additivePersistence 9876;;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitalRoot n = \n  let n_pos = digits n in\n  let l_sum = sumList n_pos in\n    if l_sum < 10\n    then l_sum\n    else digitalRoot l_sum\n;;\n\n\nlet _ = digitalRoot 9876;;\nlet _ = digitalRoot 12345;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet listReverse l = \n  let rec helperFun l z = match l with\n    | [] -> z\n    | hd :: tl -> helperFun tl (hd :: z)\n  in\n    helperFun l []\n;;\n\nlet _ = listReverse [1; 2; 3; 4];;\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet palindrome w = \n  let z = explode w in\n  let y = listReverse z in\n    if z = y\n    then true\n    else false\n;;\n\nlet _ = palindrome \"malayalam\";;\nlet _ = palindrome \"myxomatosis\";;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec addPHelper n c =\nlet n_pos = digits n in\nlet sum = sumList n_pos in \nif sum < 10\nthen c\nelse addPHelper sum (c+1)","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec addPHelper n c =\n  let n_pos = digits n in\n  let sum = sumList n_pos in if sum < 10 then c else addPHelper sum (c + 1);;\n","type":"","out":""},{"in":"let additivePersistence n c = \naddPHelper n 0","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec addPHelper n c =\n  let n_pos = digits n in\n  let sum = sumList n_pos in if sum < 10 then c else addPHelper sum (c + 1);;\n\nlet additivePersistence n c = addPHelper n 0;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9876","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec addPHelper n c =\n  let n_pos = digits n in\n  let sum = sumList n_pos in if sum < 10 then c else addPHelper sum (c + 1);;\n\nlet additivePersistence n c = addPHelper n 0;;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""}],"event":{"region":{"start":1142,"stop":2067},"type":"eval"},"cursor":2069,"time":1.39751854094509e9,"body":"(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\nXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []     -> 0 \n  | hd::tl -> hd + sumList tl\n;;\n\nlet _ = sumList [1; 2; 3; 4];;\nlet _ = sumList [1; -2; 3; 5];;\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digithelper n l=\n  let x = n/10 in\n  let y = n mod 10 in\n    if x = 0\n    then y :: l\n    else digithelper x (y :: l)\n;;\n\nlet digitsOfInt n =\n  if n <= 0 \n  then []\n  else \n    digithelper n []\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 352663;;\nlet _ = digitsOfInt 0;;\nlet _ = digitsOfInt 1;;\nlet _ = digitsOfInt (-12);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXX*)\nlet rec addPHelper n c =\n  let n_pos = digits n in\n  let sum = sumList n_pos in \n    if sum < 10\n    then c\n    else addPHelper sum (c+1)\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet additivePersistence n c = \n  addPHelper n 0\n;;\n\nlet _ = additivePersistence 9876;;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitalRoot n = \n  let n_pos = digits n in\n  let l_sum = sumList n_pos in\n    if l_sum < 10\n    then l_sum\n    else digitalRoot l_sum\n;;\n\n\nlet _ = digitalRoot 9876;;\nlet _ = digitalRoot 12345;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet listReverse l = \n  let rec helperFun l z = match l with\n    | [] -> z\n    | hd :: tl -> helperFun tl (hd :: z)\n  in\n    helperFun l []\n;;\n\nlet _ = listReverse [1; 2; 3; 4];;\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet palindrome w = \n  let z = explode w in\n  let y = listReverse z in\n    if z = y\n    then true\n    else false\n;;\n\nlet _ = palindrome \"malayalam\";;\nlet _ = palindrome \"myxomatosis\";;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let additivePersistence n = \naddPHelper n 0","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec addPHelper n c =\n  let n_pos = digits n in\n  let sum = sumList n_pos in if sum < 10 then c else addPHelper sum (c + 1);;\n\nlet additivePersistence n = addPHelper n 0;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9876","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec addPHelper n c =\n  let n_pos = digits n in\n  let sum = sumList n_pos in if sum < 10 then c else addPHelper sum (c + 1);;\n\nlet additivePersistence n = addPHelper n 0;;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""}],"event":{"region":{"start":1942,"stop":2065},"type":"eval"},"cursor":2067,"time":1.397518578523971e9,"body":"(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\nXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []     -> 0 \n  | hd::tl -> hd + sumList tl\n;;\n\nlet _ = sumList [1; 2; 3; 4];;\nlet _ = sumList [1; -2; 3; 5];;\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digithelper n l=\n  let x = n/10 in\n  let y = n mod 10 in\n    if x = 0\n    then y :: l\n    else digithelper x (y :: l)\n;;\n\nlet digitsOfInt n =\n  if n <= 0 \n  then []\n  else \n    digithelper n []\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 352663;;\nlet _ = digitsOfInt 0;;\nlet _ = digitsOfInt 1;;\nlet _ = digitsOfInt (-12);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXX*)\nlet rec addPHelper n c =\n  let n_pos = digits n in\n  let sum = sumList n_pos in \n    if sum < 10\n    then c\n    else addPHelper sum (c+1)\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet additivePersistence n = \n  addPHelper n 0\n;;\n\nlet _ = additivePersistence 9876;;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitalRoot n = \n  let n_pos = digits n in\n  let l_sum = sumList n_pos in\n    if l_sum < 10\n    then l_sum\n    else digitalRoot l_sum\n;;\n\n\nlet _ = digitalRoot 9876;;\nlet _ = digitalRoot 12345;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet listReverse l = \n  let rec helperFun l z = match l with\n    | [] -> z\n    | hd :: tl -> helperFun tl (hd :: z)\n  in\n    helperFun l []\n;;\n\nlet _ = listReverse [1; 2; 3; 4];;\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet palindrome w = \n  let z = explode w in\n  let y = listReverse z in\n    if z = y\n    then true\n    else false\n;;\n\nlet _ = palindrome \"malayalam\";;\nlet _ = palindrome \"myxomatosis\";;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec addPHelper n c =\nlet n_pos = digits n in\nlet sum = sumList n_pos in \nif sum < 10\nthen c\nelse addPHelper sum (c+2)","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec addPHelper n c =\n  let n_pos = digits n in\n  let sum = sumList n_pos in if sum < 10 then c else addPHelper sum (c + 2);;\n","type":"","out":""},{"in":"let additivePersistence n = \naddPHelper n 0","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec addPHelper n c =\n  let n_pos = digits n in\n  let sum = sumList n_pos in if sum < 10 then c else addPHelper sum (c + 2);;\n\nlet additivePersistence n = addPHelper n 0;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9876","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec addPHelper n c =\n  let n_pos = digits n in\n  let sum = sumList n_pos in if sum < 10 then c else addPHelper sum (c + 2);;\n\nlet additivePersistence n = addPHelper n 0;;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""}],"event":{"region":{"start":1142,"stop":2065},"type":"eval"},"cursor":2067,"time":1.397518597502834e9,"body":"(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\nXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []     -> 0 \n  | hd::tl -> hd + sumList tl\n;;\n\nlet _ = sumList [1; 2; 3; 4];;\nlet _ = sumList [1; -2; 3; 5];;\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digithelper n l=\n  let x = n/10 in\n  let y = n mod 10 in\n    if x = 0\n    then y :: l\n    else digithelper x (y :: l)\n;;\n\nlet digitsOfInt n =\n  if n <= 0 \n  then []\n  else \n    digithelper n []\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 352663;;\nlet _ = digitsOfInt 0;;\nlet _ = digitsOfInt 1;;\nlet _ = digitsOfInt (-12);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXX*)\nlet rec addPHelper n c =\n  let n_pos = digits n in\n  let sum = sumList n_pos in \n    if sum < 10\n    then c\n    else addPHelper sum (c+2)\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet additivePersistence n = \n  addPHelper n 0\n;;\n\nlet _ = additivePersistence 9876;;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitalRoot n = \n  let n_pos = digits n in\n  let l_sum = sumList n_pos in\n    if l_sum < 10\n    then l_sum\n    else digitalRoot l_sum\n;;\n\n\nlet _ = digitalRoot 9876;;\nlet _ = digitalRoot 12345;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet listReverse l = \n  let rec helperFun l z = match l with\n    | [] -> z\n    | hd :: tl -> helperFun tl (hd :: z)\n  in\n    helperFun l []\n;;\n\nlet _ = listReverse [1; 2; 3; 4];;\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet palindrome w = \n  let z = explode w in\n  let y = listReverse z in\n    if z = y\n    then true\n    else false\n;;\n\nlet _ = palindrome \"malayalam\";;\nlet _ = palindrome \"myxomatosis\";;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec addPHelper n c =\nlet n_pos = digits n in\nlet sum = sumList n_pos in \nif sum < 10\nthen c\nelse addPHelper sum (c+1)","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec addPHelper n c =\n  let n_pos = digits n in\n  let sum = sumList n_pos in if sum < 10 then c else addPHelper sum (c + 1);;\n","type":"","out":""},{"in":"let additivePersistence n = \naddPHelper n 1","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec addPHelper n c =\n  let n_pos = digits n in\n  let sum = sumList n_pos in if sum < 10 then c else addPHelper sum (c + 1);;\n\nlet additivePersistence n = addPHelper n 1;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9876","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec addPHelper n c =\n  let n_pos = digits n in\n  let sum = sumList n_pos in if sum < 10 then c else addPHelper sum (c + 1);;\n\nlet additivePersistence n = addPHelper n 1;;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""}],"event":{"region":{"start":1142,"stop":2065},"type":"eval"},"cursor":2067,"time":1.397518620835562e9,"body":"(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\nXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []     -> 0 \n  | hd::tl -> hd + sumList tl\n;;\n\nlet _ = sumList [1; 2; 3; 4];;\nlet _ = sumList [1; -2; 3; 5];;\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digithelper n l=\n  let x = n/10 in\n  let y = n mod 10 in\n    if x = 0\n    then y :: l\n    else digithelper x (y :: l)\n;;\n\nlet digitsOfInt n =\n  if n <= 0 \n  then []\n  else \n    digithelper n []\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 352663;;\nlet _ = digitsOfInt 0;;\nlet _ = digitsOfInt 1;;\nlet _ = digitsOfInt (-12);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXX*)\nlet rec addPHelper n c =\n  let n_pos = digits n in\n  let sum = sumList n_pos in \n    if sum < 10\n    then c\n    else addPHelper sum (c+1)\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet additivePersistence n = \n  addPHelper n 1\n;;\n\nlet _ = additivePersistence 9876;;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitalRoot n = \n  let n_pos = digits n in\n  let l_sum = sumList n_pos in\n    if l_sum < 10\n    then l_sum\n    else digitalRoot l_sum\n;;\n\n\nlet _ = digitalRoot 9876;;\nlet _ = digitalRoot 12345;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet listReverse l = \n  let rec helperFun l z = match l with\n    | [] -> z\n    | hd :: tl -> helperFun tl (hd :: z)\n  in\n    helperFun l []\n;;\n\nlet _ = listReverse [1; 2; 3; 4];;\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet palindrome w = \n  let z = explode w in\n  let y = listReverse z in\n    if z = y\n    then true\n    else false\n;;\n\nlet _ = palindrome \"malayalam\";;\nlet _ = palindrome \"myxomatosis\";;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = additivePersistence 367951","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec addPHelper n c =\n  let n_pos = digits n in\n  let sum = sumList n_pos in if sum < 10 then c else addPHelper sum (c + 1);;\n\nlet additivePersistence n = addPHelper n 1;;\n\nlet _ = additivePersistence 367951;;\n","type":"","out":""}],"event":{"region":{"start":2065,"stop":2102},"type":"eval"},"cursor":2104,"time":1.397518688867227e9,"body":"(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\nXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []     -> 0 \n  | hd::tl -> hd + sumList tl\n;;\n\nlet _ = sumList [1; 2; 3; 4];;\nlet _ = sumList [1; -2; 3; 5];;\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digithelper n l=\n  let x = n/10 in\n  let y = n mod 10 in\n    if x = 0\n    then y :: l\n    else digithelper x (y :: l)\n;;\n\nlet digitsOfInt n =\n  if n <= 0 \n  then []\n  else \n    digithelper n []\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 352663;;\nlet _ = digitsOfInt 0;;\nlet _ = digitsOfInt 1;;\nlet _ = digitsOfInt (-12);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXX*)\nlet rec addPHelper n c =\n  let n_pos = digits n in\n  let sum = sumList n_pos in \n    if sum < 10\n    then c\n    else addPHelper sum (c+1)\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet additivePersistence n = \n  addPHelper n 1\n;;\n\nlet _ = additivePersistence 9876;;\nlet _ = additivePersistence 367951;;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitalRoot n = \n  let n_pos = digits n in\n  let l_sum = sumList n_pos in\n    if l_sum < 10\n    then l_sum\n    else digitalRoot l_sum\n;;\n\n\nlet _ = digitalRoot 9876;;\nlet _ = digitalRoot 12345;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet listReverse l = \n  let rec helperFun l z = match l with\n    | [] -> z\n    | hd :: tl -> helperFun tl (hd :: z)\n  in\n    helperFun l []\n;;\n\nlet _ = listReverse [1; 2; 3; 4];;\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet palindrome w = \n  let z = explode w in\n  let y = listReverse z in\n    if z = y\n    then true\n    else false\n;;\n\nlet _ = palindrome \"malayalam\";;\nlet _ = palindrome \"myxomatosis\";;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = additivePersistence 12","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec addPHelper n c =\n  let n_pos = digits n in\n  let sum = sumList n_pos in if sum < 10 then c else addPHelper sum (c + 1);;\n\nlet additivePersistence n = addPHelper n 1;;\n\nlet _ = additivePersistence 12;;\n","type":"","out":""}],"event":{"region":{"start":2065,"stop":2098},"type":"eval"},"cursor":2100,"time":1.397518695226985e9,"body":"(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\nXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []     -> 0 \n  | hd::tl -> hd + sumList tl\n;;\n\nlet _ = sumList [1; 2; 3; 4];;\nlet _ = sumList [1; -2; 3; 5];;\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digithelper n l=\n  let x = n/10 in\n  let y = n mod 10 in\n    if x = 0\n    then y :: l\n    else digithelper x (y :: l)\n;;\n\nlet digitsOfInt n =\n  if n <= 0 \n  then []\n  else \n    digithelper n []\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 352663;;\nlet _ = digitsOfInt 0;;\nlet _ = digitsOfInt 1;;\nlet _ = digitsOfInt (-12);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXX*)\nlet rec addPHelper n c =\n  let n_pos = digits n in\n  let sum = sumList n_pos in \n    if sum < 10\n    then c\n    else addPHelper sum (c+1)\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet additivePersistence n = \n  addPHelper n 1\n;;\n\nlet _ = additivePersistence 9876;;\nlet _ = additivePersistence 12;;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitalRoot n = \n  let n_pos = digits n in\n  let l_sum = sumList n_pos in\n    if l_sum < 10\n    then l_sum\n    else digitalRoot l_sum\n;;\n\n\nlet _ = digitalRoot 9876;;\nlet _ = digitalRoot 12345;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet listReverse l = \n  let rec helperFun l z = match l with\n    | [] -> z\n    | hd :: tl -> helperFun tl (hd :: z)\n  in\n    helperFun l []\n;;\n\nlet _ = listReverse [1; 2; 3; 4];;\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet palindrome w = \n  let z = explode w in\n  let y = listReverse z in\n    if z = y\n    then true\n    else false\n;;\n\nlet _ = palindrome \"malayalam\";;\nlet _ = palindrome \"myxomatosis\";;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = additivePersistence -12","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec addPHelper n c =\n  let n_pos = digits n in\n  let sum = sumList n_pos in if sum < 10 then c else addPHelper sum (c + 1);;\n\nlet additivePersistence n = addPHelper n 1;;\n\nlet _ = additivePersistence - 12;;\n","type":"type","out":"Characters 8-27:\n  let _ = additivePersistence -12;;\n          ^^^^^^^^^^^^^^^^^^^\nError: This expression has type int -> int\n       but an expression was expected of type int\n"}],"event":{"region":{"start":2098,"stop":2132},"type":"eval"},"cursor":2134,"time":1.397518712165561e9,"body":"(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\nXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []     -> 0 \n  | hd::tl -> hd + sumList tl\n;;\n\nlet _ = sumList [1; 2; 3; 4];;\nlet _ = sumList [1; -2; 3; 5];;\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digithelper n l=\n  let x = n/10 in\n  let y = n mod 10 in\n    if x = 0\n    then y :: l\n    else digithelper x (y :: l)\n;;\n\nlet digitsOfInt n =\n  if n <= 0 \n  then []\n  else \n    digithelper n []\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 352663;;\nlet _ = digitsOfInt 0;;\nlet _ = digitsOfInt 1;;\nlet _ = digitsOfInt (-12);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXX*)\nlet rec addPHelper n c =\n  let n_pos = digits n in\n  let sum = sumList n_pos in \n    if sum < 10\n    then c\n    else addPHelper sum (c+1)\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet additivePersistence n = \n  addPHelper n 1\n;;\n\nlet _ = additivePersistence 9876;;\nlet _ = additivePersistence 12;;\nlet _ = additivePersistence -12;;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitalRoot n = \n  let n_pos = digits n in\n  let l_sum = sumList n_pos in\n    if l_sum < 10\n    then l_sum\n    else digitalRoot l_sum\n;;\n\n\nlet _ = digitalRoot 9876;;\nlet _ = digitalRoot 12345;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet listReverse l = \n  let rec helperFun l z = match l with\n    | [] -> z\n    | hd :: tl -> helperFun tl (hd :: z)\n  in\n    helperFun l []\n;;\n\nlet _ = listReverse [1; 2; 3; 4];;\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet palindrome w = \n  let z = explode w in\n  let y = listReverse z in\n    if z = y\n    then true\n    else false\n;;\n\nlet _ = palindrome \"malayalam\";;\nlet _ = palindrome \"myxomatosis\";;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = additivePersistence 1","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec addPHelper n c =\n  let n_pos = digits n in\n  let sum = sumList n_pos in if sum < 10 then c else addPHelper sum (c + 1);;\n\nlet additivePersistence n = addPHelper n 1;;\n\nlet _ = additivePersistence 1;;\n","type":"","out":""}],"event":{"region":{"start":2098,"stop":2130},"type":"eval"},"cursor":2132,"time":1.397518770073931e9,"body":"(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\nXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []     -> 0 \n  | hd::tl -> hd + sumList tl\n;;\n\nlet _ = sumList [1; 2; 3; 4];;\nlet _ = sumList [1; -2; 3; 5];;\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digithelper n l=\n  let x = n/10 in\n  let y = n mod 10 in\n    if x = 0\n    then y :: l\n    else digithelper x (y :: l)\n;;\n\nlet digitsOfInt n =\n  if n <= 0 \n  then []\n  else \n    digithelper n []\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 352663;;\nlet _ = digitsOfInt 0;;\nlet _ = digitsOfInt 1;;\nlet _ = digitsOfInt (-12);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXX*)\nlet rec addPHelper n c =\n  let n_pos = digits n in\n  let sum = sumList n_pos in \n    if sum < 10\n    then c\n    else addPHelper sum (c+1)\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet additivePersistence n = \n  addPHelper n 1\n;;\n\nlet _ = additivePersistence 9876;;\nlet _ = additivePersistence 12;;\nlet _ = additivePersistence 1;;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitalRoot n = \n  let n_pos = digits n in\n  let l_sum = sumList n_pos in\n    if l_sum < 10\n    then l_sum\n    else digitalRoot l_sum\n;;\n\n\nlet _ = digitalRoot 9876;;\nlet _ = digitalRoot 12345;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet listReverse l = \n  let rec helperFun l z = match l with\n    | [] -> z\n    | hd :: tl -> helperFun tl (hd :: z)\n  in\n    helperFun l []\n;;\n\nlet _ = listReverse [1; 2; 3; 4];;\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet palindrome w = \n  let z = explode w in\n  let y = listReverse z in\n    if z = y\n    then true\n    else false\n;;\n\nlet _ = palindrome \"malayalam\";;\nlet _ = palindrome \"myxomatosis\";;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = additivePersistence 1","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec addPHelper n c =\n  let n_pos = digits n in\n  let sum = sumList n_pos in if sum < 10 then c else addPHelper sum (c + 1);;\n\nlet additivePersistence n = addPHelper n 1;;\n\nlet _ = additivePersistence 1;;\n","type":"","out":""}],"event":{"region":{"start":2101,"stop":2130},"type":"eval"},"cursor":2133,"time":1.397518778115005e9,"body":"(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\nXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []     -> 0 \n  | hd::tl -> hd + sumList tl\n;;\n\nlet _ = sumList [1; 2; 3; 4];;\nlet _ = sumList [1; -2; 3; 5];;\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digithelper n l=\n  let x = n/10 in\n  let y = n mod 10 in\n    if x = 0\n    then y :: l\n    else digithelper x (y :: l)\n;;\n\nlet digitsOfInt n =\n  if n <= 0 \n  then []\n  else \n    digithelper n []\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 352663;;\nlet _ = digitsOfInt 0;;\nlet _ = digitsOfInt 1;;\nlet _ = digitsOfInt (-12);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXX*)\nlet rec addPHelper n c =\n  let n_pos = digits n in\n  let sum = sumList n_pos in \n    if sum < 10\n    then c\n    else addPHelper sum (c+1)\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet additivePersistence n = \n  addPHelper n 1\n;;\n\nlet _ = additivePersistence 9876;;\nlet _ = additivePersistence 12;;\nlet _ = additivePersistence 1;;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitalRoot n = \n  let n_pos = digits n in\n  let l_sum = sumList n_pos in\n    if l_sum < 10\n    then l_sum\n    else digitalRoot l_sum\n;;\n\n\nlet _ = digitalRoot 9876;;\nlet _ = digitalRoot 12345;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet listReverse l = \n  let rec helperFun l z = match l with\n    | [] -> z\n    | hd :: tl -> helperFun tl (hd :: z)\n  in\n    helperFun l []\n;;\n\nlet _ = listReverse [1; 2; 3; 4];;\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet palindrome w = \n  let z = explode w in\n  let y = listReverse z in\n    if z = y\n    then true\n    else false\n;;\n\nlet _ = palindrome \"malayalam\";;\nlet _ = palindrome \"myxomatosis\";;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = match xs with\n| []     -> 0 \n| hd::tl -> hd + sumList tl","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec digithelper n l=\nlet x = n/10 in\nlet y = n mod 10 in\nif x = 0\nthen y :: l\nelse digithelper x (y :: l)","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n","type":"","out":""},{"in":"let digitsOfInt n =\nif n <= 0 \nthen []\nelse \ndigithelper n []","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 0","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 0;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 1","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 1;;\n","type":"","out":""},{"in":"let _ = digitsOfInt (-12)","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt (-12);;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec addPHelper n c =\nlet n_pos = digits n in\nlet sum = sumList n_pos in \nif sum < 10\nthen c\nelse addPHelper sum (c+2)","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec addPHelper n c =\n  let n_pos = digits n in\n  let sum = sumList n_pos in if sum < 10 then c else addPHelper sum (c + 2);;\n","type":"","out":""},{"in":"let additivePersistence n = \naddPHelper n 0","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec addPHelper n c =\n  let n_pos = digits n in\n  let sum = sumList n_pos in if sum < 10 then c else addPHelper sum (c + 2);;\n\nlet additivePersistence n = addPHelper n 0;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9876","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec addPHelper n c =\n  let n_pos = digits n in\n  let sum = sumList n_pos in if sum < 10 then c else addPHelper sum (c + 2);;\n\nlet additivePersistence n = addPHelper n 0;;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""},{"in":"let _ = additivePersistence 12","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec addPHelper n c =\n  let n_pos = digits n in\n  let sum = sumList n_pos in if sum < 10 then c else addPHelper sum (c + 2);;\n\nlet additivePersistence n = addPHelper n 0;;\n\nlet _ = additivePersistence 12;;\n","type":"","out":""},{"in":"let _ = additivePersistence 1","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec addPHelper n c =\n  let n_pos = digits n in\n  let sum = sumList n_pos in if sum < 10 then c else addPHelper sum (c + 2);;\n\nlet additivePersistence n = addPHelper n 0;;\n\nlet _ = additivePersistence 1;;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":2130},"type":"eval"},"cursor":2132,"time":1.397518841248826e9,"body":"(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\nXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []     -> 0 \n  | hd::tl -> hd + sumList tl\n;;\n\nlet _ = sumList [1; 2; 3; 4];;\nlet _ = sumList [1; -2; 3; 5];;\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digithelper n l=\n  let x = n/10 in\n  let y = n mod 10 in\n    if x = 0\n    then y :: l\n    else digithelper x (y :: l)\n;;\n\nlet digitsOfInt n =\n  if n <= 0 \n  then []\n  else \n    digithelper n []\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 352663;;\nlet _ = digitsOfInt 0;;\nlet _ = digitsOfInt 1;;\nlet _ = digitsOfInt (-12);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXX*)\nlet rec addPHelper n c =\n  let n_pos = digits n in\n  let sum = sumList n_pos in \n    if sum < 10\n    then c\n    else addPHelper sum (c+2)\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet additivePersistence n = \n  addPHelper n 0\n;;\n\nlet _ = additivePersistence 9876;;\nlet _ = additivePersistence 12;;\nlet _ = additivePersistence 1;;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitalRoot n = \n  let n_pos = digits n in\n  let l_sum = sumList n_pos in\n    if l_sum < 10\n    then l_sum\n    else digitalRoot l_sum\n;;\n\n\nlet _ = digitalRoot 9876;;\nlet _ = digitalRoot 12345;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet listReverse l = \n  let rec helperFun l z = match l with\n    | [] -> z\n    | hd :: tl -> helperFun tl (hd :: z)\n  in\n    helperFun l []\n;;\n\nlet _ = listReverse [1; 2; 3; 4];;\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet palindrome w = \n  let z = explode w in\n  let y = listReverse z in\n    if z = y\n    then true\n    else false\n;;\n\nlet _ = palindrome \"malayalam\";;\nlet _ = palindrome \"myxomatosis\";;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = match xs with\n| []     -> 0 \n| hd::tl -> hd + sumList tl","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec digithelper n l=\nlet x = n/10 in\nlet y = n mod 10 in\nif x = 0\nthen y :: l\nelse digithelper x (y :: l)","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n","type":"","out":""},{"in":"let digitsOfInt n =\nif n <= 0 \nthen []\nelse \ndigithelper n []","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 0","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 0;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 1","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 1;;\n","type":"","out":""},{"in":"let _ = digitsOfInt (-12)","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt (-12);;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec addPHelper n c =\nlet n_pos = digits n in\nlet sum = sumList n_pos in \nif sum < 10\nthen c\nelse addPHelper sum (c+1)","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec addPHelper n c =\n  let n_pos = digits n in\n  let sum = sumList n_pos in if sum < 10 then c else addPHelper sum (c + 1);;\n","type":"","out":""},{"in":"let additivePersistence n = \nif n < 10\nthen 0\nelse \naddPHelper n 1","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec addPHelper n c =\n  let n_pos = digits n in\n  let sum = sumList n_pos in if sum < 10 then c else addPHelper sum (c + 1);;\n\nlet additivePersistence n = if n < 10 then 0 else addPHelper n 1;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9876","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec addPHelper n c =\n  let n_pos = digits n in\n  let sum = sumList n_pos in if sum < 10 then c else addPHelper sum (c + 1);;\n\nlet additivePersistence n = if n < 10 then 0 else addPHelper n 1;;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""},{"in":"let _ = additivePersistence 12","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec addPHelper n c =\n  let n_pos = digits n in\n  let sum = sumList n_pos in if sum < 10 then c else addPHelper sum (c + 1);;\n\nlet additivePersistence n = if n < 10 then 0 else addPHelper n 1;;\n\nlet _ = additivePersistence 12;;\n","type":"","out":""},{"in":"let _ = additivePersistence 1","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec addPHelper n c =\n  let n_pos = digits n in\n  let sum = sumList n_pos in if sum < 10 then c else addPHelper sum (c + 1);;\n\nlet additivePersistence n = if n < 10 then 0 else addPHelper n 1;;\n\nlet _ = additivePersistence 1;;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":2153},"type":"eval"},"cursor":2155,"time":1.397518945375194e9,"body":"(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\nXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []     -> 0 \n  | hd::tl -> hd + sumList tl\n;;\n\nlet _ = sumList [1; 2; 3; 4];;\nlet _ = sumList [1; -2; 3; 5];;\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digithelper n l=\n  let x = n/10 in\n  let y = n mod 10 in\n    if x = 0\n    then y :: l\n    else digithelper x (y :: l)\n;;\n\nlet digitsOfInt n =\n  if n <= 0 \n  then []\n  else \n    digithelper n []\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 352663;;\nlet _ = digitsOfInt 0;;\nlet _ = digitsOfInt 1;;\nlet _ = digitsOfInt (-12);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXX*)\nlet rec addPHelper n c =\n  let n_pos = digits n in\n  let sum = sumList n_pos in \n    if sum < 10\n    then c\n    else addPHelper sum (c+1)\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet additivePersistence n = \n  if n < 10\n  then 0\n  else \n    addPHelper n 1\n;;\n\nlet _ = additivePersistence 9876;;\nlet _ = additivePersistence 12;;\nlet _ = additivePersistence 1;;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitalRoot n = \n  let n_pos = digits n in\n  let l_sum = sumList n_pos in\n    if l_sum < 10\n    then l_sum\n    else digitalRoot l_sum\n;;\n\n\nlet _ = digitalRoot 9876;;\nlet _ = digitalRoot 12345;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet listReverse l = \n  let rec helperFun l z = match l with\n    | [] -> z\n    | hd :: tl -> helperFun tl (hd :: z)\n  in\n    helperFun l []\n;;\n\nlet _ = listReverse [1; 2; 3; 4];;\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet palindrome w = \n  let z = explode w in\n  let y = listReverse z in\n    if z = y\n    then true\n    else false\n;;\n\nlet _ = palindrome \"malayalam\";;\nlet _ = palindrome \"myxomatosis\";;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = match xs with\n| []     -> 0 \n| hd::tl -> hd + sumList tl","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec digithelper n l=\nlet x = n/10 in\nlet y = n mod 10 in\nif x = 0\nthen y :: l\nelse digithelper x (y :: l)","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n","type":"","out":""},{"in":"let digitsOfInt n =\nif n <= 0 \nthen []\nelse \ndigithelper n []","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 0","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 0;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 1","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 1;;\n","type":"","out":""},{"in":"let _ = digitsOfInt (-12)","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt (-12);;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec addPHelper n c =\nlet n_pos = digits n in\nlet sum = sumList n_pos in \nif sum < 10\nthen c\nelse addPHelper sum (c+1)","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec addPHelper n c =\n  let n_pos = digits n in\n  let sum = sumList n_pos in if sum < 10 then c else addPHelper sum (c + 1);;\n","type":"","out":""},{"in":"let additivePersistence n = \nif n < 10\nthen 0\nelse \naddPHelper n 1","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec addPHelper n c =\n  let n_pos = digits n in\n  let sum = sumList n_pos in if sum < 10 then c else addPHelper sum (c + 1);;\n\nlet additivePersistence n = if n < 10 then 0 else addPHelper n 1;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9876","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec addPHelper n c =\n  let n_pos = digits n in\n  let sum = sumList n_pos in if sum < 10 then c else addPHelper sum (c + 1);;\n\nlet additivePersistence n = if n < 10 then 0 else addPHelper n 1;;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""},{"in":"let _ = additivePersistence 12","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec addPHelper n c =\n  let n_pos = digits n in\n  let sum = sumList n_pos in if sum < 10 then c else addPHelper sum (c + 1);;\n\nlet additivePersistence n = if n < 10 then 0 else addPHelper n 1;;\n\nlet _ = additivePersistence 12;;\n","type":"","out":""},{"in":"let _ = additivePersistence 1","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec addPHelper n c =\n  let n_pos = digits n in\n  let sum = sumList n_pos in if sum < 10 then c else addPHelper sum (c + 1);;\n\nlet additivePersistence n = if n < 10 then 0 else addPHelper n 1;;\n\nlet _ = additivePersistence 1;;\n","type":"","out":""},{"in":"let rec digitalRoot n = \nlet n_pos = digits n in\nlet l_sum = sumList n_pos in\nif l_sum < 10\nthen l_sum\nelse digitalRoot l_sum","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let n_pos = digits n in\n  let l_sum = sumList n_pos in\n  if l_sum < 10 then l_sum else digitalRoot l_sum;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9876","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let n_pos = digits n in\n  let l_sum = sumList n_pos in\n  if l_sum < 10 then l_sum else digitalRoot l_sum;;\n\nlet _ = digitalRoot 9876;;\n","type":"","out":""},{"in":"let _ = digitalRoot 12345","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let n_pos = digits n in\n  let l_sum = sumList n_pos in\n  if l_sum < 10 then l_sum else digitalRoot l_sum;;\n\nlet _ = digitalRoot 12345;;\n","type":"","out":""},{"in":"let listReverse l = \nlet rec helperFun l z = match l with\n| [] -> z\n| hd :: tl -> helperFun tl (hd :: z)\nin\nhelperFun l []","min":"\nlet listReverse l =\n  let rec helperFun l z =\n    match l with | [] -> z | hd::tl -> helperFun tl (hd :: z) in\n  helperFun l [];;\n","type":"","out":""},{"in":"let _ = listReverse [1; 2; 3; 4]","min":"\nlet listReverse l =\n  let rec helperFun l z =\n    match l with | [] -> z | hd::tl -> helperFun tl (hd :: z) in\n  helperFun l [];;\n\nlet _ = listReverse [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]","min":"\nlet listReverse l =\n  let rec helperFun l z =\n    match l with | [] -> z | hd::tl -> helperFun tl (hd :: z) in\n  helperFun l [];;\n\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n","type":"","out":""},{"in":"let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n","type":"","out":""},{"in":"let palindrome w = \nlet z = explode w in\nlet y = listReverse z in\nif z = y\nthen true\nelse false","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet listReverse l =\n  let rec helperFun l z =\n    match l with | [] -> z | hd::tl -> helperFun tl (hd :: z) in\n  helperFun l [];;\n\nlet palindrome w =\n  let z = explode w in let y = listReverse z in if z = y then true else false;;\n","type":"","out":""},{"in":"let _ = palindrome \"malayalam\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet listReverse l =\n  let rec helperFun l z =\n    match l with | [] -> z | hd::tl -> helperFun tl (hd :: z) in\n  helperFun l [];;\n\nlet palindrome w =\n  let z = explode w in let y = listReverse z in if z = y then true else false;;\n\nlet _ = palindrome \"malayalam\";;\n","type":"","out":""},{"in":"let _ = palindrome \"myxomatosis\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet listReverse l =\n  let rec helperFun l z =\n    match l with | [] -> z | hd::tl -> helperFun tl (hd :: z) in\n  helperFun l [];;\n\nlet palindrome w =\n  let z = explode w in let y = listReverse z in if z = y then true else false;;\n\nlet _ = palindrome \"myxomatosis\";;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key        = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130  = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":6198},"type":"eval"},"cursor":2155,"time":1.397518959576214e9,"body":"(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\nXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []     -> 0 \n  | hd::tl -> hd + sumList tl\n;;\n\nlet _ = sumList [1; 2; 3; 4];;\nlet _ = sumList [1; -2; 3; 5];;\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digithelper n l=\n  let x = n/10 in\n  let y = n mod 10 in\n    if x = 0\n    then y :: l\n    else digithelper x (y :: l)\n;;\n\nlet digitsOfInt n =\n  if n <= 0 \n  then []\n  else \n    digithelper n []\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 352663;;\nlet _ = digitsOfInt 0;;\nlet _ = digitsOfInt 1;;\nlet _ = digitsOfInt (-12);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXX*)\nlet rec addPHelper n c =\n  let n_pos = digits n in\n  let sum = sumList n_pos in \n    if sum < 10\n    then c\n    else addPHelper sum (c+1)\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet additivePersistence n = \n  if n < 10\n  then 0\n  else \n    addPHelper n 1\n;;\n\nlet _ = additivePersistence 9876;;\nlet _ = additivePersistence 12;;\nlet _ = additivePersistence 1;;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitalRoot n = \n  let n_pos = digits n in\n  let l_sum = sumList n_pos in\n    if l_sum < 10\n    then l_sum\n    else digitalRoot l_sum\n;;\n\n\nlet _ = digitalRoot 9876;;\nlet _ = digitalRoot 12345;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet listReverse l = \n  let rec helperFun l z = match l with\n    | [] -> z\n    | hd :: tl -> helperFun tl (hd :: z)\n  in\n    helperFun l []\n;;\n\nlet _ = listReverse [1; 2; 3; 4];;\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet palindrome w = \n  let z = explode w in\n  let y = listReverse z in\n    if z = y\n    then true\n    else false\n;;\n\nlet _ = palindrome \"malayalam\";;\nlet _ = palindrome \"myxomatosis\";;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = match xs with\n| []     -> 0 \n| hd::tl -> hd + sumList tl","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec digithelper n l=\nlet x = n/10 in\nlet y = n mod 10 in\nif x = 0\nthen y :: l\nelse digithelper x (y :: l)","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n","type":"","out":""},{"in":"let digitsOfInt n =\nif n <= 0 \nthen []\nelse \ndigithelper n []","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 0","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 0;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 1","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 1;;\n","type":"","out":""},{"in":"let _ = digitsOfInt (-12)","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt (-12);;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec addPHelper n c =\nlet n_pos = digits n in\nlet sum = sumList n_pos in \nif sum < 10\nthen c\nelse addPHelper sum (c+1)","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec addPHelper n c =\n  let n_pos = digits n in\n  let sum = sumList n_pos in if sum < 10 then c else addPHelper sum (c + 1);;\n","type":"","out":""},{"in":"let additivePersistence n = \nif n < 10\nthen 0\nelse \naddPHelper n 1","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec addPHelper n c =\n  let n_pos = digits n in\n  let sum = sumList n_pos in if sum < 10 then c else addPHelper sum (c + 1);;\n\nlet additivePersistence n = if n < 10 then 0 else addPHelper n 1;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9876","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec addPHelper n c =\n  let n_pos = digits n in\n  let sum = sumList n_pos in if sum < 10 then c else addPHelper sum (c + 1);;\n\nlet additivePersistence n = if n < 10 then 0 else addPHelper n 1;;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""},{"in":"let _ = additivePersistence 12","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec addPHelper n c =\n  let n_pos = digits n in\n  let sum = sumList n_pos in if sum < 10 then c else addPHelper sum (c + 1);;\n\nlet additivePersistence n = if n < 10 then 0 else addPHelper n 1;;\n\nlet _ = additivePersistence 12;;\n","type":"","out":""},{"in":"let _ = additivePersistence 1","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec addPHelper n c =\n  let n_pos = digits n in\n  let sum = sumList n_pos in if sum < 10 then c else addPHelper sum (c + 1);;\n\nlet additivePersistence n = if n < 10 then 0 else addPHelper n 1;;\n\nlet _ = additivePersistence 1;;\n","type":"","out":""},{"in":"let rec digitalRoot n = \nlet n_pos = digits n in\nlet l_sum = sumList n_pos in\nif l_sum < 10\nthen l_sum\nelse digitalRoot l_sum","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let n_pos = digits n in\n  let l_sum = sumList n_pos in\n  if l_sum < 10 then l_sum else digitalRoot l_sum;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9876","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let n_pos = digits n in\n  let l_sum = sumList n_pos in\n  if l_sum < 10 then l_sum else digitalRoot l_sum;;\n\nlet _ = digitalRoot 9876;;\n","type":"","out":""},{"in":"let _ = digitalRoot 12345","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let n_pos = digits n in\n  let l_sum = sumList n_pos in\n  if l_sum < 10 then l_sum else digitalRoot l_sum;;\n\nlet _ = digitalRoot 12345;;\n","type":"","out":""},{"in":"let listReverse l = \nlet rec helperFun l z = match l with\n| [] -> z\n| hd :: tl -> helperFun tl (hd :: z)\nin\nhelperFun l []","min":"\nlet listReverse l =\n  let rec helperFun l z =\n    match l with | [] -> z | hd::tl -> helperFun tl (hd :: z) in\n  helperFun l [];;\n","type":"","out":""},{"in":"let _ = listReverse [1; 2; 3; 4]","min":"\nlet listReverse l =\n  let rec helperFun l z =\n    match l with | [] -> z | hd::tl -> helperFun tl (hd :: z) in\n  helperFun l [];;\n\nlet _ = listReverse [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]","min":"\nlet listReverse l =\n  let rec helperFun l z =\n    match l with | [] -> z | hd::tl -> helperFun tl (hd :: z) in\n  helperFun l [];;\n\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n","type":"","out":""},{"in":"let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n","type":"","out":""},{"in":"let palindrome w = \nlet z = explode w in\nlet y = listReverse z in\nif z = y\nthen true\nelse false","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet listReverse l =\n  let rec helperFun l z =\n    match l with | [] -> z | hd::tl -> helperFun tl (hd :: z) in\n  helperFun l [];;\n\nlet palindrome w =\n  let z = explode w in let y = listReverse z in if z = y then true else false;;\n","type":"","out":""},{"in":"let _ = palindrome \"malayalam\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet listReverse l =\n  let rec helperFun l z =\n    match l with | [] -> z | hd::tl -> helperFun tl (hd :: z) in\n  helperFun l [];;\n\nlet palindrome w =\n  let z = explode w in let y = listReverse z in if z = y then true else false;;\n\nlet _ = palindrome \"malayalam\";;\n","type":"","out":""},{"in":"let _ = palindrome \"myxomatosis\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet listReverse l =\n  let rec helperFun l z =\n    match l with | [] -> z | hd::tl -> helperFun tl (hd :: z) in\n  helperFun l [];;\n\nlet palindrome w =\n  let z = explode w in let y = listReverse z in if z = y then true else false;;\n\nlet _ = palindrome \"myxomatosis\";;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key        = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130  = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":6198},"type":"eval"},"cursor":0,"time":1.397519595006364e9,"body":"(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\nXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []     -> 0 \n  | hd::tl -> hd + sumList tl\n;;\n\nlet _ = sumList [1; 2; 3; 4];;\nlet _ = sumList [1; -2; 3; 5];;\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digithelper n l=\n  let x = n/10 in\n  let y = n mod 10 in\n    if x = 0\n    then y :: l\n    else digithelper x (y :: l)\n;;\n\nlet digitsOfInt n =\n  if n <= 0 \n  then []\n  else \n    digithelper n []\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 352663;;\nlet _ = digitsOfInt 0;;\nlet _ = digitsOfInt 1;;\nlet _ = digitsOfInt (-12);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXX*)\nlet rec addPHelper n c =\n  let n_pos = digits n in\n  let sum = sumList n_pos in \n    if sum < 10\n    then c\n    else addPHelper sum (c+1)\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet additivePersistence n = \n  if n < 10\n  then 0\n  else \n    addPHelper n 1\n;;\n\nlet _ = additivePersistence 9876;;\nlet _ = additivePersistence 12;;\nlet _ = additivePersistence 1;;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitalRoot n = \n  let n_pos = digits n in\n  let l_sum = sumList n_pos in\n    if l_sum < 10\n    then l_sum\n    else digitalRoot l_sum\n;;\n\n\nlet _ = digitalRoot 9876;;\nlet _ = digitalRoot 12345;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet listReverse l = \n  let rec helperFun l z = match l with\n    | [] -> z\n    | hd :: tl -> helperFun tl (hd :: z)\n  in\n    helperFun l []\n;;\n\nlet _ = listReverse [1; 2; 3; 4];;\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet palindrome w = \n  let z = explode w in\n  let y = listReverse z in\n    if z = y\n    then true\n    else false\n;;\n\nlet _ = palindrome \"malayalam\";;\nlet _ = palindrome \"myxomatosis\";;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = match xs with\n| []     -> 0 \n| hd::tl -> hd + sumList tl","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec digithelper n l=\nlet x = n/10 in\nlet y = n mod 10 in\nif x = 0\nthen y :: l\nelse digithelper x (y :: l)","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n","type":"","out":""},{"in":"let digitsOfInt n =\nif n <= 0 \nthen []\nelse \ndigithelper n []","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 0","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 0;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 1","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt 1;;\n","type":"","out":""},{"in":"let _ = digitsOfInt (-12)","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt (-12);;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec addPHelper n c =\nlet n_pos = digits n in\nlet sum = sumList n_pos in \nif sum < 10\nthen c\nelse addPHelper sum (c+1)","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec addPHelper n c =\n  let n_pos = digits n in\n  let sum = sumList n_pos in if sum < 10 then c else addPHelper sum (c + 1);;\n","type":"","out":""},{"in":"let additivePersistence n = \nif n < 10\nthen 0\nelse \naddPHelper n 1","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec addPHelper n c =\n  let n_pos = digits n in\n  let sum = sumList n_pos in if sum < 10 then c else addPHelper sum (c + 1);;\n\nlet additivePersistence n = if n < 10 then 0 else addPHelper n 1;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9876","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec addPHelper n c =\n  let n_pos = digits n in\n  let sum = sumList n_pos in if sum < 10 then c else addPHelper sum (c + 1);;\n\nlet additivePersistence n = if n < 10 then 0 else addPHelper n 1;;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""},{"in":"let _ = additivePersistence 12","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec addPHelper n c =\n  let n_pos = digits n in\n  let sum = sumList n_pos in if sum < 10 then c else addPHelper sum (c + 1);;\n\nlet additivePersistence n = if n < 10 then 0 else addPHelper n 1;;\n\nlet _ = additivePersistence 12;;\n","type":"","out":""},{"in":"let _ = additivePersistence 1","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec addPHelper n c =\n  let n_pos = digits n in\n  let sum = sumList n_pos in if sum < 10 then c else addPHelper sum (c + 1);;\n\nlet additivePersistence n = if n < 10 then 0 else addPHelper n 1;;\n\nlet _ = additivePersistence 1;;\n","type":"","out":""},{"in":"let rec digitalRoot n = \nlet n_pos = digits n in\nlet l_sum = sumList n_pos in\nif l_sum < 10\nthen l_sum\nelse digitalRoot l_sum","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let n_pos = digits n in\n  let l_sum = sumList n_pos in\n  if l_sum < 10 then l_sum else digitalRoot l_sum;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9876","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let n_pos = digits n in\n  let l_sum = sumList n_pos in\n  if l_sum < 10 then l_sum else digitalRoot l_sum;;\n\nlet _ = digitalRoot 9876;;\n","type":"","out":""},{"in":"let _ = digitalRoot 12345","min":"\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let n_pos = digits n in\n  let l_sum = sumList n_pos in\n  if l_sum < 10 then l_sum else digitalRoot l_sum;;\n\nlet _ = digitalRoot 12345;;\n","type":"","out":""},{"in":"let rec append l1 l2 = match l1 with\n| [] -> l2\n| hd :: tl -> hd :: (append tl) l2","min":"\nlet rec append l1 l2 =\n  match l1 with | [] -> l2 | hd::tl -> hd :: ((append tl) l2);;\n","type":"","out":""},{"in":"let rec listReverse l = match l with\n| [] -> []\n| hd :: tl -> append (listReverse tl) [hd]","min":"\nlet rec append l1 l2 =\n  match l1 with | [] -> l2 | hd::tl -> hd :: ((append tl) l2);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> append (listReverse tl) [hd];;\n","type":"","out":""},{"in":"let _ = listReverse [1; 2; 3; 4]","min":"\nlet rec append l1 l2 =\n  match l1 with | [] -> l2 | hd::tl -> hd :: ((append tl) l2);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> append (listReverse tl) [hd];;\n\nlet _ = listReverse [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]","min":"\nlet rec append l1 l2 =\n  match l1 with | [] -> l2 | hd::tl -> hd :: ((append tl) l2);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> append (listReverse tl) [hd];;\n\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n","type":"","out":""},{"in":"let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n","type":"","out":""},{"in":"let palindrome w = \nlet z = explode w in\nlet y = listReverse z in\nif z = y\nthen true\nelse false","min":"\nlet rec append l1 l2 =\n  match l1 with | [] -> l2 | hd::tl -> hd :: ((append tl) l2);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> append (listReverse tl) [hd];;\n\nlet palindrome w =\n  let z = explode w in let y = listReverse z in if z = y then true else false;;\n","type":"","out":""},{"in":"let _ = palindrome \"malayalam\"","min":"\nlet rec append l1 l2 =\n  match l1 with | [] -> l2 | hd::tl -> hd :: ((append tl) l2);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> append (listReverse tl) [hd];;\n\nlet palindrome w =\n  let z = explode w in let y = listReverse z in if z = y then true else false;;\n\nlet _ = palindrome \"malayalam\";;\n","type":"","out":""},{"in":"let _ = palindrome \"myxomatosis\"","min":"\nlet rec append l1 l2 =\n  match l1 with | [] -> l2 | hd::tl -> hd :: ((append tl) l2);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> append (listReverse tl) [hd];;\n\nlet palindrome w =\n  let z = explode w in let y = listReverse z in if z = y then true else false;;\n\nlet _ = palindrome \"myxomatosis\";;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key        = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130  = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":6275},"type":"eval"},"cursor":2764,"time":1.397759572979519e9,"body":"(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\nXXXXXXXXXXXXXXXX\nXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []     -> 0 \n  | hd::tl -> hd + sumList tl\n;;\n\nlet _ = sumList [1; 2; 3; 4];;\nlet _ = sumList [1; -2; 3; 5];;\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digithelper n l=\n  let x = n/10 in\n  let y = n mod 10 in\n    if x = 0\n    then y :: l\n    else digithelper x (y :: l)\n;;\n\nlet digitsOfInt n =\n  if n <= 0 \n  then []\n  else \n    digithelper n []\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 352663;;\nlet _ = digitsOfInt 0;;\nlet _ = digitsOfInt 1;;\nlet _ = digitsOfInt (-12);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXX*)\nlet rec addPHelper n c =\n  let n_pos = digits n in\n  let sum = sumList n_pos in \n    if sum < 10\n    then c\n    else addPHelper sum (c+1)\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet additivePersistence n = \n  if n < 10\n  then 0\n  else \n    addPHelper n 1\n;;\n\nlet _ = additivePersistence 9876;;\nlet _ = additivePersistence 12;;\nlet _ = additivePersistence 1;;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitalRoot n = \n  let n_pos = digits n in\n  let l_sum = sumList n_pos in\n    if l_sum < 10\n    then l_sum\n    else digitalRoot l_sum\n;;\n\n\nlet _ = digitalRoot 9876;;\nlet _ = digitalRoot 12345;;\n\n\n(*XXXXXXXXXXXXXXXXX*)\nlet rec append l1 l2 = match l1 with\n  | [] -> l2\n  | hd :: tl -> hd :: (append tl) l2\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec listReverse l = match l with\n  | [] -> []\n  | hd :: tl -> append (listReverse tl) [hd]\n;;\n\nlet _ = listReverse [1; 2; 3; 4];;\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet palindrome w = \n  let z = explode w in\n  let y = listReverse z in\n    if z = y\n    then true\n    else false\n;;\n\nlet _ = palindrome \"malayalam\";;\nlet _ = palindrome \"myxomatosis\";;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
