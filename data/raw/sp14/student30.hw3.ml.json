{"ocaml":[{"in":"let sqsum xs = \nlet f a x = a**2 + x in\nlet base = 0 in\nList.fold_left f base xs","min":"\nlet sqsum xs =\n  let f a x = (a ** 2) + x in let base = 0 in List.fold_left f base xs;;\n","type":"type","out":"Characters 31-32:\n  let f a x = a**2 + x in\n                 ^\nError: This expression has type int but an expression was expected of type\n         float\n"},{"in":"let _ = sqsum []","min":"\nlet _ = sqsum [];;\n","type":"scope","out":"Characters 8-13:\n  let _ = sqsum [];;\n          ^^^^^\nError: Unbound value sqsum\n"},{"in":"let _ = sqsum [1;2;3;4]","min":"\nlet _ = sqsum [1; 2; 3; 4];;\n","type":"scope","out":"Characters 8-13:\n  let _ = sqsum [1;2;3;4];;\n          ^^^^^\nError: Unbound value sqsum\n"},{"in":"let _ = sqsum [(-1); (-2); (-3); (-4)]","min":"\nlet _ = sqsum [(-1); (-2); (-3); (-4)];;\n","type":"scope","out":"Characters 8-13:\n  let _ = sqsum [(-1); (-2); (-3); (-4)];;\n          ^^^^^\nError: Unbound value sqsum\n"}],"event":{"region":{"start":0,"stop":877},"type":"eval"},"cursor":877,"time":1.398926104168386e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a**2 + x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n    List.fold_left f base fs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let sqsum xs = \nlet f a x = a**2. + x in\nlet base = 0 in\nList.fold_left f base xs","min":"\nlet sqsum xs =\n  let f a x = (a ** 2.) + x in let base = 0 in List.fold_left f base xs;;\n","type":"type","out":"Characters 28-33:\n  let f a x = a**2. + x in\n              ^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n"}],"event":{"region":{"start":0,"stop":796},"type":"eval"},"cursor":748,"time":1.398926110405568e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a**2. + x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n    List.fold_left f base fs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let sqsum xs = \nlet f a x = a**2. +. x in\nlet base = 0 in\nList.fold_left f base xs","min":"\nlet sqsum xs =\n  let f a x = (a ** 2.) +. x in let base = 0 in List.fold_left f base xs;;\n","type":"type","out":"Characters 75-79:\n  List.fold_left f base xs;;\n                   ^^^^\nError: This expression has type int but an expression was expected of type\n         float\n"}],"event":{"region":{"start":0,"stop":797},"type":"eval"},"cursor":751,"time":1.398926127016699e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a**2. +. x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n    List.fold_left f base fs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let sqsum xs = \nlet f a x = a**2. +. x in\nlet base = 0. in\nList.fold_left f base xs","min":"\nlet sqsum xs =\n  let f a x = (a ** 2.) +. x in let base = 0. in List.fold_left f base xs;;\n","type":"","out":""},{"in":"let _ = sqsum []","min":"\nlet sqsum xs =\n  let f a x = (a ** 2.) +. x in let base = 0. in List.fold_left f base xs;;\n\nlet _ = sqsum [];;\n","type":"","out":""},{"in":"let _ = sqsum [1;2;3;4]","min":"\nlet sqsum xs =\n  let f a x = (a ** 2.) +. x in let base = 0. in List.fold_left f base xs;;\n\nlet _ = sqsum [1; 2; 3; 4];;\n","type":"type","out":"Characters 15-16:\n  let _ = sqsum [1;2;3;4];;\n                 ^\nError: This expression has type int but an expression was expected of type\n         float\n"},{"in":"let _ = sqsum [(-1); (-2); (-3); (-4)]","min":"\nlet sqsum xs =\n  let f a x = (a ** 2.) +. x in let base = 0. in List.fold_left f base xs;;\n\nlet _ = sqsum [(-1); (-2); (-3); (-4)];;\n","type":"type","out":"Characters 15-19:\n  let _ = sqsum [(-1); (-2); (-3); (-4)];;\n                 ^^^^\nError: This expression has type int but an expression was expected of type\n         float\n"}],"event":{"region":{"start":0,"stop":880},"type":"eval"},"cursor":880,"time":1.398926135201693e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a**2. +. x in\n  let base = 0. in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n    List.fold_left f base fs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let sqsum xs = \nlet f a x = a*a + x in\nlet base = 0 in\nList.fold_left f base xs","min":"\nlet sqsum xs =\n  let f a x = (a * a) + x in let base = 0 in List.fold_left f base xs;;\n","type":"","out":""},{"in":"let _ = sqsum []","min":"\nlet sqsum xs =\n  let f a x = (a * a) + x in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [];;\n","type":"","out":""},{"in":"let _ = sqsum [1;2;3;4]","min":"\nlet sqsum xs =\n  let f a x = (a * a) + x in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sqsum [(-1); (-2); (-3); (-4)]","min":"\nlet sqsum xs =\n  let f a x = (a * a) + x in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [(-1); (-2); (-3); (-4)];;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":876},"type":"eval"},"cursor":876,"time":1.398926164828001e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a*a + x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n    List.fold_left f base fs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let sqsum xs = \nlet f a x = (a*a) + x in\nlet base = 0 in\nList.fold_left f base xs","min":"\nlet sqsum xs =\n  let f a x = (a * a) + x in let base = 0 in List.fold_left f base xs;;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":796},"type":"eval"},"cursor":744,"time":1.398926211121191e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = (a*a) + x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n    List.fold_left f base fs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = sqsum []","min":"\nlet sqsum xs =\n  let f a x = (a * a) + x in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [];;\n","type":"","out":""},{"in":"let _ = sqsum [1;2;3;4]","min":"\nlet sqsum xs =\n  let f a x = (a * a) + x in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sqsum [(-1); (-2); (-3); (-4)]","min":"\nlet sqsum xs =\n  let f a x = (a * a) + x in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [(-1); (-2); (-3); (-4)];;\n","type":"","out":""}],"event":{"region":{"start":796,"stop":878},"type":"eval"},"cursor":868,"time":1.398926213588056e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = (a*a) + x in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n    List.fold_left f base fs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n","type":"","out":""},{"in":"let _ = sqsum []","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [];;\n","type":"","out":""},{"in":"let _ = sqsum [1;2;3;4]","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sqsum [(-1); (-2); (-3); (-4)]","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [(-1); (-2); (-3); (-4)];;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":878},"type":"eval"},"cursor":878,"time":1.398926244276682e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n    List.fold_left f base fs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let pipe fs = \nlet f a x = a x in\nlet base = in\nList.fold_left f base fs","min":"","type":"syntax","out":"Characters 45-47:\n  let base = in\n             ^^\nError: Syntax error\n"}],"event":{"region":{"start":878,"stop":954},"type":"eval"},"cursor":926,"time":1.398926358572063e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = a x in\n  let base = in\n    List.fold_left f base fs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let pipe fs = \nlet f a x = a x in\nlet base = x' in\nList.fold_left f base fs","min":"\nlet pipe fs = let f a x = a x in let base = x' in List.fold_left f base fs;;\n","type":"scope","out":"Characters 45-47:\n  let base = x' in\n             ^^\nError: Unbound value x'\n"}],"event":{"region":{"start":878,"stop":957},"type":"eval"},"cursor":929,"time":1.398926366015018e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = a x in\n  let base = x' in\n    List.fold_left f base fs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let pipe fs = \nlet f a x = a x in\nlet base = (f s = s) in\nList.fold_left f base fs","min":"\nlet pipe fs =\n  let f a x = a x in let base = (f s) = s in List.fold_left f base fs;;\n","type":"scope","out":"Characters 48-49:\n  let base = (f s = s) in\n                ^\nError: Unbound value s\n"}],"event":{"region":{"start":878,"stop":964},"type":"eval"},"cursor":935,"time":1.398926389695418e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = a x in\n  let base = (f s = s) in\n    List.fold_left f base fs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let pipe fs = \nlet f a x = a x in\nlet base = (fun x -> x) in\nList.fold_left f base fs","min":"\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n","type":"type","out":"Characters 76-77:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"}],"event":{"region":{"start":878,"stop":967},"type":"eval"},"cursor":938,"time":1.398926403049012e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = a x in\n  let base = (fun x -> x) in\n    List.fold_left f base fs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let pipe fs = \nlet f a x = a (x) in\nlet base = (fun x -> x) in\nList.fold_left f base fs","min":"\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n","type":"type","out":"Characters 78-79:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"}],"event":{"region":{"start":878,"stop":969},"type":"eval"},"cursor":914,"time":1.398926447632532e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = a (x) in\n  let base = (fun x -> x) in\n    List.fold_left f base fs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let pipe fs = \nlet f a x = a x in\nlet base = (fun x -> x) in\nList.fold_left f base fs","min":"\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n","type":"type","out":"Characters 76-77:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"}],"event":{"region":{"start":878,"stop":967},"type":"eval"},"cursor":967,"time":1.398926521994695e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = a x in\n  let base = (fun x -> x) in\n    List.fold_left f base fs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let pipe fs = \nlet f a x = (a x) in\nlet base = (fun x -> x) in\nList.fold_left f base fs","min":"\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n","type":"type","out":"Characters 78-79:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"}],"event":{"region":{"start":878,"stop":969},"type":"eval"},"cursor":914,"time":1.398926620120988e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = (a x) in\n  let base = (fun x -> x) in\n    List.fold_left f base fs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let pipe fs = \nlet f a x = a -> x in\nlet base = (fun x -> x) in\nList.fold_left f base fs","min":"","type":"syntax","out":"Characters 29-31:\n  let f a x = a -> x in\n                ^^\nError: Syntax error\n"}],"event":{"region":{"start":878,"stop":970},"type":"eval"},"cursor":913,"time":1.398926666454048e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = a -> x in\n  let base = (fun x -> x) in\n    List.fold_left f base fs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let pipe fs = \nlet f a x = a x in\nlet base = (fun x -> x) in\nList.fold_left f base fs","min":"\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n","type":"type","out":"Characters 76-77:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"}],"event":{"region":{"start":878,"stop":967},"type":"eval"},"cursor":910,"time":1.398926671194642e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = a x in\n  let base = (fun x -> x) in\n    List.fold_left f base fs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let pipe fs = \nlet f a x = x in\nlet base = (fun x -> x) in\nList.fold_left f base fs","min":"\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n","type":"","out":""}],"event":{"region":{"start":878,"stop":965},"type":"eval"},"cursor":908,"time":1.398926785451758e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x in\n  let base = (fun x -> x) in\n    List.fold_left f base fs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let pipe fs = \nlet f a x = x in\nlet base = fun x -> x in\nList.fold_left f base fs","min":"\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n","type":"","out":""}],"event":{"region":{"start":878,"stop":963},"type":"eval"},"cursor":935,"time":1.398926808054245e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let pipe fs = \nlet f a x = fun x in\nlet base = fun x -> x in\nList.fold_left f base fs","min":"","type":"syntax","out":"Characters 33-35:\n  let f a x = fun x in\n                    ^^\nError: Syntax error\n"}],"event":{"region":{"start":878,"stop":967},"type":"eval"},"cursor":913,"time":1.398926817191335e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun x in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let pipe fs = \nlet f a x = (x) in\nlet base = fun x -> x in\nList.fold_left f base fs","min":"\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n","type":"","out":""}],"event":{"region":{"start":878,"stop":965},"type":"eval"},"cursor":912,"time":1.398926823608786e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = (x) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let pipe fs = \nlet f a x = x in\nlet base = fun x -> x in\nList.fold_left f base fs","min":"\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n","type":"","out":""}],"event":{"region":{"start":878,"stop":963},"type":"eval"},"cursor":909,"time":1.398926826899719e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = pipe [] 3","min":"\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n","type":"","out":""}],"event":{"region":{"start":963,"stop":985},"type":"eval"},"cursor":974,"time":1.398926833194972e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3","min":"\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n","type":"","out":""}],"event":{"region":{"start":985,"stop":1036},"type":"eval"},"cursor":993,"time":1.39892683649615e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs","min":"\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n","type":"","out":""}],"event":{"region":{"start":878,"stop":965},"type":"eval"},"cursor":912,"time":1.398926845906318e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let pipe fs = \nlet f a x = a x in\nlet base = fun x -> x in\nList.fold_left f base fs","min":"\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n","type":"type","out":"Characters 74-75:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"}],"event":{"region":{"start":878,"stop":965},"type":"eval"},"cursor":911,"time":1.398926853374085e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = a x in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let pipe fs = \nlet f a x = a in\nlet base = fun x -> x in\nList.fold_left f base fs","min":"\nlet pipe fs = let f a x = a in let base x = x in List.fold_left f base fs;;\n","type":"","out":""}],"event":{"region":{"start":878,"stop":963},"type":"eval"},"cursor":910,"time":1.398926855727697e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = a in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = pipe [] 3","min":"\nlet pipe fs = let f a x = a in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n","type":"","out":""},{"in":"let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3","min":"\nlet pipe fs = let f a x = a in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n","type":"","out":""}],"event":{"region":{"start":963,"stop":1036},"type":"eval"},"cursor":997,"time":1.398926860827712e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = a in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let pipe fs = \nlet f a x = x in\nlet base = fun x -> x in\nList.fold_left f base fs","min":"\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n","type":"","out":""}],"event":{"region":{"start":878,"stop":963},"type":"eval"},"cursor":910,"time":1.39892686764425e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let pipe fs = \nlet f a x = x in\nlet base = (fun x -> x) in\nList.fold_left f base fs","min":"\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n","type":"","out":""}],"event":{"region":{"start":878,"stop":965},"type":"eval"},"cursor":926,"time":1.398926940495114e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x in\n  let base = (fun x -> x) in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let pipe fs = \nlet f a x = x in\nlet base = (fun x -> x+x) in\nList.fold_left f base fs","min":"\nlet pipe fs = let f a x = x in let base x = x + x in List.fold_left f base fs;;\n","type":"","out":""}],"event":{"region":{"start":878,"stop":967},"type":"eval"},"cursor":938,"time":1.398926954485065e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x in\n  let base = (fun x -> x+x) in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let pipe fs = \nlet f a x = x in\nlet base = (fun x -> x) in\nList.fold_left f base fs","min":"\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n","type":"","out":""}],"event":{"region":{"start":878,"stop":965},"type":"eval"},"cursor":936,"time":1.398926964805344e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x in\n  let base = (fun x -> x) in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let pipe fs = \nlet f a x = x in\nlet base = x in\nList.fold_left f base fs","min":"\nlet pipe fs = let f a x = x in let base = x in List.fold_left f base fs;;\n","type":"scope","out":"Characters 43-44:\n  let base = x in\n             ^\nError: Unbound value x\n"}],"event":{"region":{"start":878,"stop":954},"type":"eval"},"cursor":926,"time":1.398926978822171e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x in\n  let base = x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let pipe fs = \nlet f a x = x in\nlet base = () in\nList.fold_left f base fs","min":"\nlet pipe fs = let f a x = x in let base = () in List.fold_left f base fs;;\n","type":"","out":""}],"event":{"region":{"start":878,"stop":955},"type":"eval"},"cursor":927,"time":1.398926985631006e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x in\n  let base = () in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let pipe fs = \nlet f a x = x in\nlet base = base in\nList.fold_left f base fs","min":"\nlet pipe fs = let f a x = x in let base = base in List.fold_left f base fs;;\n","type":"scope","out":"Characters 43-47:\n  let base = base in\n             ^^^^\nError: Unbound value base\n"}],"event":{"region":{"start":878,"stop":957},"type":"eval"},"cursor":929,"time":1.398927011034639e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x in\n  let base = base in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let pipe fs = \nlet f a x = a x in\nlet base = fun x -> x in\nList.fold_left f base fs","min":"\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n","type":"type","out":"Characters 74-75:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"}],"event":{"region":{"start":878,"stop":965},"type":"eval"},"cursor":937,"time":1.398927031016579e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = a x in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let pipe fs = \nlet f a x = x in\nlet base = fun x -> x in\nList.fold_left f base fs","min":"\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n","type":"","out":""}],"event":{"region":{"start":878,"stop":963},"type":"eval"},"cursor":909,"time":1.398927066500078e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = pipe [] 3","min":"\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n","type":"","out":""},{"in":"let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3","min":"\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n","type":"","out":""}],"event":{"region":{"start":963,"stop":1036},"type":"eval"},"cursor":1007,"time":1.398927071241458e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3","min":"\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n","type":"","out":""}],"event":{"region":{"start":1036,"stop":1087},"type":"eval"},"cursor":1064,"time":1.398927074216862e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let pipe fs = \nlet f a x = a x in\nlet base = fun x y -> x y in\nList.fold_left f base fs","min":"\nlet pipe fs =\n  let f a x = a x in let base x y = x y in List.fold_left f base fs;;\n","type":"type","out":"Characters 78-79:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"}],"event":{"region":{"start":878,"stop":969},"type":"eval"},"cursor":911,"time":1.398927218282215e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = a x in\n  let base = fun x y -> x y in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let pipe fs = \nlet f a x = x in\nlet base = fun x y -> x y in\nList.fold_left f base fs","min":"\nlet pipe fs = let f a x = x in let base x y = x y in List.fold_left f base fs;;\n","type":"","out":""}],"event":{"region":{"start":878,"stop":967},"type":"eval"},"cursor":909,"time":1.398927222965803e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = x in\n  let base = fun x y -> x y in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let pipe fs = \nlet f a x = a x in\nlet base = fun x y -> x y in\nList.fold_left f base fs","min":"\nlet pipe fs =\n  let f a x = a x in let base x y = x y in List.fold_left f base fs;;\n","type":"type","out":"Characters 78-79:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"}],"event":{"region":{"start":878,"stop":969},"type":"eval"},"cursor":912,"time":1.39892724410487e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = a x in\n  let base = fun x y -> x y in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let pipe fs = \nlet f a x = a x in\nlet base = fun x -> x in\nList.fold_left f base fs","min":"\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n","type":"type","out":"Characters 74-75:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"}],"event":{"region":{"start":878,"stop":965},"type":"eval"},"cursor":938,"time":1.398927255857735e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = a x in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let pipe fs = \nlet f a x = fun y -> a (x y) in\nlet base = fun x -> x in\nList.fold_left f base fs","min":"\nlet pipe fs =\n  let f a x y = a (x y) in let base x = x in List.fold_left f base fs;;\n","type":"","out":""}],"event":{"region":{"start":878,"stop":978},"type":"eval"},"cursor":940,"time":1.398927408834023e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> a (x y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = pipe [] 3","min":"\nlet pipe fs =\n  let f a x y = a (x y) in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n","type":"","out":""},{"in":"let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3","min":"\nlet pipe fs =\n  let f a x y = a (x y) in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n","type":"","out":""}],"event":{"region":{"start":978,"stop":1051},"type":"eval"},"cursor":1038,"time":1.398927412768827e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> a (x y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3","min":"\nlet pipe fs =\n  let f a x y = a (x y) in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n","type":"","out":""}],"event":{"region":{"start":1051,"stop":1102},"type":"eval"},"cursor":1085,"time":1.398927415757447e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> a (x y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let pipe fs = \nlet f a x = fun y -> a (x y) in\nlet base = fun x y -> x y in\nList.fold_left f base fs","min":"\nlet pipe fs =\n  let f a x y = a (x y) in let base x y = x y in List.fold_left f base fs;;\n","type":"","out":""}],"event":{"region":{"start":878,"stop":982},"type":"eval"},"cursor":955,"time":1.398927437407152e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> a (x y) in\n  let base = fun x y -> x y in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let pipe fs = \nlet f a x = fun y -> a (x y) in\nlet base = fun x y -> (x y)in\nList.fold_left f base fs","min":"\nlet pipe fs =\n  let f a x y = a (x y) in let base x y = x y in List.fold_left f base fs;;\n","type":"","out":""}],"event":{"region":{"start":878,"stop":983},"type":"eval"},"cursor":955,"time":1.398927445414808e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> a (x y) in\n  let base = fun x y -> (x y)in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let pipe fs = \nlet f a x = fun y -> a (x y) in\nlet base = fun x -> y in\nList.fold_left f base fs","min":"\nlet pipe fs =\n  let f a x y = a (x y) in let base x = y in List.fold_left f base fs;;\n","type":"scope","out":"Characters 67-68:\n  let base = fun x -> y in\n                      ^\nError: Unbound value y\n"}],"event":{"region":{"start":878,"stop":978},"type":"eval"},"cursor":951,"time":1.398927453145318e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> a (x y) in\n  let base = fun x -> y in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let pipe fs = \nlet f a x = fun y -> a (x y) in\nlet base = fun x -> x in\nList.fold_left f base fs","min":"\nlet pipe fs =\n  let f a x y = a (x y) in let base x = x in List.fold_left f base fs;;\n","type":"","out":""}],"event":{"region":{"start":878,"stop":978},"type":"eval"},"cursor":950,"time":1.398927459229126e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> a (x y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = pipe [] 3","min":"\nlet pipe fs =\n  let f a x y = a (x y) in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n","type":"","out":""},{"in":"let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3","min":"\nlet pipe fs =\n  let f a x y = a (x y) in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n","type":"","out":""}],"event":{"region":{"start":978,"stop":1051},"type":"eval"},"cursor":1029,"time":1.398927462676776e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> a (x y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let pipe fs = \nlet f a x = fun y -> x (a y) in\nlet base = fun x -> x in\nList.fold_left f base fs","min":"\nlet pipe fs =\n  let f a x y = x (a y) in let base x = x in List.fold_left f base fs;;\n","type":"","out":""}],"event":{"region":{"start":878,"stop":978},"type":"eval"},"cursor":919,"time":1.398927498805321e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = pipe [] 3","min":"\nlet pipe fs =\n  let f a x y = x (a y) in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n","type":"","out":""},{"in":"let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3","min":"\nlet pipe fs =\n  let f a x y = x (a y) in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n","type":"","out":""}],"event":{"region":{"start":978,"stop":1051},"type":"eval"},"cursor":1021,"time":1.398927501728532e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3","min":"\nlet pipe fs =\n  let f a x y = x (a y) in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n","type":"","out":""}],"event":{"region":{"start":1051,"stop":1102},"type":"eval"},"cursor":1080,"time":1.398927504016748e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ x in\nlet base = \"\" in\nlet l = l in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ x in\n      let base = \"\" in let l = l in List.fold_left f base l;;\n","type":"scope","out":"Characters 112-113:\n  let l = l in\n          ^\nError: Unbound value l\n"}],"event":{"region":{"start":1102,"stop":1247},"type":"eval"},"cursor":1233,"time":1.398927638411882e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ x in\n      let base = \"\" in\n      let l = l in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ x in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ x in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n","type":"","out":""}],"event":{"region":{"start":1102,"stop":1248},"type":"eval"},"cursor":1221,"time":1.398927665964174e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ x in\n      let base = \"\" in\n      let l = sl in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ x in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"","out":""}],"event":{"region":{"start":1248,"stop":1295},"type":"eval"},"cursor":1263,"time":1.398927675365386e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ x in\n      let base = \"\" in\n      let l = sl in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n","type":"","out":""}],"event":{"region":{"start":1102,"stop":1254},"type":"eval"},"cursor":1192,"time":1.398927695905098e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = \"\" in\n      let l = sl in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"","out":""}],"event":{"region":{"start":1254,"stop":1301},"type":"eval"},"cursor":1283,"time":1.398927704843916e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = \"\" in\n      let l = sl in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = (fun x -> match x with\n| sep ^ y -> y\n| _ -> x) in\nlet l = sl in\nList.fold_left f base l","min":"","type":"syntax","out":"Characters 133-134:\n  | sep ^ y -> y\n        ^\nError: Syntax error: operator expected.\n"}],"event":{"region":{"start":1102,"stop":1299},"type":"eval"},"cursor":1297,"time":1.398927770905702e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = (fun x -> match x with\n                   | sep ^ y -> y\n                   | _ -> x) in\n      let l = sl in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = if a != \"\" then a ^ sep ^ x else x in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if a != \"\" then a ^ (sep ^ x) else x in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n","type":"","out":""}],"event":{"region":{"start":1102,"stop":1277},"type":"eval"},"cursor":1236,"time":1.398927976130361e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = if a != \"\" then a ^ sep ^ x else x in\n      let base = \"\" in\n      let l = sl in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if a != \"\" then a ^ (sep ^ x) else x in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"","out":""}],"event":{"region":{"start":1277,"stop":1324},"type":"eval"},"cursor":1314,"time":1.398927979302788e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = if a != \"\" then a ^ sep ^ x else x in\n      let base = \"\" in\n      let l = sl in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (if a != \"\" then a ^ sep ^ x else x) in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if a != \"\" then a ^ (sep ^ x) else x in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n","type":"","out":""},{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if a != \"\" then a ^ (sep ^ x) else x in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"","out":""}],"event":{"region":{"start":1102,"stop":1326},"type":"eval"},"cursor":1303,"time":1.398927988978148e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = (if a != \"\" then a ^ sep ^ x else x) in\n      let base = \"\" in\n      let l = sl in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (if a != \"1\" then a ^ sep ^ x else x) in\nlet base = \"1\" in\nlet l = sl in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if a != \"1\" then a ^ (sep ^ x) else x in\n      let base = \"1\" in let l = sl in List.fold_left f base l;;\n","type":"","out":""}],"event":{"region":{"start":1102,"stop":1281},"type":"eval"},"cursor":1196,"time":1.39892800159838e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = (if a != \"1\" then a ^ sep ^ x else x) in\n      let base = \"1\" in\n      let l = sl in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if a != \"1\" then a ^ (sep ^ x) else x in\n      let base = \"1\" in let l = sl in List.fold_left f base l;;\n\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"","out":""}],"event":{"region":{"start":1281,"stop":1328},"type":"eval"},"cursor":1308,"time":1.398928003574125e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = (if a != \"1\" then a ^ sep ^ x else x) in\n      let base = \"1\" in\n      let l = sl in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let pipe fs = \nlet f a x = fun y -> x (a y) in\nlet base = fun x -> x in\nList.fold_left f base fs","min":"\nlet pipe fs =\n  let f a x y = x (a y) in let base x = x in List.fold_left f base fs;;\n","type":"","out":""}],"event":{"region":{"start":882,"stop":978},"type":"eval"},"cursor":980,"time":1.398928028066924e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = (if a != base then a ^ sep ^ x else x) in\n      let base = \"\" in\n      let l = sl in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = pipe [] 3","min":"\nlet pipe fs =\n  let f a x y = x (a y) in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n","type":"","out":""},{"in":"let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3","min":"\nlet pipe fs =\n  let f a x y = x (a y) in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n","type":"","out":""},{"in":"let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3","min":"\nlet pipe fs =\n  let f a x y = x (a y) in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n","type":"","out":""},{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (if a != base then a ^ sep ^ x else x) in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if a != base then a ^ (sep ^ x) else x in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n","type":"scope","out":"Characters 87-91:\n  let f a x = (if a != base then a ^ sep ^ x else x) in\n                       ^^^^\nError: Unbound value base\n"},{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if a != \"1\" then a ^ (sep ^ x) else x in\n      let base = \"1\" in let l = sl in List.fold_left f base l;;\n\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"","out":""}],"event":{"region":{"start":978,"stop":1328},"type":"eval"},"cursor":1316,"time":1.398928032213582e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = (if a != base then a ^ sep ^ x else x) in\n      let base = \"\" in\n      let l = sl in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (if a != \"\" then a ^ sep ^ x else x) in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if a != \"\" then a ^ (sep ^ x) else x in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n","type":"","out":""},{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if a != \"\" then a ^ (sep ^ x) else x in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"","out":""}],"event":{"region":{"start":1102,"stop":1326},"type":"eval"},"cursor":1306,"time":1.398928043181351e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = (if a != \"\" then a ^ sep ^ x else x) in\n      let base = \"\" in\n      let l = sl in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (if a != \"\" then a ^ sep else \"\") ^ x in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = (if a != \"\" then a ^ sep else \"\") ^ x in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n","type":"","out":""}],"event":{"region":{"start":1102,"stop":1280},"type":"eval"},"cursor":1217,"time":1.398928141363706e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = (if a != \"\" then a ^ sep else \"\") ^ x in\n      let base = \"\" in\n      let l = sl in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = (if a != \"\" then a ^ sep else \"\") ^ x in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"","out":""}],"event":{"region":{"start":1280,"stop":1327},"type":"eval"},"cursor":1305,"time":1.398928143915373e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = (if a != \"\" then a ^ sep else \"\") ^ x in\n      let base = \"\" in\n      let l = sl in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n","type":"","out":""},{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"","out":""}],"event":{"region":{"start":1102,"stop":1301},"type":"eval"},"cursor":1285,"time":1.39892821938461e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = \"\" in\n      let l = sl in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = sepConcat \"---\" []","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n\nlet _ = sepConcat \"---\" [];;\n","type":"","out":""}],"event":{"region":{"start":1301,"stop":1328},"type":"eval"},"cursor":1328,"time":1.398928257914464e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = \"\" in\n      let l = sl in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n\nlet _ = sepConcat \"\" [\"a\"; \"b\"; \"c\"; \"d\"; \"e\"];;\n","type":"","out":""}],"event":{"region":{"start":1328,"stop":1371},"type":"eval"},"cursor":1357,"time":1.398928260871816e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = \"\" in\n      let l = sl in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = sepConcat \"X\" [\"hello\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n\nlet _ = sepConcat \"X\" [\"hello\"];;\n","type":"","out":""}],"event":{"region":{"start":1371,"stop":1403},"type":"eval"},"cursor":1394,"time":1.39892826357646e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = \"\" in\n      let l = sl in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = (^) h in\nlet l = t in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = (^) h in let l = t in List.fold_left f base l;;\n","type":"type","out":"Characters 143-147:\n  List.fold_left f base l;;\n                   ^^^^\nError: This expression has type string -> string\n       but an expression was expected of type string\n"}],"event":{"region":{"start":1102,"stop":1256},"type":"eval"},"cursor":1185,"time":1.398928322425213e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = (^) h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = sep ^ x in\nlet base = (^) h in\nlet l = t in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = sep ^ x in\n      let base = (^) h in let l = t in List.fold_left f base l;;\n","type":"type","out":"Characters 139-143:\n  List.fold_left f base l;;\n                   ^^^^\nError: This expression has type string -> string\n       but an expression was expected of type string\n"}],"event":{"region":{"start":1102,"stop":1252},"type":"eval"},"cursor":1185,"time":1.398928365483661e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = sep ^ x in\n      let base = (^) h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = sep ^ x in\nlet base = fun x-> h ^ x in\nlet l = t in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = sep ^ x in\n      let base x = h ^ x in let l = t in List.fold_left f base l;;\n","type":"type","out":"Characters 147-151:\n  List.fold_left f base l;;\n                   ^^^^\nError: This expression has type string -> string\n       but an expression was expected of type string\n"}],"event":{"region":{"start":1102,"stop":1260},"type":"eval"},"cursor":1260,"time":1.398928386529173e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = sep ^ x in\n      let base = fun x-> h ^ x in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n","type":"","out":""}],"event":{"region":{"start":1102,"stop":1252},"type":"eval"},"cursor":1212,"time":1.398928418030682e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"","out":""}],"event":{"region":{"start":1252,"stop":1299},"type":"eval"},"cursor":1275,"time":1.398928420805667e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = sepConcat \"---\" []","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"---\" [];;\n","type":"","out":""}],"event":{"region":{"start":1299,"stop":1326},"type":"eval"},"cursor":1325,"time":1.398928424386454e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"\" [\"a\"; \"b\"; \"c\"; \"d\"; \"e\"];;\n","type":"","out":""}],"event":{"region":{"start":1326,"stop":1369},"type":"eval"},"cursor":1355,"time":1.398928427086043e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = sepConcat \"X\" [\"hello\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"X\" [\"hello\"];;\n","type":"","out":""}],"event":{"region":{"start":1369,"stop":1401},"type":"eval"},"cursor":1397,"time":1.398928429303573e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n","type":"","out":""}],"event":{"region":{"start":1401,"stop":1469},"type":"eval"},"cursor":1463,"time":1.398928638922474e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = stringOfList string_of_int [1;2;3;4;5;6]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n\nlet _ = stringOfList string_of_int [1; 2; 3; 4; 5; 6];;\n","type":"","out":""},{"in":"let _ = stringOfList (fun x -> x) [\"foo\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n\nlet _ = stringOfList (fun x  -> x) [\"foo\"];;\n","type":"","out":""},{"in":"let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n\nlet _ =\n  stringOfList (stringOfList string_of_int) [[1; 2; 3]; [4; 5]; [6]; []];;\n","type":"","out":""}],"event":{"region":{"start":1469,"stop":1640},"type":"eval"},"cursor":1575,"time":1.398928654298032e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec clone x n =\nif n > 0 then\nx :: clone x n-1\nelse\n[]","min":"\nlet rec clone x n = if n > 0 then x :: ((clone x n) - 1) else [];;\n","type":"type","out":"Characters 39-48:\n  x :: clone x n-1\n       ^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n"}],"event":{"region":{"start":1640,"stop":1911},"type":"eval"},"cursor":1911,"time":1.398928778252184e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x n-1\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec clone x n =\nif n > 0 then\nx :: clone x (n-1)\nelse\n[]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n","type":"","out":""}],"event":{"region":{"start":1640,"stop":1913},"type":"eval"},"cursor":1905,"time":1.398928788494403e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = clone 3 5","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet _ = clone 3 5;;\n","type":"","out":""},{"in":"let _ = clone \"foo\" 2","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet _ = clone \"foo\" 2;;\n","type":"","out":""},{"in":"let _ = clone clone (-3)","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet _ = clone clone (-3);;\n","type":"","out":""}],"event":{"region":{"start":1913,"stop":1986},"type":"eval"},"cursor":1971,"time":1.398928793746018e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let padZero l1 l2 = if List.length l1 > List.length l2 then\n(l1,(clone 0 (List.length l1 - List.length l2))::l2)\nelse\n((clone 0 (List.length l2 - List.length l1))::l1,l2)","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) :: l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) :: l1), l2);;\n","type":"","out":""}],"event":{"region":{"start":1986,"stop":2162},"type":"eval"},"cursor":2163,"time":1.398929040764035e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1,(clone 0 (List.length l1 - List.length l2))::l2)\n  else\n    ((clone 0 (List.length l2 - List.length l1))::l1,l2)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = padZero [9;9] [1;0;0;2]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) :: l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) :: l1), l2);;\n\nlet _ = padZero [9; 9] [1; 0; 0; 2];;\n","type":"type","out":"Characters 17-18:\n  let _ = padZero [9;9] [1;0;0;2];;\n                   ^\nError: This expression has type int but an expression was expected of type\n         int list\n"}],"event":{"region":{"start":2162,"stop":2197},"type":"eval"},"cursor":2176,"time":1.398929068744759e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if List.length l1 > List.length l2 then\n    (l1,(clone 0 (List.length l1 - List.length l2))::l2)\n  else\n    ((clone 0 (List.length l2 - List.length l1))::l1,l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let padZero l1 l2 = if (List.length l1) > (List.length l2) then\n(l1,(clone 0 ((List.length l1) - (List.length l2)))::l2)\nelse\n((clone 0 ((List.length l2) - (List.length l1)))::l1,l2)","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) :: l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) :: l1), l2);;\n","type":"","out":""}],"event":{"region":{"start":1986,"stop":2174},"type":"eval"},"cursor":2164,"time":1.398929136758282e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,(clone 0 ((List.length l1) - (List.length l2)))::l2)\n  else\n    ((clone 0 ((List.length l2) - (List.length l1)))::l1,l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let padZero l1 l2 = if (List.length l1) > (List.length l2) then\n(l1,(clone 0 ((List.length l1) - (List.length l2)))@l2)\nelse\n((clone 0 ((List.length l2) - (List.length l1)))@l1,l2)","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n","type":"","out":""}],"event":{"region":{"start":1986,"stop":2172},"type":"eval"},"cursor":2166,"time":1.398929158999982e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,(clone 0 ((List.length l1) - (List.length l2)))@l2)\n  else\n    ((clone 0 ((List.length l2) - (List.length l1)))@l1,l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = padZero [9;9] [1;0;0;2]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet _ = padZero [9; 9] [1; 0; 0; 2];;\n","type":"","out":""}],"event":{"region":{"start":2172,"stop":2207},"type":"eval"},"cursor":2204,"time":1.398929162378928e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,(clone 0 ((List.length l1) - (List.length l2)))@l2)\n  else\n    ((clone 0 ((List.length l2) - (List.length l1)))@l1,l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = padZero [1;0;0;2] [9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet _ = padZero [1; 0; 0; 2] [9; 9];;\n","type":"","out":""}],"event":{"region":{"start":2207,"stop":2239},"type":"eval"},"cursor":2236,"time":1.398929166312197e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,(clone 0 ((List.length l1) - (List.length l2)))@l2)\n  else\n    ((clone 0 ((List.length l2) - (List.length l1)))@l1,l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let padZero l1 l2 = if (List.length l1) > (List.length l2) then\n(l1,List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\nelse\n(List.append (clone 0 ((List.length l2) - (List.length l1))) l1,l2)","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n","type":"","out":""},{"in":"let _ = padZero [9;9] [1;0;0;2]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet _ = padZero [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = padZero [1;0;0;2] [9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet _ = padZero [1; 0; 0; 2] [9; 9];;\n","type":"","out":""}],"event":{"region":{"start":1986,"stop":2263},"type":"eval"},"cursor":2264,"time":1.398929193871901e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let padZero l1 l2 = if (List.length l1) > (List.length l2) then\n(l1,\nList.append (clone 0 ((List.length l1) - (List.length l2))) l2)\nelse\n(List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\nl2)","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n","type":"","out":""},{"in":"let _ = padZero [9;9] [1;0;0;2]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet _ = padZero [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = padZero [1;0;0;2] [9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet _ = padZero [1; 0; 0; 2] [9; 9];;\n","type":"","out":""},{"in":"let rec removeZero l = match l with\n| 0::t -> t\n| _ -> t","min":"\nlet rec removeZero l = match l with | 0::t -> t | _ -> t;;\n","type":"scope","out":"Characters 55-56:\n  | _ -> t;;\n         ^\nError: Unbound value t\n"}],"event":{"region":{"start":1986,"stop":2326},"type":"eval"},"cursor":2326,"time":1.398929249598038e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> t\n  | _ -> t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec removeZero l = match l with\n| 0::t -> t\n| _ -> l","min":"\nlet rec removeZero l = match l with | 0::t -> t | _ -> l;;\n","type":"","out":""}],"event":{"region":{"start":2265,"stop":2326},"type":"eval"},"cursor":2326,"time":1.398929255084467e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> t\n  | _ -> l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = removeZero [0;0;0;1;0;0;2]","min":"\nlet rec removeZero l = match l with | 0::t -> t | _ -> l;;\n\nlet _ = removeZero [0; 0; 0; 1; 0; 0; 2];;\n","type":"","out":""}],"event":{"region":{"start":2326,"stop":2364},"type":"eval"},"cursor":2338,"time":1.39892926163626e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec removeZero l = match l with\n| 0::t -> removeZero t\n| _ -> l","min":"\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;1;0;0;2]","min":"\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet _ = removeZero [0; 0; 0; 1; 0; 0; 2];;\n","type":"","out":""}],"event":{"region":{"start":2265,"stop":2375},"type":"eval"},"cursor":2356,"time":1.398929270967282e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = removeZero [9;9]","min":"\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet _ = removeZero [9; 9];;\n","type":"","out":""}],"event":{"region":{"start":2375,"stop":2400},"type":"eval"},"cursor":2391,"time":1.398929275141458e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = removeZero [0;0;0;0]","min":"\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet _ = removeZero [0; 0; 0; 0];;\n","type":"","out":""}],"event":{"region":{"start":2400,"stop":2429},"type":"eval"},"cursor":2416,"time":1.398929276896135e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = []::3","min":"\nlet _ = [] :: 3;;\n","type":"type","out":"Characters 12-13:\n  let _ = []::3;;\n              ^\nError: This expression has type int but an expression was expected of type\n         'a list list\n"}],"event":{"region":{"start":2429,"stop":2445},"type":"eval"},"cursor":2445,"time":1.398929404446233e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\nlet _ = []::3\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let combine x1 x2 match (x1,x2) with\n| (h1::t1,h2::t2) -> (h1,h2)::combine t1 t2\n| _ -> []\nin combine [0;0;9;9] [1;0;0;2]","min":"","type":"syntax","out":"Characters 18-23:\n  let combine x1 x2 match (x1,x2) with\n                    ^^^^^\nError: Syntax error\n"}],"event":{"region":{"start":2429,"stop":2553},"type":"eval"},"cursor":2553,"time":1.398930028158898e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\nlet combine x1 x2 match (x1,x2) with\n      | (h1::t1,h2::t2) -> (h1,h2)::combine t1 t2\n      | _ -> []\nin combine [0;0;9;9] [1;0;0;2]\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = List.append a  in\n    let base = failwith \"to be implemented\" in\n    let args = \n      let combine x1 x2 match (x1,x2) with\n            | (h1::t1,h2::t2) -> (h1,h2)::combine t1 t2\n            | _ -> []\n      in combine l1 l2\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let combine x1 x2 = match (x1,x2) with\n| (h1::t1,h2::t2) -> (h1,h2)::combine t1 t2\n| _ -> []\nin combine [0;0;9;9] [1;0;0;2]","min":"\nlet _ =\n  let combine x1 x2 =\n    match (x1, x2) with\n    | (h1::t1,h2::t2) -> (h1, h2) :: (combine t1 t2)\n    | _ -> [] in\n  combine [0; 0; 9; 9] [1; 0; 0; 2];;\n","type":"scope","out":"Characters 69-76:\n  | (h1::t1,h2::t2) -> (h1,h2)::combine t1 t2\n                                ^^^^^^^\nError: Unbound value combine\n"}],"event":{"region":{"start":2429,"stop":2555},"type":"eval"},"cursor":2452,"time":1.39893003628949e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\nlet combine x1 x2 = match (x1,x2) with\n  | (h1::t1,h2::t2) -> (h1,h2)::combine t1 t2\n  | _ -> []\nin combine [0;0;9;9] [1;0;0;2]\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = List.append a  in\n    let base = failwith \"to be implemented\" in\n    let args = \n      let combine x1 x2 match (x1,x2) with\n            | (h1::t1,h2::t2) -> (h1,h2)::combine t1 t2\n            | _ -> []\n      in combine l1 l2\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec combine x1 x2 = match (x1,x2) with\n| (h1::t1,h2::t2) -> (h1,h2)::combine t1 t2\n| _ -> []\nin combine [0;0;9;9] [1;0;0;2]","min":"\nlet _ =\n  let rec combine x1 x2 =\n    match (x1, x2) with\n    | (h1::t1,h2::t2) -> (h1, h2) :: (combine t1 t2)\n    | _ -> [] in\n  combine [0; 0; 9; 9] [1; 0; 0; 2];;\n","type":"","out":""}],"event":{"region":{"start":2429,"stop":2559},"type":"eval"},"cursor":2440,"time":1.398930068307294e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\nlet rec combine x1 x2 = match (x1,x2) with\n  | (h1::t1,h2::t2) -> (h1,h2)::combine t1 t2\n  | _ -> []\nin combine [0;0;9;9] [1;0;0;2]\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = List.append a  in\n    let base = failwith \"to be implemented\" in\n    let args = \n      let combine x1 x2 match (x1,x2) with\n            | (h1::t1,h2::t2) -> (h1,h2)::combine t1 t2\n            | _ -> []\n      in combine l1 l2\n    in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n","type":"","out":""},{"in":"let _ = sqsum []","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [];;\n","type":"","out":""},{"in":"let _ = sqsum [1;2;3;4]","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sqsum [(-1); (-2); (-3); (-4)]","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [(-1); (-2); (-3); (-4)];;\n","type":"","out":""},{"in":"let pipe fs = \nlet f a x = fun y -> x (a y) in\nlet base = fun x -> x in\nList.fold_left f base fs","min":"\nlet pipe fs =\n  let f a x y = x (a y) in let base x = x in List.fold_left f base fs;;\n","type":"","out":""},{"in":"let _ = pipe [] 3","min":"\nlet pipe fs =\n  let f a x y = x (a y) in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n","type":"","out":""},{"in":"let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3","min":"\nlet pipe fs =\n  let f a x y = x (a y) in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n","type":"","out":""},{"in":"let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3","min":"\nlet pipe fs =\n  let f a x y = x (a y) in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n","type":"","out":""},{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n","type":"","out":""},{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"---\" []","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"---\" [];;\n","type":"","out":""},{"in":"let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"\" [\"a\"; \"b\"; \"c\"; \"d\"; \"e\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"X\" [\"hello\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"X\" [\"hello\"];;\n","type":"","out":""},{"in":"let stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n","type":"","out":""},{"in":"let _ = stringOfList string_of_int [1;2;3;4;5;6]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n\nlet _ = stringOfList string_of_int [1; 2; 3; 4; 5; 6];;\n","type":"","out":""},{"in":"let _ = stringOfList (fun x -> x) [\"foo\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n\nlet _ = stringOfList (fun x  -> x) [\"foo\"];;\n","type":"","out":""},{"in":"let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n\nlet _ =\n  stringOfList (stringOfList string_of_int) [[1; 2; 3]; [4; 5]; [6]; []];;\n","type":"","out":""},{"in":"let rec clone x n =\nif n > 0 then\nx :: clone x (n-1)\nelse\n[]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n","type":"","out":""},{"in":"let _ = clone 3 5","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet _ = clone 3 5;;\n","type":"","out":""},{"in":"let _ = clone \"foo\" 2","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet _ = clone \"foo\" 2;;\n","type":"","out":""},{"in":"let _ = clone clone (-3)","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet _ = clone clone (-3);;\n","type":"","out":""},{"in":"let padZero l1 l2 = if (List.length l1) > (List.length l2) then\n(l1,\nList.append (clone 0 ((List.length l1) - (List.length l2))) l2)\nelse\n(List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\nl2)","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n","type":"","out":""},{"in":"let _ = padZero [9;9] [1;0;0;2]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet _ = padZero [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = padZero [1;0;0;2] [9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet _ = padZero [1; 0; 0; 2] [9; 9];;\n","type":"","out":""},{"in":"let rec removeZero l = match l with\n| 0::t -> removeZero t\n| _ -> l","min":"\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;1;0;0;2]","min":"\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet _ = removeZero [0; 0; 0; 1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = removeZero [9;9]","min":"\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet _ = removeZero [9; 9];;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;0]","min":"\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet _ = removeZero [0; 0; 0; 0];;\n","type":"","out":""},{"in":"let _ = List.combine [0;0;9;9] [1;0;0;2]","min":"\nlet _ = List.combine [0; 0; 9; 9] [1; 0; 0; 2];;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":2471},"type":"eval"},"cursor":2472,"time":1.398931619010825e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.combine [0;0;9;9] [1;0;0;2];;\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = List.rev List.combine l1 l2 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = List.rev List.combine [0;0;9;9] [1;0;0;2]","min":"\nlet _ = List.rev List.combine [0; 0; 9; 9] [1; 0; 0; 2];;\n","type":"type","out":"Characters 8-16:\n  let _ = List.rev List.combine [0;0;9;9] [1;0;0;2];;\n          ^^^^^^^^\nError: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}],"event":{"region":{"start":2429,"stop":2480},"type":"eval"},"cursor":2448,"time":1.398931628439662e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.rev List.combine [0;0;9;9] [1;0;0;2];;\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = List.rev List.combine l1 l2 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = List.rev (List.combine [0;0;9;9] [1;0;0;2])","min":"\nlet _ = List.rev (List.combine [0; 0; 9; 9] [1; 0; 0; 2]);;\n","type":"","out":""}],"event":{"region":{"start":2429,"stop":2482},"type":"eval"},"cursor":2482,"time":1.398931636442984e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.rev (List.combine [0;0;9;9] [1;0;0;2]);;\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = List.rev List.combine l1 l2 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = List.rev (List.combine (List.map (fun x -> [x]) [0;0;9;9]) (List.map (fun x -> [x]) [1;0;0;2]))","min":"\nlet _ =\n  List.rev\n    (List.combine (List.map (fun x  -> [x]) [0; 0; 9; 9])\n       (List.map (fun x  -> [x]) [1; 0; 0; 2]));;\n","type":"","out":""}],"event":{"region":{"start":2429,"stop":2534},"type":"eval"},"cursor":2532,"time":1.398931936362229e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.rev (List.combine (List.map (fun x -> [x]) [0;0;9;9]) (List.map (fun x -> [x]) [1;0;0;2]));;\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x =  in\n    let base = (0,0) in\n    let args = List.rev (List.combine (List.map (fun x -> [x]) l1) (List.map (fun x -> [x]) l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = 17/10","min":"\nlet _ = 17 / 10;;\n","type":"","out":""}],"event":{"region":{"start":2534,"stop":2551},"type":"eval"},"cursor":2551,"time":1.398932107452604e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.rev (List.combine (List.map (fun x -> [x]) [0;0;9;9]) (List.map (fun x -> [x]) [1;0;0;2]));;\n\nlet _ = 17/10\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match x with\n      | (d::e,f::g) -> (d::e,::(f+d) mod 10)\n    in\n    let base = (0,0) in\n    let args = List.rev (List.combine (List.map (fun x -> [x]) l1) (List.map (fun x -> [x]) l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match (a,x) with\n| ((h::i,j::k),(d::e,f::g)) -> ((f+d) / 10)::((h+j) mod 10)\nin\nlet base = (0,0) in\nlet args = List.rev (List.combine (List.map (fun x -> [x]) l1) (List.map (fun x -> [x]) l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((h::i,j::k),(d::e,f::g)) -> ((f + d) / 10) :: ((h + j) mod 10) in\n    let base = (0, 0) in\n    let args =\n      List.rev\n        (List.combine (List.map (fun x  -> [x]) l1)\n           (List.map (fun x  -> [x]) l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"type","out":"Characters 114-128:\n  | ((h::i,j::k),(d::e,f::g)) -> ((f+d) / 10)::((h+j) mod 10)\n                                               ^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         int list\n"}],"event":{"region":{"start":2551,"stop":2886},"type":"eval"},"cursor":2684,"time":1.398932323761618e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.rev (List.combine (List.map (fun x -> [x]) [0;0;9;9]) (List.map (fun x -> [x]) [1;0;0;2]));;\n\nlet _ = 17/10\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match (a,x) with\n      | ((h::i,j::k),(d::e,f::g)) -> ((f+d) / 10)::((h+j) mod 10)\n    in\n    let base = (0,0) in\n    let args = List.rev (List.combine (List.map (fun x -> [x]) l1) (List.map (fun x -> [x]) l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match (a,x) with\n| ((h::i,j::k),(d::e,f::g)) -> ((f+d) / 10)::((h+j) mod 10)\nin\nlet base = ([],[]) in\nlet args = List.rev (List.combine (List.map (fun x -> [x]) l1) (List.map (fun x -> [x]) l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((h::i,j::k),(d::e,f::g)) -> ((f + d) / 10) :: ((h + j) mod 10) in\n    let base = ([], []) in\n    let args =\n      List.rev\n        (List.combine (List.map (fun x  -> [x]) l1)\n           (List.map (fun x  -> [x]) l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"type","out":"Characters 114-128:\n  | ((h::i,j::k),(d::e,f::g)) -> ((f+d) / 10)::((h+j) mod 10)\n                                               ^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         int list\n"}],"event":{"region":{"start":2551,"stop":2888},"type":"eval"},"cursor":2702,"time":1.398932337613114e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.rev (List.combine (List.map (fun x -> [x]) [0;0;9;9]) (List.map (fun x -> [x]) [1;0;0;2]));;\n\nlet _ = 17/10\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match (a,x) with\n      | ((h::i,j::k),(d::e,f::g)) -> ((f+d) / 10)::((h+j) mod 10)\n    in\n    let base = ([],[]) in\n    let args = List.rev (List.combine (List.map (fun x -> [x]) l1) (List.map (fun x -> [x]) l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n","type":"","out":""},{"in":"let _ = sqsum []","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [];;\n","type":"","out":""},{"in":"let _ = sqsum [1;2;3;4]","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sqsum [(-1); (-2); (-3); (-4)]","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [(-1); (-2); (-3); (-4)];;\n","type":"","out":""},{"in":"let pipe fs = \nlet f a x = fun y -> x (a y) in\nlet base = fun x -> x in\nList.fold_left f base fs","min":"\nlet pipe fs =\n  let f a x y = x (a y) in let base x = x in List.fold_left f base fs;;\n","type":"","out":""},{"in":"let _ = pipe [] 3","min":"\nlet pipe fs =\n  let f a x y = x (a y) in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n","type":"","out":""},{"in":"let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3","min":"\nlet pipe fs =\n  let f a x y = x (a y) in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n","type":"","out":""},{"in":"let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3","min":"\nlet pipe fs =\n  let f a x y = x (a y) in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n","type":"","out":""},{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n","type":"","out":""},{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"---\" []","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"---\" [];;\n","type":"","out":""},{"in":"let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"\" [\"a\"; \"b\"; \"c\"; \"d\"; \"e\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"X\" [\"hello\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"X\" [\"hello\"];;\n","type":"","out":""},{"in":"let stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n","type":"","out":""},{"in":"let _ = stringOfList string_of_int [1;2;3;4;5;6]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n\nlet _ = stringOfList string_of_int [1; 2; 3; 4; 5; 6];;\n","type":"","out":""},{"in":"let _ = stringOfList (fun x -> x) [\"foo\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n\nlet _ = stringOfList (fun x  -> x) [\"foo\"];;\n","type":"","out":""},{"in":"let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n\nlet _ =\n  stringOfList (stringOfList string_of_int) [[1; 2; 3]; [4; 5]; [6]; []];;\n","type":"","out":""},{"in":"let rec clone x n =\nif n > 0 then\nx :: clone x (n-1)\nelse\n[]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n","type":"","out":""},{"in":"let _ = clone 3 5","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet _ = clone 3 5;;\n","type":"","out":""},{"in":"let _ = clone \"foo\" 2","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet _ = clone \"foo\" 2;;\n","type":"","out":""},{"in":"let _ = clone clone (-3)","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet _ = clone clone (-3);;\n","type":"","out":""},{"in":"let padZero l1 l2 = if (List.length l1) > (List.length l2) then\n(l1,\nList.append (clone 0 ((List.length l1) - (List.length l2))) l2)\nelse\n(List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\nl2)","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n","type":"","out":""},{"in":"let _ = padZero [9;9] [1;0;0;2]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet _ = padZero [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = padZero [1;0;0;2] [9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet _ = padZero [1; 0; 0; 2] [9; 9];;\n","type":"","out":""},{"in":"let rec removeZero l = match l with\n| 0::t -> removeZero t\n| _ -> l","min":"\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;1;0;0;2]","min":"\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet _ = removeZero [0; 0; 0; 1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = removeZero [9;9]","min":"\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet _ = removeZero [9; 9];;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;0]","min":"\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet _ = removeZero [0; 0; 0; 0];;\n","type":"","out":""},{"in":"let _ = List.combine [0;0;9;9] [1;0;0;2]","min":"\nlet _ = List.combine [0; 0; 9; 9] [1; 0; 0; 2];;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":2471},"type":"eval"},"cursor":2473,"time":1.398932773526598e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.combine [0;0;9;9] [1;0;0;2];;\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = List.fold_right  a x in\n    let base = (clone 0 List.length l1, clone 0 List.length l2) in\n    let args = [(l1,l2)] in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match (a,x) with\n| ((b,c),(d,e)) -> (b,(d+e)::c) \nin\nlet base = ([], []) in\nlet args = List.rev (List.combine [0;0;9;9] [1;0;0;2]) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match (a, x) with | ((b,c),(d,e)) -> (b, ((d + e) :: c)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine [0; 0; 9; 9] [1; 0; 0; 2]) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"","out":""}],"event":{"region":{"start":2471,"stop":2746},"type":"eval"},"cursor":2742,"time":1.398933385956039e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.combine [0;0;9;9] [1;0;0;2];;\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match (a,x) with\n      | ((b,c),(d,e)) -> (b,(d+e)::c) \n    in\n    let base = ([], []) in\n    let args = List.rev (List.combine [0;0;9;9] [1;0;0;2]) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = bigAdd [9;9] [1;0;0;2]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match (a, x) with | ((b,c),(d,e)) -> (b, ((d + e) :: c)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine [0; 0; 9; 9] [1; 0; 0; 2]) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9] [1; 0; 0; 2];;\n","type":"","out":""}],"event":{"region":{"start":2746,"stop":2780},"type":"eval"},"cursor":2762,"time":1.398933396606087e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.combine [0;0;9;9] [1;0;0;2];;\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match (a,x) with\n      | ((b,c),(d,e)) -> (b,(d+e)::c) \n    in\n    let base = ([], []) in\n    let args = List.rev (List.combine [0;0;9;9] [1;0;0;2]) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match (a,x) with\n| ((b,h::t),(d,e)) -> (b,((d+e)/10)::((d+e+h) mod 10)::t) \nin\nlet base = ([], [0]) in\nlet args = List.rev (List.combine [0;0;9;9] [1;0;0;2]) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,h::t),(d,e)) ->\n          (b, (((d + e) / 10) :: (((d + e) + h) mod 10) :: t)) in\n    let base = ([], [0]) in\n    let args = List.rev (List.combine [0; 0; 9; 9] [1; 0; 0; 2]) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"","out":""}],"event":{"region":{"start":2471,"stop":2773},"type":"eval"},"cursor":2570,"time":1.398933509724767e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.combine [0;0;9;9] [1;0;0;2];;\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match (a,x) with\n      | ((b,h::t),(d,e)) -> (b,((d+e)/10)::((d+e+h) mod 10)::t) \n    in\n    let base = ([], [0]) in\n    let args = List.rev (List.combine [0;0;9;9] [1;0;0;2]) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = bigAdd [9;9] [1;0;0;2]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,h::t),(d,e)) ->\n          (b, (((d + e) / 10) :: (((d + e) + h) mod 10) :: t)) in\n    let base = ([], [0]) in\n    let args = List.rev (List.combine [0; 0; 9; 9] [1; 0; 0; 2]) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9] [1; 0; 0; 2];;\n","type":"","out":""}],"event":{"region":{"start":2773,"stop":2807},"type":"eval"},"cursor":2798,"time":1.398933513450523e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.combine [0;0;9;9] [1;0;0;2];;\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match (a,x) with\n      | ((b,h::t),(d,e)) -> (b,((d+e)/10)::((d+e+h) mod 10)::t) \n    in\n    let base = ([], [0]) in\n    let args = List.rev (List.combine [0;0;9;9] [1;0;0;2]) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = bigAdd [9;9;9;9] [9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,h::t),(d,e)) ->\n          (b, (((d + e) / 10) :: (((d + e) + h) mod 10) :: t)) in\n    let base = ([], [0]) in\n    let args = List.rev (List.combine [0; 0; 9; 9] [1; 0; 0; 2]) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n","type":"","out":""}],"event":{"region":{"start":2807,"stop":2842},"type":"eval"},"cursor":2831,"time":1.398933591103429e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.combine [0;0;9;9] [1;0;0;2];;\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match (a,x) with\n      | ((b,h::t),(d,e)) -> (b,((d+e)/10)::((d+e+h) mod 10)::t) \n    in\n    let base = ([], [0]) in\n    let args = List.rev (List.combine [0;0;9;9] [1;0;0;2]) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match (a,x) with\n| ((b,c),(d,e)) -> (b,((d+e) mod 10)::c) \nin\nlet base = ([], []) in\nlet args = List.rev (List.combine [0;0;9;9] [1;0;0;2]) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with | ((b,c),(d,e)) -> (b, (((d + e) mod 10) :: c)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine [0; 0; 9; 9] [1; 0; 0; 2]) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"","out":""}],"event":{"region":{"start":2471,"stop":2755},"type":"eval"},"cursor":2580,"time":1.398933622748522e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.combine [0;0;9;9] [1;0;0;2];;\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match (a,x) with\n      | ((b,c),(d,e)) -> (b,((d+e) mod 10)::c) \n    in\n    let base = ([], []) in\n    let args = List.rev (List.combine [0;0;9;9] [1;0;0;2]) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = bigAdd [9;9] [1;0;0;2]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with | ((b,c),(d,e)) -> (b, (((d + e) mod 10) :: c)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine [0; 0; 9; 9] [1; 0; 0; 2]) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9] [1; 0; 0; 2];;\n","type":"","out":""}],"event":{"region":{"start":2755,"stop":2789},"type":"eval"},"cursor":2780,"time":1.398933625911245e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.combine [0;0;9;9] [1;0;0;2];;\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match (a,x) with\n      | ((b,c),(d,e)) -> (b,((d+e) mod 10)::c) \n    in\n    let base = ([], []) in\n    let args = List.rev (List.combine [0;0;9;9] [1;0;0;2]) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match (a,x) with\n| ((b,h::t),(d,e)) -> (b,((d+e)/10)::((d+e+h) mod 10)::t) \nin\nlet base = ([], [0]) in\nlet args = List.rev (List.combine [0;0;9;9] [1;0;0;2]) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,h::t),(d,e)) ->\n          (b, (((d + e) / 10) :: (((d + e) + h) mod 10) :: t)) in\n    let base = ([], [0]) in\n    let args = List.rev (List.combine [0; 0; 9; 9] [1; 0; 0; 2]) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9] [1;0;0;2]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,h::t),(d,e)) ->\n          (b, (((d + e) / 10) :: (((d + e) + h) mod 10) :: t)) in\n    let base = ([], [0]) in\n    let args = List.rev (List.combine [0; 0; 9; 9] [1; 0; 0; 2]) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9] [1; 0; 0; 2];;\n","type":"","out":""}],"event":{"region":{"start":2471,"stop":2807},"type":"eval"},"cursor":2794,"time":1.398933666032374e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.combine [0;0;9;9] [1;0;0;2];;\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match (a,x) with\n      | ((b,h::t),(d,e)) -> (b,((d+e)/10)::((d+e+h) mod 10)::t) \n    in\n    let base = ([], [0]) in\n    let args = List.rev (List.combine [0;0;9;9] [1;0;0;2]) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = 5::6::[]","min":"\nlet _ = [5; 6];;\n","type":"","out":""}],"event":{"region":{"start":2471,"stop":2490},"type":"eval"},"cursor":2490,"time":1.398933744425851e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.combine [0;0;9;9] [1;0;0;2];;\nlet _ = 5::6::[]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match (a,x) with\n      | ((b,h::t),(d,e)) -> (b,((d+e)/10)::((d+e+h) mod 10)::t) \n    in\n    let base = ([], [0]) in\n    let args = List.rev (List.combine [0;0;9;9] [1;0;0;2]) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match (a,x) with\n| ((b,c),(d,e)) -> (b,((d+e)::c) \nin\nlet base = ([], [0]) in\nlet args = List.rev (List.combine [0;0;9;9] [1;0;0;2]) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"","type":"syntax","out":"Characters 88-89:\n  | ((b,c),(d,e)) -> (b,((d+e)::c) \n                     ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n"}],"event":{"region":{"start":2490,"stop":2765},"type":"eval"},"cursor":2583,"time":1.398933855062902e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.combine [0;0;9;9] [1;0;0;2];;\nlet _ = 5::6::[]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match (a,x) with\n      | ((b,c),(d,e)) -> (b,((d+e)::c) \n    in\n    let base = ([], [0]) in\n    let args = List.rev (List.combine [0;0;9;9] [1;0;0;2]) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match (a,x) with\n| ((b,c),(d,e)) -> (b,(d+e)::c) \nin\nlet base = ([], [0]) in\nlet args = List.rev (List.combine [0;0;9;9] [1;0;0;2]) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match (a, x) with | ((b,c),(d,e)) -> (b, ((d + e) :: c)) in\n    let base = ([], [0]) in\n    let args = List.rev (List.combine [0; 0; 9; 9] [1; 0; 0; 2]) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"","out":""}],"event":{"region":{"start":2490,"stop":2764},"type":"eval"},"cursor":2583,"time":1.39893386451314e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.combine [0;0;9;9] [1;0;0;2];;\nlet _ = 5::6::[]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match (a,x) with\n      | ((b,c),(d,e)) -> (b,(d+e)::c) \n    in\n    let base = ([], [0]) in\n    let args = List.rev (List.combine [0;0;9;9] [1;0;0;2]) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = bigAdd [9;9] [1;0;0;2]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match (a, x) with | ((b,c),(d,e)) -> (b, ((d + e) :: c)) in\n    let base = ([], [0]) in\n    let args = List.rev (List.combine [0; 0; 9; 9] [1; 0; 0; 2]) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9] [1; 0; 0; 2];;\n","type":"","out":""}],"event":{"region":{"start":2764,"stop":2798},"type":"eval"},"cursor":2784,"time":1.398933867153236e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.combine [0;0;9;9] [1;0;0;2];;\nlet _ = 5::6::[]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match (a,x) with\n      | ((b,c),(d,e)) -> (b,(d+e)::c) \n    in\n    let base = ([], [0]) in\n    let args = List.rev (List.combine [0;0;9;9] [1;0;0;2]) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match (a,x) with\n| ((b,c),(d,e)) -> (b,(d+e)::c) \nin\nlet base = ([], []) in\nlet args = List.rev (List.combine [0;0;9;9] [1;0;0;2]) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match (a, x) with | ((b,c),(d,e)) -> (b, ((d + e) :: c)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine [0; 0; 9; 9] [1; 0; 0; 2]) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9] [1;0;0;2]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match (a, x) with | ((b,c),(d,e)) -> (b, ((d + e) :: c)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine [0; 0; 9; 9] [1; 0; 0; 2]) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9] [1; 0; 0; 2];;\n","type":"","out":""}],"event":{"region":{"start":2490,"stop":2797},"type":"eval"},"cursor":2790,"time":1.398933875006373e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.combine [0;0;9;9] [1;0;0;2];;\nlet _ = 5::6::[]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match (a,x) with\n      | ((b,c),(d,e)) -> (b,(d+e)::c) \n    in\n    let base = ([], []) in\n    let args = List.rev (List.combine [0;0;9;9] [1;0;0;2]) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match (a,x) with\n| ((b,c),(d,e)) -> (b,(d+e) mod 10::c) \nin\nlet base = ([], []) in\nlet args = List.rev (List.combine [0;0;9;9] [1;0;0;2]) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with | ((b,c),(d,e)) -> (b, (((d + e) mod 10) :: c)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine [0; 0; 9; 9] [1; 0; 0; 2]) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"","out":""}],"event":{"region":{"start":2490,"stop":2770},"type":"eval"},"cursor":2595,"time":1.398933894828655e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.combine [0;0;9;9] [1;0;0;2];;\nlet _ = 5::6::[]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match (a,x) with\n      | ((b,c),(d,e)) -> (b,(d+e) mod 10::c) \n    in\n    let base = ([], []) in\n    let args = List.rev (List.combine [0;0;9;9] [1;0;0;2]) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = bigAdd [9;9] [1;0;0;2]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with | ((b,c),(d,e)) -> (b, (((d + e) mod 10) :: c)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine [0; 0; 9; 9] [1; 0; 0; 2]) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9] [1; 0; 0; 2];;\n","type":"","out":""}],"event":{"region":{"start":2770,"stop":2804},"type":"eval"},"cursor":2794,"time":1.398933898225149e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.combine [0;0;9;9] [1;0;0;2];;\nlet _ = 5::6::[]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match (a,x) with\n      | ((b,c),(d,e)) -> (b,(d+e) mod 10::c) \n    in\n    let base = ([], []) in\n    let args = List.rev (List.combine [0;0;9;9] [1;0;0;2]) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match (a,x) with\n| ((b,c),(d,e)) -> ((d+e)/10,(d+e+h) mod 10::c) \nin\nlet base = (0, []) in\nlet args = List.rev (List.combine [0;0;9;9] [1;0;0;2]) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) -> (((d + e) / 10), ((((d + e) + h) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine [0; 0; 9; 9] [1; 0; 0; 2]) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"scope","out":"Characters 103-104:\n  | ((b,c),(d,e)) -> ((d+e)/10,(d+e+h) mod 10::c) \n                                    ^\nError: Unbound value h\n"}],"event":{"region":{"start":2490,"stop":2778},"type":"eval"},"cursor":2596,"time":1.398933970736348e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.combine [0;0;9;9] [1;0;0;2];;\nlet _ = 5::6::[]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match (a,x) with\n      | ((b,c),(d,e)) -> ((d+e)/10,(d+e+h) mod 10::c) \n    in\n    let base = (0, []) in\n    let args = List.rev (List.combine [0;0;9;9] [1;0;0;2]) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match (a,x) with\n| ((b,c),(d,e)) -> ((d+e)/10,(d+e+b) mod 10::c) \nin\nlet base = (0, []) in\nlet args = List.rev (List.combine [0;0;9;9] [1;0;0;2]) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) -> (((d + e) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine [0; 0; 9; 9] [1; 0; 0; 2]) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"","out":""}],"event":{"region":{"start":2490,"stop":2778},"type":"eval"},"cursor":2596,"time":1.398933976250597e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.combine [0;0;9;9] [1;0;0;2];;\nlet _ = 5::6::[]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match (a,x) with\n      | ((b,c),(d,e)) -> ((d+e)/10,(d+e+b) mod 10::c) \n    in\n    let base = (0, []) in\n    let args = List.rev (List.combine [0;0;9;9] [1;0;0;2]) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = bigAdd [9;9] [1;0;0;2]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) -> (((d + e) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine [0; 0; 9; 9] [1; 0; 0; 2]) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9] [1; 0; 0; 2];;\n","type":"","out":""}],"event":{"region":{"start":2778,"stop":2812},"type":"eval"},"cursor":2809,"time":1.398933979164358e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.combine [0;0;9;9] [1;0;0;2];;\nlet _ = 5::6::[]\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match (a,x) with\n      | ((b,c),(d,e)) -> ((d+e)/10,(d+e+b) mod 10::c) \n    in\n    let base = (0, []) in\n    let args = List.rev (List.combine [0;0;9;9] [1;0;0;2]) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = 11/10","min":"\nlet _ = 11 / 10;;\n","type":"","out":""}],"event":{"region":{"start":2471,"stop":2487},"type":"eval"},"cursor":2487,"time":1.3989339901145e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.combine [0;0;9;9] [1;0;0;2];;\nlet _ = 11/10\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match (a,x) with\n      | ((b,c),(d,e)) -> ((d+e)/10,(d+e+b) mod 10::c) \n    in\n    let base = (0, []) in\n    let args = List.rev (List.combine [0;0;9;9] [1;0;0;2]) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match (a,x) with\n| ((b,c),(d,e)) -> ((d+e)/10,(d+b+e) mod 10::c) \nin\nlet base = (0, []) in\nlet args = List.rev (List.combine [0;0;9;9] [1;0;0;2]) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) -> (((d + e) / 10), ((((d + b) + e) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine [0; 0; 9; 9] [1; 0; 0; 2]) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"","out":""}],"event":{"region":{"start":2487,"stop":2775},"type":"eval"},"cursor":2593,"time":1.398934017908193e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.combine [0;0;9;9] [1;0;0;2];;\nlet _ = 11/10\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match (a,x) with\n      | ((b,c),(d,e)) -> ((d+e)/10,(d+b+e) mod 10::c) \n    in\n    let base = (0, []) in\n    let args = List.rev (List.combine [0;0;9;9] [1;0;0;2]) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = bigAdd [9;9] [1;0;0;2]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) -> (((d + e) / 10), ((((d + b) + e) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine [0; 0; 9; 9] [1; 0; 0; 2]) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9] [1; 0; 0; 2];;\n","type":"","out":""}],"event":{"region":{"start":2775,"stop":2809},"type":"eval"},"cursor":2800,"time":1.398934020472282e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.combine [0;0;9;9] [1;0;0;2];;\nlet _ = 11/10\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match (a,x) with\n      | ((b,c),(d,e)) -> ((d+e)/10,(d+b+e) mod 10::c) \n    in\n    let base = (0, []) in\n    let args = List.rev (List.combine [0;0;9;9] [1;0;0;2]) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match (a,x) with\n| ((b,c),(d,e)) -> ((d+e+b)/10,(d+b+e) mod 10::c) \nin\nlet base = (0, []) in\nlet args = List.rev (List.combine [0;0;9;9] [1;0;0;2]) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + b) + e) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine [0; 0; 9; 9] [1; 0; 0; 2]) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"","out":""}],"event":{"region":{"start":2487,"stop":2777},"type":"eval"},"cursor":2584,"time":1.398934054657807e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.combine [0;0;9;9] [1;0;0;2];;\nlet _ = 11/10\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match (a,x) with\n      | ((b,c),(d,e)) -> ((d+e+b)/10,(d+b+e) mod 10::c) \n    in\n    let base = (0, []) in\n    let args = List.rev (List.combine [0;0;9;9] [1;0;0;2]) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = bigAdd [9;9] [1;0;0;2]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + b) + e) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine [0; 0; 9; 9] [1; 0; 0; 2]) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9] [1; 0; 0; 2];;\n","type":"","out":""}],"event":{"region":{"start":2777,"stop":2811},"type":"eval"},"cursor":2798,"time":1.398934057565168e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.combine [0;0;9;9] [1;0;0;2];;\nlet _ = 11/10\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match (a,x) with\n      | ((b,c),(d,e)) -> ((d+e+b)/10,(d+b+e) mod 10::c) \n    in\n    let base = (0, []) in\n    let args = List.rev (List.combine [0;0;9;9] [1;0;0;2]) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = bigAdd [9;9;9;9] [9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + b) + e) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine [0; 0; 9; 9] [1; 0; 0; 2]) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n","type":"","out":""}],"event":{"region":{"start":2811,"stop":2846},"type":"eval"},"cursor":2831,"time":1.398934060666387e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.combine [0;0;9;9] [1;0;0;2];;\nlet _ = 11/10\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match (a,x) with\n      | ((b,c),(d,e)) -> ((d+e+b)/10,(d+b+e) mod 10::c) \n    in\n    let base = (0, []) in\n    let args = List.rev (List.combine [0;0;9;9] [1;0;0;2]) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = 18 mod 10","min":"\nlet _ = 18 mod 10;;\n","type":"","out":""}],"event":{"region":{"start":2471,"stop":2491},"type":"eval"},"cursor":2489,"time":1.398934125215766e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.combine [0;0;9;9] [1;0;0;2];;\nlet _ = 18 mod 10\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match (a,x) with\n      | ((b,c),(d,e)) -> ((d+e+b)/10,(d+b+e) mod 10::c) \n    in\n    let base = (0, []) in\n    let args = List.rev (List.combine [0;0;9;9] [1;0;0;2]) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match (a,x) with\n| ((b,c),(d,e)) -> ((d+e+b)/10,(d+e+b) mod 10::c) \nin\nlet base = (0, []) in\nlet args = List.rev (List.combine [0;0;9;9] [1;0;0;2]) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine [0; 0; 9; 9] [1; 0; 0; 2]) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"","out":""}],"event":{"region":{"start":2491,"stop":2781},"type":"eval"},"cursor":2599,"time":1.398934191488688e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.combine [0;0;9;9] [1;0;0;2];;\nlet _ = 18 mod 10\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match (a,x) with\n      | ((b,c),(d,e)) -> ((d+e+b)/10,(d+e+b) mod 10::c) \n    in\n    let base = (0, []) in\n    let args = List.rev (List.combine [0;0;9;9] [1;0;0;2]) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = bigAdd [9;9] [1;0;0;2]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine [0; 0; 9; 9] [1; 0; 0; 2]) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9] [1; 0; 0; 2];;\n","type":"","out":""}],"event":{"region":{"start":2781,"stop":2815},"type":"eval"},"cursor":2806,"time":1.398934193370469e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.combine [0;0;9;9] [1;0;0;2];;\nlet _ = 18 mod 10\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match (a,x) with\n      | ((b,c),(d,e)) -> ((d+e+b)/10,(d+e+b) mod 10::c) \n    in\n    let base = (0, []) in\n    let args = List.rev (List.combine [0;0;9;9] [1;0;0;2]) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = bigAdd [9;9;9;9] [9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine [0; 0; 9; 9] [1; 0; 0; 2]) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n","type":"","out":""}],"event":{"region":{"start":2815,"stop":2850},"type":"eval"},"cursor":2839,"time":1.398934194671152e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.combine [0;0;9;9] [1;0;0;2];;\nlet _ = 18 mod 10\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match (a,x) with\n      | ((b,c),(d,e)) -> ((d+e+b)/10,(d+e+b) mod 10::c) \n    in\n    let base = (0, []) in\n    let args = List.rev (List.combine [0;0;9;9] [1;0;0;2]) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = bigAdd [9;9;9;9] [9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine [0; 0; 9; 9] [1; 0; 0; 2]) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n","type":"","out":""}],"event":{"region":{"start":2818,"stop":2850},"type":"eval"},"cursor":2839,"time":1.398934196268808e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.combine [0;0;9;9] [1;0;0;2];;\nlet _ = 18 mod 10\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match (a,x) with\n      | ((b,c),(d,e)) -> ((d+e+b)/10,(d+e+b) mod 10::c) \n    in\n    let base = (0, []) in\n    let args = List.rev (List.combine [0;0;9;9] [1;0;0;2]) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match (a,x) with\n| ((b,c),(d,e)) -> ((d+e+b)/10,(d+e+b) mod 10::c) \nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"","out":""}],"event":{"region":{"start":2491,"stop":2767},"type":"eval"},"cursor":2677,"time":1.398934210406671e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.combine [0;0;9;9] [1;0;0;2];;\nlet _ = 18 mod 10\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match (a,x) with\n      | ((b,c),(d,e)) -> ((d+e+b)/10,(d+e+b) mod 10::c) \n    in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = bigAdd [9;9] [1;0;0;2]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9;9;9] [9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n","type":"","out":""}],"event":{"region":{"start":2767,"stop":2836},"type":"eval"},"cursor":2826,"time":1.39893421277389e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.combine [0;0;9;9] [1;0;0;2];;\nlet _ = 18 mod 10\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match (a,x) with\n      | ((b,c),(d,e)) -> ((d+e+b)/10,(d+e+b) mod 10::c) \n    in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match (a,x) with\n| ((b,c),(d,e)) -> ((d+e+b)/10,(d+e+b) mod 10::c) \nin\nlet base = (0, []) in\nlet args = List.rev (List.combine 0::l1 0::l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev ((List.combine 0) :: (l1 0) :: l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"type","out":"Characters 179-180:\n  let args = List.rev (List.combine 0::l1 0::l2) in\n                                    ^\nError: This expression has type int but an expression was expected of type\n         'a list\n"}],"event":{"region":{"start":2491,"stop":2773},"type":"eval"},"cursor":2681,"time":1.398934246416843e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.combine [0;0;9;9] [1;0;0;2];;\nlet _ = 18 mod 10\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match (a,x) with\n      | ((b,c),(d,e)) -> ((d+e+b)/10,(d+e+b) mod 10::c) \n    in\n    let base = (0, []) in\n    let args = List.rev (List.combine 0::l1 0::l2) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match (a,x) with\n| ((b,c),(d,e)) -> ((d+e+b)/10,(d+e+b) mod 10::c) \nin\nlet base = (0, []) in\nlet args = List.rev (List.combine 0::l1 0::l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev ((List.combine 0) :: (l1 0) :: l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"type","out":"Characters 179-180:\n  let args = List.rev (List.combine 0::l1 0::l2) in\n                                    ^\nError: This expression has type int but an expression was expected of type\n         'a list\n"}],"event":{"region":{"start":2491,"stop":2773},"type":"eval"},"cursor":2681,"time":1.398934281158897e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.combine [0;0;9;9] [1;0;0;2];;\nlet _ = 18 mod 10\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match (a,x) with\n      | ((b,c),(d,e)) -> ((d+e+b)/10,(d+e+b) mod 10::c) \n    in\n    let base = (0, []) in\n    let args = List.rev (List.combine 0::l1 0::l2) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = 0::[0;0;9;9]","min":"\nlet _ = [0; 0; 0; 9; 9];;\n","type":"","out":""}],"event":{"region":{"start":2471,"stop":2494},"type":"eval"},"cursor":2496,"time":1.398934302357993e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.combine [0;0;9;9] [1;0;0;2];;\nlet _ = 0::[0;0;9;9];;\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match (a,x) with\n      | ((b,c),(d,e)) -> ((d+e+b)/10,(d+e+b) mod 10::c) \n    in\n    let base = (0, []) in\n    let args = List.rev (List.combine 0::l1 0::l2) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match (a,x) with\n| ((b,c),(d,e)) -> ((d+e+b)/10,(d+e+b) mod 10::c) \nin\nlet base = (0, []) in\nlet args = List.rev (List.combine (0::l1) 0::l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev ((List.combine (0 :: l1) 0) :: l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"type","out":"Characters 187-188:\n  let args = List.rev (List.combine (0::l1) 0::l2) in\n                                            ^\nError: This expression has type int but an expression was expected of type\n         'a list\n"}],"event":{"region":{"start":2494,"stop":2780},"type":"eval"},"cursor":2685,"time":1.398934319916889e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.combine [0;0;9;9] [1;0;0;2];;\nlet _ = 0::[0;0;9;9];;\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match (a,x) with\n      | ((b,c),(d,e)) -> ((d+e+b)/10,(d+e+b) mod 10::c) \n    in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0::l1) 0::l2) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match (a,x) with\n| ((b,c),(d,e)) -> ((d+e+b)/10,(d+e+b) mod 10::c) \nin\nlet base = (0, []) in\nlet args = List.rev (List.combine (0::l1) (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"","out":""}],"event":{"region":{"start":2494,"stop":2782},"type":"eval"},"cursor":2692,"time":1.39893432548428e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.combine [0;0;9;9] [1;0;0;2];;\nlet _ = 0::[0;0;9;9];;\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match (a,x) with\n      | ((b,c),(d,e)) -> ((d+e+b)/10,(d+e+b) mod 10::c) \n    in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0::l1) (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = bigAdd [9;9] [1;0;0;2]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9] [1; 0; 0; 2];;\n","type":"","out":""}],"event":{"region":{"start":2782,"stop":2816},"type":"eval"},"cursor":2802,"time":1.398934327979833e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.combine [0;0;9;9] [1;0;0;2];;\nlet _ = 0::[0;0;9;9];;\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match (a,x) with\n      | ((b,c),(d,e)) -> ((d+e+b)/10,(d+e+b) mod 10::c) \n    in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0::l1) (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = bigAdd [9;9;9;9] [9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n","type":"","out":""}],"event":{"region":{"start":2816,"stop":2851},"type":"eval"},"cursor":2835,"time":1.398934330461999e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.combine [0;0;9;9] [1;0;0;2];;\nlet _ = 0::[0;0;9;9];;\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match (a,x) with\n      | ((b,c),(d,e)) -> ((d+e+b)/10,(d+e+b) mod 10::c) \n    in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0::l1) (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = bigAdd [2;3;4;3;2] [9;7;8;9;6;7;6;4;2]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [2; 3; 4; 3; 2] [9; 7; 8; 9; 6; 7; 6; 4; 2];;\n","type":"","out":""}],"event":{"region":{"start":2851,"stop":2901},"type":"eval"},"cursor":2900,"time":1.398934382777182e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.combine [0;0;9;9] [1;0;0;2];;\nlet _ = 0::[0;0;9;9];;\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match (a,x) with\n      | ((b,c),(d,e)) -> ((d+e+b)/10,(d+e+b) mod 10::c) \n    in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0::l1) (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [2;3;4;3;2] [9;7;8;9;6;7;6;4;2]\n\n\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match (a,x) with\n| ((b,c),(d,e)) -> ((d+e+b)/10,(d+e+b) mod 10::c) \nin\nlet base = (0, []) in\nlet args = List.rev (List.combine (0::l1) (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"","out":""}],"event":{"region":{"start":2498,"stop":2782},"type":"eval"},"cursor":2782,"time":1.398934399842731e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.combine [0;0;9;9] [1;0;0;2];;\nlet _ = 0::[0;0;9;9];;\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match (a,x) with\n      | ((b,c),(d,e)) -> ((d+e+b)/10,(d+e+b) mod 10::c) \n    in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0::l1) (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [2;3;4;3;2] [9;7;8;9;6;7;6;4;2];;\n\n\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = bigAdd [9;9] [1;0;0;2]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9;9;9] [9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigAdd [9;3;4;3;2] [9;7;8;9;6;7;6;4;2]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 3; 4; 3; 2] [9; 7; 8; 9; 6; 7; 6; 4; 2];;\n","type":"","out":""}],"event":{"region":{"start":2782,"stop":2901},"type":"eval"},"cursor":2885,"time":1.398934421234562e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.combine [0;0;9;9] [1;0;0;2];;\nlet _ = 0::[0;0;9;9];;\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match (a,x) with\n      | ((b,c),(d,e)) -> ((d+e+b)/10,(d+e+b) mod 10::c) \n    in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0::l1) (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [9;3;4;3;2] [9;7;8;9;6;7;6;4;2];;\n\n\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec mulByDigit i l = mulByDigit i-1 bigAdd l l","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = (mulByDigit i) - (1 bigAdd l l);;\n","type":"type","out":"Characters 25-37:\n  let rec mulByDigit i l = mulByDigit i-1 bigAdd l l;;\n                           ^^^^^^^^^^^^\nError: This expression has type 'a -> 'b\n       but an expression was expected of type int\n"}],"event":{"region":{"start":2901,"stop":2958},"type":"eval"},"cursor":2958,"time":1.398934488047651e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.combine [0;0;9;9] [1;0;0;2];;\nlet _ = 0::[0;0;9;9];;\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match (a,x) with\n      | ((b,c),(d,e)) -> ((d+e+b)/10,(d+e+b) mod 10::c) \n    in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0::l1) (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [9;3;4;3;2] [9;7;8;9;6;7;6;4;2];;\n\n\n\n\nlet rec mulByDigit i l = mulByDigit i-1 bigAdd l l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec mulByDigit i l = mulByDigit (i-1) bigAdd l l","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = mulByDigit (i - 1) bigAdd l l;;\n","type":"type","out":"Characters 25-52:\n  let rec mulByDigit i l = mulByDigit (i-1) bigAdd l l;;\n                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a but an expression was expected of type\n         (int list -> int list -> int list) ->\n         (int list -> int list -> int list) -> 'a\n       The type variable 'a occurs inside\n       (int list -> int list -> int list) ->\n       (int list -> int list -> int list) -> 'a\n"}],"event":{"region":{"start":2901,"stop":2960},"type":"eval"},"cursor":2949,"time":1.398934494522524e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.combine [0;0;9;9] [1;0;0;2];;\nlet _ = 0::[0;0;9;9];;\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match (a,x) with\n      | ((b,c),(d,e)) -> ((d+e+b)/10,(d+e+b) mod 10::c) \n    in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0::l1) (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [9;3;4;3;2] [9;7;8;9;6;7;6;4;2];;\n\n\n\n\nlet rec mulByDigit i l = mulByDigit (i-1) bigAdd l l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec mulByDigit i l = if i > 0\nthen\nmulByDigit (i-1) bigAdd l l\nelse\n0","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = if i > 0 then mulByDigit (i - 1) bigAdd l l else 0;;\n","type":"type","out":"Characters 39-66:\n  mulByDigit (i-1) bigAdd l l\n  ^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a but an expression was expected of type\n         (int list -> int list -> int list) ->\n         (int list -> int list -> int list) -> 'a\n       The type variable 'a occurs inside\n       (int list -> int list -> int list) ->\n       (int list -> int list -> int list) -> 'a\n"}],"event":{"region":{"start":2901,"stop":2981},"type":"eval"},"cursor":2981,"time":1.398934513204175e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.combine [0;0;9;9] [1;0;0;2];;\nlet _ = 0::[0;0;9;9];;\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match (a,x) with\n      | ((b,c),(d,e)) -> ((d+e+b)/10,(d+e+b) mod 10::c) \n    in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0::l1) (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [9;3;4;3;2] [9;7;8;9;6;7;6;4;2];;\n\n\n\n\nlet rec mulByDigit i l = if i > 0\n  then\n    mulByDigit (i-1) bigAdd l l\n  else\n    0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec mulByDigit i l = if i > 0\nthen\nmulByDigit (i-1) (bigAdd l l)\nelse\n0","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = if i > 0 then mulByDigit (i - 1) (bigAdd l l) else 0;;\n","type":"","out":""}],"event":{"region":{"start":2901,"stop":2983},"type":"eval"},"cursor":2976,"time":1.39893452090036e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.combine [0;0;9;9] [1;0;0;2];;\nlet _ = 0::[0;0;9;9];;\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match (a,x) with\n      | ((b,c),(d,e)) -> ((d+e+b)/10,(d+e+b) mod 10::c) \n    in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0::l1) (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [9;3;4;3;2] [9;7;8;9;6;7;6;4;2];;\n\n\n\n\nlet rec mulByDigit i l = if i > 0\n  then\n    mulByDigit (i-1) (bigAdd l l)\n  else\n    0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = mulByDigit 9 [9;9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = if i > 0 then mulByDigit (i - 1) (bigAdd l l) else 0;;\n\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n","type":"","out":""}],"event":{"region":{"start":2983,"stop":3017},"type":"eval"},"cursor":2998,"time":1.398934530145412e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.combine [0;0;9;9] [1;0;0;2];;\nlet _ = 0::[0;0;9;9];;\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match (a,x) with\n      | ((b,c),(d,e)) -> ((d+e+b)/10,(d+e+b) mod 10::c) \n    in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0::l1) (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [9;3;4;3;2] [9;7;8;9;6;7;6;4;2];;\n\n\n\n\nlet rec mulByDigit i l = if i > 0\n  then\n    mulByDigit (i-1) (bigAdd l l)\n  else\n    0\n\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = padZero [] [1;3]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet _ = padZero [] [1; 3];;\n","type":"","out":""}],"event":{"region":{"start":2265,"stop":2291},"type":"eval"},"cursor":2290,"time":1.398934695663051e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \nlet _ = padZero [] [1;3]\n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.combine [0;0;9;9] [1;0;0;2];;\nlet _ = 0::[0;0;9;9];;\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match (a,x) with\n      | ((b,c),(d,e)) -> ((d+e+b)/10,(d+e+b) mod 10::c) \n    in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0::l1) (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [9;3;4;3;2] [9;7;8;9;6;7;6;4;2];;\n\n\n\n\nlet rec mulByDigit i l = let rec helper i acc l =\n  if i > 0 then\n    acc = bigAdd acc l\n  else\n    acc\n  in\n    helper i [0]\n\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec removeZero l = match l with\n| 0::t -> removeZero t\n| _ -> l","min":"\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;1;0;0;2]","min":"\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet _ = removeZero [0; 0; 0; 1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = removeZero [9;9]","min":"\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet _ = removeZero [9; 9];;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;0]","min":"\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet _ = removeZero [0; 0; 0; 0];;\n","type":"","out":""},{"in":"let _ = List.combine [0;0;9;9] [1;0;0;2]","min":"\nlet _ = List.combine [0; 0; 9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = 0::[0;0;9;9]","min":"\nlet _ = [0; 0; 0; 9; 9];;\n","type":"","out":""},{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match (a,x) with\n| ((b,c),(d,e)) -> ((d+e+b)/10,(d+e+b) mod 10::c) \nin\nlet base = (0, []) in\nlet args = List.rev (List.combine (0::l1) (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9] [1;0;0;2]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9;9;9] [9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigAdd [9;3;4;3;2] [9;7;8;9;6;7;6;4;2]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 3; 4; 3; 2] [9; 7; 8; 9; 6; 7; 6; 4; 2];;\n","type":"","out":""},{"in":"let rec mulByDigit i l = let rec helper i acc l =\nif i > 0 then\nhelper i (bigAdd acc l) l\nelse\nacc\nin\nhelper i [] l","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper i acc l = if i > 0 then helper i (bigAdd acc l) l else acc in\n  helper i [] l;;\n","type":"","out":""}],"event":{"region":{"start":2291,"stop":3048},"type":"eval"},"cursor":3050,"time":1.398934732739329e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \nlet _ = padZero [] [1;3]\n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.combine [0;0;9;9] [1;0;0;2];;\nlet _ = 0::[0;0;9;9];;\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match (a,x) with\n      | ((b,c),(d,e)) -> ((d+e+b)/10,(d+e+b) mod 10::c) \n    in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0::l1) (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [9;3;4;3;2] [9;7;8;9;6;7;6;4;2];;\n\n\n\n\nlet rec mulByDigit i l = let rec helper i acc l =\n  if i > 0 then\n    helper i (bigAdd acc l) l\n  else\n    acc\n  in\n    helper i [] l;;\n\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = mulByDigit 9 [9;9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper i acc l = if i > 0 then helper i (bigAdd acc l) l else acc in\n  helper i [] l;;\n\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n","type":"","out":""}],"event":{"region":{"start":3048,"stop":3084},"type":"eval"},"cursor":3075,"time":1.398934737212748e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \nlet _ = padZero [] [1;3]\n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.combine [0;0;9;9] [1;0;0;2];;\nlet _ = 0::[0;0;9;9];;\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match (a,x) with\n      | ((b,c),(d,e)) -> ((d+e+b)/10,(d+e+b) mod 10::c) \n    in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0::l1) (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [9;3;4;3;2] [9;7;8;9;6;7;6;4;2];;\n\n\n\n\nlet rec mulByDigit i l = let rec helper i acc l =\n  if i > 0 then\n    helper i (bigAdd acc l) l\n  else\n    acc\n  in\n    helper i [] l;;\n\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec mulByDigit i l = let rec helper i acc l =\nif i > 0 then\nhelper i-1 (bigAdd acc l) l\nelse\nacc\nin\nhelper i [] l","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper i acc l =\n    if i > 0 then (helper i) - (1 (bigAdd acc l) l) else acc in\n  helper i [] l;;\n","type":"type","out":"Characters 64-72:\n  helper i-1 (bigAdd acc l) l\n  ^^^^^^^^\nError: This expression has type 'a -> 'b -> 'c\n       but an expression was expected of type int\n"},{"in":"let _ = mulByDigit 9 [9;9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper i acc l = if i > 0 then helper i (bigAdd acc l) l else acc in\n  helper i [] l;;\n\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n","type":"","out":""}],"event":{"region":{"start":2926,"stop":3086},"type":"eval"},"cursor":3072,"time":1.398934745826916e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \nlet _ = padZero [] [1;3]\n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.combine [0;0;9;9] [1;0;0;2];;\nlet _ = 0::[0;0;9;9];;\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match (a,x) with\n      | ((b,c),(d,e)) -> ((d+e+b)/10,(d+e+b) mod 10::c) \n    in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0::l1) (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [9;3;4;3;2] [9;7;8;9;6;7;6;4;2];;\n\n\n\n\nlet rec mulByDigit i l = let rec helper i acc l =\n  if i > 0 then\n    helper i-1 (bigAdd acc l) l\n  else\n    acc\n  in\n    helper i [] l;;\n\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec mulByDigit i l = let rec helper i acc l =\nif i > 0 then\nhelper (i-1) (bigAdd acc l) l\nelse\nacc\nin\nhelper i [] l","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper i acc l =\n    if i > 0 then helper (i - 1) (bigAdd acc l) l else acc in\n  helper i [] l;;\n","type":"","out":""},{"in":"let _ = mulByDigit 9 [9;9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper i acc l =\n    if i > 0 then helper (i - 1) (bigAdd acc l) l else acc in\n  helper i [] l;;\n\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n","type":"","out":""}],"event":{"region":{"start":2926,"stop":3088},"type":"eval"},"cursor":3070,"time":1.398934752307693e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \nlet _ = padZero [] [1;3]\n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.combine [0;0;9;9] [1;0;0;2];;\nlet _ = 0::[0;0;9;9];;\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match (a,x) with\n      | ((b,c),(d,e)) -> ((d+e+b)/10,(d+e+b) mod 10::c) \n    in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0::l1) (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [9;3;4;3;2] [9;7;8;9;6;7;6;4;2];;\n\n\n\n\nlet rec mulByDigit i l = let rec helper i acc l =\n  if i > 0 then\n    helper (i-1) (bigAdd acc l) l\n  else\n    acc\n  in\n    helper i [] l;;\n\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = mulByDigit 10 [3;0]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper i acc l =\n    if i > 0 then helper (i - 1) (bigAdd acc l) l else acc in\n  helper i [] l;;\n\nlet _ = mulByDigit 10 [3; 0];;\n","type":"","out":""}],"event":{"region":{"start":3088,"stop":3116},"type":"eval"},"cursor":3115,"time":1.39893476927459e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \nlet _ = padZero [] [1;3]\n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.combine [0;0;9;9] [1;0;0;2];;\nlet _ = 0::[0;0;9;9];;\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match (a,x) with\n      | ((b,c),(d,e)) -> ((d+e+b)/10,(d+e+b) mod 10::c) \n    in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0::l1) (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [9;3;4;3;2] [9;7;8;9;6;7;6;4;2];;\n\n\n\n\nlet rec mulByDigit i l = let rec helper i acc l =\n  if i > 0 then\n    helper (i-1) (bigAdd acc l) l\n  else\n    acc\n  in\n    helper i [] l;;\n\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\nlet _ = mulByDigit 10 [3;0]\n\n\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = mulByDigit 9 [6]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper i acc l =\n    if i > 0 then helper (i - 1) (bigAdd acc l) l else acc in\n  helper i [] l;;\n\nlet _ = mulByDigit 9 [6];;\n","type":"","out":""}],"event":{"region":{"start":3116,"stop":3141},"type":"eval"},"cursor":3140,"time":1.398934782787707e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \nlet _ = padZero [] [1;3]\n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.combine [0;0;9;9] [1;0;0;2];;\nlet _ = 0::[0;0;9;9];;\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match (a,x) with\n      | ((b,c),(d,e)) -> ((d+e+b)/10,(d+e+b) mod 10::c) \n    in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0::l1) (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [9;3;4;3;2] [9;7;8;9;6;7;6;4;2];;\n\n\n\n\nlet rec mulByDigit i l = let rec helper i acc l =\n  if i > 0 then\n    helper (i-1) (bigAdd acc l) l\n  else\n    acc\n  in\n    helper i [] l;;\n\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\nlet _ = mulByDigit 10 [3;0]\nlet _ = mulByDigit 9 [6]\n\n\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _  = mulByDigit [9;3;4;3;2] [9;7;8;9;6;7;6;4;2]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper i acc l =\n    if i > 0 then helper (i - 1) (bigAdd acc l) l else acc in\n  helper i [] l;;\n\nlet _ = mulByDigit [9; 3; 4; 3; 2] [9; 7; 8; 9; 6; 7; 6; 4; 2];;\n","type":"type","out":"Characters 20-31:\n  let _  = mulByDigit [9;3;4;3;2] [9;7;8;9;6;7;6;4;2];;\n                      ^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n"}],"event":{"region":{"start":3141,"stop":3193},"type":"eval"},"cursor":3162,"time":1.398934799360041e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \nlet _ = padZero [] [1;3]\n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.combine [0;0;9;9] [1;0;0;2];;\nlet _ = 0::[0;0;9;9];;\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match (a,x) with\n      | ((b,c),(d,e)) -> ((d+e+b)/10,(d+e+b) mod 10::c) \n    in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0::l1) (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [9;3;4;3;2] [9;7;8;9;6;7;6;4;2];;\n\n\n\n\nlet rec mulByDigit i l = let rec helper i acc l =\n  if i > 0 then\n    helper (i-1) (bigAdd acc l) l\n  else\n    acc\n  in\n    helper i [] l;;\n\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\nlet _ = mulByDigit 10 [3;0]\nlet _ = mulByDigit 9 [6]\nlet _  = mulByDigit [9;3;4;3;2] [9;7;8;9;6;7;6;4;2]\n\n\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _  = mulByDigit 9 [9;7;8;9;6;7;6;4;2]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper i acc l =\n    if i > 0 then helper (i - 1) (bigAdd acc l) l else acc in\n  helper i [] l;;\n\nlet _ = mulByDigit 9 [9; 7; 8; 9; 6; 7; 6; 4; 2];;\n","type":"","out":""}],"event":{"region":{"start":3141,"stop":3183},"type":"eval"},"cursor":3163,"time":1.398934810398051e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \nlet _ = padZero [] [1;3]\n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.combine [0;0;9;9] [1;0;0;2];;\nlet _ = 0::[0;0;9;9];;\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match (a,x) with\n      | ((b,c),(d,e)) -> ((d+e+b)/10,(d+e+b) mod 10::c) \n    in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0::l1) (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [9;3;4;3;2] [9;7;8;9;6;7;6;4;2];;\n\n\n\n\nlet rec mulByDigit i l = let rec helper i acc l =\n  if i > 0 then\n    helper (i-1) (bigAdd acc l) l\n  else\n    acc\n  in\n    helper i [] l;;\n\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\nlet _ = mulByDigit 10 [3;0]\nlet _ = mulByDigit 9 [6]\nlet _  = mulByDigit 9 [9;7;8;9;6;7;6;4;2]\n\n\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigMul l1 l2 = \nlet f a x = match (a,x) with\n| ((b,c),d) -> d \nin\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres","min":"\nlet bigMul l1 l2 =\n  let f a x = match (a, x) with | ((b,c),d) -> d in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n","type":"","out":""}],"event":{"region":{"start":3183,"stop":3352},"type":"eval"},"cursor":3252,"time":1.398935381286088e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \nlet _ = padZero [] [1;3]\n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.combine [0;0;9;9] [1;0;0;2];;\nlet _ = 0::[0;0;9;9];;\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match (a,x) with\n      | ((b,c),(d,e)) -> ((d+e+b)/10,(d+e+b) mod 10::c) \n    in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0::l1) (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [9;3;4;3;2] [9;7;8;9;6;7;6;4;2];;\n\n\n\n\nlet rec mulByDigit i l = let rec helper i acc l =\n  if i > 0 then\n    helper (i-1) (bigAdd acc l) l\n  else\n    acc\n  in\n    helper i [] l;;\n\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\nlet _ = mulByDigit 10 [3;0]\nlet _ = mulByDigit 9 [6]\nlet _  = mulByDigit 9 [9;7;8;9;6;7;6;4;2]\n\n\n\nlet bigMul l1 l2 = \n  let f a x = match (a,x) with\n    | ((b,c),d) -> d \n  in\n  let base = (0,[]) in\n  let args = List.rev l2 in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigMul l1 l2 = \nlet f a x = match (a,x) with\n| ((b,c),d) -> (b+1,(mulByDigit d l1)::(clone 0 b))\nin\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres","min":"","type":"scope","out":"Error: This expression has type int list\n       but an expression was expected of type int list list\n       Type int is not compatible with type int list \nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 88-99:\n  | ((b,c),d) -> (b+1,(mulByDigit d l1)::(clone 0 b))\n                                         ^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int list list\n       Type int is not compatible with type int list \n"}],"event":{"region":{"start":3183,"stop":3386},"type":"eval"},"cursor":3287,"time":1.398935465226238e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \nlet _ = padZero [] [1;3]\n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.combine [0;0;9;9] [1;0;0;2];;\nlet _ = 0::[0;0;9;9];;\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match (a,x) with\n      | ((b,c),(d,e)) -> ((d+e+b)/10,(d+e+b) mod 10::c) \n    in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0::l1) (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [9;3;4;3;2] [9;7;8;9;6;7;6;4;2];;\n\n\n\n\nlet rec mulByDigit i l = let rec helper i acc l =\n  if i > 0 then\n    helper (i-1) (bigAdd acc l) l\n  else\n    acc\n  in\n    helper i [] l;;\n\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\nlet _ = mulByDigit 10 [3;0]\nlet _ = mulByDigit 9 [6]\nlet _  = mulByDigit 9 [9;7;8;9;6;7;6;4;2]\n\n\n\nlet bigMul l1 l2 = \n  let f a x = match (a,x) with\n    | ((b,c),d) -> (b+1,(mulByDigit d l1)::(clone 0 b))\n  in\n  let base = (0,[]) in\n  let args = List.rev l2 in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigMul l1 l2 = \nlet f a x = match (a,x) with\n| ((b,c),d) -> (b+1,List.append (mulByDigit d l1) (clone 0 b))\nin\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres","min":"\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet rec mulByDigit i l =\n  let rec helper i acc l =\n    if i > 0 then helper (i - 1) (bigAdd acc l) l else acc in\n  helper i [] l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match (a, x) with\n    | ((b,c),d) -> ((b + 1), (List.append (mulByDigit d l1) (clone 0 b))) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n","type":"","out":""}],"event":{"region":{"start":3183,"stop":3397},"type":"eval"},"cursor":3268,"time":1.398935494499217e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \nlet _ = padZero [] [1;3]\n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.combine [0;0;9;9] [1;0;0;2];;\nlet _ = 0::[0;0;9;9];;\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match (a,x) with\n      | ((b,c),(d,e)) -> ((d+e+b)/10,(d+e+b) mod 10::c) \n    in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0::l1) (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [9;3;4;3;2] [9;7;8;9;6;7;6;4;2];;\n\n\n\n\nlet rec mulByDigit i l = let rec helper i acc l =\n  if i > 0 then\n    helper (i-1) (bigAdd acc l) l\n  else\n    acc\n  in\n    helper i [] l;;\n\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\nlet _ = mulByDigit 10 [3;0]\nlet _ = mulByDigit 9 [6]\nlet _  = mulByDigit 9 [9;7;8;9;6;7;6;4;2]\n\n\n\nlet bigMul l1 l2 = \n  let f a x = match (a,x) with\n    | ((b,c),d) -> (b+1,List.append (mulByDigit d l1) (clone 0 b))\n  in\n  let base = (0,[]) in\n  let args = List.rev l2 in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = bigMul [9;9;9;9] [9;9;9;9]","min":"\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet rec mulByDigit i l =\n  let rec helper i acc l =\n    if i > 0 then helper (i - 1) (bigAdd acc l) l else acc in\n  helper i [] l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match (a, x) with\n    | ((b,c),d) -> ((b + 1), (List.append (mulByDigit d l1) (clone 0 b))) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n","type":"","out":""}],"event":{"region":{"start":3397,"stop":3436},"type":"eval"},"cursor":3406,"time":1.39893550081817e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \nlet _ = padZero [] [1;3]\n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.combine [0;0;9;9] [1;0;0;2];;\nlet _ = 0::[0;0;9;9];;\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match (a,x) with\n      | ((b,c),(d,e)) -> ((d+e+b)/10,(d+e+b) mod 10::c) \n    in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0::l1) (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [9;3;4;3;2] [9;7;8;9;6;7;6;4;2];;\n\n\n\n\nlet rec mulByDigit i l = let rec helper i acc l =\n  if i > 0 then\n    helper (i-1) (bigAdd acc l) l\n  else\n    acc\n  in\n    helper i [] l;;\n\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\nlet _ = mulByDigit 10 [3;0]\nlet _ = mulByDigit 9 [6]\nlet _  = mulByDigit 9 [9;7;8;9;6;7;6;4;2]\n\n\n\nlet bigMul l1 l2 = \n  let f a x = match (a,x) with\n    | ((b,c),d) -> (b+1,List.append (mulByDigit d l1) (clone 0 b))\n  in\n  let base = (0,[]) in\n  let args = List.rev l2 in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n\n\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = bigMul [4;0] [1;0]","min":"\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet rec mulByDigit i l =\n  let rec helper i acc l =\n    if i > 0 then helper (i - 1) (bigAdd acc l) l else acc in\n  helper i [] l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match (a, x) with\n    | ((b,c),d) -> ((b + 1), (List.append (mulByDigit d l1) (clone 0 b))) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [4; 0] [1; 0];;\n","type":"","out":""}],"event":{"region":{"start":3397,"stop":3427},"type":"eval"},"cursor":3426,"time":1.398935550744989e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \nlet _ = padZero [] [1;3]\n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.combine [0;0;9;9] [1;0;0;2];;\nlet _ = 0::[0;0;9;9];;\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match (a,x) with\n      | ((b,c),(d,e)) -> ((d+e+b)/10,(d+e+b) mod 10::c) \n    in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0::l1) (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [9;3;4;3;2] [9;7;8;9;6;7;6;4;2];;\n\n\n\n\nlet rec mulByDigit i l = let rec helper i acc l =\n  if i > 0 then\n    helper (i-1) (bigAdd acc l) l\n  else\n    acc\n  in\n    helper i [] l;;\n\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\nlet _ = mulByDigit 10 [3;0]\nlet _ = mulByDigit 9 [6]\nlet _  = mulByDigit 9 [9;7;8;9;6;7;6;4;2]\n\n\n\nlet bigMul l1 l2 = \n  let f a x = match (a,x) with\n    | ((b,c),d) -> (b+1,List.append (mulByDigit d l1) (clone 0 b))\n  in\n  let base = (0,[]) in\n  let args = List.rev l2 in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n\nlet _ = bigMul [4;0] [1;0]\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = bigMul [4;0] [1;1]","min":"\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet rec mulByDigit i l =\n  let rec helper i acc l =\n    if i > 0 then helper (i - 1) (bigAdd acc l) l else acc in\n  helper i [] l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match (a, x) with\n    | ((b,c),d) -> ((b + 1), (List.append (mulByDigit d l1) (clone 0 b))) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [4; 0] [1; 1];;\n","type":"","out":""}],"event":{"region":{"start":3397,"stop":3427},"type":"eval"},"cursor":3426,"time":1.39893555597527e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \nlet _ = padZero [] [1;3]\n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.combine [0;0;9;9] [1;0;0;2];;\nlet _ = 0::[0;0;9;9];;\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match (a,x) with\n      | ((b,c),(d,e)) -> ((d+e+b)/10,(d+e+b) mod 10::c) \n    in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0::l1) (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [9;3;4;3;2] [9;7;8;9;6;7;6;4;2];;\n\n\n\n\nlet rec mulByDigit i l = let rec helper i acc l =\n  if i > 0 then\n    helper (i-1) (bigAdd acc l) l\n  else\n    acc\n  in\n    helper i [] l;;\n\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\nlet _ = mulByDigit 10 [3;0]\nlet _ = mulByDigit 9 [6]\nlet _  = mulByDigit 9 [9;7;8;9;6;7;6;4;2]\n\n\n\nlet bigMul l1 l2 = \n  let f a x = match (a,x) with\n    | ((b,c),d) -> (b+1,List.append (mulByDigit d l1) (clone 0 b))\n  in\n  let base = (0,[]) in\n  let args = List.rev l2 in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n\nlet _ = bigMul [4;0] [1;1]\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigMul l1 l2 = \nlet f a x = match (a,x) with\n| ((b,c),d) -> (b+1,bigAdd (List.append (mulByDigit d l1) (clone 0 b)) c)\nin\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres","min":"\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet rec mulByDigit i l =\n  let rec helper i acc l =\n    if i > 0 then helper (i - 1) (bigAdd acc l) l else acc in\n  helper i [] l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match (a, x) with\n    | ((b,c),d) ->\n        ((b + 1), (bigAdd (List.append (mulByDigit d l1) (clone 0 b)) c)) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n","type":"","out":""}],"event":{"region":{"start":3183,"stop":3408},"type":"eval"},"cursor":3308,"time":1.398935599452531e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \nlet _ = padZero [] [1;3]\n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.combine [0;0;9;9] [1;0;0;2];;\nlet _ = 0::[0;0;9;9];;\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match (a,x) with\n      | ((b,c),(d,e)) -> ((d+e+b)/10,(d+e+b) mod 10::c) \n    in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0::l1) (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [9;3;4;3;2] [9;7;8;9;6;7;6;4;2];;\n\n\n\n\nlet rec mulByDigit i l = let rec helper i acc l =\n  if i > 0 then\n    helper (i-1) (bigAdd acc l) l\n  else\n    acc\n  in\n    helper i [] l;;\n\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\nlet _ = mulByDigit 10 [3;0]\nlet _ = mulByDigit 9 [6]\nlet _  = mulByDigit 9 [9;7;8;9;6;7;6;4;2]\n\n\n\nlet bigMul l1 l2 = \n  let f a x = match (a,x) with\n    | ((b,c),d) -> (b+1,bigAdd (List.append (mulByDigit d l1) (clone 0 b)) c)\n  in\n  let base = (0,[]) in\n  let args = List.rev l2 in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n\nlet _ = bigMul [4;0] [1;1]\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = bigMul [4;0] [1;1]","min":"\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet rec mulByDigit i l =\n  let rec helper i acc l =\n    if i > 0 then helper (i - 1) (bigAdd acc l) l else acc in\n  helper i [] l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match (a, x) with\n    | ((b,c),d) ->\n        ((b + 1), (bigAdd (List.append (mulByDigit d l1) (clone 0 b)) c)) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [4; 0] [1; 1];;\n","type":"","out":""}],"event":{"region":{"start":3408,"stop":3438},"type":"eval"},"cursor":3436,"time":1.398935602556917e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \nlet _ = padZero [] [1;3]\n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.combine [0;0;9;9] [1;0;0;2];;\nlet _ = 0::[0;0;9;9];;\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match (a,x) with\n      | ((b,c),(d,e)) -> ((d+e+b)/10,(d+e+b) mod 10::c) \n    in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0::l1) (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [9;3;4;3;2] [9;7;8;9;6;7;6;4;2];;\n\n\n\n\nlet rec mulByDigit i l = let rec helper i acc l =\n  if i > 0 then\n    helper (i-1) (bigAdd acc l) l\n  else\n    acc\n  in\n    helper i [] l;;\n\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\nlet _ = mulByDigit 10 [3;0]\nlet _ = mulByDigit 9 [6]\nlet _  = mulByDigit 9 [9;7;8;9;6;7;6;4;2]\n\n\n\nlet bigMul l1 l2 = \n  let f a x = match (a,x) with\n    | ((b,c),d) -> (b+1,bigAdd (List.append (mulByDigit d l1) (clone 0 b)) c)\n  in\n  let base = (0,[]) in\n  let args = List.rev l2 in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n\nlet _ = bigMul [4;0] [1;1]\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = bigMul [9;9;9;9] [9;9;9;9]","min":"\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet rec mulByDigit i l =\n  let rec helper i acc l =\n    if i > 0 then helper (i - 1) (bigAdd acc l) l else acc in\n  helper i [] l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match (a, x) with\n    | ((b,c),d) ->\n        ((b + 1), (bigAdd (List.append (mulByDigit d l1) (clone 0 b)) c)) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n","type":"","out":""}],"event":{"region":{"start":3438,"stop":3473},"type":"eval"},"cursor":3463,"time":1.398935604103862e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \nlet _ = padZero [] [1;3]\n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.combine [0;0;9;9] [1;0;0;2];;\nlet _ = 0::[0;0;9;9];;\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match (a,x) with\n      | ((b,c),(d,e)) -> ((d+e+b)/10,(d+e+b) mod 10::c) \n    in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0::l1) (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [9;3;4;3;2] [9;7;8;9;6;7;6;4;2];;\n\n\n\n\nlet rec mulByDigit i l = let rec helper i acc l =\n  if i > 0 then\n    helper (i-1) (bigAdd acc l) l\n  else\n    acc\n  in\n    helper i [] l;;\n\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\nlet _ = mulByDigit 10 [3;0]\nlet _ = mulByDigit 9 [6]\nlet _  = mulByDigit 9 [9;7;8;9;6;7;6;4;2]\n\n\n\nlet bigMul l1 l2 = \n  let f a x = match (a,x) with\n    | ((b,c),d) -> (b+1,bigAdd (List.append (mulByDigit d l1) (clone 0 b)) c)\n  in\n  let base = (0,[]) in\n  let args = List.rev l2 in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n\nlet _ = bigMul [4;0] [1;1]\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]","min":"\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet rec mulByDigit i l =\n  let rec helper i acc l =\n    if i > 0 then helper (i - 1) (bigAdd acc l) l else acc in\n  helper i [] l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match (a, x) with\n    | ((b,c),d) ->\n        ((b + 1), (bigAdd (List.append (mulByDigit d l1) (clone 0 b)) c)) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9; 9] [9; 9; 9; 9; 9];;\n","type":"","out":""}],"event":{"region":{"start":3473,"stop":3512},"type":"eval"},"cursor":3498,"time":1.398935612415303e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \nlet _ = padZero [] [1;3]\n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.combine [0;0;9;9] [1;0;0;2];;\nlet _ = 0::[0;0;9;9];;\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match (a,x) with\n      | ((b,c),(d,e)) -> ((d+e+b)/10,(d+e+b) mod 10::c) \n    in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0::l1) (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [9;3;4;3;2] [9;7;8;9;6;7;6;4;2];;\n\n\n\n\nlet rec mulByDigit i l = let rec helper i acc l =\n  if i > 0 then\n    helper (i-1) (bigAdd acc l) l\n  else\n    acc\n  in\n    helper i [] l;;\n\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\nlet _ = mulByDigit 10 [3;0]\nlet _ = mulByDigit 9 [6]\nlet _  = mulByDigit 9 [9;7;8;9;6;7;6;4;2]\n\n\n\nlet bigMul l1 l2 = \n  let f a x = match (a,x) with\n    | ((b,c),d) -> (b+1,bigAdd (List.append (mulByDigit d l1) (clone 0 b)) c)\n  in\n  let base = (0,[]) in\n  let args = List.rev l2 in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n\nlet _ = bigMul [4;0] [1;1]\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]","min":"\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet rec mulByDigit i l =\n  let rec helper i acc l =\n    if i > 0 then helper (i - 1) (bigAdd acc l) l else acc in\n  helper i [] l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match (a, x) with\n    | ((b,c),d) ->\n        ((b + 1), (bigAdd (List.append (mulByDigit d l1) (clone 0 b)) c)) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9; 9] [9; 9; 9; 9; 9];;\n","type":"","out":""},{"in":"let key = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130 = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ ((Printexc.to_string e) ^ \"\\n\"));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n","type":"","out":""},{"in":"let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","min":"\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n","type":"","out":""},{"in":"let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n\nlet drop_paren s =\n  implode\n    (List.filter (fun c  -> not (List.mem c ['('; ' '; ')'])) (explode s));;\n","type":"","out":""},{"in":"let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","min":"\nlet eq_real p (r1,r2) = ((r1 -. r2) < p) || ((r2 -. r1) < p);;\n","type":"","out":""},{"in":"let wrap_curried_2 f (a,b) = f a b","min":"\nlet wrap_curried_2 f (a,b) = f a b;;\n","type":"","out":""},{"in":"let _ = print130 (\"Compiled\"^key^\"\\n\")","min":"\nlet prefix130 = \"130\";;\n\nlet key = \"\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet _ = print130 (\"Compiled\" ^ (key ^ \"\\n\"));;\n","type":"","out":""}],"event":{"region":{"start":3474,"stop":7533},"type":"eval"},"cursor":3498,"time":1.398935624958275e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \nlet _ = padZero [] [1;3]\n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.combine [0;0;9;9] [1;0;0;2];;\nlet _ = 0::[0;0;9;9];;\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match (a,x) with\n      | ((b,c),(d,e)) -> ((d+e+b)/10,(d+e+b) mod 10::c) \n    in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0::l1) (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [9;3;4;3;2] [9;7;8;9;6;7;6;4;2];;\n\n\n\n\nlet rec mulByDigit i l = let rec helper i acc l =\n  if i > 0 then\n    helper (i-1) (bigAdd acc l) l\n  else\n    acc\n  in\n    helper i [] l;;\n\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\nlet _ = mulByDigit 10 [3;0]\nlet _ = mulByDigit 9 [6]\nlet _  = mulByDigit 9 [9;7;8;9;6;7;6;4;2]\n\n\n\nlet bigMul l1 l2 = \n  let f a x = match (a,x) with\n    | ((b,c),d) -> (b+1,bigAdd (List.append (mulByDigit d l1) (clone 0 b)) c)\n  in\n  let base = (0,[]) in\n  let args = List.rev l2 in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n\nlet _ = bigMul [4;0] [1;1]\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n\nlet _ =\n  stringOfList (stringOfList string_of_int) [[1; 2; 3]; [4; 5]; [6]; []];;\n","type":"","out":""}],"event":{"region":{"start":1568,"stop":1640},"type":"eval"},"cursor":1628,"time":1.398935694898728e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \nlet _ = padZero [] [1;3]\n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.combine [0;0;9;9] [1;0;0;2];;\nlet _ = 0::[0;0;9;9];;\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match (a,x) with\n      | ((b,c),(d,e)) -> ((d+e+b)/10,(d+e+b) mod 10::c) \n    in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0::l1) (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [9;3;4;3;2] [9;7;8;9;6;7;6;4;2];;\n\n\n\n\nlet rec mulByDigit i l = let rec helper i acc l =\n  if i > 0 then\n    helper (i-1) (bigAdd acc l) l\n  else\n    acc\n  in\n    helper i [] l;;\n\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\nlet _ = mulByDigit 10 [3;0]\nlet _ = mulByDigit 9 [6]\nlet _  = mulByDigit 9 [9;7;8;9;6;7;6;4;2]\n\n\n\nlet bigMul l1 l2 = \n  let f a x = match (a,x) with\n    | ((b,c),d) -> (b+1,bigAdd (List.append (mulByDigit d l1) (clone 0 b)) c)\n  in\n  let base = (0,[]) in\n  let args = List.rev l2 in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n\nlet _ = bigMul [4;0] [1;1]\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n","type":"","out":""},{"in":"let _ = sqsum []","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [];;\n","type":"","out":""},{"in":"let _ = sqsum [1;2;3;4]","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sqsum [(-1); (-2); (-3); (-4)]","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [(-1); (-2); (-3); (-4)];;\n","type":"","out":""},{"in":"let pipe fs = \nlet f a x = fun y -> x (a y) in\nlet base = fun x -> x in\nList.fold_left f base fs","min":"\nlet pipe fs =\n  let f a x y = x (a y) in let base x = x in List.fold_left f base fs;;\n","type":"","out":""},{"in":"let _ = pipe [] 3","min":"\nlet pipe fs =\n  let f a x y = x (a y) in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n","type":"","out":""},{"in":"let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3","min":"\nlet pipe fs =\n  let f a x y = x (a y) in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n","type":"","out":""},{"in":"let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3","min":"\nlet pipe fs =\n  let f a x y = x (a y) in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n","type":"","out":""},{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n","type":"","out":""},{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"---\" []","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"---\" [];;\n","type":"","out":""},{"in":"let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"\" [\"a\"; \"b\"; \"c\"; \"d\"; \"e\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"X\" [\"hello\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"X\" [\"hello\"];;\n","type":"","out":""},{"in":"let stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n","type":"","out":""},{"in":"let _ = stringOfList string_of_int [1;2;3;4;5;6]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n\nlet _ = stringOfList string_of_int [1; 2; 3; 4; 5; 6];;\n","type":"","out":""},{"in":"let _ = stringOfList (fun x -> x) [\"foo\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n\nlet _ = stringOfList (fun x  -> x) [\"foo\"];;\n","type":"","out":""},{"in":"let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n\nlet _ =\n  stringOfList (stringOfList string_of_int) [[1; 2; 3]; [4; 5]; [6]; []];;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":1640},"type":"eval"},"cursor":1642,"time":1.398935701585278e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \nlet _ = padZero [] [1;3]\n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.combine [0;0;9;9] [1;0;0;2];;\nlet _ = 0::[0;0;9;9];;\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match (a,x) with\n      | ((b,c),(d,e)) -> ((d+e+b)/10,(d+e+b) mod 10::c) \n    in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0::l1) (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [9;3;4;3;2] [9;7;8;9;6;7;6;4;2];;\n\n\n\n\nlet rec mulByDigit i l = let rec helper i acc l =\n  if i > 0 then\n    helper (i-1) (bigAdd acc l) l\n  else\n    acc\n  in\n    helper i [] l;;\n\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\nlet _ = mulByDigit 10 [3;0]\nlet _ = mulByDigit 9 [6]\nlet _  = mulByDigit 9 [9;7;8;9;6;7;6;4;2]\n\n\n\nlet bigMul l1 l2 = \n  let f a x = match (a,x) with\n    | ((b,c),d) -> (b+1,bigAdd (List.append (mulByDigit d l1) (clone 0 b)) c)\n  in\n  let base = (0,[]) in\n  let args = List.rev l2 in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n\nlet _ = bigMul [4;0] [1;1]\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n","type":"","out":""}],"event":{"region":{"start":1401,"stop":1470},"type":"eval"},"cursor":1448,"time":1.398935720652318e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \nlet _ = padZero [] [1;3]\n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.combine [0;0;9;9] [1;0;0;2];;\nlet _ = 0::[0;0;9;9];;\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match (a,x) with\n      | ((b,c),(d,e)) -> ((d+e+b)/10,(d+e+b) mod 10::c) \n    in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0::l1) (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [9;3;4;3;2] [9;7;8;9;6;7;6;4;2];;\n\n\n\n\nlet rec mulByDigit i l = let rec helper i acc l =\n  if i > 0 then\n    helper (i-1) (bigAdd acc l) l\n  else\n    acc\n  in\n    helper i [] l;;\n\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\nlet _ = mulByDigit 10 [3;0]\nlet _ = mulByDigit 9 [6]\nlet _  = mulByDigit 9 [9;7;8;9;6;7;6;4;2]\n\n\n\nlet bigMul l1 l2 = \n  let f a x = match (a,x) with\n    | ((b,c),d) -> (b+1,bigAdd (List.append (mulByDigit d l1) (clone 0 b)) c)\n  in\n  let base = (0,[]) in\n  let args = List.rev l2 in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n\nlet _ = bigMul [4;0] [1;1]\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = stringOfList string_of_int [1;2;3;4;5;6]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n\nlet _ = stringOfList string_of_int [1; 2; 3; 4; 5; 6];;\n","type":"","out":""},{"in":"let _ = stringOfList (fun x -> x) [\"foo\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n\nlet _ = stringOfList (fun x  -> x) [\"foo\"];;\n","type":"","out":""},{"in":"let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n\nlet _ =\n  stringOfList (stringOfList string_of_int) [[1; 2; 3]; [4; 5]; [6]; []];;\n","type":"","out":""}],"event":{"region":{"start":1470,"stop":1641},"type":"eval"},"cursor":1641,"time":1.398935724761158e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \nlet _ = padZero [] [1;3]\n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.combine [0;0;9;9] [1;0;0;2];;\nlet _ = 0::[0;0;9;9];;\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match (a,x) with\n      | ((b,c),(d,e)) -> ((d+e+b)/10,(d+e+b) mod 10::c) \n    in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0::l1) (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [9;3;4;3;2] [9;7;8;9;6;7;6;4;2];;\n\n\n\n\nlet rec mulByDigit i l = let rec helper i acc l =\n  if i > 0 then\n    helper (i-1) (bigAdd acc l) l\n  else\n    acc\n  in\n    helper i [] l;;\n\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\nlet _ = mulByDigit 10 [3;0]\nlet _ = mulByDigit 9 [6]\nlet _  = mulByDigit 9 [9;7;8;9;6;7;6;4;2]\n\n\n\nlet bigMul l1 l2 = \n  let f a x = match (a,x) with\n    | ((b,c),d) -> (b+1,bigAdd (List.append (mulByDigit d l1) (clone 0 b)) c)\n  in\n  let base = (0,[]) in\n  let args = List.rev l2 in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n\nlet _ = bigMul [4;0] [1;1]\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n\nlet _ =\n  stringOfList (stringOfList string_of_int) [[1; 2; 3]; [4; 5]; [6]; []];;\n","type":"","out":""},{"in":"let rec clone x n =\nif n > 0 then\nx :: clone x (n-1)\nelse\n[]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n","type":"","out":""},{"in":"let _ = clone 3 5","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet _ = clone 3 5;;\n","type":"","out":""},{"in":"let _ = clone \"foo\" 2","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet _ = clone \"foo\" 2;;\n","type":"","out":""},{"in":"let _ = clone clone (-3)","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet _ = clone clone (-3);;\n","type":"","out":""},{"in":"let padZero l1 l2 = if (List.length l1) > (List.length l2) then\n(l1,\nList.append (clone 0 ((List.length l1) - (List.length l2))) l2)\nelse\n(List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\nl2)","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n","type":"","out":""},{"in":"let _ = padZero [9;9] [1;0;0;2]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet _ = padZero [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = padZero [1;0;0;2] [9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet _ = padZero [1; 0; 0; 2] [9; 9];;\n","type":"","out":""},{"in":"let _ = padZero [] [1;3]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet _ = padZero [] [1; 3];;\n","type":"","out":""},{"in":"let rec removeZero l = match l with\n| 0::t -> removeZero t\n| _ -> l","min":"\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;1;0;0;2]","min":"\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet _ = removeZero [0; 0; 0; 1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = removeZero [9;9]","min":"\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet _ = removeZero [9; 9];;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;0]","min":"\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet _ = removeZero [0; 0; 0; 0];;\n","type":"","out":""},{"in":"let _ = List.combine [0;0;9;9] [1;0;0;2]","min":"\nlet _ = List.combine [0; 0; 9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = 0::[0;0;9;9]","min":"\nlet _ = [0; 0; 0; 9; 9];;\n","type":"","out":""},{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match (a,x) with\n| ((b,c),(d,e)) -> ((d+e+b)/10,(d+e+b) mod 10::c) \nin\nlet base = (0, []) in\nlet args = List.rev (List.combine (0::l1) (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9] [1;0;0;2]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9;9;9] [9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigAdd [9;3;4;3;2] [9;7;8;9;6;7;6;4;2]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 3; 4; 3; 2] [9; 7; 8; 9; 6; 7; 6; 4; 2];;\n","type":"","out":""},{"in":"let rec mulByDigit i l = let rec helper i acc l =\nif i > 0 then\nhelper (i-1) (bigAdd acc l) l\nelse\nacc\nin\nhelper i [] l","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper i acc l =\n    if i > 0 then helper (i - 1) (bigAdd acc l) l else acc in\n  helper i [] l;;\n","type":"","out":""},{"in":"let _ = mulByDigit 9 [9;9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper i acc l =\n    if i > 0 then helper (i - 1) (bigAdd acc l) l else acc in\n  helper i [] l;;\n\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let _ = mulByDigit 10 [3;0]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper i acc l =\n    if i > 0 then helper (i - 1) (bigAdd acc l) l else acc in\n  helper i [] l;;\n\nlet _ = mulByDigit 10 [3; 0];;\n","type":"","out":""},{"in":"let _ = mulByDigit 9 [6]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper i acc l =\n    if i > 0 then helper (i - 1) (bigAdd acc l) l else acc in\n  helper i [] l;;\n\nlet _ = mulByDigit 9 [6];;\n","type":"","out":""},{"in":"let _  = mulByDigit 9 [9;7;8;9;6;7;6;4;2]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper i acc l =\n    if i > 0 then helper (i - 1) (bigAdd acc l) l else acc in\n  helper i [] l;;\n\nlet _ = mulByDigit 9 [9; 7; 8; 9; 6; 7; 6; 4; 2];;\n","type":"","out":""},{"in":"let bigMul l1 l2 = \nlet f a x = match (a,x) with\n| ((b,c),d) -> (b+1,bigAdd (List.append (mulByDigit d l1) (clone 0 b)) c)\nin\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres","min":"\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet rec mulByDigit i l =\n  let rec helper i acc l =\n    if i > 0 then helper (i - 1) (bigAdd acc l) l else acc in\n  helper i [] l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match (a, x) with\n    | ((b,c),d) ->\n        ((b + 1), (bigAdd (List.append (mulByDigit d l1) (clone 0 b)) c)) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n","type":"","out":""},{"in":"let _ = bigMul [4;0] [1;1]","min":"\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet rec mulByDigit i l =\n  let rec helper i acc l =\n    if i > 0 then helper (i - 1) (bigAdd acc l) l else acc in\n  helper i [] l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match (a, x) with\n    | ((b,c),d) ->\n        ((b + 1), (bigAdd (List.append (mulByDigit d l1) (clone 0 b)) c)) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [4; 0] [1; 1];;\n","type":"","out":""},{"in":"let _ = bigMul [9;9;9;9] [9;9;9;9]","min":"\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet rec mulByDigit i l =\n  let rec helper i acc l =\n    if i > 0 then helper (i - 1) (bigAdd acc l) l else acc in\n  helper i [] l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match (a, x) with\n    | ((b,c),d) ->\n        ((b + 1), (bigAdd (List.append (mulByDigit d l1) (clone 0 b)) c)) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]","min":"\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet rec mulByDigit i l =\n  let rec helper i acc l =\n    if i > 0 then helper (i - 1) (bigAdd acc l) l else acc in\n  helper i [] l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match (a, x) with\n    | ((b,c),d) ->\n        ((b + 1), (bigAdd (List.append (mulByDigit d l1) (clone 0 b)) c)) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9; 9] [9; 9; 9; 9; 9];;\n","type":"","out":""},{"in":"let key = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130 = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ ((Printexc.to_string e) ^ \"\\n\"));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n","type":"","out":""},{"in":"let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","min":"\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n","type":"","out":""},{"in":"let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n\nlet drop_paren s =\n  implode\n    (List.filter (fun c  -> not (List.mem c ['('; ' '; ')'])) (explode s));;\n","type":"","out":""},{"in":"let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","min":"\nlet eq_real p (r1,r2) = ((r1 -. r2) < p) || ((r2 -. r1) < p);;\n","type":"","out":""},{"in":"let wrap_curried_2 f (a,b) = f a b","min":"\nlet wrap_curried_2 f (a,b) = f a b;;\n","type":"","out":""}],"event":{"region":{"start":1569,"stop":7534},"type":"eval"},"cursor":1641,"time":1.398935728104718e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \nlet _ = padZero [] [1;3]\n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.combine [0;0;9;9] [1;0;0;2];;\nlet _ = 0::[0;0;9;9];;\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match (a,x) with\n      | ((b,c),(d,e)) -> ((d+e+b)/10,(d+e+b) mod 10::c) \n    in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0::l1) (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [9;3;4;3;2] [9;7;8;9;6;7;6;4;2];;\n\n\n\n\nlet rec mulByDigit i l = let rec helper i acc l =\n  if i > 0 then\n    helper (i-1) (bigAdd acc l) l\n  else\n    acc\n  in\n    helper i [] l;;\n\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\nlet _ = mulByDigit 10 [3;0]\nlet _ = mulByDigit 9 [6]\nlet _  = mulByDigit 9 [9;7;8;9;6;7;6;4;2]\n\n\n\nlet bigMul l1 l2 = \n  let f a x = match (a,x) with\n    | ((b,c),d) -> (b+1,bigAdd (List.append (mulByDigit d l1) (clone 0 b)) c)\n  in\n  let base = (0,[]) in\n  let args = List.rev l2 in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n\nlet _ = bigMul [4;0] [1;1]\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n","type":"","out":""},{"in":"let _ = sqsum []","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [];;\n","type":"","out":""},{"in":"let _ = sqsum [1;2;3;4]","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sqsum [(-1); (-2); (-3); (-4)]","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [(-1); (-2); (-3); (-4)];;\n","type":"","out":""},{"in":"let pipe fs = \nlet f a x = fun y -> x (a y) in\nlet base = fun x -> x in\nList.fold_left f base fs","min":"\nlet pipe fs =\n  let f a x y = x (a y) in let base x = x in List.fold_left f base fs;;\n","type":"","out":""},{"in":"let _ = pipe [] 3","min":"\nlet pipe fs =\n  let f a x y = x (a y) in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n","type":"","out":""},{"in":"let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3","min":"\nlet pipe fs =\n  let f a x y = x (a y) in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n","type":"","out":""},{"in":"let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3","min":"\nlet pipe fs =\n  let f a x y = x (a y) in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n","type":"","out":""},{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n","type":"","out":""},{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"---\" []","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"---\" [];;\n","type":"","out":""},{"in":"let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"\" [\"a\"; \"b\"; \"c\"; \"d\"; \"e\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"X\" [\"hello\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"X\" [\"hello\"];;\n","type":"","out":""},{"in":"let stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n","type":"","out":""},{"in":"let _ = stringOfList string_of_int [1;2;3;4;5;6]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n\nlet _ = stringOfList string_of_int [1; 2; 3; 4; 5; 6];;\n","type":"","out":""},{"in":"let _ = stringOfList (fun x -> x) [\"foo\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n\nlet _ = stringOfList (fun x  -> x) [\"foo\"];;\n","type":"","out":""},{"in":"let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n\nlet _ =\n  stringOfList (stringOfList string_of_int) [[1; 2; 3]; [4; 5]; [6]; []];;\n","type":"","out":""},{"in":"let rec clone x n =\nif n > 0 then\nx :: clone x (n-1)\nelse\n[]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n","type":"","out":""},{"in":"let _ = clone 3 5","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet _ = clone 3 5;;\n","type":"","out":""},{"in":"let _ = clone \"foo\" 2","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet _ = clone \"foo\" 2;;\n","type":"","out":""},{"in":"let _ = clone clone (-3)","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet _ = clone clone (-3);;\n","type":"","out":""},{"in":"let padZero l1 l2 = if (List.length l1) > (List.length l2) then\n(l1,\nList.append (clone 0 ((List.length l1) - (List.length l2))) l2)\nelse\n(List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\nl2)","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n","type":"","out":""},{"in":"let _ = padZero [9;9] [1;0;0;2]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet _ = padZero [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = padZero [1;0;0;2] [9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet _ = padZero [1; 0; 0; 2] [9; 9];;\n","type":"","out":""},{"in":"let _ = padZero [] [1;3]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet _ = padZero [] [1; 3];;\n","type":"","out":""},{"in":"let rec removeZero l = match l with\n| 0::t -> removeZero t\n| _ -> l","min":"\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;1;0;0;2]","min":"\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet _ = removeZero [0; 0; 0; 1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = removeZero [9;9]","min":"\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet _ = removeZero [9; 9];;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;0]","min":"\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet _ = removeZero [0; 0; 0; 0];;\n","type":"","out":""},{"in":"let _ = List.combine [0;0;9;9] [1;0;0;2]","min":"\nlet _ = List.combine [0; 0; 9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = 0::[0;0;9;9]","min":"\nlet _ = [0; 0; 0; 9; 9];;\n","type":"","out":""},{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match (a,x) with\n| ((b,c),(d,e)) -> ((d+e+b)/10,(d+e+b) mod 10::c) \nin\nlet base = (0, []) in\nlet args = List.rev (List.combine (0::l1) (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9] [1;0;0;2]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9;9;9] [9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigAdd [9;3;4;3;2] [9;7;8;9;6;7;6;4;2]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 3; 4; 3; 2] [9; 7; 8; 9; 6; 7; 6; 4; 2];;\n","type":"","out":""},{"in":"let rec mulByDigit i l = let rec helper i acc l =\nif i > 0 then\nhelper (i-1) (bigAdd acc l) l\nelse\nacc\nin\nhelper i [] l","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper i acc l =\n    if i > 0 then helper (i - 1) (bigAdd acc l) l else acc in\n  helper i [] l;;\n","type":"","out":""},{"in":"let _ = mulByDigit 9 [9;9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper i acc l =\n    if i > 0 then helper (i - 1) (bigAdd acc l) l else acc in\n  helper i [] l;;\n\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let _ = mulByDigit 10 [3;0]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper i acc l =\n    if i > 0 then helper (i - 1) (bigAdd acc l) l else acc in\n  helper i [] l;;\n\nlet _ = mulByDigit 10 [3; 0];;\n","type":"","out":""},{"in":"let _ = mulByDigit 9 [6]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper i acc l =\n    if i > 0 then helper (i - 1) (bigAdd acc l) l else acc in\n  helper i [] l;;\n\nlet _ = mulByDigit 9 [6];;\n","type":"","out":""},{"in":"let _  = mulByDigit 9 [9;7;8;9;6;7;6;4;2]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper i acc l =\n    if i > 0 then helper (i - 1) (bigAdd acc l) l else acc in\n  helper i [] l;;\n\nlet _ = mulByDigit 9 [9; 7; 8; 9; 6; 7; 6; 4; 2];;\n","type":"","out":""},{"in":"let bigMul l1 l2 = \nlet f a x = match (a,x) with\n| ((b,c),d) -> (b+1,bigAdd (List.append (mulByDigit d l1) (clone 0 b)) c)\nin\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres","min":"\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet rec mulByDigit i l =\n  let rec helper i acc l =\n    if i > 0 then helper (i - 1) (bigAdd acc l) l else acc in\n  helper i [] l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match (a, x) with\n    | ((b,c),d) ->\n        ((b + 1), (bigAdd (List.append (mulByDigit d l1) (clone 0 b)) c)) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n","type":"","out":""},{"in":"let _ = bigMul [4;0] [1;1]","min":"\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet rec mulByDigit i l =\n  let rec helper i acc l =\n    if i > 0 then helper (i - 1) (bigAdd acc l) l else acc in\n  helper i [] l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match (a, x) with\n    | ((b,c),d) ->\n        ((b + 1), (bigAdd (List.append (mulByDigit d l1) (clone 0 b)) c)) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [4; 0] [1; 1];;\n","type":"","out":""},{"in":"let _ = bigMul [9;9;9;9] [9;9;9;9]","min":"\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet rec mulByDigit i l =\n  let rec helper i acc l =\n    if i > 0 then helper (i - 1) (bigAdd acc l) l else acc in\n  helper i [] l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match (a, x) with\n    | ((b,c),d) ->\n        ((b + 1), (bigAdd (List.append (mulByDigit d l1) (clone 0 b)) c)) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]","min":"\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet rec mulByDigit i l =\n  let rec helper i acc l =\n    if i > 0 then helper (i - 1) (bigAdd acc l) l else acc in\n  helper i [] l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match (a, x) with\n    | ((b,c),d) ->\n        ((b + 1), (bigAdd (List.append (mulByDigit d l1) (clone 0 b)) c)) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9; 9] [9; 9; 9; 9; 9];;\n","type":"","out":""},{"in":"let key = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130 = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ ((Printexc.to_string e) ^ \"\\n\"));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n","type":"","out":""},{"in":"let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","min":"\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n","type":"","out":""},{"in":"let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n\nlet drop_paren s =\n  implode\n    (List.filter (fun c  -> not (List.mem c ['('; ' '; ')'])) (explode s));;\n","type":"","out":""},{"in":"let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","min":"\nlet eq_real p (r1,r2) = ((r1 -. r2) < p) || ((r2 -. r1) < p);;\n","type":"","out":""},{"in":"let wrap_curried_2 f (a,b) = f a b","min":"\nlet wrap_curried_2 f (a,b) = f a b;;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":7534},"type":"eval"},"cursor":0,"time":1.399010882511701e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \nlet _ = padZero [] [1;3]\n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.combine [0;0;9;9] [1;0;0;2];;\nlet _ = 0::[0;0;9;9];;\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match (a,x) with\n      | ((b,c),(d,e)) -> ((d+e+b)/10,(d+e+b) mod 10::c) \n    in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0::l1) (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [9;3;4;3;2] [9;7;8;9;6;7;6;4;2];;\n\n\n\n\nlet rec mulByDigit i l = let rec helper i acc l =\n  if i > 0 then\n    helper (i-1) (bigAdd acc l) l\n  else\n    acc\n  in\n    helper i [] l;;\n\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\nlet _ = mulByDigit 10 [3;0]\nlet _ = mulByDigit 9 [6]\nlet _  = mulByDigit 9 [9;7;8;9;6;7;6;4;2]\n\n\n\nlet bigMul l1 l2 = \n  let f a x = match (a,x) with\n    | ((b,c),d) -> (b+1,bigAdd (List.append (mulByDigit d l1) (clone 0 b)) c)\n  in\n  let base = (0,[]) in\n  let args = List.rev l2 in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n\nlet _ = bigMul [4;0] [1;1]\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n","type":"","out":""},{"in":"let _ = sqsum []","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [];;\n","type":"","out":""},{"in":"let _ = sqsum [1;2;3;4]","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sqsum [(-1); (-2); (-3); (-4)]","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [(-1); (-2); (-3); (-4)];;\n","type":"","out":""},{"in":"let pipe fs = \nlet f a x = fun y -> x (a y) in\nlet base = fun x -> x in\nList.fold_left f base fs","min":"\nlet pipe fs =\n  let f a x y = x (a y) in let base x = x in List.fold_left f base fs;;\n","type":"","out":""},{"in":"let _ = pipe [] 3","min":"\nlet pipe fs =\n  let f a x y = x (a y) in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n","type":"","out":""},{"in":"let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3","min":"\nlet pipe fs =\n  let f a x y = x (a y) in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n","type":"","out":""},{"in":"let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3","min":"\nlet pipe fs =\n  let f a x y = x (a y) in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n","type":"","out":""},{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n","type":"","out":""},{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"---\" []","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"---\" [];;\n","type":"","out":""},{"in":"let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"\" [\"a\"; \"b\"; \"c\"; \"d\"; \"e\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"X\" [\"hello\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"X\" [\"hello\"];;\n","type":"","out":""},{"in":"let stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n","type":"","out":""},{"in":"let _ = stringOfList string_of_int [1;2;3;4;5;6]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n\nlet _ = stringOfList string_of_int [1; 2; 3; 4; 5; 6];;\n","type":"","out":""},{"in":"let _ = stringOfList (fun x -> x) [\"foo\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n\nlet _ = stringOfList (fun x  -> x) [\"foo\"];;\n","type":"","out":""},{"in":"let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n\nlet _ =\n  stringOfList (stringOfList string_of_int) [[1; 2; 3]; [4; 5]; [6]; []];;\n","type":"","out":""},{"in":"let rec clone x n =\nif n > 0 then\nx :: clone x (n-1)\nelse\n[]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n","type":"","out":""},{"in":"let _ = clone 3 5","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet _ = clone 3 5;;\n","type":"","out":""},{"in":"let _ = clone \"foo\" 2","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet _ = clone \"foo\" 2;;\n","type":"","out":""},{"in":"let _ = clone clone (-3)","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet _ = clone clone (-3);;\n","type":"","out":""},{"in":"let padZero l1 l2 = if (List.length l1) > (List.length l2) then\n(l1,\nList.append (clone 0 ((List.length l1) - (List.length l2))) l2)\nelse\n(List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\nl2)","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n","type":"","out":""},{"in":"let _ = padZero [9;9] [1;0;0;2]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet _ = padZero [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = padZero [1;0;0;2] [9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet _ = padZero [1; 0; 0; 2] [9; 9];;\n","type":"","out":""},{"in":"let _ = padZero [] [1;3]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet _ = padZero [] [1; 3];;\n","type":"","out":""},{"in":"let rec removeZero l = match l with\n| 0::t -> removeZero t\n| _ -> l","min":"\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;1;0;0;2]","min":"\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet _ = removeZero [0; 0; 0; 1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = removeZero [9;9]","min":"\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet _ = removeZero [9; 9];;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;0]","min":"\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet _ = removeZero [0; 0; 0; 0];;\n","type":"","out":""},{"in":"let _ = List.combine [0;0;9;9] [1;0;0;2]","min":"\nlet _ = List.combine [0; 0; 9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = 0::[0;0;9;9]","min":"\nlet _ = [0; 0; 0; 9; 9];;\n","type":"","out":""},{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match (a,x) with\n| ((b,c),(d,e)) -> ((d+e+b)/10,(d+e+b) mod 10::c) \nin\nlet base = (0, []) in\nlet args = List.rev (List.combine (0::l1) (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9] [1;0;0;2]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9;9;9] [9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigAdd [9;3;4;3;2] [9;7;8;9;6;7;6;4;2]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 3; 4; 3; 2] [9; 7; 8; 9; 6; 7; 6; 4; 2];;\n","type":"","out":""},{"in":"let rec mulByDigit i l = let rec helper i acc l =\nif i > 0 then\nhelper (i-1) (bigAdd acc l) l\nelse\nacc\nin\nhelper i [] l","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper i acc l =\n    if i > 0 then helper (i - 1) (bigAdd acc l) l else acc in\n  helper i [] l;;\n","type":"","out":""},{"in":"let _ = mulByDigit 9 [9;9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper i acc l =\n    if i > 0 then helper (i - 1) (bigAdd acc l) l else acc in\n  helper i [] l;;\n\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let _ = mulByDigit 10 [3;0]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper i acc l =\n    if i > 0 then helper (i - 1) (bigAdd acc l) l else acc in\n  helper i [] l;;\n\nlet _ = mulByDigit 10 [3; 0];;\n","type":"","out":""},{"in":"let _ = mulByDigit 9 [6]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper i acc l =\n    if i > 0 then helper (i - 1) (bigAdd acc l) l else acc in\n  helper i [] l;;\n\nlet _ = mulByDigit 9 [6];;\n","type":"","out":""},{"in":"let _  = mulByDigit 9 [9;7;8;9;6;7;6;4;2]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper i acc l =\n    if i > 0 then helper (i - 1) (bigAdd acc l) l else acc in\n  helper i [] l;;\n\nlet _ = mulByDigit 9 [9; 7; 8; 9; 6; 7; 6; 4; 2];;\n","type":"","out":""},{"in":"let bigMul l1 l2 = \nlet f a x = match (a,x) with\n| ((b,c),d) -> (b+1,bigAdd (List.append (mulByDigit d l1) (clone 0 b)) c)\nin\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres","min":"\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet rec mulByDigit i l =\n  let rec helper i acc l =\n    if i > 0 then helper (i - 1) (bigAdd acc l) l else acc in\n  helper i [] l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match (a, x) with\n    | ((b,c),d) ->\n        ((b + 1), (bigAdd (List.append (mulByDigit d l1) (clone 0 b)) c)) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n","type":"","out":""},{"in":"let _ = bigMul [4;0] [1;1]","min":"\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet rec mulByDigit i l =\n  let rec helper i acc l =\n    if i > 0 then helper (i - 1) (bigAdd acc l) l else acc in\n  helper i [] l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match (a, x) with\n    | ((b,c),d) ->\n        ((b + 1), (bigAdd (List.append (mulByDigit d l1) (clone 0 b)) c)) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [4; 0] [1; 1];;\n","type":"","out":""},{"in":"let _ = bigMul [9;9;9;9] [9;9;9;9]","min":"\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet rec mulByDigit i l =\n  let rec helper i acc l =\n    if i > 0 then helper (i - 1) (bigAdd acc l) l else acc in\n  helper i [] l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match (a, x) with\n    | ((b,c),d) ->\n        ((b + 1), (bigAdd (List.append (mulByDigit d l1) (clone 0 b)) c)) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]","min":"\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet rec mulByDigit i l =\n  let rec helper i acc l =\n    if i > 0 then helper (i - 1) (bigAdd acc l) l else acc in\n  helper i [] l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match (a, x) with\n    | ((b,c),d) ->\n        ((b + 1), (bigAdd (List.append (mulByDigit d l1) (clone 0 b)) c)) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9; 9] [9; 9; 9; 9; 9];;\n","type":"","out":""},{"in":"let key = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130 = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ ((Printexc.to_string e) ^ \"\\n\"));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n","type":"","out":""},{"in":"let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","min":"\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n","type":"","out":""},{"in":"let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n\nlet drop_paren s =\n  implode\n    (List.filter (fun c  -> not (List.mem c ['('; ' '; ')'])) (explode s));;\n","type":"","out":""},{"in":"let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","min":"\nlet eq_real p (r1,r2) = ((r1 -. r2) < p) || ((r2 -. r1) < p);;\n","type":"","out":""},{"in":"let wrap_curried_2 f (a,b) = f a b","min":"\nlet wrap_curried_2 f (a,b) = f a b;;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":7534},"type":"eval"},"cursor":2916,"time":1.399016224270509e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \nlet _ = padZero [] [1;3]\n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.combine [0;0;9;9] [1;0;0;2];;\nlet _ = 0::[0;0;9;9];;\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match (a,x) with\n      | ((b,c),(d,e)) -> ((d+e+b)/10,(d+e+b) mod 10::c) \n    in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0::l1) (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [9;3;4;3;2] [9;7;8;9;6;7;6;4;2];;\n\n\n\n\nlet rec mulByDigit i l = let rec helper i acc l =\n  if i > 0 then\n    helper (i-1) (bigAdd acc l) l\n  else\n    acc\n  in\n    helper i [] l;;\n\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\nlet _ = mulByDigit 10 [3;0]\nlet _ = mulByDigit 9 [6]\nlet _  = mulByDigit 9 [9;7;8;9;6;7;6;4;2]\n\n\n\nlet bigMul l1 l2 = \n  let f a x = match (a,x) with\n    | ((b,c),d) -> (b+1,bigAdd (List.append (mulByDigit d l1) (clone 0 b)) c)\n  in\n  let base = (0,[]) in\n  let args = List.rev l2 in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n\nlet _ = bigMul [4;0] [1;1]\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = bigAdd [9;3;4;3;2] [9;7;8;9;6;7;6;4;2]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 3; 4; 3; 2] [9; 7; 8; 9; 6; 7; 6; 4; 2];;\n","type":"","out":""}],"event":{"region":{"start":2881,"stop":2927},"type":"eval"},"cursor":2916,"time":1.399016231948846e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \nlet _ = padZero [] [1;3]\n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.combine [0;0;9;9] [1;0;0;2];;\nlet _ = 0::[0;0;9;9];;\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match (a,x) with\n      | ((b,c),(d,e)) -> ((d+e+b)/10,(d+e+b) mod 10::c) \n    in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0::l1) (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [9;3;4;3;2] [9;7;8;9;6;7;6;4;2];;\n\n\n\n\nlet rec mulByDigit i l = let rec helper i acc l =\n  if i > 0 then\n    helper (i-1) (bigAdd acc l) l\n  else\n    acc\n  in\n    helper i [] l;;\n\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\nlet _ = mulByDigit 10 [3;0]\nlet _ = mulByDigit 9 [6]\nlet _  = mulByDigit 9 [9;7;8;9;6;7;6;4;2]\n\n\n\nlet bigMul l1 l2 = \n  let f a x = match (a,x) with\n    | ((b,c),d) -> (b+1,bigAdd (List.append (mulByDigit d l1) (clone 0 b)) c)\n  in\n  let base = (0,[]) in\n  let args = List.rev l2 in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n\nlet _ = bigMul [4;0] [1;1]\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = bigAdd [9;9] [1;0;0;2]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9] [1; 0; 0; 2];;\n","type":"","out":""}],"event":{"region":{"start":2812,"stop":2842},"type":"eval"},"cursor":2835,"time":1.399016236406722e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \nlet _ = padZero [] [1;3]\n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.combine [0;0;9;9] [1;0;0;2];;\nlet _ = 0::[0;0;9;9];;\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match (a,x) with\n      | ((b,c),(d,e)) -> ((d+e+b)/10,(d+e+b) mod 10::c) \n    in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0::l1) (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [9;3;4;3;2] [9;7;8;9;6;7;6;4;2];;\n\n\n\n\nlet rec mulByDigit i l = let rec helper i acc l =\n  if i > 0 then\n    helper (i-1) (bigAdd acc l) l\n  else\n    acc\n  in\n    helper i [] l;;\n\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\nlet _ = mulByDigit 10 [3;0]\nlet _ = mulByDigit 9 [6]\nlet _  = mulByDigit 9 [9;7;8;9;6;7;6;4;2]\n\n\n\nlet bigMul l1 l2 = \n  let f a x = match (a,x) with\n    | ((b,c),d) -> (b+1,bigAdd (List.append (mulByDigit d l1) (clone 0 b)) c)\n  in\n  let base = (0,[]) in\n  let args = List.rev l2 in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n\nlet _ = bigMul [4;0] [1;1]\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = List.combine [0;0;9;9] [1;0;0;2]","min":"\nlet _ = List.combine [0; 0; 9; 9] [1; 0; 0; 2];;\n","type":"","out":""}],"event":{"region":{"start":2457,"stop":2497},"type":"eval"},"cursor":2483,"time":1.399016869846422e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \nlet _ = padZero [] [1;3]\n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.combine [0;0;9;9] [1;0;0;2];;\nlet _ = 0::[0;0;9;9];;\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match (a,x) with\n      | ((b,c),(d,e)) -> ((d+e+b)/10,(d+e+b) mod 10::c) \n    in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0::l1) (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [9;3;4;3;2] [9;7;8;9;6;7;6;4;2];;\n\n\n\n\nlet rec mulByDigit i l = let rec helper i acc l =\n  if i > 0 then\n    helper (i-1) (bigAdd acc l) l\n  else\n    acc\n  in\n    helper i [] l;;\n\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\nlet _ = mulByDigit 10 [3;0]\nlet _ = mulByDigit 9 [6]\nlet _  = mulByDigit 9 [9;7;8;9;6;7;6;4;2]\n\n\n\nlet bigMul l1 l2 = \n  let f a x = match (a,x) with\n    | ((b,c),d) -> (b+1,bigAdd (List.append (mulByDigit d l1) (clone 0 b)) c)\n  in\n  let base = (0,[]) in\n  let args = List.rev l2 in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n\nlet _ = bigMul [4;0] [1;1]\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n","type":"","out":""},{"in":"let _ = sqsum []","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [];;\n","type":"","out":""},{"in":"let _ = sqsum [1;2;3;4]","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sqsum [(-1); (-2); (-3); (-4)]","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [(-1); (-2); (-3); (-4)];;\n","type":"","out":""},{"in":"let pipe fs = \nlet f a x = fun y -> x (a y) in\nlet base = fun x -> x in\nList.fold_left f base fs","min":"\nlet pipe fs =\n  let f a x y = x (a y) in let base x = x in List.fold_left f base fs;;\n","type":"","out":""},{"in":"let _ = pipe [] 3","min":"\nlet pipe fs =\n  let f a x y = x (a y) in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n","type":"","out":""},{"in":"let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3","min":"\nlet pipe fs =\n  let f a x y = x (a y) in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n","type":"","out":""},{"in":"let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3","min":"\nlet pipe fs =\n  let f a x y = x (a y) in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n","type":"","out":""},{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n","type":"","out":""},{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"---\" []","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"---\" [];;\n","type":"","out":""},{"in":"let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"\" [\"a\"; \"b\"; \"c\"; \"d\"; \"e\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"X\" [\"hello\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"X\" [\"hello\"];;\n","type":"","out":""},{"in":"let stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n","type":"","out":""},{"in":"let _ = stringOfList string_of_int [1;2;3;4;5;6]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n\nlet _ = stringOfList string_of_int [1; 2; 3; 4; 5; 6];;\n","type":"","out":""},{"in":"let _ = stringOfList (fun x -> x) [\"foo\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n\nlet _ = stringOfList (fun x  -> x) [\"foo\"];;\n","type":"","out":""},{"in":"let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n\nlet _ =\n  stringOfList (stringOfList string_of_int) [[1; 2; 3]; [4; 5]; [6]; []];;\n","type":"","out":""},{"in":"let rec clone x n =\nif n > 0 then\nx :: clone x (n-1)\nelse\n[]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n","type":"","out":""},{"in":"let _ = clone 3 5","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet _ = clone 3 5;;\n","type":"","out":""},{"in":"let _ = clone \"foo\" 2","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet _ = clone \"foo\" 2;;\n","type":"","out":""},{"in":"let _ = clone clone (-3)","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet _ = clone clone (-3);;\n","type":"","out":""},{"in":"let padZero l1 l2 = if (List.length l1) > (List.length l2) then\n(l1,\nList.append (clone 0 ((List.length l1) - (List.length l2))) l2)\nelse\n(List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\nl2)","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n","type":"","out":""},{"in":"let _ = padZero [9;9] [1;0;0;2]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet _ = padZero [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = padZero [1;0;0;2] [9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet _ = padZero [1; 0; 0; 2] [9; 9];;\n","type":"","out":""},{"in":"let _ = padZero [] [1;3]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet _ = padZero [] [1; 3];;\n","type":"","out":""},{"in":"let rec removeZero l = match l with\n| 0::t -> removeZero t\n| _ -> l","min":"\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;1;0;0;2]","min":"\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet _ = removeZero [0; 0; 0; 1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = removeZero [9;9]","min":"\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet _ = removeZero [9; 9];;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;0]","min":"\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet _ = removeZero [0; 0; 0; 0];;\n","type":"","out":""},{"in":"let _ = List.combine [0;0;9;9] [1;0;0;2]","min":"\nlet _ = List.combine [0; 0; 9; 9] [1; 0; 0; 2];;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":2497},"type":"eval"},"cursor":2485,"time":1.399017188487288e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \nlet _ = padZero [] [1;3]\n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.combine [0;0;9;9] [1;0;0;2];;\nlet _ = 0::[0;0;9;9];;\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match (a,x) with\n      | ((b,c),(d,e)) -> ((d+e+b)/10,(d+e+b) mod 10::c) \n    in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0::l1) (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [9;3;4;3;2] [9;7;8;9;6;7;6;4;2];;\n\n\n\n\nlet rec mulByDigit i l = let rec helper i acc l =\n  if i > 0 then\n    helper (i-1) (bigAdd acc l) l\n  else\n    acc\n  in\n    helper i [] l;;\n\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\nlet _ = mulByDigit 10 [3;0]\nlet _ = mulByDigit 9 [6]\nlet _  = mulByDigit 9 [9;7;8;9;6;7;6;4;2]\n\n\n\nlet bigMul l1 l2 = \n  let f a x = match (a,x) with\n    | ((b,c),d) -> (b+1,bigAdd (List.append (mulByDigit d l1) (clone 0 b)) c)\n  in\n  let base = (0,[]) in\n  let args = List.rev l2 in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n\nlet _ = bigMul [4;0] [1;1]\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n","type":"","out":""},{"in":"let _ = sqsum []","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [];;\n","type":"","out":""},{"in":"let _ = sqsum [1;2;3;4]","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sqsum [(-1); (-2); (-3); (-4)]","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [(-1); (-2); (-3); (-4)];;\n","type":"","out":""},{"in":"let pipe fs = \nlet f a x = fun y -> x (a y) in\nlet base = fun x -> x in\nList.fold_left f base fs","min":"\nlet pipe fs =\n  let f a x y = x (a y) in let base x = x in List.fold_left f base fs;;\n","type":"","out":""},{"in":"let _ = pipe [] 3","min":"\nlet pipe fs =\n  let f a x y = x (a y) in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n","type":"","out":""},{"in":"let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3","min":"\nlet pipe fs =\n  let f a x y = x (a y) in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n","type":"","out":""},{"in":"let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3","min":"\nlet pipe fs =\n  let f a x y = x (a y) in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n","type":"","out":""},{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n","type":"","out":""},{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"---\" []","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"---\" [];;\n","type":"","out":""},{"in":"let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"\" [\"a\"; \"b\"; \"c\"; \"d\"; \"e\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"X\" [\"hello\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"X\" [\"hello\"];;\n","type":"","out":""},{"in":"let stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n","type":"","out":""},{"in":"let _ = stringOfList string_of_int [1;2;3;4;5;6]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n\nlet _ = stringOfList string_of_int [1; 2; 3; 4; 5; 6];;\n","type":"","out":""},{"in":"let _ = stringOfList (fun x -> x) [\"foo\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n\nlet _ = stringOfList (fun x  -> x) [\"foo\"];;\n","type":"","out":""},{"in":"let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n\nlet _ =\n  stringOfList (stringOfList string_of_int) [[1; 2; 3]; [4; 5]; [6]; []];;\n","type":"","out":""},{"in":"let rec clone x n =\nif n > 0 then\nx :: clone x (n-1)\nelse\n[]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":1914},"type":"eval"},"cursor":1914,"time":1.399544777037382e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \nlet _ = padZero [] [1;3]\n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.combine [0;0;9;9] [1;0;0;2];;\nlet _ = 0::[0;0;9;9];;\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match (a,x) with\n      | ((b,c),(d,e)) -> ((d+e+b)/10,(d+e+b) mod 10::c) \n    in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0::l1) (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [9;3;4;3;2] [9;7;8;9;6;7;6;4;2];;\n\n\n\n\nlet rec mulByDigit i l = let rec helper i acc l =\n  if i > 0 then\n    helper (i-1) (bigAdd acc l) l\n  else\n    acc\n  in\n    helper i [] l;;\n\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\nlet _ = mulByDigit 10 [3;0]\nlet _ = mulByDigit 9 [6]\nlet _  = mulByDigit 9 [9;7;8;9;6;7;6;4;2]\n\n\n\nlet bigMul l1 l2 = \n  let f a x = match (a,x) with\n    | ((b,c),d) -> (b+1,bigAdd (List.append (mulByDigit d l1) (clone 0 b)) c)\n  in\n  let base = (0,[]) in\n  let args = List.rev l2 in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n\nlet _ = bigMul [4;0] [1;1]\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = clone 3 5","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet _ = clone 3 5;;\n","type":"","out":""},{"in":"let _ = clone \"foo\" 2","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet _ = clone \"foo\" 2;;\n","type":"","out":""},{"in":"let _ = clone clone (-3)","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet _ = clone clone (-3);;\n","type":"","out":""}],"event":{"region":{"start":1914,"stop":1987},"type":"eval"},"cursor":1989,"time":1.399544787274164e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \nlet _ = padZero [] [1;3]\n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.combine [0;0;9;9] [1;0;0;2];;\nlet _ = 0::[0;0;9;9];;\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match (a,x) with\n      | ((b,c),(d,e)) -> ((d+e+b)/10,(d+e+b) mod 10::c) \n    in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0::l1) (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [9;3;4;3;2] [9;7;8;9;6;7;6;4;2];;\n\n\n\n\nlet rec mulByDigit i l = let rec helper i acc l =\n  if i > 0 then\n    helper (i-1) (bigAdd acc l) l\n  else\n    acc\n  in\n    helper i [] l;;\n\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\nlet _ = mulByDigit 10 [3;0]\nlet _ = mulByDigit 9 [6]\nlet _  = mulByDigit 9 [9;7;8;9;6;7;6;4;2]\n\n\n\nlet bigMul l1 l2 = \n  let f a x = match (a,x) with\n    | ((b,c),d) -> (b+1,bigAdd (List.append (mulByDigit d l1) (clone 0 b)) c)\n  in\n  let base = (0,[]) in\n  let args = List.rev l2 in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n\nlet _ = bigMul [4;0] [1;1]\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n","type":"","out":""},{"in":"let _ = sqsum []","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [];;\n","type":"","out":""},{"in":"let _ = sqsum [1;2;3;4]","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sqsum [(-1); (-2); (-3); (-4)]","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [(-1); (-2); (-3); (-4)];;\n","type":"","out":""},{"in":"let pipe fs = \nlet f a x = fun y -> x (a y) in\nlet base = fun x -> x in\nList.fold_left f base fs","min":"\nlet pipe fs =\n  let f a x y = x (a y) in let base x = x in List.fold_left f base fs;;\n","type":"","out":""},{"in":"let _ = pipe [] 3","min":"\nlet pipe fs =\n  let f a x y = x (a y) in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n","type":"","out":""},{"in":"let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3","min":"\nlet pipe fs =\n  let f a x y = x (a y) in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n","type":"","out":""},{"in":"let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3","min":"\nlet pipe fs =\n  let f a x y = x (a y) in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n","type":"","out":""},{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n","type":"","out":""},{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"---\" []","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"---\" [];;\n","type":"","out":""},{"in":"let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"\" [\"a\"; \"b\"; \"c\"; \"d\"; \"e\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"X\" [\"hello\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"X\" [\"hello\"];;\n","type":"","out":""},{"in":"let stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n","type":"","out":""},{"in":"let _ = stringOfList string_of_int [1;2;3;4;5;6]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n\nlet _ = stringOfList string_of_int [1; 2; 3; 4; 5; 6];;\n","type":"","out":""},{"in":"let _ = stringOfList (fun x -> x) [\"foo\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n\nlet _ = stringOfList (fun x  -> x) [\"foo\"];;\n","type":"","out":""},{"in":"let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n\nlet _ =\n  stringOfList (stringOfList string_of_int) [[1; 2; 3]; [4; 5]; [6]; []];;\n","type":"","out":""},{"in":"let rec clone x n =\nif n > 0 then\nx :: clone x (n-1)\nelse\n[]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n","type":"","out":""},{"in":"let _ = clone 3 5","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet _ = clone 3 5;;\n","type":"","out":""},{"in":"let _ = clone \"foo\" 2","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet _ = clone \"foo\" 2;;\n","type":"","out":""},{"in":"let _ = clone clone (-3)","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet _ = clone clone (-3);;\n","type":"","out":""},{"in":"let padZero l1 l2 = if (List.length l1) > (List.length l2) then\n(l1,\nList.append (clone 0 ((List.length l1) - (List.length l2))) l2)\nelse\n(List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\nl2)","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n","type":"","out":""},{"in":"let _ = padZero [9;9] [1;0;0;2]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet _ = padZero [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = padZero [1;0;0;2] [9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet _ = padZero [1; 0; 0; 2] [9; 9];;\n","type":"","out":""},{"in":"let _ = padZero [] [1;3]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet _ = padZero [] [1; 3];;\n","type":"","out":""},{"in":"let rec removeZero l = match l with\n| 0::t -> removeZero t\n| _ -> l","min":"\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;1;0;0;2]","min":"\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet _ = removeZero [0; 0; 0; 1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = removeZero [9;9]","min":"\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet _ = removeZero [9; 9];;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;0]","min":"\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet _ = removeZero [0; 0; 0; 0];;\n","type":"","out":""},{"in":"let _ = List.combine [0;0;9;9] [1;0;0;2]","min":"\nlet _ = List.combine [0; 0; 9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = 0::[0;0;9;9]","min":"\nlet _ = [0; 0; 0; 9; 9];;\n","type":"","out":""},{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match (a,x) with\n| ((b,c),(d,e)) -> ((d+e+b)/10,(d+e+b) mod 10::c) \nin\nlet base = (0, []) in\nlet args = List.rev (List.combine (0::l1) (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9] [1;0;0;2]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9;9;9] [9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigAdd [9;3;4;3;2] [9;7;8;9;6;7;6;4;2]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 3; 4; 3; 2] [9; 7; 8; 9; 6; 7; 6; 4; 2];;\n","type":"","out":""},{"in":"let rec mulByDigit i l = let rec helper i acc l =\nif i > 0 then\nhelper (i-1) (bigAdd acc l) l\nelse\nacc\nin\nhelper i [] l","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper i acc l =\n    if i > 0 then helper (i - 1) (bigAdd acc l) l else acc in\n  helper i [] l;;\n","type":"","out":""},{"in":"let _ = mulByDigit 9 [9;9;9;9]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper i acc l =\n    if i > 0 then helper (i - 1) (bigAdd acc l) l else acc in\n  helper i [] l;;\n\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let _ = mulByDigit 10 [3;0]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper i acc l =\n    if i > 0 then helper (i - 1) (bigAdd acc l) l else acc in\n  helper i [] l;;\n\nlet _ = mulByDigit 10 [3; 0];;\n","type":"","out":""},{"in":"let _ = mulByDigit 9 [6]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper i acc l =\n    if i > 0 then helper (i - 1) (bigAdd acc l) l else acc in\n  helper i [] l;;\n\nlet _ = mulByDigit 9 [6];;\n","type":"","out":""},{"in":"let _  = mulByDigit 9 [9;7;8;9;6;7;6;4;2]","min":"\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper i acc l =\n    if i > 0 then helper (i - 1) (bigAdd acc l) l else acc in\n  helper i [] l;;\n\nlet _ = mulByDigit 9 [9; 7; 8; 9; 6; 7; 6; 4; 2];;\n","type":"","out":""},{"in":"let bigMul l1 l2 = \nlet f a x = match (a,x) with\n| ((b,c),d) -> (b+1,bigAdd (List.append (mulByDigit d l1) (clone 0 b)) c)\nin\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres","min":"\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet rec mulByDigit i l =\n  let rec helper i acc l =\n    if i > 0 then helper (i - 1) (bigAdd acc l) l else acc in\n  helper i [] l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match (a, x) with\n    | ((b,c),d) ->\n        ((b + 1), (bigAdd (List.append (mulByDigit d l1) (clone 0 b)) c)) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n","type":"","out":""},{"in":"let _ = bigMul [4;0] [1;1]","min":"\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet rec mulByDigit i l =\n  let rec helper i acc l =\n    if i > 0 then helper (i - 1) (bigAdd acc l) l else acc in\n  helper i [] l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match (a, x) with\n    | ((b,c),d) ->\n        ((b + 1), (bigAdd (List.append (mulByDigit d l1) (clone 0 b)) c)) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [4; 0] [1; 1];;\n","type":"","out":""},{"in":"let _ = bigMul [9;9;9;9] [9;9;9;9]","min":"\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet rec mulByDigit i l =\n  let rec helper i acc l =\n    if i > 0 then helper (i - 1) (bigAdd acc l) l else acc in\n  helper i [] l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match (a, x) with\n    | ((b,c),d) ->\n        ((b + 1), (bigAdd (List.append (mulByDigit d l1) (clone 0 b)) c)) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]","min":"\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet rec mulByDigit i l =\n  let rec helper i acc l =\n    if i > 0 then helper (i - 1) (bigAdd acc l) l else acc in\n  helper i [] l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match (a, x) with\n    | ((b,c),d) ->\n        ((b + 1), (bigAdd (List.append (mulByDigit d l1) (clone 0 b)) c)) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9; 9] [9; 9; 9; 9; 9];;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":3513},"type":"eval"},"cursor":3516,"time":1.399545267309747e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x*x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = fun y -> x (a y) in\n  let base = fun x -> x in\n    List.fold_left f base fs\n\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n =\n  if n > 0 then\n    x :: clone x (n-1)\n  else\n    []\n\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = if (List.length l1) > (List.length l2) then\n    (l1,\n     List.append (clone 0 ((List.length l1) - (List.length l2))) l2)\n  else\n    (List.append (clone 0 ((List.length l2) - (List.length l1))) l1,\n     l2)\n\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \nlet _ = padZero [] [1;3]\n\n\n\nlet rec removeZero l = match l with\n  | 0::t -> removeZero t\n  | _ -> l\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\nlet _ = List.combine [0;0;9;9] [1;0;0;2];;\nlet _ = 0::[0;0;9;9];;\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = match (a,x) with\n      | ((b,c),(d,e)) -> ((d+e+b)/10,(d+e+b) mod 10::c) \n    in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0::l1) (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \nlet _ = bigAdd [9;3;4;3;2] [9;7;8;9;6;7;6;4;2];;\n\n\n\n\nlet rec mulByDigit i l = let rec helper i acc l =\n  if i > 0 then\n    helper (i-1) (bigAdd acc l) l\n  else\n    acc\n  in\n    helper i [] l;;\n\n\n\nlet _ = mulByDigit 9 [9;9;9;9]\nlet _ = mulByDigit 10 [3;0]\nlet _ = mulByDigit 9 [6]\nlet _  = mulByDigit 9 [9;7;8;9;6;7;6;4;2]\n\n\n\nlet bigMul l1 l2 = \n  let f a x = match (a,x) with\n    | ((b,c),d) -> (b+1,bigAdd (List.append (mulByDigit d l1) (clone 0 b)) c)\n  in\n  let base = (0,[]) in\n  let args = List.rev l2 in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n\nlet _ = bigMul [4;0] [1;1]\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
