{"ocaml":[{"in":"let rec assoc (d,k,l) =\nmatch l with\n[] -> d\n|front::back ->\nmatch front with\n(x,y) ->\nif (x=k)\nthen y\nelse assoc (d,k,back)","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | front::back ->\n      (match front with | (x,y) -> if x = k then y else assoc (d, k, back));;\n","type":"","out":""},{"in":"let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | front::back ->\n      (match front with | (x,y) -> if x = k then y else assoc (d, k, back));;\n\nlet _ =\n  assoc ((-1), \"william\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n","type":"","out":""},{"in":"let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | front::back ->\n      (match front with | (x,y) -> if x = k then y else assoc (d, k, back));;\n\nlet _ = assoc ((-1), \"bob\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n","type":"","out":""},{"in":"let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' =  \nif (List.mem h seen = true) \nthen []@seen\nelse [h]@seen\nin\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))","min":"\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' =\n          if (List.mem h seen) = true then [] @ seen else [h] @ seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n","type":"","out":""},{"in":"let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]","min":"\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' =\n          if (List.mem h seen) = true then [] @ seen else [h] @ seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ = removeDuplicates [1; 6; 2; 4; 12; 2; 13; 6; 9];;\n","type":"","out":""},{"in":"let rec wwhile (f,b) = failwith \"to be written\"","min":"\nlet rec wwhile (f,b) = failwith \"to be written\";;\n","type":"","out":""},{"in":"let fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)","min":"\nlet rec wwhile (f,b) = failwith \"to be written\";;\n\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"), b);;\n","type":"","out":""},{"in":"type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n","type":"","out":""},{"in":"let rec exprToString e = failwith \"to be written\"","min":"\nlet rec exprToString e = failwith \"to be written\";;\n","type":"","out":""},{"in":"let buildX()                       = VarX","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n","type":"","out":""},{"in":"let buildY()                       = VarY","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildY () = VarY;;\n","type":"","out":""},{"in":"let buildSine(e)                   = Sine(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n","type":"","out":""},{"in":"let buildCosine(e)                 = Cosine(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n","type":"","out":""},{"in":"let buildAverage(e1,e2)            = Average(e1,e2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n","type":"","out":""},{"in":"let buildTimes(e1,e2)              = Times(e1,e2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n","type":"","out":""},{"in":"let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n","type":"","out":""},{"in":"let pi = 4.0 *. atan 1.0","min":"\nlet pi = 4.0 *. (atan 1.0);;\n","type":"","out":""},{"in":"let rec eval (e,x,y) = failwith \"to be written\"","min":"\nlet rec eval (e,x,y) = failwith \"to be written\";;\n","type":"","out":""},{"in":"let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv","min":"\nlet rec eval (e,x,y) = failwith \"to be written\";;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n","type":"","out":""},{"in":"let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n","type":"","out":""},{"in":"let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr2 =\n  buildThresh\n    ((buildX ()), (buildY ()), (buildSine (buildX ())),\n      (buildCosine (buildY ())));;\n","type":"","out":""},{"in":"let rec build (rand, depth) = failwith \"to be implemented\"","min":"\nlet rec build (rand,depth) = failwith \"to be implemented\";;\n","type":"","out":""},{"in":"let g1 () = failwith \"to be implemented\"","min":"\nlet g1 () = failwith \"to be implemented\";;\n","type":"","out":""},{"in":"let g2 () = failwith \"to be implemented\"","min":"\nlet g2 () = failwith \"to be implemented\";;\n","type":"","out":""},{"in":"let g3 () = failwith \"to be implemented\"","min":"\nlet g3 () = failwith \"to be implemented\";;\n","type":"","out":""},{"in":"let c1 () = failwith \"to be implemented\"","min":"\nlet c1 () = failwith \"to be implemented\";;\n","type":"","out":""},{"in":"let c2 () = failwith \"to be implemented\"","min":"\nlet c2 () = failwith \"to be implemented\";;\n","type":"","out":""},{"in":"let c3 () = failwith \"to be implemented\"","min":"\nlet c3 () = failwith \"to be implemented\";;\n","type":"","out":""},{"in":"let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))","min":"\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n","type":"","out":""},{"in":"let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))","min":"\nlet rec rseq g r n = if n <= 0 then [] else (g r) :: (rseq g r (n - 1));;\n","type":"","out":""},{"in":"let toReal (i,n) = (float_of_int i) /. (float_of_int n)","min":"\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n","type":"","out":""},{"in":"let toIntensity z = int_of_float (127.5 +. (127.5 *. z))","min":"\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n","type":"","out":""},{"in":"let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n","type":"","out":""},{"in":"let emitGrayscale (f,n,name) =\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet z = f (x,y) in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet iz = toIntensity(z) in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n","type":"","out":""},{"in":"let doRandomGray (depth,seed1,seed2) =\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet g = makeRand(seed1,seed2) in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(*XXXXXXXXXXXXXXXXXX*)\nlet n = 150 in\n(*XXXXXXXXXXXXXXXXXX*)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)","min":"\nlet rec eval (e,x,y) = failwith \"to be written\";;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet rec build (rand,depth) = failwith \"to be implemented\";;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e = failwith \"to be written\";;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n","type":"","out":""},{"in":"let emitColor (f1,f2,f3,n,name) =\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n","type":"","out":""},{"in":"let doRandomColor (depth,seed1,seed2) =\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet g = makeRand (seed1,seed2) in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(*XXXXXXXXXXXXXXXXXX*)\nlet n = 150 in\n(*XXXXXXXXXXXXXXXXXX*)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)","min":"\nlet rec eval (e,x,y) = failwith \"to be written\";;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet rec build (rand,depth) = failwith \"to be implemented\";;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e = failwith \"to be written\";;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130 = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n","type":"","out":""},{"in":"let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","min":"\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n","type":"","out":""},{"in":"let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n\nlet drop_paren s =\n  implode\n    (List.filter (fun c  -> not (List.mem c ['('; ' '; ')'])) (explode s));;\n","type":"","out":""},{"in":"let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","min":"\nlet eq_real p (r1,r2) = ((r1 -. r2) < p) || ((r2 -. r1) < p);;\n","type":"","out":""},{"in":"let scoreMsg () = \nFormat.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":15666},"type":"eval"},"cursor":1946,"time":1.39829858109533e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) =\n  match l with\n      [] -> d\n    |front::back ->\n        match front with\n            (x,y) ->\n              if (x=k)\n              then y\n              else assoc (d,k,back)\n;; \n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' =  \n            if (List.mem h seen = true) \n            then []@seen\n            else [h]@seen\n          in\n          let rest' = t in \n            \t  helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n;;\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 \tfixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec assoc (d,k,l) =\nmatch l with\n[] -> d\n|front::back ->\nmatch front with\n(x,y) ->\nif (x=k)\nthen y\nelse assoc (d,k,back)","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | front::back ->\n      (match front with | (x,y) -> if x = k then y else assoc (d, k, back));;\n","type":"","out":""},{"in":"let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | front::back ->\n      (match front with | (x,y) -> if x = k then y else assoc (d, k, back));;\n\nlet _ =\n  assoc ((-1), \"william\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n","type":"","out":""},{"in":"let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | front::back ->\n      (match front with | (x,y) -> if x = k then y else assoc (d, k, back));;\n\nlet _ = assoc ((-1), \"bob\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n","type":"","out":""},{"in":"let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' =  \nif (List.mem h seen = true) \nthen []@seen\nelse [h]@seen\nin\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))","min":"\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' =\n          if (List.mem h seen) = true then [] @ seen else [h] @ seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n","type":"","out":""},{"in":"let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]","min":"\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' =\n          if (List.mem h seen) = true then [] @ seen else [h] @ seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ = removeDuplicates [1; 6; 2; 4; 12; 2; 13; 6; 9];;\n","type":"","out":""},{"in":"let rec wwhile (f,b) = \nmatch f b with\n(x,y) -> if (y=true) then wwhile (f,x) else x","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n","type":"","out":""},{"in":"let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n","type":"","out":""},{"in":"let fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"), b);;\n","type":"","out":""},{"in":"type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n","type":"","out":""},{"in":"let rec exprToString e = failwith \"to be written\"","min":"\nlet rec exprToString e = failwith \"to be written\";;\n","type":"","out":""},{"in":"let buildX()                       = VarX","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n","type":"","out":""},{"in":"let buildY()                       = VarY","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildY () = VarY;;\n","type":"","out":""},{"in":"let buildSine(e)                   = Sine(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n","type":"","out":""},{"in":"let buildCosine(e)                 = Cosine(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n","type":"","out":""},{"in":"let buildAverage(e1,e2)            = Average(e1,e2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n","type":"","out":""},{"in":"let buildTimes(e1,e2)              = Times(e1,e2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n","type":"","out":""},{"in":"let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n","type":"","out":""},{"in":"let pi = 4.0 *. atan 1.0","min":"\nlet pi = 4.0 *. (atan 1.0);;\n","type":"","out":""},{"in":"let rec eval (e,x,y) = failwith \"to be written\"","min":"\nlet rec eval (e,x,y) = failwith \"to be written\";;\n","type":"","out":""},{"in":"let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv","min":"\nlet rec eval (e,x,y) = failwith \"to be written\";;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n","type":"","out":""},{"in":"let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n","type":"","out":""},{"in":"let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr2 =\n  buildThresh\n    ((buildX ()), (buildY ()), (buildSine (buildX ())),\n      (buildCosine (buildY ())));;\n","type":"","out":""},{"in":"let rec build (rand, depth) = failwith \"to be implemented\"","min":"\nlet rec build (rand,depth) = failwith \"to be implemented\";;\n","type":"","out":""},{"in":"let g1 () = failwith \"to be implemented\"","min":"\nlet g1 () = failwith \"to be implemented\";;\n","type":"","out":""},{"in":"let g2 () = failwith \"to be implemented\"","min":"\nlet g2 () = failwith \"to be implemented\";;\n","type":"","out":""},{"in":"let g3 () = failwith \"to be implemented\"","min":"\nlet g3 () = failwith \"to be implemented\";;\n","type":"","out":""},{"in":"let c1 () = failwith \"to be implemented\"","min":"\nlet c1 () = failwith \"to be implemented\";;\n","type":"","out":""},{"in":"let c2 () = failwith \"to be implemented\"","min":"\nlet c2 () = failwith \"to be implemented\";;\n","type":"","out":""},{"in":"let c3 () = failwith \"to be implemented\"","min":"\nlet c3 () = failwith \"to be implemented\";;\n","type":"","out":""},{"in":"let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))","min":"\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n","type":"","out":""},{"in":"let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))","min":"\nlet rec rseq g r n = if n <= 0 then [] else (g r) :: (rseq g r (n - 1));;\n","type":"","out":""},{"in":"let toReal (i,n) = (float_of_int i) /. (float_of_int n)","min":"\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n","type":"","out":""},{"in":"let toIntensity z = int_of_float (127.5 +. (127.5 *. z))","min":"\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n","type":"","out":""},{"in":"let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n","type":"","out":""},{"in":"let emitGrayscale (f,n,name) =\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet z = f (x,y) in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet iz = toIntensity(z) in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n","type":"","out":""},{"in":"let doRandomGray (depth,seed1,seed2) =\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet g = makeRand(seed1,seed2) in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(*XXXXXXXXXXXXXXXXXX*)\nlet n = 150 in\n(*XXXXXXXXXXXXXXXXXX*)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)","min":"\nlet rec eval (e,x,y) = failwith \"to be written\";;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet rec build (rand,depth) = failwith \"to be implemented\";;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e = failwith \"to be written\";;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n","type":"","out":""},{"in":"let emitColor (f1,f2,f3,n,name) =\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n","type":"","out":""},{"in":"let doRandomColor (depth,seed1,seed2) =\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet g = makeRand (seed1,seed2) in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(*XXXXXXXXXXXXXXXXXX*)\nlet n = 150 in\n(*XXXXXXXXXXXXXXXXXX*)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)","min":"\nlet rec eval (e,x,y) = failwith \"to be written\";;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet rec build (rand,depth) = failwith \"to be implemented\";;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e = failwith \"to be written\";;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130 = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n","type":"","out":""},{"in":"let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","min":"\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n","type":"","out":""},{"in":"let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n\nlet drop_paren s =\n  implode\n    (List.filter (fun c  -> not (List.mem c ['('; ' '; ')'])) (explode s));;\n","type":"","out":""},{"in":"let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","min":"\nlet eq_real p (r1,r2) = ((r1 -. r2) < p) || ((r2 -. r1) < p);;\n","type":"","out":""},{"in":"let scoreMsg () = \nFormat.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":15664},"type":"eval"},"cursor":2555,"time":1.398299813463071e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) =\n  match l with\n      [] -> d\n    |front::back ->\n        match front with\n            (x,y) ->\n              if (x=k)\n              then y\n              else assoc (d,k,back)\n;; \n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' =  \n            if (List.mem h seen = true) \n            then []@seen\n            else [h]@seen\n          in\n          let rest' = t in \n            \t  helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n;;\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  match f b with\n      (x,y) -> if (y=true) then wwhile (f,x) else x\n;;\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 \tfixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec assoc (d,k,l) =\nmatch l with\n[] -> d\n|front::back ->\nmatch front with\n(x,y) ->\nif (x=k)\nthen y\nelse assoc (d,k,back)","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | front::back ->\n      (match front with | (x,y) -> if x = k then y else assoc (d, k, back));;\n","type":"","out":""},{"in":"let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | front::back ->\n      (match front with | (x,y) -> if x = k then y else assoc (d, k, back));;\n\nlet _ =\n  assoc ((-1), \"william\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n","type":"","out":""},{"in":"let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | front::back ->\n      (match front with | (x,y) -> if x = k then y else assoc (d, k, back));;\n\nlet _ = assoc ((-1), \"bob\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n","type":"","out":""},{"in":"let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' =  \nif (List.mem h seen = true) \nthen []@seen\nelse [h]@seen\nin\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))","min":"\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' =\n          if (List.mem h seen) = true then [] @ seen else [h] @ seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n","type":"","out":""},{"in":"let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]","min":"\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' =\n          if (List.mem h seen) = true then [] @ seen else [h] @ seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ = removeDuplicates [1; 6; 2; 4; 12; 2; 13; 6; 9];;\n","type":"","out":""},{"in":"let rec wwhile (f,b) = \nmatch f b with\n(x,y) -> if (y=true) then wwhile (f,x) else x","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n","type":"","out":""},{"in":"let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n","type":"","out":""},{"in":"let fixpoint (f,b) = wwhile ((let g x = let b'=f(x) in (b',b'!=x) in (g)),b)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n","type":"","out":""},{"in":"let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n","type":"","out":""},{"in":"let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1","min":"\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 1)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n\nlet _ = fixpoint (collatz, 1);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 3)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n\nlet _ = fixpoint (collatz, 3);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 48)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n\nlet _ = fixpoint (collatz, 48);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 107)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n\nlet _ = fixpoint (collatz, 107);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 9001)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n\nlet _ = fixpoint (collatz, 9001);;\n","type":"","out":""},{"in":"type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n","type":"","out":""},{"in":"let rec exprToString e = failwith \"to be written\"","min":"\nlet rec exprToString e = failwith \"to be written\";;\n","type":"","out":""},{"in":"let buildX()                       = VarX","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n","type":"","out":""},{"in":"let buildY()                       = VarY","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildY () = VarY;;\n","type":"","out":""},{"in":"let buildSine(e)                   = Sine(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n","type":"","out":""},{"in":"let buildCosine(e)                 = Cosine(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n","type":"","out":""},{"in":"let buildAverage(e1,e2)            = Average(e1,e2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n","type":"","out":""},{"in":"let buildTimes(e1,e2)              = Times(e1,e2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n","type":"","out":""},{"in":"let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n","type":"","out":""},{"in":"let pi = 4.0 *. atan 1.0","min":"\nlet pi = 4.0 *. (atan 1.0);;\n","type":"","out":""},{"in":"let rec eval (e,x,y) = failwith \"to be written\"","min":"\nlet rec eval (e,x,y) = failwith \"to be written\";;\n","type":"","out":""},{"in":"let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv","min":"\nlet rec eval (e,x,y) = failwith \"to be written\";;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n","type":"","out":""},{"in":"let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n","type":"","out":""},{"in":"let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr2 =\n  buildThresh\n    ((buildX ()), (buildY ()), (buildSine (buildX ())),\n      (buildCosine (buildY ())));;\n","type":"","out":""},{"in":"let rec build (rand, depth) = failwith \"to be implemented\"","min":"\nlet rec build (rand,depth) = failwith \"to be implemented\";;\n","type":"","out":""},{"in":"let g1 () = failwith \"to be implemented\"","min":"\nlet g1 () = failwith \"to be implemented\";;\n","type":"","out":""},{"in":"let g2 () = failwith \"to be implemented\"","min":"\nlet g2 () = failwith \"to be implemented\";;\n","type":"","out":""},{"in":"let g3 () = failwith \"to be implemented\"","min":"\nlet g3 () = failwith \"to be implemented\";;\n","type":"","out":""},{"in":"let c1 () = failwith \"to be implemented\"","min":"\nlet c1 () = failwith \"to be implemented\";;\n","type":"","out":""},{"in":"let c2 () = failwith \"to be implemented\"","min":"\nlet c2 () = failwith \"to be implemented\";;\n","type":"","out":""},{"in":"let c3 () = failwith \"to be implemented\"","min":"\nlet c3 () = failwith \"to be implemented\";;\n","type":"","out":""},{"in":"let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))","min":"\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n","type":"","out":""},{"in":"let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))","min":"\nlet rec rseq g r n = if n <= 0 then [] else (g r) :: (rseq g r (n - 1));;\n","type":"","out":""},{"in":"let toReal (i,n) = (float_of_int i) /. (float_of_int n)","min":"\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n","type":"","out":""},{"in":"let toIntensity z = int_of_float (127.5 +. (127.5 *. z))","min":"\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n","type":"","out":""},{"in":"let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n","type":"","out":""},{"in":"let emitGrayscale (f,n,name) =\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet z = f (x,y) in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet iz = toIntensity(z) in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n","type":"","out":""},{"in":"let doRandomGray (depth,seed1,seed2) =\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet g = makeRand(seed1,seed2) in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(*XXXXXXXXXXXXXXXXXX*)\nlet n = 150 in\n(*XXXXXXXXXXXXXXXXXX*)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)","min":"\nlet rec eval (e,x,y) = failwith \"to be written\";;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet rec build (rand,depth) = failwith \"to be implemented\";;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e = failwith \"to be written\";;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n","type":"","out":""},{"in":"let emitColor (f1,f2,f3,n,name) =\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n","type":"","out":""},{"in":"let doRandomColor (depth,seed1,seed2) =\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet g = makeRand (seed1,seed2) in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(*XXXXXXXXXXXXXXXXXX*)\nlet n = 150 in\n(*XXXXXXXXXXXXXXXXXX*)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)","min":"\nlet rec eval (e,x,y) = failwith \"to be written\";;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet rec build (rand,depth) = failwith \"to be implemented\";;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e = failwith \"to be written\";;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130 = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n","type":"","out":""},{"in":"let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","min":"\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n","type":"","out":""},{"in":"let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n\nlet drop_paren s =\n  implode\n    (List.filter (fun c  -> not (List.mem c ['('; ' '; ')'])) (explode s));;\n","type":"","out":""},{"in":"let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","min":"\nlet eq_real p (r1,r2) = ((r1 -. r2) < p) || ((r2 -. r1) < p);;\n","type":"","out":""},{"in":"let scoreMsg () = \nFormat.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":15638},"type":"eval"},"cursor":3370,"time":1.398304267639615e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) =\n  match l with\n      [] -> d\n    |front::back ->\n        match front with\n            (x,y) ->\n              if (x=k)\n              then y\n              else assoc (d,k,back)\n;; \n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' =  \n            if (List.mem h seen = true) \n            then []@seen\n            else [h]@seen\n          in\n          let rest' = t in \n            \t  helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n;;\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  match f b with\n      (x,y) -> if (y=true) then wwhile (f,x) else x\n;;\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = wwhile ((let g x = let b'=f(x) in (b',b'!=x) in (g)),b);;\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = failwith \"to be written\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 \tfixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec assoc (d,k,l) =\nmatch l with\n[] -> d\n|front::back ->\nmatch front with\n(x,y) ->\nif (x=k)\nthen y\nelse assoc (d,k,back)","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | front::back ->\n      (match front with | (x,y) -> if x = k then y else assoc (d, k, back));;\n","type":"","out":""},{"in":"let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | front::back ->\n      (match front with | (x,y) -> if x = k then y else assoc (d, k, back));;\n\nlet _ =\n  assoc ((-1), \"william\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n","type":"","out":""},{"in":"let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | front::back ->\n      (match front with | (x,y) -> if x = k then y else assoc (d, k, back));;\n\nlet _ = assoc ((-1), \"bob\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n","type":"","out":""},{"in":"let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' =  \nif (List.mem h seen = true) \nthen []@seen\nelse [h]@seen\nin\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))","min":"\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' =\n          if (List.mem h seen) = true then [] @ seen else [h] @ seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n","type":"","out":""},{"in":"let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]","min":"\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' =\n          if (List.mem h seen) = true then [] @ seen else [h] @ seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ = removeDuplicates [1; 6; 2; 4; 12; 2; 13; 6; 9];;\n","type":"","out":""},{"in":"let rec wwhile (f,b) = \nmatch f b with\n(x,y) -> if (y=true) then wwhile (f,x) else x","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n","type":"","out":""},{"in":"let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n","type":"","out":""},{"in":"let fixpoint (f,b) = wwhile ((let g x = let b'=f(x) in (b',b'!=x) in (g)),b)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n","type":"","out":""},{"in":"let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n","type":"","out":""},{"in":"let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1","min":"\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 1)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n\nlet _ = fixpoint (collatz, 1);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 3)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n\nlet _ = fixpoint (collatz, 3);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 48)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n\nlet _ = fixpoint (collatz, 48);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 107)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n\nlet _ = fixpoint (collatz, 107);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 9001)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n\nlet _ = fixpoint (collatz, 9001);;\n","type":"","out":""},{"in":"type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n","type":"","out":""},{"in":"let rec exprToString e = \nmatch e with\nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine e1 -> \"sin(pi*\"^exprToString e1^\")\"\n| Cosine e2 -> \"cos(pi*\"^exprToString e2^\")\"\n| Average (e3,e4) -> \"((\"^exprToString e3^\"+\"^exprToString e4^\")/2)\"\n| Times (e5,e6) -> exprToString e5^\"*\"^exprToString e6\n| Thresh (e7,e8,e9,e10) -> \"(\"^exprToString e7^\"<\"^exprToString e8^\"?\"^exprToString e9^\":\"^exprToString e10^\")\"","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e2 -> \"cos(pi*\" ^ ((exprToString e2) ^ \")\")\n  | Average (e3,e4) ->\n      \"((\" ^ ((exprToString e3) ^ (\"+\" ^ ((exprToString e4) ^ \")/2)\")))\n  | Times (e5,e6) -> (exprToString e5) ^ (\"*\" ^ (exprToString e6))\n  | Thresh (e7,e8,e9,e10) ->\n      \"(\" ^\n        ((exprToString e7) ^\n           (\"<\" ^\n              ((exprToString e8) ^\n                 (\"?\" ^\n                    ((exprToString e9) ^ (\":\" ^ ((exprToString e10) ^ \")\")))))));;\n","type":"","out":""},{"in":"let buildX()                       = VarX","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n","type":"","out":""},{"in":"let buildY()                       = VarY","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildY () = VarY;;\n","type":"","out":""},{"in":"let buildSine(e)                   = Sine(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n","type":"","out":""},{"in":"let buildCosine(e)                 = Cosine(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n","type":"","out":""},{"in":"let buildAverage(e1,e2)            = Average(e1,e2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n","type":"","out":""},{"in":"let buildTimes(e1,e2)              = Times(e1,e2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n","type":"","out":""},{"in":"let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n","type":"","out":""},{"in":"let pi = 4.0 *. atan 1.0","min":"\nlet pi = 4.0 *. (atan 1.0);;\n","type":"","out":""},{"in":"let rec eval (e,x,y) = failwith \"to be written\"","min":"\nlet rec eval (e,x,y) = failwith \"to be written\";;\n","type":"","out":""},{"in":"let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv","min":"\nlet rec eval (e,x,y) = failwith \"to be written\";;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n","type":"","out":""},{"in":"let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n","type":"","out":""},{"in":"let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr2 =\n  buildThresh\n    ((buildX ()), (buildY ()), (buildSine (buildX ())),\n      (buildCosine (buildY ())));;\n","type":"","out":""},{"in":"let rec build (rand, depth) = failwith \"to be implemented\"","min":"\nlet rec build (rand,depth) = failwith \"to be implemented\";;\n","type":"","out":""},{"in":"let g1 () = failwith \"to be implemented\"","min":"\nlet g1 () = failwith \"to be implemented\";;\n","type":"","out":""},{"in":"let g2 () = failwith \"to be implemented\"","min":"\nlet g2 () = failwith \"to be implemented\";;\n","type":"","out":""},{"in":"let g3 () = failwith \"to be implemented\"","min":"\nlet g3 () = failwith \"to be implemented\";;\n","type":"","out":""},{"in":"let c1 () = failwith \"to be implemented\"","min":"\nlet c1 () = failwith \"to be implemented\";;\n","type":"","out":""},{"in":"let c2 () = failwith \"to be implemented\"","min":"\nlet c2 () = failwith \"to be implemented\";;\n","type":"","out":""},{"in":"let c3 () = failwith \"to be implemented\"","min":"\nlet c3 () = failwith \"to be implemented\";;\n","type":"","out":""},{"in":"let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))","min":"\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n","type":"","out":""},{"in":"let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))","min":"\nlet rec rseq g r n = if n <= 0 then [] else (g r) :: (rseq g r (n - 1));;\n","type":"","out":""},{"in":"let toReal (i,n) = (float_of_int i) /. (float_of_int n)","min":"\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n","type":"","out":""},{"in":"let toIntensity z = int_of_float (127.5 +. (127.5 *. z))","min":"\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n","type":"","out":""},{"in":"let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n","type":"","out":""},{"in":"let emitGrayscale (f,n,name) =\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet z = f (x,y) in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet iz = toIntensity(z) in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n","type":"","out":""},{"in":"let doRandomGray (depth,seed1,seed2) =\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet g = makeRand(seed1,seed2) in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(*XXXXXXXXXXXXXXXXXX*)\nlet n = 150 in\n(*XXXXXXXXXXXXXXXXXX*)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) = failwith \"to be written\";;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet rec build (rand,depth) = failwith \"to be implemented\";;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e2 -> \"cos(pi*\" ^ ((exprToString e2) ^ \")\")\n  | Average (e3,e4) ->\n      \"((\" ^ ((exprToString e3) ^ (\"+\" ^ ((exprToString e4) ^ \")/2)\")))\n  | Times (e5,e6) -> (exprToString e5) ^ (\"*\" ^ (exprToString e6))\n  | Thresh (e7,e8,e9,e10) ->\n      \"(\" ^\n        ((exprToString e7) ^\n           (\"<\" ^\n              ((exprToString e8) ^\n                 (\"?\" ^\n                    ((exprToString e9) ^ (\":\" ^ ((exprToString e10) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n","type":"","out":""},{"in":"let emitColor (f1,f2,f3,n,name) =\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n","type":"","out":""},{"in":"let doRandomColor (depth,seed1,seed2) =\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet g = makeRand (seed1,seed2) in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(*XXXXXXXXXXXXXXXXXX*)\nlet n = 150 in\n(*XXXXXXXXXXXXXXXXXX*)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) = failwith \"to be written\";;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet rec build (rand,depth) = failwith \"to be implemented\";;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e2 -> \"cos(pi*\" ^ ((exprToString e2) ^ \")\")\n  | Average (e3,e4) ->\n      \"((\" ^ ((exprToString e3) ^ (\"+\" ^ ((exprToString e4) ^ \")/2)\")))\n  | Times (e5,e6) -> (exprToString e5) ^ (\"*\" ^ (exprToString e6))\n  | Thresh (e7,e8,e9,e10) ->\n      \"(\" ^\n        ((exprToString e7) ^\n           (\"<\" ^\n              ((exprToString e8) ^\n                 (\"?\" ^\n                    ((exprToString e9) ^ (\":\" ^ ((exprToString e10) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130 = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n","type":"","out":""},{"in":"let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","min":"\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n","type":"","out":""},{"in":"let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n\nlet drop_paren s =\n  implode\n    (List.filter (fun c  -> not (List.mem c ['('; ' '; ')'])) (explode s));;\n","type":"","out":""},{"in":"let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","min":"\nlet eq_real p (r1,r2) = ((r1 -. r2) < p) || ((r2 -. r1) < p);;\n","type":"","out":""},{"in":"let scoreMsg () = \nFormat.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":15980},"type":"eval"},"cursor":4322,"time":1.398306020362628e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) =\n  match l with\n      [] -> d\n    |front::back ->\n        match front with\n            (x,y) ->\n              if (x=k)\n              then y\n              else assoc (d,k,back)\n;; \n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' =  \n            if (List.mem h seen = true) \n            then []@seen\n            else [h]@seen\n          in\n          let rest' = t in \n            \t  helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n;;\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  match f b with\n      (x,y) -> if (y=true) then wwhile (f,x) else x\n;;\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = wwhile ((let g x = let b'=f(x) in (b',b'!=x) in (g)),b);;\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = \n  match e with\n      VarX -> \"x\"\n    | VarY -> \"y\"\n    | Sine e1 -> \"sin(pi*\"^exprToString e1^\")\"\n    | Cosine e2 -> \"cos(pi*\"^exprToString e2^\")\"\n    | Average (e3,e4) -> \"((\"^exprToString e3^\"+\"^exprToString e4^\")/2)\"\n    | Times (e5,e6) -> exprToString e5^\"*\"^exprToString e6\n    | Thresh (e7,e8,e9,e10) -> \"(\"^exprToString e7^\"<\"^exprToString e8^\"?\"^exprToString e9^\":\"^exprToString e10^\")\"\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = failwith \"to be written\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 \tfixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec assoc (d,k,l) =\nmatch l with\n[] -> d\n|front::back ->\nmatch front with\n(x,y) ->\nif (x=k)\nthen y\nelse assoc (d,k,back)","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | front::back ->\n      (match front with | (x,y) -> if x = k then y else assoc (d, k, back));;\n","type":"","out":""},{"in":"let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | front::back ->\n      (match front with | (x,y) -> if x = k then y else assoc (d, k, back));;\n\nlet _ =\n  assoc ((-1), \"william\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n","type":"","out":""},{"in":"let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | front::back ->\n      (match front with | (x,y) -> if x = k then y else assoc (d, k, back));;\n\nlet _ = assoc ((-1), \"bob\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n","type":"","out":""},{"in":"let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' =  \nif (List.mem h seen = true) \nthen []@seen\nelse [h]@seen\nin\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))","min":"\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' =\n          if (List.mem h seen) = true then [] @ seen else [h] @ seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n","type":"","out":""},{"in":"let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]","min":"\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' =\n          if (List.mem h seen) = true then [] @ seen else [h] @ seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ = removeDuplicates [1; 6; 2; 4; 12; 2; 13; 6; 9];;\n","type":"","out":""},{"in":"let rec wwhile (f,b) = \nmatch f b with\n(x,y) -> if (y=true) then wwhile (f,x) else x","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n","type":"","out":""},{"in":"let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n","type":"","out":""},{"in":"let fixpoint (f,b) = wwhile ((let g x = let b'=f(x) in (b',b'!=x) in (g)),b)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n","type":"","out":""},{"in":"let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n","type":"","out":""},{"in":"let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1","min":"\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 1)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n\nlet _ = fixpoint (collatz, 1);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 3)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n\nlet _ = fixpoint (collatz, 3);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 48)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n\nlet _ = fixpoint (collatz, 48);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 107)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n\nlet _ = fixpoint (collatz, 107);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 9001)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n\nlet _ = fixpoint (collatz, 9001);;\n","type":"","out":""},{"in":"type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n","type":"","out":""},{"in":"let rec exprToString e = \nmatch e with\nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine e1 -> \"sin(pi*\"^exprToString e1^\")\"\n| Cosine e2 -> \"cos(pi*\"^exprToString e2^\")\"\n| Average (e3,e4) -> \"((\"^exprToString e3^\"+\"^exprToString e4^\")/2)\"\n| Times (e5,e6) -> exprToString e5^\"*\"^exprToString e6\n| Thresh (e7,e8,e9,e10) -> \"(\"^exprToString e7^\"<\"^exprToString e8^\"?\"^exprToString e9^\":\"^exprToString e10^\")\"","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e2 -> \"cos(pi*\" ^ ((exprToString e2) ^ \")\")\n  | Average (e3,e4) ->\n      \"((\" ^ ((exprToString e3) ^ (\"+\" ^ ((exprToString e4) ^ \")/2)\")))\n  | Times (e5,e6) -> (exprToString e5) ^ (\"*\" ^ (exprToString e6))\n  | Thresh (e7,e8,e9,e10) ->\n      \"(\" ^\n        ((exprToString e7) ^\n           (\"<\" ^\n              ((exprToString e8) ^\n                 (\"?\" ^\n                    ((exprToString e9) ^ (\":\" ^ ((exprToString e10) ^ \")\")))))));;\n","type":"","out":""},{"in":"let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n","type":"","out":""},{"in":"let _ = exprToString sampleExpr1","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e2 -> \"cos(pi*\" ^ ((exprToString e2) ^ \")\")\n  | Average (e3,e4) ->\n      \"((\" ^ ((exprToString e3) ^ (\"+\" ^ ((exprToString e4) ^ \")/2)\")))\n  | Times (e5,e6) -> (exprToString e5) ^ (\"*\" ^ (exprToString e6))\n  | Thresh (e7,e8,e9,e10) ->\n      \"(\" ^\n        ((exprToString e7) ^\n           (\"<\" ^\n              ((exprToString e8) ^\n                 (\"?\" ^\n                    ((exprToString e9) ^ (\":\" ^ ((exprToString e10) ^ \")\")))))));;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet _ = exprToString sampleExpr1;;\n","type":"","out":""},{"in":"let buildX()                       = VarX","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n","type":"","out":""},{"in":"let buildY()                       = VarY","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildY () = VarY;;\n","type":"","out":""},{"in":"let buildSine(e)                   = Sine(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n","type":"","out":""},{"in":"let buildCosine(e)                 = Cosine(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n","type":"","out":""},{"in":"let buildAverage(e1,e2)            = Average(e1,e2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n","type":"","out":""},{"in":"let buildTimes(e1,e2)              = Times(e1,e2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n","type":"","out":""},{"in":"let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n","type":"","out":""},{"in":"let pi = 4.0 *. atan 1.0","min":"\nlet pi = 4.0 *. (atan 1.0);;\n","type":"","out":""},{"in":"let rec eval (e,x,y) = \nmatch e with \nVarX -> x\n| VarY -> y\n| Sine (e) -> sin(pi*.eval (e,x,y))\n| Cosine (e) -> cos(pi*. eval (e,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y))/.2.0)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (a,b,a_less,b_less) -> if (eval (a,x,y)<eval(b,x,y)) then eval(a_less,x,y) else eval(b_less,x,y)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n","type":"","out":""},{"in":"let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n","type":"","out":""},{"in":"let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n","type":"","out":""},{"in":"let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr2 =\n  buildThresh\n    ((buildX ()), (buildY ()), (buildSine (buildX ())),\n      (buildCosine (buildY ())));;\n","type":"","out":""},{"in":"let rec build (rand, depth) = failwith \"to be implemented\"","min":"\nlet rec build (rand,depth) = failwith \"to be implemented\";;\n","type":"","out":""},{"in":"let g1 () = failwith \"to be implemented\"","min":"\nlet g1 () = failwith \"to be implemented\";;\n","type":"","out":""},{"in":"let g2 () = failwith \"to be implemented\"","min":"\nlet g2 () = failwith \"to be implemented\";;\n","type":"","out":""},{"in":"let g3 () = failwith \"to be implemented\"","min":"\nlet g3 () = failwith \"to be implemented\";;\n","type":"","out":""},{"in":"let c1 () = failwith \"to be implemented\"","min":"\nlet c1 () = failwith \"to be implemented\";;\n","type":"","out":""},{"in":"let c2 () = failwith \"to be implemented\"","min":"\nlet c2 () = failwith \"to be implemented\";;\n","type":"","out":""},{"in":"let c3 () = failwith \"to be implemented\"","min":"\nlet c3 () = failwith \"to be implemented\";;\n","type":"","out":""},{"in":"let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))","min":"\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n","type":"","out":""},{"in":"let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))","min":"\nlet rec rseq g r n = if n <= 0 then [] else (g r) :: (rseq g r (n - 1));;\n","type":"","out":""},{"in":"let toReal (i,n) = (float_of_int i) /. (float_of_int n)","min":"\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n","type":"","out":""},{"in":"let toIntensity z = int_of_float (127.5 +. (127.5 *. z))","min":"\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n","type":"","out":""},{"in":"let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n","type":"","out":""},{"in":"let emitGrayscale (f,n,name) =\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet z = f (x,y) in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet iz = toIntensity(z) in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n","type":"","out":""},{"in":"let doRandomGray (depth,seed1,seed2) =\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet g = makeRand(seed1,seed2) in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(*XXXXXXXXXXXXXXXXXX*)\nlet n = 150 in\n(*XXXXXXXXXXXXXXXXXX*)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet rec build (rand,depth) = failwith \"to be implemented\";;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e2 -> \"cos(pi*\" ^ ((exprToString e2) ^ \")\")\n  | Average (e3,e4) ->\n      \"((\" ^ ((exprToString e3) ^ (\"+\" ^ ((exprToString e4) ^ \")/2)\")))\n  | Times (e5,e6) -> (exprToString e5) ^ (\"*\" ^ (exprToString e6))\n  | Thresh (e7,e8,e9,e10) ->\n      \"(\" ^\n        ((exprToString e7) ^\n           (\"<\" ^\n              ((exprToString e8) ^\n                 (\"?\" ^\n                    ((exprToString e9) ^ (\":\" ^ ((exprToString e10) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n","type":"","out":""},{"in":"let emitColor (f1,f2,f3,n,name) =\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n","type":"","out":""},{"in":"let doRandomColor (depth,seed1,seed2) =\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet g = makeRand (seed1,seed2) in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(*XXXXXXXXXXXXXXXXXX*)\nlet n = 150 in\n(*XXXXXXXXXXXXXXXXXX*)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet rec build (rand,depth) = failwith \"to be implemented\";;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e2 -> \"cos(pi*\" ^ ((exprToString e2) ^ \")\")\n  | Average (e3,e4) ->\n      \"((\" ^ ((exprToString e3) ^ (\"+\" ^ ((exprToString e4) ^ \")/2)\")))\n  | Times (e5,e6) -> (exprToString e5) ^ (\"*\" ^ (exprToString e6))\n  | Thresh (e7,e8,e9,e10) ->\n      \"(\" ^\n        ((exprToString e7) ^\n           (\"<\" ^\n              ((exprToString e8) ^\n                 (\"?\" ^\n                    ((exprToString e9) ^ (\":\" ^ ((exprToString e10) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130 = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n","type":"","out":""},{"in":"let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","min":"\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n","type":"","out":""},{"in":"let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n\nlet drop_paren s =\n  implode\n    (List.filter (fun c  -> not (List.mem c ['('; ' '; ')'])) (explode s));;\n","type":"","out":""},{"in":"let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","min":"\nlet eq_real p (r1,r2) = ((r1 -. r2) < p) || ((r2 -. r1) < p);;\n","type":"","out":""},{"in":"let scoreMsg () = \nFormat.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":16239},"type":"eval"},"cursor":5467,"time":1.398308920436863e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) =\n  match l with\n      [] -> d\n    |front::back ->\n        match front with\n            (x,y) ->\n              if (x=k)\n              then y\n              else assoc (d,k,back)\n;; \n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' =  \n            if (List.mem h seen = true) \n            then []@seen\n            else [h]@seen\n          in\n          let rest' = t in \n            \t  helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n;;\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  match f b with\n      (x,y) -> if (y=true) then wwhile (f,x) else x\n;;\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = wwhile ((let g x = let b'=f(x) in (b',b'!=x) in (g)),b);;\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = \n  match e with\n      VarX -> \"x\"\n    | VarY -> \"y\"\n    | Sine e1 -> \"sin(pi*\"^exprToString e1^\")\"\n    | Cosine e2 -> \"cos(pi*\"^exprToString e2^\")\"\n    | Average (e3,e4) -> \"((\"^exprToString e3^\"+\"^exprToString e4^\")/2)\"\n    | Times (e5,e6) -> exprToString e5^\"*\"^exprToString e6\n    | Thresh (e7,e8,e9,e10) -> \"(\"^exprToString e7^\"<\"^exprToString e8^\"?\"^exprToString e9^\":\"^exprToString e10^\")\"\n;;\n\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\nlet _ = exprToString sampleExpr1 ;;\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = \n  match e with \n      VarX -> x\n    | VarY -> y\n    | Sine (e) -> sin(pi*.eval (e,x,y))\n    | Cosine (e) -> cos(pi*. eval (e,x,y))\n    | Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y))/.2.0)\n    | Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y)\n    | Thresh (a,b,a_less,b_less) -> if (eval (a,x,y)<eval(b,x,y)) then eval(a_less,x,y) else eval(b_less,x,y)\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 \tfixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":" _ = eval (sampleExpr,0.5,0.2)","min":"","type":"syntax","out":"Characters 1-2:\n   _ = eval (sampleExpr,0.5,0.2);;\n   ^\nError: Syntax error\n"}],"event":{"region":{"start":5570,"stop":5605},"type":"eval"},"cursor":5570,"time":1.398308985741784e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) =\n  match l with\n      [] -> d\n    |front::back ->\n        match front with\n            (x,y) ->\n              if (x=k)\n              then y\n              else assoc (d,k,back)\n;; \n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' =  \n            if (List.mem h seen = true) \n            then []@seen\n            else [h]@seen\n          in\n          let rest' = t in \n            \t  helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n;;\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  match f b with\n      (x,y) -> if (y=true) then wwhile (f,x) else x\n;;\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = wwhile ((let g x = let b'=f(x) in (b',b'!=x) in (g)),b);;\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = \n  match e with\n      VarX -> \"x\"\n    | VarY -> \"y\"\n    | Sine e1 -> \"sin(pi*\"^exprToString e1^\")\"\n    | Cosine e2 -> \"cos(pi*\"^exprToString e2^\")\"\n    | Average (e3,e4) -> \"((\"^exprToString e3^\"+\"^exprToString e4^\")/2)\"\n    | Times (e5,e6) -> exprToString e5^\"*\"^exprToString e6\n    | Thresh (e7,e8,e9,e10) -> \"(\"^exprToString e7^\"<\"^exprToString e8^\"?\"^exprToString e9^\":\"^exprToString e10^\")\"\n;;\n\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\nlet _ = exprToString sampleExpr1 ;;\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = \n  match e with \n      VarX -> x\n    | VarY -> y\n    | Sine (e) -> sin(pi*.eval (e,x,y))\n    | Cosine (e) -> cos(pi*. eval (e,x,y))\n    | Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y))/.2.0)\n    | Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y)\n    | Thresh (a,b,a_less,b_less) -> if (eval (a,x,y)<eval(b,x,y)) then eval(a_less,x,y) else eval(b_less,x,y)\n;;\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr,0.5,0.2);;\n\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = failwith \"to be implemented\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 \tfixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec assoc (d,k,l) =\nmatch l with\n[] -> d\n|front::back ->\nmatch front with\n(x,y) ->\nif (x=k)\nthen y\nelse assoc (d,k,back)","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | front::back ->\n      (match front with | (x,y) -> if x = k then y else assoc (d, k, back));;\n","type":"","out":""},{"in":"let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | front::back ->\n      (match front with | (x,y) -> if x = k then y else assoc (d, k, back));;\n\nlet _ =\n  assoc ((-1), \"william\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n","type":"","out":""},{"in":"let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | front::back ->\n      (match front with | (x,y) -> if x = k then y else assoc (d, k, back));;\n\nlet _ = assoc ((-1), \"bob\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n","type":"","out":""},{"in":"let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' =  \nif (List.mem h seen = true) \nthen []@seen\nelse [h]@seen\nin\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))","min":"\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' =\n          if (List.mem h seen) = true then [] @ seen else [h] @ seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n","type":"","out":""},{"in":"let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]","min":"\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' =\n          if (List.mem h seen) = true then [] @ seen else [h] @ seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ = removeDuplicates [1; 6; 2; 4; 12; 2; 13; 6; 9];;\n","type":"","out":""},{"in":"let rec wwhile (f,b) = \nmatch f b with\n(x,y) -> if (y=true) then wwhile (f,x) else x","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n","type":"","out":""},{"in":"let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n","type":"","out":""},{"in":"let fixpoint (f,b) = wwhile ((let g x = let b'=f(x) in (b',b'!=x) in (g)),b)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n","type":"","out":""},{"in":"let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n","type":"","out":""},{"in":"let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1","min":"\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 1)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n\nlet _ = fixpoint (collatz, 1);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 3)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n\nlet _ = fixpoint (collatz, 3);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 48)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n\nlet _ = fixpoint (collatz, 48);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 107)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n\nlet _ = fixpoint (collatz, 107);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 9001)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n\nlet _ = fixpoint (collatz, 9001);;\n","type":"","out":""},{"in":"type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n","type":"","out":""},{"in":"let rec exprToString e = \nmatch e with\nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine e1 -> \"sin(pi*\"^exprToString e1^\")\"\n| Cosine e2 -> \"cos(pi*\"^exprToString e2^\")\"\n| Average (e3,e4) -> \"((\"^exprToString e3^\"+\"^exprToString e4^\")/2)\"\n| Times (e5,e6) -> exprToString e5^\"*\"^exprToString e6\n| Thresh (e7,e8,e9,e10) -> \"(\"^exprToString e7^\"<\"^exprToString e8^\"?\"^exprToString e9^\":\"^exprToString e10^\")\"","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e2 -> \"cos(pi*\" ^ ((exprToString e2) ^ \")\")\n  | Average (e3,e4) ->\n      \"((\" ^ ((exprToString e3) ^ (\"+\" ^ ((exprToString e4) ^ \")/2)\")))\n  | Times (e5,e6) -> (exprToString e5) ^ (\"*\" ^ (exprToString e6))\n  | Thresh (e7,e8,e9,e10) ->\n      \"(\" ^\n        ((exprToString e7) ^\n           (\"<\" ^\n              ((exprToString e8) ^\n                 (\"?\" ^\n                    ((exprToString e9) ^ (\":\" ^ ((exprToString e10) ^ \")\")))))));;\n","type":"","out":""},{"in":"let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n","type":"","out":""},{"in":"let _ = exprToString sampleExpr1","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e2 -> \"cos(pi*\" ^ ((exprToString e2) ^ \")\")\n  | Average (e3,e4) ->\n      \"((\" ^ ((exprToString e3) ^ (\"+\" ^ ((exprToString e4) ^ \")/2)\")))\n  | Times (e5,e6) -> (exprToString e5) ^ (\"*\" ^ (exprToString e6))\n  | Thresh (e7,e8,e9,e10) ->\n      \"(\" ^\n        ((exprToString e7) ^\n           (\"<\" ^\n              ((exprToString e8) ^\n                 (\"?\" ^\n                    ((exprToString e9) ^ (\":\" ^ ((exprToString e10) ^ \")\")))))));;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet _ = exprToString sampleExpr1;;\n","type":"","out":""},{"in":"let buildX()                       = VarX","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n","type":"","out":""},{"in":"let buildY()                       = VarY","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildY () = VarY;;\n","type":"","out":""},{"in":"let buildSine(e)                   = Sine(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n","type":"","out":""},{"in":"let buildCosine(e)                 = Cosine(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n","type":"","out":""},{"in":"let buildAverage(e1,e2)            = Average(e1,e2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n","type":"","out":""},{"in":"let buildTimes(e1,e2)              = Times(e1,e2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n","type":"","out":""},{"in":"let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n","type":"","out":""},{"in":"let pi = 4.0 *. atan 1.0","min":"\nlet pi = 4.0 *. (atan 1.0);;\n","type":"","out":""},{"in":"let rec eval (e,x,y) = \nmatch e with \nVarX -> x\n| VarY -> y\n| Sine (e) -> sin(pi*.eval (e,x,y))\n| Cosine (e) -> cos(pi*. eval (e,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y))/.2.0)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (a,b,a_less,b_less) -> if (eval (a,x,y)<eval(b,x,y)) then eval(a_less,x,y) else eval(b_less,x,y)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.5, (-0.5));;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.3, 0.3);;\n","type":"","out":""},{"in":"let _ = eval (sampleExpr,0.5,0.2)","min":"","type":"type","out":"Error: This expression has type expr/1813\n       but an expression was expected of type expr/2024\nError: This expression has type expr/2077\n       but an expression was expected of type expr/2097\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 14-24:\n  let _ = eval (sampleExpr,0.5,0.2);;\n                ^^^^^^^^^^\nError: This expression has type expr/1813\n       but an expression was expected of type expr/2024\n"},{"in":"let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n","type":"","out":""},{"in":"let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n","type":"","out":""},{"in":"let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr2 =\n  buildThresh\n    ((buildX ()), (buildY ()), (buildSine (buildX ())),\n      (buildCosine (buildY ())));;\n","type":"","out":""},{"in":"let rec build (rand, depth) = \nif (depth = 0)\nthen let z = rand (0,1) in \nmatch z with \n0 -> buildX()\n| 1 -> buildY()\nelse\nlet z = rand (2,6) in\nmatch z with \n2 -> buildSine(build (rand, depth-1))\n| 3 -> buildCosine(build (rand, depth-1))\n| 4 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 5 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 6 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let z = rand (0, 1) in match z with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let z = rand (2, 6) in\n     match z with\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n","type":"","out":""},{"in":"let g1 () = failwith \"to be implemented\"","min":"\nlet g1 () = failwith \"to be implemented\";;\n","type":"","out":""},{"in":"let g2 () = failwith \"to be implemented\"","min":"\nlet g2 () = failwith \"to be implemented\";;\n","type":"","out":""},{"in":"let g3 () = failwith \"to be implemented\"","min":"\nlet g3 () = failwith \"to be implemented\";;\n","type":"","out":""},{"in":"let c1 () = failwith \"to be implemented\"","min":"\nlet c1 () = failwith \"to be implemented\";;\n","type":"","out":""},{"in":"let c2 () = failwith \"to be implemented\"","min":"\nlet c2 () = failwith \"to be implemented\";;\n","type":"","out":""},{"in":"let c3 () = failwith \"to be implemented\"","min":"\nlet c3 () = failwith \"to be implemented\";;\n","type":"","out":""},{"in":"let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))","min":"\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n","type":"","out":""},{"in":"let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))","min":"\nlet rec rseq g r n = if n <= 0 then [] else (g r) :: (rseq g r (n - 1));;\n","type":"","out":""},{"in":"let toReal (i,n) = (float_of_int i) /. (float_of_int n)","min":"\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n","type":"","out":""},{"in":"let toIntensity z = int_of_float (127.5 +. (127.5 *. z))","min":"\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n","type":"","out":""},{"in":"let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n","type":"","out":""},{"in":"let emitGrayscale (f,n,name) =\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fname","min":"","type":"syntax","out":"Characters 41-43:\n  let fname;;\n           ^^\nError: Syntax error\n"}],"event":{"region":{"start":0,"stop":10461},"type":"eval"},"cursor":10462,"time":1.398312362963888e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) =\n  match l with\n      [] -> d\n    |front::back ->\n        match front with\n            (x,y) ->\n              if (x=k)\n              then y\n              else assoc (d,k,back)\n;; \n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' =  \n            if (List.mem h seen = true) \n            then []@seen\n            else [h]@seen\n          in\n          let rest' = t in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n;;\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  match f b with\n      (x,y) -> if (y=true) then wwhile (f,x) else x\n;;\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = wwhile ((let g x = let b'=f(x) in (b',b'!=x) in (g)),b);;\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = \n  match e with\n      VarX -> \"x\"\n    | VarY -> \"y\"\n    | Sine e1 -> \"sin(pi*\"^exprToString e1^\")\"\n    | Cosine e2 -> \"cos(pi*\"^exprToString e2^\")\"\n    | Average (e3,e4) -> \"((\"^exprToString e3^\"+\"^exprToString e4^\")/2)\"\n    | Times (e5,e6) -> exprToString e5^\"*\"^exprToString e6\n    | Thresh (e7,e8,e9,e10) -> \"(\"^exprToString e7^\"<\"^exprToString e8^\"?\"^exprToString e9^\":\"^exprToString e10^\")\"\n;;\n\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\nlet _ = exprToString sampleExpr1 ;;\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = \n  match e with \n      VarX -> x\n    | VarY -> y\n    | Sine (e) -> sin(pi*.eval (e,x,y))\n    | Cosine (e) -> cos(pi*. eval (e,x,y))\n    | Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y))/.2.0)\n    | Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y)\n    | Thresh (a,b,a_less,b_less) -> if (eval (a,x,y)<eval(b,x,y)) then eval(a_less,x,y) else eval(b_less,x,y)\n;;\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr,0.5,0.2);;\n\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  if (depth = 0)\n  then let z = rand (0,1) in \n      match z with \n          0 -> buildX()\n        | 1 -> buildY()\n  else\n    let z = rand (2,6) in\n      match z with \n          2 -> buildSine(build (rand, depth-1))\n        | 3 -> buildCosine(build (rand, depth-1))\n        | 4 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n        | 5 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n        | 6 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n\n\n\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec assoc (d,k,l) =\nmatch l with\n[] -> d\n|front::back ->\nmatch front with\n(x,y) ->\nif (x=k)\nthen y\nelse assoc (d,k,back)","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | front::back ->\n      (match front with | (x,y) -> if x = k then y else assoc (d, k, back));;\n","type":"","out":""},{"in":"let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | front::back ->\n      (match front with | (x,y) -> if x = k then y else assoc (d, k, back));;\n\nlet _ =\n  assoc ((-1), \"william\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n","type":"","out":""},{"in":"let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | front::back ->\n      (match front with | (x,y) -> if x = k then y else assoc (d, k, back));;\n\nlet _ = assoc ((-1), \"bob\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n","type":"","out":""},{"in":"let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' =  \nif (List.mem h seen = true) \nthen []@seen\nelse [h]@seen\nin\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))","min":"\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' =\n          if (List.mem h seen) = true then [] @ seen else [h] @ seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n","type":"","out":""},{"in":"let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]","min":"\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' =\n          if (List.mem h seen) = true then [] @ seen else [h] @ seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ = removeDuplicates [1; 6; 2; 4; 12; 2; 13; 6; 9];;\n","type":"","out":""},{"in":"let rec wwhile (f,b) = \nmatch f b with\n(x,y) -> if (y=true) then wwhile (f,x) else x","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n","type":"","out":""},{"in":"let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n","type":"","out":""},{"in":"let fixpoint (f,b) = wwhile ((let g x = let b'=f(x) in (b',b'!=x) in (g)),b)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n","type":"","out":""},{"in":"let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n","type":"","out":""},{"in":"let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1","min":"\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 1)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n\nlet _ = fixpoint (collatz, 1);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 3)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n\nlet _ = fixpoint (collatz, 3);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 48)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n\nlet _ = fixpoint (collatz, 48);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 107)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n\nlet _ = fixpoint (collatz, 107);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 9001)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n\nlet _ = fixpoint (collatz, 9001);;\n","type":"","out":""},{"in":"type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n","type":"","out":""},{"in":"let rec exprToString e = \nmatch e with\nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine e1 -> \"sin(pi*\"^exprToString e1^\")\"\n| Cosine e2 -> \"cos(pi*\"^exprToString e2^\")\"\n| Average (e3,e4) -> \"((\"^exprToString e3^\"+\"^exprToString e4^\")/2)\"\n| Times (e5,e6) -> exprToString e5^\"*\"^exprToString e6\n| Thresh (e7,e8,e9,e10) -> \"(\"^exprToString e7^\"<\"^exprToString e8^\"?\"^exprToString e9^\":\"^exprToString e10^\")\"","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e2 -> \"cos(pi*\" ^ ((exprToString e2) ^ \")\")\n  | Average (e3,e4) ->\n      \"((\" ^ ((exprToString e3) ^ (\"+\" ^ ((exprToString e4) ^ \")/2)\")))\n  | Times (e5,e6) -> (exprToString e5) ^ (\"*\" ^ (exprToString e6))\n  | Thresh (e7,e8,e9,e10) ->\n      \"(\" ^\n        ((exprToString e7) ^\n           (\"<\" ^\n              ((exprToString e8) ^\n                 (\"?\" ^\n                    ((exprToString e9) ^ (\":\" ^ ((exprToString e10) ^ \")\")))))));;\n","type":"","out":""},{"in":"let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n","type":"","out":""},{"in":"let _ = exprToString sampleExpr1","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e2 -> \"cos(pi*\" ^ ((exprToString e2) ^ \")\")\n  | Average (e3,e4) ->\n      \"((\" ^ ((exprToString e3) ^ (\"+\" ^ ((exprToString e4) ^ \")/2)\")))\n  | Times (e5,e6) -> (exprToString e5) ^ (\"*\" ^ (exprToString e6))\n  | Thresh (e7,e8,e9,e10) ->\n      \"(\" ^\n        ((exprToString e7) ^\n           (\"<\" ^\n              ((exprToString e8) ^\n                 (\"?\" ^\n                    ((exprToString e9) ^ (\":\" ^ ((exprToString e10) ^ \")\")))))));;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet _ = exprToString sampleExpr1;;\n","type":"","out":""},{"in":"let buildX()                       = VarX","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n","type":"","out":""},{"in":"let buildY()                       = VarY","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildY () = VarY;;\n","type":"","out":""},{"in":"let buildSine(e)                   = Sine(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n","type":"","out":""},{"in":"let buildCosine(e)                 = Cosine(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n","type":"","out":""},{"in":"let buildAverage(e1,e2)            = Average(e1,e2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n","type":"","out":""},{"in":"let buildTimes(e1,e2)              = Times(e1,e2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n","type":"","out":""},{"in":"let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n","type":"","out":""},{"in":"let pi = 4.0 *. atan 1.0","min":"\nlet pi = 4.0 *. (atan 1.0);;\n","type":"","out":""},{"in":"let rec eval (e,x,y) = \nmatch e with \nVarX -> x\n| VarY -> y\n| Sine (e) -> sin(pi*.eval (e,x,y))\n| Cosine (e) -> cos(pi*. eval (e,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y))/.2.0)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (a,b,a_less,b_less) -> if (eval (a,x,y)<eval(b,x,y)) then eval(a_less,x,y) else eval(b_less,x,y)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.5, (-0.5));;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.3, 0.3);;\n","type":"","out":""},{"in":"let _ = eval (sampleExpr,0.5,0.2)","min":"","type":"type","out":"Error: This expression has type expr/2024\n       but an expression was expected of type expr/2194\nError: This expression has type expr/2247\n       but an expression was expected of type expr/2267\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 14-24:\n  let _ = eval (sampleExpr,0.5,0.2);;\n                ^^^^^^^^^^\nError: This expression has type expr/2024\n       but an expression was expected of type expr/2194\n"},{"in":"let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n","type":"","out":""},{"in":"let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n","type":"","out":""},{"in":"let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr2 =\n  buildThresh\n    ((buildX ()), (buildY ()), (buildSine (buildX ())),\n      (buildCosine (buildY ())));;\n","type":"","out":""},{"in":"let rec build (rand, depth) = \nif (depth = 0)\nthen let z = rand (0,1) in \nmatch z with \n0 -> buildX()\n| 1 -> buildY()\nelse\nlet z = rand (2,6) in\nmatch z with \n2 -> buildSine(build (rand, depth-1))\n| 3 -> buildCosine(build (rand, depth-1))\n| 4 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 5 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 6 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let z = rand (0, 1) in match z with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let z = rand (2, 6) in\n     match z with\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n","type":"","out":""},{"in":"let g1 () = (7,1,90)","min":"\nlet g1 () = (7, 1, 90);;\n","type":"","out":""},{"in":"let g2 () = (6,14,33)","min":"\nlet g2 () = (6, 14, 33);;\n","type":"","out":""},{"in":"let g3 () = (5,7,200)","min":"\nlet g3 () = (5, 7, 200);;\n","type":"","out":""},{"in":"let c1 () = (4,33,99)","min":"\nlet c1 () = (4, 33, 99);;\n","type":"","out":""},{"in":"let c2 () = (8,13,99)","min":"\nlet c2 () = (8, 13, 99);;\n","type":"","out":""},{"in":"let c3 () = (5,11,107)","min":"\nlet c3 () = (5, 11, 107);;\n","type":"","out":""},{"in":"let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))","min":"\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n","type":"","out":""},{"in":"let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))","min":"\nlet rec rseq g r n = if n <= 0 then [] else (g r) :: (rseq g r (n - 1));;\n","type":"","out":""},{"in":"let toReal (i,n) = (float_of_int i) /. (float_of_int n)","min":"\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n","type":"","out":""},{"in":"let toIntensity z = int_of_float (127.5 +. (127.5 *. z))","min":"\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n","type":"","out":""},{"in":"let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n","type":"","out":""},{"in":"let emitGrayscale (f,n,name) =\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet z = f (x,y) in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet iz = toIntensity(z) in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n","type":"","out":""},{"in":"let doRandomGray (depth,seed1,seed2) =\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet g = makeRand(seed1,seed2) in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(*XXXXXXXXXXXXXXXXXX*)\nlet n = 150 in\n(*XXXXXXXXXXXXXXXXXX*)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let z = rand (0, 1) in match z with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let z = rand (2, 6) in\n     match z with\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e2 -> \"cos(pi*\" ^ ((exprToString e2) ^ \")\")\n  | Average (e3,e4) ->\n      \"((\" ^ ((exprToString e3) ^ (\"+\" ^ ((exprToString e4) ^ \")/2)\")))\n  | Times (e5,e6) -> (exprToString e5) ^ (\"*\" ^ (exprToString e6))\n  | Thresh (e7,e8,e9,e10) ->\n      \"(\" ^\n        ((exprToString e7) ^\n           (\"<\" ^\n              ((exprToString e8) ^\n                 (\"?\" ^\n                    ((exprToString e9) ^ (\":\" ^ ((exprToString e10) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n","type":"","out":""},{"in":"let emitColor (f1,f2,f3,n,name) =\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n","type":"","out":""},{"in":"let doRandomColor (depth,seed1,seed2) =\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet g = makeRand (seed1,seed2) in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(*XXXXXXXXXXXXXXXXXX*)\nlet n = 150 in\n(*XXXXXXXXXXXXXXXXXX*)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let z = rand (0, 1) in match z with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let z = rand (2, 6) in\n     match z with\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e2 -> \"cos(pi*\" ^ ((exprToString e2) ^ \")\")\n  | Average (e3,e4) ->\n      \"((\" ^ ((exprToString e3) ^ (\"+\" ^ ((exprToString e4) ^ \")/2)\")))\n  | Times (e5,e6) -> (exprToString e5) ^ (\"*\" ^ (exprToString e6))\n  | Thresh (e7,e8,e9,e10) ->\n      \"(\" ^\n        ((exprToString e7) ^\n           (\"<\" ^\n              ((exprToString e8) ^\n                 (\"?\" ^\n                    ((exprToString e9) ^ (\":\" ^ ((exprToString e10) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130 = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n","type":"","out":""},{"in":"let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","min":"\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n","type":"","out":""},{"in":"let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n\nlet drop_paren s =\n  implode\n    (List.filter (fun c  -> not (List.mem c ['('; ' '; ')'])) (explode s));;\n","type":"","out":""},{"in":"let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","min":"\nlet eq_real p (r1,r2) = ((r1 -. r2) < p) || ((r2 -. r1) < p);;\n","type":"","out":""},{"in":"let scoreMsg () = \nFormat.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":16481},"type":"eval"},"cursor":7217,"time":1.398314006400638e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) =\n  match l with\n      [] -> d\n    |front::back ->\n        match front with\n            (x,y) ->\n              if (x=k)\n              then y\n              else assoc (d,k,back)\n;; \n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' =  \n            if (List.mem h seen = true) \n            then []@seen\n            else [h]@seen\n          in\n          let rest' = t in \n            \t  helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n;;\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  match f b with\n      (x,y) -> if (y=true) then wwhile (f,x) else x\n;;\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = wwhile ((let g x = let b'=f(x) in (b',b'!=x) in (g)),b);;\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = \n  match e with\n      VarX -> \"x\"\n    | VarY -> \"y\"\n    | Sine e1 -> \"sin(pi*\"^exprToString e1^\")\"\n    | Cosine e2 -> \"cos(pi*\"^exprToString e2^\")\"\n    | Average (e3,e4) -> \"((\"^exprToString e3^\"+\"^exprToString e4^\")/2)\"\n    | Times (e5,e6) -> exprToString e5^\"*\"^exprToString e6\n    | Thresh (e7,e8,e9,e10) -> \"(\"^exprToString e7^\"<\"^exprToString e8^\"?\"^exprToString e9^\":\"^exprToString e10^\")\"\n;;\n\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\nlet _ = exprToString sampleExpr1 ;;\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = \n  match e with \n      VarX -> x\n    | VarY -> y\n    | Sine (e) -> sin(pi*.eval (e,x,y))\n    | Cosine (e) -> cos(pi*. eval (e,x,y))\n    | Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y))/.2.0)\n    | Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y)\n    | Thresh (a,b,a_less,b_less) -> if (eval (a,x,y)<eval(b,x,y)) then eval(a_less,x,y) else eval(b_less,x,y)\n;;\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr,0.5,0.2);;\n\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  if (depth = 0)\n  then let z = rand (0,1) in \n      match z with \n          0 -> buildX()\n        | 1 -> buildY()\n  else\n    let z = rand (2,6) in\n      match z with \n          2 -> buildSine(build (rand, depth-1))\n        | 3 -> buildCosine(build (rand, depth-1))\n        | 4 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n        | 5 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n        | 6 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = (7,1,90)\nlet g2 () = (6,14,33)\nlet g3 () = (5,7,200) \n\nlet c1 () = (4,33,99)\nlet c2 () = (8,13,99)\nlet c3 () = (5,11,107)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 \tfixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec assoc (d,k,l) =\nmatch l with\n[] -> d\n|front::back ->\nmatch front with\n(x,y) ->\nif (x=k)\nthen y\nelse assoc (d,k,back)","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | front::back ->\n      (match front with | (x,y) -> if x = k then y else assoc (d, k, back));;\n","type":"","out":""},{"in":"let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | front::back ->\n      (match front with | (x,y) -> if x = k then y else assoc (d, k, back));;\n\nlet _ =\n  assoc ((-1), \"william\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n","type":"","out":""},{"in":"let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | front::back ->\n      (match front with | (x,y) -> if x = k then y else assoc (d, k, back));;\n\nlet _ = assoc ((-1), \"bob\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n","type":"","out":""},{"in":"let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' =  \nif (List.mem h seen = true) \nthen []@seen\nelse [h]@seen\nin\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))","min":"\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' =\n          if (List.mem h seen) = true then [] @ seen else [h] @ seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n","type":"","out":""},{"in":"let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]","min":"\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' =\n          if (List.mem h seen) = true then [] @ seen else [h] @ seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ = removeDuplicates [1; 6; 2; 4; 12; 2; 13; 6; 9];;\n","type":"","out":""},{"in":"let rec wwhile (f,b) = \nmatch f b with\n(x,y) -> if (y=true) then wwhile (f,x) else x","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n","type":"","out":""},{"in":"let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n","type":"","out":""},{"in":"let fixpoint (f,b) = wwhile ((let g x = let b'=f(x) in (b',b'!=x) in (g)),b)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n","type":"","out":""},{"in":"let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n","type":"","out":""},{"in":"let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1","min":"\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 1)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n\nlet _ = fixpoint (collatz, 1);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 3)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n\nlet _ = fixpoint (collatz, 3);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 48)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n\nlet _ = fixpoint (collatz, 48);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 107)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n\nlet _ = fixpoint (collatz, 107);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 9001)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n\nlet _ = fixpoint (collatz, 9001);;\n","type":"","out":""},{"in":"type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n","type":"","out":""},{"in":"let rec exprToString e = \nmatch e with\nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine e1 -> \"sin(pi*\"^exprToString e1^\")\"\n| Cosine e2 -> \"cos(pi*\"^exprToString e2^\")\"\n| Average (e3,e4) -> \"((\"^exprToString e3^\"+\"^exprToString e4^\")/2)\"\n| Times (e5,e6) -> exprToString e5^\"*\"^exprToString e6\n| Thresh (e7,e8,e9,e10) -> \"(\"^exprToString e7^\"<\"^exprToString e8^\"?\"^exprToString e9^\":\"^exprToString e10^\")\"","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e2 -> \"cos(pi*\" ^ ((exprToString e2) ^ \")\")\n  | Average (e3,e4) ->\n      \"((\" ^ ((exprToString e3) ^ (\"+\" ^ ((exprToString e4) ^ \")/2)\")))\n  | Times (e5,e6) -> (exprToString e5) ^ (\"*\" ^ (exprToString e6))\n  | Thresh (e7,e8,e9,e10) ->\n      \"(\" ^\n        ((exprToString e7) ^\n           (\"<\" ^\n              ((exprToString e8) ^\n                 (\"?\" ^\n                    ((exprToString e9) ^ (\":\" ^ ((exprToString e10) ^ \")\")))))));;\n","type":"","out":""},{"in":"let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n","type":"","out":""},{"in":"let _ = exprToString sampleExpr1","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e2 -> \"cos(pi*\" ^ ((exprToString e2) ^ \")\")\n  | Average (e3,e4) ->\n      \"((\" ^ ((exprToString e3) ^ (\"+\" ^ ((exprToString e4) ^ \")/2)\")))\n  | Times (e5,e6) -> (exprToString e5) ^ (\"*\" ^ (exprToString e6))\n  | Thresh (e7,e8,e9,e10) ->\n      \"(\" ^\n        ((exprToString e7) ^\n           (\"<\" ^\n              ((exprToString e8) ^\n                 (\"?\" ^\n                    ((exprToString e9) ^ (\":\" ^ ((exprToString e10) ^ \")\")))))));;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet _ = exprToString sampleExpr1;;\n","type":"","out":""},{"in":"let buildX()                       = VarX","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n","type":"","out":""},{"in":"let buildY()                       = VarY","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildY () = VarY;;\n","type":"","out":""},{"in":"let buildSine(e)                   = Sine(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n","type":"","out":""},{"in":"let buildCosine(e)                 = Cosine(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n","type":"","out":""},{"in":"let buildAverage(e1,e2)            = Average(e1,e2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n","type":"","out":""},{"in":"let buildTimes(e1,e2)              = Times(e1,e2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n","type":"","out":""},{"in":"let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n","type":"","out":""},{"in":"let pi = 4.0 *. atan 1.0","min":"\nlet pi = 4.0 *. (atan 1.0);;\n","type":"","out":""},{"in":"let rec eval (e,x,y) = \nmatch e with \nVarX -> x\n| VarY -> y\n| Sine (e) -> sin(pi*.eval (e,x,y))\n| Cosine (e) -> cos(pi*. eval (e,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y))/.2.0)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (a,b,a_less,b_less) -> if (eval (a,x,y)<eval(b,x,y)) then eval(a_less,x,y) else eval(b_less,x,y)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.5, (-0.5));;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.3, 0.3);;\n","type":"","out":""},{"in":"let _ = eval (sampleExpr1,0.5,0.2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet _ = eval (sampleExpr1, 0.5, 0.2);;\n","type":"","out":""},{"in":"let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n","type":"","out":""},{"in":"let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n","type":"","out":""},{"in":"let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr2 =\n  buildThresh\n    ((buildX ()), (buildY ()), (buildSine (buildX ())),\n      (buildCosine (buildY ())));;\n","type":"","out":""},{"in":"let rec build (rand, depth) = \nif (depth = 0)\nthen let z = rand (0,1) in \nmatch z with \n0 -> buildX()\n| 1 -> buildY()\nelse\nlet z = rand (2,6) in\nmatch z with \n2 -> buildSine(build (rand, depth-1))\n| 3 -> buildCosine(build (rand, depth-1))\n| 4 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 5 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 6 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let z = rand (0, 1) in match z with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let z = rand (2, 6) in\n     match z with\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n","type":"","out":""},{"in":"let g1 () = (7,1,90)","min":"\nlet g1 () = (7, 1, 90);;\n","type":"","out":""},{"in":"let g2 () = (6,14,33)","min":"\nlet g2 () = (6, 14, 33);;\n","type":"","out":""},{"in":"let g3 () = (5,7,200)","min":"\nlet g3 () = (5, 7, 200);;\n","type":"","out":""},{"in":"let c1 () = (4,33,99)","min":"\nlet c1 () = (4, 33, 99);;\n","type":"","out":""},{"in":"let c2 () = (8,13,99)","min":"\nlet c2 () = (8, 13, 99);;\n","type":"","out":""},{"in":"let c3 () = (5,11,107)","min":"\nlet c3 () = (5, 11, 107);;\n","type":"","out":""},{"in":"let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))","min":"\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n","type":"","out":""},{"in":"let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))","min":"\nlet rec rseq g r n = if n <= 0 then [] else (g r) :: (rseq g r (n - 1));;\n","type":"","out":""},{"in":"let toReal (i,n) = (float_of_int i) /. (float_of_int n)","min":"\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n","type":"","out":""},{"in":"let toIntensity z = int_of_float (127.5 +. (127.5 *. z))","min":"\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n","type":"","out":""},{"in":"let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n","type":"","out":""},{"in":"let emitGrayscale (f,n,name) =\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet z = f (x,y) in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet iz = toIntensity(z) in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n","type":"","out":""},{"in":"let doRandomGray (depth,seed1,seed2) =\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet g = makeRand(seed1,seed2) in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(*XXXXXXXXXXXXXXXXXX*)\nlet n = 150 in\n(*XXXXXXXXXXXXXXXXXX*)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let z = rand (0, 1) in match z with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let z = rand (2, 6) in\n     match z with\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e2 -> \"cos(pi*\" ^ ((exprToString e2) ^ \")\")\n  | Average (e3,e4) ->\n      \"((\" ^ ((exprToString e3) ^ (\"+\" ^ ((exprToString e4) ^ \")/2)\")))\n  | Times (e5,e6) -> (exprToString e5) ^ (\"*\" ^ (exprToString e6))\n  | Thresh (e7,e8,e9,e10) ->\n      \"(\" ^\n        ((exprToString e7) ^\n           (\"<\" ^\n              ((exprToString e8) ^\n                 (\"?\" ^\n                    ((exprToString e9) ^ (\":\" ^ ((exprToString e10) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n","type":"","out":""},{"in":"let emitColor (f1,f2,f3,n,name) =\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n","type":"","out":""},{"in":"let doRandomColor (depth,seed1,seed2) =\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet g = makeRand (seed1,seed2) in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(*XXXXXXXXXXXXXXXXXX*)\nlet n = 150 in\n(*XXXXXXXXXXXXXXXXXX*)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let z = rand (0, 1) in match z with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let z = rand (2, 6) in\n     match z with\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e2 -> \"cos(pi*\" ^ ((exprToString e2) ^ \")\")\n  | Average (e3,e4) ->\n      \"((\" ^ ((exprToString e3) ^ (\"+\" ^ ((exprToString e4) ^ \")/2)\")))\n  | Times (e5,e6) -> (exprToString e5) ^ (\"*\" ^ (exprToString e6))\n  | Thresh (e7,e8,e9,e10) ->\n      \"(\" ^\n        ((exprToString e7) ^\n           (\"<\" ^\n              ((exprToString e8) ^\n                 (\"?\" ^\n                    ((exprToString e9) ^ (\":\" ^ ((exprToString e10) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130 = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n","type":"","out":""},{"in":"let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","min":"\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n","type":"","out":""},{"in":"let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n\nlet drop_paren s =\n  implode\n    (List.filter (fun c  -> not (List.mem c ['('; ' '; ')'])) (explode s));;\n","type":"","out":""},{"in":"let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","min":"\nlet eq_real p (r1,r2) = ((r1 -. r2) < p) || ((r2 -. r1) < p);;\n","type":"","out":""},{"in":"let scoreMsg () = \nFormat.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":16482},"type":"eval"},"cursor":5595,"time":1.398314075142524e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) =\n  match l with\n      [] -> d\n    |front::back ->\n        match front with\n            (x,y) ->\n              if (x=k)\n              then y\n              else assoc (d,k,back)\n;; \n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' =  \n            if (List.mem h seen = true) \n            then []@seen\n            else [h]@seen\n          in\n          let rest' = t in \n            \t  helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n;;\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  match f b with\n      (x,y) -> if (y=true) then wwhile (f,x) else x\n;;\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = wwhile ((let g x = let b'=f(x) in (b',b'!=x) in (g)),b);;\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = \n  match e with\n      VarX -> \"x\"\n    | VarY -> \"y\"\n    | Sine e1 -> \"sin(pi*\"^exprToString e1^\")\"\n    | Cosine e2 -> \"cos(pi*\"^exprToString e2^\")\"\n    | Average (e3,e4) -> \"((\"^exprToString e3^\"+\"^exprToString e4^\")/2)\"\n    | Times (e5,e6) -> exprToString e5^\"*\"^exprToString e6\n    | Thresh (e7,e8,e9,e10) -> \"(\"^exprToString e7^\"<\"^exprToString e8^\"?\"^exprToString e9^\":\"^exprToString e10^\")\"\n;;\n\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\nlet _ = exprToString sampleExpr1 ;;\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = \n  match e with \n      VarX -> x\n    | VarY -> y\n    | Sine (e) -> sin(pi*.eval (e,x,y))\n    | Cosine (e) -> cos(pi*. eval (e,x,y))\n    | Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y))/.2.0)\n    | Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y)\n    | Thresh (a,b,a_less,b_less) -> if (eval (a,x,y)<eval(b,x,y)) then eval(a_less,x,y) else eval(b_less,x,y)\n;;\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr1,0.5,0.2);;\n\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  if (depth = 0)\n  then let z = rand (0,1) in \n      match z with \n          0 -> buildX()\n        | 1 -> buildY()\n  else\n    let z = rand (2,6) in\n      match z with \n          2 -> buildSine(build (rand, depth-1))\n        | 3 -> buildCosine(build (rand, depth-1))\n        | 4 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n        | 5 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n        | 6 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = (7,1,90)\nlet g2 () = (6,14,33)\nlet g3 () = (5,7,200) \n\nlet c1 () = (4,33,99)\nlet c2 () = (8,13,99)\nlet c3 () = (5,11,107)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 \tfixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec assoc (d,k,l) =\nmatch l with\n[] -> d\n|front::back ->\nmatch front with\n(x,y) ->\nif (x=k)\nthen y\nelse assoc (d,k,back)","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | front::back ->\n      (match front with | (x,y) -> if x = k then y else assoc (d, k, back));;\n","type":"","out":""},{"in":"let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | front::back ->\n      (match front with | (x,y) -> if x = k then y else assoc (d, k, back));;\n\nlet _ =\n  assoc ((-1), \"william\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n","type":"","out":""},{"in":"let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | front::back ->\n      (match front with | (x,y) -> if x = k then y else assoc (d, k, back));;\n\nlet _ = assoc ((-1), \"bob\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n","type":"","out":""},{"in":"let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' =  \nif (List.mem h seen = true) \nthen []@seen\nelse [h]@seen\nin\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))","min":"\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' =\n          if (List.mem h seen) = true then [] @ seen else [h] @ seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n","type":"","out":""},{"in":"let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]","min":"\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' =\n          if (List.mem h seen) = true then [] @ seen else [h] @ seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ = removeDuplicates [1; 6; 2; 4; 12; 2; 13; 6; 9];;\n","type":"","out":""},{"in":"let rec wwhile (f,b) = \nmatch f b with\n(x,y) -> if (y=true) then wwhile (f,x) else x","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n","type":"","out":""},{"in":"let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n","type":"","out":""},{"in":"let fixpoint (f,b) = wwhile ((let g x = let b'=f(x) in (b',b'!=x) in (g)),b)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n","type":"","out":""},{"in":"let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n","type":"","out":""},{"in":"let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1","min":"\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 1)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n\nlet _ = fixpoint (collatz, 1);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 3)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n\nlet _ = fixpoint (collatz, 3);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 48)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n\nlet _ = fixpoint (collatz, 48);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 107)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n\nlet _ = fixpoint (collatz, 107);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 9001)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n\nlet _ = fixpoint (collatz, 9001);;\n","type":"","out":""},{"in":"type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Power    of expr\n| KellysOp of expr * expr * expr * expr","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr* expr;;\n","type":"","out":""},{"in":"let rec exprToString e = \nmatch e with\nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine e1 -> \"sin(pi*\"^exprToString e1^\")\"\n| Cosine e2 -> \"cos(pi*\"^exprToString e2^\")\"\n| Average (e3,e4) -> \"((\"^exprToString e3^\"+\"^exprToString e4^\")/2)\"\n| Times (e5,e6) -> exprToString e5^\"*\"^exprToString e6\n| Thresh (e7,e8,e9,e10) -> \"(\"^exprToString e7^\"<\"^exprToString e8^\"?\"^exprToString e9^\":\"^exprToString e10^\")\"\n| Power (e11) -> \"((\"^exprToString e11^\")^2)\"\n| KellysOp (e1,e2,e3) -> \"(\"^exprToString e1^\">\"^exprToString e2^\"?\"^exprToString e3^\":0.0\"","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e2 -> \"cos(pi*\" ^ ((exprToString e2) ^ \")\")\n  | Average (e3,e4) ->\n      \"((\" ^ ((exprToString e3) ^ (\"+\" ^ ((exprToString e4) ^ \")/2)\")))\n  | Times (e5,e6) -> (exprToString e5) ^ (\"*\" ^ (exprToString e6))\n  | Thresh (e7,e8,e9,e10) ->\n      \"(\" ^\n        ((exprToString e7) ^\n           (\"<\" ^\n              ((exprToString e8) ^\n                 (\"?\" ^\n                    ((exprToString e9) ^ (\":\" ^ ((exprToString e10) ^ \")\")))))))\n  | Power e11 -> \"((\" ^ ((exprToString e11) ^ \")^2)\")\n  | KellysOp (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\">\" ^ ((exprToString e2) ^ (\"?\" ^ ((exprToString e3) ^ \":0.0\")))));;\n","type":"type","out":"Characters 437-456:\n  | KellysOp (e1,e2,e3) -> \"(\"^exprToString e1^\">\"^exprToString e2^\"?\"^exprToString e3^\":0.0\";;\n    ^^^^^^^^^^^^^^^^^^^\nError: The constructor KellysOp expects 4 argument(s),\n       but is applied here to 3 argument(s)\n"},{"in":"let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr* expr;;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n","type":"","out":""},{"in":"let _ = exprToString sampleExpr1","min":"","type":"type","out":"NO ERROR FROM MINIMAL PROGRAM!!!\nCharacters 21-32:\n  let _ = exprToString sampleExpr1;;\n                       ^^^^^^^^^^^\nError: This expression has type expr/2664\n       but an expression was expected of type expr/2451\n"},{"in":"let buildX()                       = VarX","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n","type":"","out":""},{"in":"let buildY()                       = VarY","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr* expr;;\n\nlet buildY () = VarY;;\n","type":"","out":""},{"in":"let buildSine(e)                   = Sine(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n","type":"","out":""},{"in":"let buildCosine(e)                 = Cosine(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n","type":"","out":""},{"in":"let buildAverage(e1,e2)            = Average(e1,e2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n","type":"","out":""},{"in":"let buildTimes(e1,e2)              = Times(e1,e2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr* expr;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n","type":"","out":""},{"in":"let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr* expr;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n","type":"","out":""},{"in":"let buildPower(e)                  = Power(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr* expr;;\n\nlet buildPower e = Power e;;\n","type":"","out":""},{"in":"let buildKellysOp(a,b,a_more)      = KellysOp(a,b,a_more)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr* expr;;\n\nlet buildKellysOp (a,b,a_more) = KellysOp (a, b, a_more);;\n","type":"type","out":"Characters 37-57:\n  let buildKellysOp(a,b,a_more)      = KellysOp(a,b,a_more);;\n                                       ^^^^^^^^^^^^^^^^^^^^\nError: The constructor KellysOp expects 4 argument(s),\n       but is applied here to 3 argument(s)\n"},{"in":"let pi = 4.0 *. atan 1.0","min":"\nlet pi = 4.0 *. (atan 1.0);;\n","type":"","out":""},{"in":"let rec eval (e,x,y) = \nmatch e with \nVarX -> x\n| VarY -> y\n| Sine (e) -> sin(pi*.eval (e,x,y))\n| Cosine (e) -> cos(pi*. eval (e,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y))/.2.0)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (a,b,a_less,b_less) -> if (eval (a,x,y)<eval(b,x,y)) then eval(a_less,x,y) else eval(b_less,x,y)\n| Power (e) -> eval(e,x,y) *. eval(e,x,y)\n| KellysOp (a,b,a_more) -> if (eval(a,x,y)>eval(b,x,y)) then eval (a_more,x,y) else 0.0","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Power e -> (eval (e, x, y)) *. (eval (e, x, y))\n  | KellysOp (a,b,a_more) ->\n      if (eval (a, x, y)) > (eval (b, x, y))\n      then eval (a_more, x, y)\n      else 0.0;;\n","type":"type","out":"Characters 396-417:\n  | KellysOp (a,b,a_more) -> if (eval(a,x,y)>eval(b,x,y)) then eval (a_more,x,y) else 0.0;;\n    ^^^^^^^^^^^^^^^^^^^^^\nError: The constructor KellysOp expects 4 argument(s),\n       but is applied here to 3 argument(s)\n"},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.5, (-0.5));;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.3, 0.3);;\n","type":"","out":""},{"in":"let _ = eval (sampleExpr1,0.5,0.2)","min":"","type":"type","out":"NO ERROR FROM MINIMAL PROGRAM!!!\nCharacters 14-25:\n  let _ = eval (sampleExpr1,0.5,0.2);;\n                ^^^^^^^^^^^\nError: This expression has type expr/2664\n       but an expression was expected of type expr/2451\n"},{"in":"let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n","type":"","out":""},{"in":"let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n","type":"","out":""},{"in":"let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr2 =\n  buildThresh\n    ((buildX ()), (buildY ()), (buildSine (buildX ())),\n      (buildCosine (buildY ())));;\n","type":"","out":""},{"in":"let rec build (rand, depth) = \nif (depth = 0)\nthen let z = rand (0,1) in \nmatch z with \n0 -> buildX()\n| 1 -> buildY()\nelse\nlet z = rand (2,8) in\nmatch z with \n2 -> buildSine(build (rand, depth-1))\n| 3 -> buildCosine(build (rand, depth-1))\n| 4 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 5 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 6 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| 7 -> buildPower(build(rand, depth-1))\n| 8 -> buildKellysOp(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildPower e = Power e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let z = rand (0, 1) in match z with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let z = rand (2, 8) in\n     match z with\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7 -> buildPower (build (rand, (depth - 1)))\n     | 8 ->\n         buildKellysOp\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n","type":"scope","out":"Characters 506-519:\n  | 8 -> buildKellysOp(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1));;\n         ^^^^^^^^^^^^^\nError: Unbound value buildKellysOp\n"},{"in":"let g1 () = (7,1,90)","min":"\nlet g1 () = (7, 1, 90);;\n","type":"","out":""},{"in":"let g2 () = (6,14,33)","min":"\nlet g2 () = (6, 14, 33);;\n","type":"","out":""},{"in":"let g3 () = (5,7,200)","min":"\nlet g3 () = (5, 7, 200);;\n","type":"","out":""},{"in":"let c1 () = (4,33,99)","min":"\nlet c1 () = (4, 33, 99);;\n","type":"","out":""},{"in":"let c2 () = (8,13,99)","min":"\nlet c2 () = (8, 13, 99);;\n","type":"","out":""},{"in":"let c3 () = (5,11,107)","min":"\nlet c3 () = (5, 11, 107);;\n","type":"","out":""},{"in":"let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))","min":"\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n","type":"","out":""},{"in":"let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))","min":"\nlet rec rseq g r n = if n <= 0 then [] else (g r) :: (rseq g r (n - 1));;\n","type":"","out":""},{"in":"let toReal (i,n) = (float_of_int i) /. (float_of_int n)","min":"\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n","type":"","out":""},{"in":"let toIntensity z = int_of_float (127.5 +. (127.5 *. z))","min":"\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n","type":"","out":""},{"in":"let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n","type":"","out":""},{"in":"let emitGrayscale (f,n,name) =\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet z = f (x,y) in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet iz = toIntensity(z) in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n","type":"","out":""},{"in":"let doRandomGray (depth,seed1,seed2) =\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet g = makeRand(seed1,seed2) in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(*XXXXXXXXXXXXXXXXXX*)\nlet n = 150 in\n(*XXXXXXXXXXXXXXXXXX*)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let z = rand (0, 1) in match z with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let z = rand (2, 6) in\n     match z with\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e2 -> \"cos(pi*\" ^ ((exprToString e2) ^ \")\")\n  | Average (e3,e4) ->\n      \"((\" ^ ((exprToString e3) ^ (\"+\" ^ ((exprToString e4) ^ \")/2)\")))\n  | Times (e5,e6) -> (exprToString e5) ^ (\"*\" ^ (exprToString e6))\n  | Thresh (e7,e8,e9,e10) ->\n      \"(\" ^\n        ((exprToString e7) ^\n           (\"<\" ^\n              ((exprToString e8) ^\n                 (\"?\" ^\n                    ((exprToString e9) ^ (\":\" ^ ((exprToString e10) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n","type":"","out":""},{"in":"let emitColor (f1,f2,f3,n,name) =\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n","type":"","out":""},{"in":"let doRandomColor (depth,seed1,seed2) =\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet g = makeRand (seed1,seed2) in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(*XXXXXXXXXXXXXXXXXX*)\nlet n = 150 in\n(*XXXXXXXXXXXXXXXXXX*)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let z = rand (0, 1) in match z with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let z = rand (2, 6) in\n     match z with\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e2 -> \"cos(pi*\" ^ ((exprToString e2) ^ \")\")\n  | Average (e3,e4) ->\n      \"((\" ^ ((exprToString e3) ^ (\"+\" ^ ((exprToString e4) ^ \")/2)\")))\n  | Times (e5,e6) -> (exprToString e5) ^ (\"*\" ^ (exprToString e6))\n  | Thresh (e7,e8,e9,e10) ->\n      \"(\" ^\n        ((exprToString e7) ^\n           (\"<\" ^\n              ((exprToString e8) ^\n                 (\"?\" ^\n                    ((exprToString e9) ^ (\":\" ^ ((exprToString e10) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130 = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n","type":"","out":""},{"in":"let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","min":"\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n","type":"","out":""},{"in":"let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n\nlet drop_paren s =\n  implode\n    (List.filter (fun c  -> not (List.mem c ['('; ' '; ')'])) (explode s));;\n","type":"","out":""},{"in":"let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","min":"\nlet eq_real p (r1,r2) = ((r1 -. r2) < p) || ((r2 -. r1) < p);;\n","type":"","out":""},{"in":"let scoreMsg () = \nFormat.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":17035},"type":"eval"},"cursor":5302,"time":1.398315220830629e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) =\n  match l with\n      [] -> d\n    |front::back ->\n        match front with\n            (x,y) ->\n              if (x=k)\n              then y\n              else assoc (d,k,back)\n;; \n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' =  \n            if (List.mem h seen = true) \n            then []@seen\n            else [h]@seen\n          in\n          let rest' = t in \n            \t  helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n;;\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  match f b with\n      (x,y) -> if (y=true) then wwhile (f,x) else x\n;;\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = wwhile ((let g x = let b'=f(x) in (b',b'!=x) in (g)),b);;\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n    | Power    of expr\n    | KellysOp of expr * expr * expr * expr\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = \n  match e with\n      VarX -> \"x\"\n    | VarY -> \"y\"\n    | Sine e1 -> \"sin(pi*\"^exprToString e1^\")\"\n    | Cosine e2 -> \"cos(pi*\"^exprToString e2^\")\"\n    | Average (e3,e4) -> \"((\"^exprToString e3^\"+\"^exprToString e4^\")/2)\"\n    | Times (e5,e6) -> exprToString e5^\"*\"^exprToString e6\n    | Thresh (e7,e8,e9,e10) -> \"(\"^exprToString e7^\"<\"^exprToString e8^\"?\"^exprToString e9^\":\"^exprToString e10^\")\"\n    | Power (e11) -> \"((\"^exprToString e11^\")^2)\"\n    | KellysOp (e1,e2,e3) -> \"(\"^exprToString e1^\">\"^exprToString e2^\"?\"^exprToString e3^\":0.0\"\n;;\n\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\nlet _ = exprToString sampleExpr1 ;;\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\nlet buildPower(e)                  = Power(e)\nlet buildKellysOp(a,b,a_more)      = KellysOp(a,b,a_more)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = \n  match e with \n      VarX -> x\n    | VarY -> y\n    | Sine (e) -> sin(pi*.eval (e,x,y))\n    | Cosine (e) -> cos(pi*. eval (e,x,y))\n    | Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y))/.2.0)\n    | Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y)\n    | Thresh (a,b,a_less,b_less) -> if (eval (a,x,y)<eval(b,x,y)) then eval(a_less,x,y) else eval(b_less,x,y)\n    | Power (e) -> eval(e,x,y) *. eval(e,x,y)\n    | KellysOp (a,b,a_more) -> if (eval(a,x,y)>eval(b,x,y)) then eval (a_more,x,y) else 0.0\n;;\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr1,0.5,0.2);;\n\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  if (depth = 0)\n  then let z = rand (0,1) in \n      match z with \n          0 -> buildX()\n        | 1 -> buildY()\n  else\n    let z = rand (2,8) in\n      match z with \n          2 -> buildSine(build (rand, depth-1))\n        | 3 -> buildCosine(build (rand, depth-1))\n        | 4 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n        | 5 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n        | 6 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n        | 7 -> buildPower(build(rand, depth-1))\n        | 8 -> buildKellysOp(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = (7,1,90)\nlet g2 () = (6,14,33)\nlet g3 () = (5,7,200) \n\nlet c1 () = (4,33,99)\nlet c2 () = (8,13,99)\nlet c3 () = (5,11,107)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 \tfixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec assoc (d,k,l) =\nmatch l with\n[] -> d\n|front::back ->\nmatch front with\n(x,y) ->\nif (x=k)\nthen y\nelse assoc (d,k,back)","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | front::back ->\n      (match front with | (x,y) -> if x = k then y else assoc (d, k, back));;\n","type":"","out":""},{"in":"let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | front::back ->\n      (match front with | (x,y) -> if x = k then y else assoc (d, k, back));;\n\nlet _ =\n  assoc ((-1), \"william\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n","type":"","out":""},{"in":"let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | front::back ->\n      (match front with | (x,y) -> if x = k then y else assoc (d, k, back));;\n\nlet _ = assoc ((-1), \"bob\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n","type":"","out":""},{"in":"let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' =  \nif (List.mem h seen = true) \nthen []@seen\nelse [h]@seen\nin\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))","min":"\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' =\n          if (List.mem h seen) = true then [] @ seen else [h] @ seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n","type":"","out":""},{"in":"let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]","min":"\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' =\n          if (List.mem h seen) = true then [] @ seen else [h] @ seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ = removeDuplicates [1; 6; 2; 4; 12; 2; 13; 6; 9];;\n","type":"","out":""},{"in":"let rec wwhile (f,b) = \nmatch f b with\n(x,y) -> if (y=true) then wwhile (f,x) else x","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n","type":"","out":""},{"in":"let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n","type":"","out":""},{"in":"let fixpoint (f,b) = wwhile ((let g x = let b'=f(x) in (b',b'!=x) in (g)),b)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n","type":"","out":""},{"in":"let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n","type":"","out":""},{"in":"let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1","min":"\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 1)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n\nlet _ = fixpoint (collatz, 1);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 3)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n\nlet _ = fixpoint (collatz, 3);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 48)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n\nlet _ = fixpoint (collatz, 48);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 107)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n\nlet _ = fixpoint (collatz, 107);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 9001)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n\nlet _ = fixpoint (collatz, 9001);;\n","type":"","out":""},{"in":"type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Power    of expr\n| KellysOp of expr * expr * expr","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n","type":"","out":""},{"in":"let rec exprToString e = \nmatch e with\nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine e1 -> \"sin(pi*\"^exprToString e1^\")\"\n| Cosine e2 -> \"cos(pi*\"^exprToString e2^\")\"\n| Average (e3,e4) -> \"((\"^exprToString e3^\"+\"^exprToString e4^\")/2)\"\n| Times (e5,e6) -> exprToString e5^\"*\"^exprToString e6\n| Thresh (e7,e8,e9,e10) -> \"(\"^exprToString e7^\"<\"^exprToString e8^\"?\"^exprToString e9^\":\"^exprToString e10^\")\"\n| Power (e11) -> \"((\"^exprToString e11^\")^2)\"\n| KellysOp (e1,e2,e3) -> \"(\"^exprToString e1^\">\"^exprToString e2^\"?\"^exprToString e3^\":0.0\"","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e2 -> \"cos(pi*\" ^ ((exprToString e2) ^ \")\")\n  | Average (e3,e4) ->\n      \"((\" ^ ((exprToString e3) ^ (\"+\" ^ ((exprToString e4) ^ \")/2)\")))\n  | Times (e5,e6) -> (exprToString e5) ^ (\"*\" ^ (exprToString e6))\n  | Thresh (e7,e8,e9,e10) ->\n      \"(\" ^\n        ((exprToString e7) ^\n           (\"<\" ^\n              ((exprToString e8) ^\n                 (\"?\" ^\n                    ((exprToString e9) ^ (\":\" ^ ((exprToString e10) ^ \")\")))))))\n  | Power e11 -> \"((\" ^ ((exprToString e11) ^ \")^2)\")\n  | KellysOp (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\">\" ^ ((exprToString e2) ^ (\"?\" ^ ((exprToString e3) ^ \":0.0\")))));;\n","type":"","out":""},{"in":"let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n","type":"","out":""},{"in":"let _ = exprToString sampleExpr1","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e2 -> \"cos(pi*\" ^ ((exprToString e2) ^ \")\")\n  | Average (e3,e4) ->\n      \"((\" ^ ((exprToString e3) ^ (\"+\" ^ ((exprToString e4) ^ \")/2)\")))\n  | Times (e5,e6) -> (exprToString e5) ^ (\"*\" ^ (exprToString e6))\n  | Thresh (e7,e8,e9,e10) ->\n      \"(\" ^\n        ((exprToString e7) ^\n           (\"<\" ^\n              ((exprToString e8) ^\n                 (\"?\" ^\n                    ((exprToString e9) ^ (\":\" ^ ((exprToString e10) ^ \")\")))))))\n  | Power e11 -> \"((\" ^ ((exprToString e11) ^ \")^2)\")\n  | KellysOp (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\">\" ^ ((exprToString e2) ^ (\"?\" ^ ((exprToString e3) ^ \":0.0\")))));;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet _ = exprToString sampleExpr1;;\n","type":"","out":""},{"in":"let buildX()                       = VarX","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet buildX () = VarX;;\n","type":"","out":""},{"in":"let buildY()                       = VarY","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet buildY () = VarY;;\n","type":"","out":""},{"in":"let buildSine(e)                   = Sine(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n","type":"","out":""},{"in":"let buildCosine(e)                 = Cosine(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n","type":"","out":""},{"in":"let buildAverage(e1,e2)            = Average(e1,e2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n","type":"","out":""},{"in":"let buildTimes(e1,e2)              = Times(e1,e2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n","type":"","out":""},{"in":"let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n","type":"","out":""},{"in":"let buildPower(e)                  = Power(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet buildPower e = Power e;;\n","type":"","out":""},{"in":"let buildKellysOp(a,b,a_more)      = KellysOp(a,b,a_more)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet buildKellysOp (a,b,a_more) = KellysOp (a, b, a_more);;\n","type":"","out":""},{"in":"let pi = 4.0 *. atan 1.0","min":"\nlet pi = 4.0 *. (atan 1.0);;\n","type":"","out":""},{"in":"let rec eval (e,x,y) = \nmatch e with \nVarX -> x\n| VarY -> y\n| Sine (e) -> sin(pi*.eval (e,x,y))\n| Cosine (e) -> cos(pi*. eval (e,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y))/.2.0)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (a,b,a_less,b_less) -> if (eval (a,x,y)<eval(b,x,y)) then eval(a_less,x,y) else eval(b_less,x,y)\n| Power (e) -> eval(e,x,y) *. eval(e,x,y)\n| KellysOp (a,b,a_more) -> if (eval(a,x,y)>eval(b,x,y)) then eval (a_more,x,y) else 0.0","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Power e -> (eval (e, x, y)) *. (eval (e, x, y))\n  | KellysOp (a,b,a_more) ->\n      if (eval (a, x, y)) > (eval (b, x, y))\n      then eval (a_more, x, y)\n      else 0.0;;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Power e -> (eval (e, x, y)) *. (eval (e, x, y))\n  | KellysOp (a,b,a_more) ->\n      if (eval (a, x, y)) > (eval (b, x, y))\n      then eval (a_more, x, y)\n      else 0.0;;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.5, (-0.5));;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Power e -> (eval (e, x, y)) *. (eval (e, x, y))\n  | KellysOp (a,b,a_more) ->\n      if (eval (a, x, y)) > (eval (b, x, y))\n      then eval (a_more, x, y)\n      else 0.0;;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.3, 0.3);;\n","type":"","out":""},{"in":"let _ = eval (sampleExpr1,0.5,0.2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Power e -> (eval (e, x, y)) *. (eval (e, x, y))\n  | KellysOp (a,b,a_more) ->\n      if (eval (a, x, y)) > (eval (b, x, y))\n      then eval (a_more, x, y)\n      else 0.0;;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet _ = eval (sampleExpr1, 0.5, 0.2);;\n","type":"","out":""},{"in":"let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Power e -> (eval (e, x, y)) *. (eval (e, x, y))\n  | KellysOp (a,b,a_more) ->\n      if (eval (a, x, y)) > (eval (b, x, y))\n      then eval (a_more, x, y)\n      else 0.0;;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n","type":"","out":""},{"in":"let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n","type":"","out":""},{"in":"let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr2 =\n  buildThresh\n    ((buildX ()), (buildY ()), (buildSine (buildX ())),\n      (buildCosine (buildY ())));;\n","type":"","out":""},{"in":"let rec build (rand, depth) = \nif (depth = 0)\nthen let z = rand (0,1) in \nmatch z with \n0 -> buildX()\n| 1 -> buildY()\nelse\nlet z = rand (2,8) in\nmatch z with \n2 -> buildSine(build (rand, depth-1))\n| 3 -> buildCosine(build (rand, depth-1))\n| 4 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 5 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 6 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| 7 -> buildPower(build(rand, depth-1))\n| 8 -> buildKellysOp(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildKellysOp (a,b,a_more) = KellysOp (a, b, a_more);;\n\nlet buildPower e = Power e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let z = rand (0, 1) in match z with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let z = rand (2, 8) in\n     match z with\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7 -> buildPower (build (rand, (depth - 1)))\n     | 8 ->\n         buildKellysOp\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n","type":"","out":""},{"in":"let g1 () = (7,1,90)","min":"\nlet g1 () = (7, 1, 90);;\n","type":"","out":""},{"in":"let g2 () = (6,14,33)","min":"\nlet g2 () = (6, 14, 33);;\n","type":"","out":""},{"in":"let g3 () = (5,7,200)","min":"\nlet g3 () = (5, 7, 200);;\n","type":"","out":""},{"in":"let c1 () = (4,33,99)","min":"\nlet c1 () = (4, 33, 99);;\n","type":"","out":""},{"in":"let c2 () = (8,13,99)","min":"\nlet c2 () = (8, 13, 99);;\n","type":"","out":""},{"in":"let c3 () = (5,11,107)","min":"\nlet c3 () = (5, 11, 107);;\n","type":"","out":""},{"in":"let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))","min":"\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n","type":"","out":""},{"in":"let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))","min":"\nlet rec rseq g r n = if n <= 0 then [] else (g r) :: (rseq g r (n - 1));;\n","type":"","out":""},{"in":"let toReal (i,n) = (float_of_int i) /. (float_of_int n)","min":"\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n","type":"","out":""},{"in":"let toIntensity z = int_of_float (127.5 +. (127.5 *. z))","min":"\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n","type":"","out":""},{"in":"let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n","type":"","out":""},{"in":"let emitGrayscale (f,n,name) =\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet z = f (x,y) in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet iz = toIntensity(z) in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n","type":"","out":""},{"in":"let doRandomGray (depth,seed1,seed2) =\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet g = makeRand(seed1,seed2) in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(*XXXXXXXXXXXXXXXXXX*)\nlet n = 150 in\n(*XXXXXXXXXXXXXXXXXX*)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Power e -> (eval (e, x, y)) *. (eval (e, x, y))\n  | KellysOp (a,b,a_more) ->\n      if (eval (a, x, y)) > (eval (b, x, y))\n      then eval (a_more, x, y)\n      else 0.0;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildKellysOp (a,b,a_more) = KellysOp (a, b, a_more);;\n\nlet buildPower e = Power e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let z = rand (0, 1) in match z with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let z = rand (2, 8) in\n     match z with\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7 -> buildPower (build (rand, (depth - 1)))\n     | 8 ->\n         buildKellysOp\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e2 -> \"cos(pi*\" ^ ((exprToString e2) ^ \")\")\n  | Average (e3,e4) ->\n      \"((\" ^ ((exprToString e3) ^ (\"+\" ^ ((exprToString e4) ^ \")/2)\")))\n  | Times (e5,e6) -> (exprToString e5) ^ (\"*\" ^ (exprToString e6))\n  | Thresh (e7,e8,e9,e10) ->\n      \"(\" ^\n        ((exprToString e7) ^\n           (\"<\" ^\n              ((exprToString e8) ^\n                 (\"?\" ^\n                    ((exprToString e9) ^ (\":\" ^ ((exprToString e10) ^ \")\")))))))\n  | Power e11 -> \"((\" ^ ((exprToString e11) ^ \")^2)\")\n  | KellysOp (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\">\" ^ ((exprToString e2) ^ (\"?\" ^ ((exprToString e3) ^ \":0.0\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n","type":"","out":""},{"in":"let emitColor (f1,f2,f3,n,name) =\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n","type":"","out":""},{"in":"let doRandomColor (depth,seed1,seed2) =\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet g = makeRand (seed1,seed2) in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(*XXXXXXXXXXXXXXXXXX*)\nlet n = 150 in\n(*XXXXXXXXXXXXXXXXXX*)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Power e -> (eval (e, x, y)) *. (eval (e, x, y))\n  | KellysOp (a,b,a_more) ->\n      if (eval (a, x, y)) > (eval (b, x, y))\n      then eval (a_more, x, y)\n      else 0.0;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildKellysOp (a,b,a_more) = KellysOp (a, b, a_more);;\n\nlet buildPower e = Power e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let z = rand (0, 1) in match z with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let z = rand (2, 8) in\n     match z with\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7 -> buildPower (build (rand, (depth - 1)))\n     | 8 ->\n         buildKellysOp\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e2 -> \"cos(pi*\" ^ ((exprToString e2) ^ \")\")\n  | Average (e3,e4) ->\n      \"((\" ^ ((exprToString e3) ^ (\"+\" ^ ((exprToString e4) ^ \")/2)\")))\n  | Times (e5,e6) -> (exprToString e5) ^ (\"*\" ^ (exprToString e6))\n  | Thresh (e7,e8,e9,e10) ->\n      \"(\" ^\n        ((exprToString e7) ^\n           (\"<\" ^\n              ((exprToString e8) ^\n                 (\"?\" ^\n                    ((exprToString e9) ^ (\":\" ^ ((exprToString e10) ^ \")\")))))))\n  | Power e11 -> \"((\" ^ ((exprToString e11) ^ \")^2)\")\n  | KellysOp (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\">\" ^ ((exprToString e2) ^ (\"?\" ^ ((exprToString e3) ^ \":0.0\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130 = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n","type":"","out":""},{"in":"let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","min":"\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n","type":"","out":""},{"in":"let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n\nlet drop_paren s =\n  implode\n    (List.filter (fun c  -> not (List.mem c ['('; ' '; ')'])) (explode s));;\n","type":"","out":""},{"in":"let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","min":"\nlet eq_real p (r1,r2) = ((r1 -. r2) < p) || ((r2 -. r1) < p);;\n","type":"","out":""},{"in":"let scoreMsg () = \nFormat.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":17029},"type":"eval"},"cursor":3891,"time":1.39831525119476e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) =\n  match l with\n      [] -> d\n    |front::back ->\n        match front with\n            (x,y) ->\n              if (x=k)\n              then y\n              else assoc (d,k,back)\n;; \n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' =  \n            if (List.mem h seen = true) \n            then []@seen\n            else [h]@seen\n          in\n          let rest' = t in \n            \t  helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n;;\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  match f b with\n      (x,y) -> if (y=true) then wwhile (f,x) else x\n;;\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = wwhile ((let g x = let b'=f(x) in (b',b'!=x) in (g)),b);;\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n    | Power    of expr\n    | KellysOp of expr * expr * expr \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = \n  match e with\n      VarX -> \"x\"\n    | VarY -> \"y\"\n    | Sine e1 -> \"sin(pi*\"^exprToString e1^\")\"\n    | Cosine e2 -> \"cos(pi*\"^exprToString e2^\")\"\n    | Average (e3,e4) -> \"((\"^exprToString e3^\"+\"^exprToString e4^\")/2)\"\n    | Times (e5,e6) -> exprToString e5^\"*\"^exprToString e6\n    | Thresh (e7,e8,e9,e10) -> \"(\"^exprToString e7^\"<\"^exprToString e8^\"?\"^exprToString e9^\":\"^exprToString e10^\")\"\n    | Power (e11) -> \"((\"^exprToString e11^\")^2)\"\n    | KellysOp (e1,e2,e3) -> \"(\"^exprToString e1^\">\"^exprToString e2^\"?\"^exprToString e3^\":0.0\"\n;;\n\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\nlet _ = exprToString sampleExpr1 ;;\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\nlet buildPower(e)                  = Power(e)\nlet buildKellysOp(a,b,a_more)      = KellysOp(a,b,a_more)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = \n  match e with \n      VarX -> x\n    | VarY -> y\n    | Sine (e) -> sin(pi*.eval (e,x,y))\n    | Cosine (e) -> cos(pi*. eval (e,x,y))\n    | Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y))/.2.0)\n    | Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y)\n    | Thresh (a,b,a_less,b_less) -> if (eval (a,x,y)<eval(b,x,y)) then eval(a_less,x,y) else eval(b_less,x,y)\n    | Power (e) -> eval(e,x,y) *. eval(e,x,y)\n    | KellysOp (a,b,a_more) -> if (eval(a,x,y)>eval(b,x,y)) then eval (a_more,x,y) else 0.0\n;;\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr1,0.5,0.2);;\n\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  if (depth = 0)\n  then let z = rand (0,1) in \n      match z with \n          0 -> buildX()\n        | 1 -> buildY()\n  else\n    let z = rand (2,8) in\n      match z with \n          2 -> buildSine(build (rand, depth-1))\n        | 3 -> buildCosine(build (rand, depth-1))\n        | 4 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n        | 5 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n        | 6 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n        | 7 -> buildPower(build(rand, depth-1))\n        | 8 -> buildKellysOp(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = (7,1,90)\nlet g2 () = (6,14,33)\nlet g3 () = (5,7,200) \n\nlet c1 () = (4,33,99)\nlet c2 () = (8,13,99)\nlet c3 () = (5,11,107)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 \tfixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec assoc (d,k,l) =\nmatch l with\n[] -> d\n|front::back ->\nmatch front with\n(x,y) ->\nif (x=k)\nthen y\nelse assoc (d,k,back)","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | front::back ->\n      (match front with | (x,y) -> if x = k then y else assoc (d, k, back));;\n","type":"","out":""},{"in":"let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | front::back ->\n      (match front with | (x,y) -> if x = k then y else assoc (d, k, back));;\n\nlet _ =\n  assoc ((-1), \"william\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n","type":"","out":""},{"in":"let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | front::back ->\n      (match front with | (x,y) -> if x = k then y else assoc (d, k, back));;\n\nlet _ = assoc ((-1), \"bob\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n","type":"","out":""},{"in":"let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' =  \nif (List.mem h seen = true) \nthen []@seen\nelse [h]@seen\nin\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))","min":"\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' =\n          if (List.mem h seen) = true then [] @ seen else [h] @ seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n","type":"","out":""},{"in":"let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]","min":"\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' =\n          if (List.mem h seen) = true then [] @ seen else [h] @ seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ = removeDuplicates [1; 6; 2; 4; 12; 2; 13; 6; 9];;\n","type":"","out":""},{"in":"let rec wwhile (f,b) = \nmatch f b with\n(x,y) -> if (y=true) then wwhile (f,x) else x","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n","type":"","out":""},{"in":"let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n","type":"","out":""},{"in":"let fixpoint (f,b) = wwhile ((let g x = let b'=f(x) in (b',b'!=x) in (g)),b)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n","type":"","out":""},{"in":"let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n","type":"","out":""},{"in":"let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1","min":"\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 1)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n\nlet _ = fixpoint (collatz, 1);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 3)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n\nlet _ = fixpoint (collatz, 3);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 48)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n\nlet _ = fixpoint (collatz, 48);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 107)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n\nlet _ = fixpoint (collatz, 107);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 9001)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n\nlet _ = fixpoint (collatz, 9001);;\n","type":"","out":""},{"in":"type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Power    of expr\n| KellysOp of expr * expr * expr * expr","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr* expr;;\n","type":"","out":""},{"in":"let rec exprToString e = \nmatch e with\nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine e1 -> \"sin(pi*\"^exprToString e1^\")\"\n| Cosine e2 -> \"cos(pi*\"^exprToString e2^\")\"\n| Average (e3,e4) -> \"((\"^exprToString e3^\"+\"^exprToString e4^\")/2)\"\n| Times (e5,e6) -> exprToString e5^\"*\"^exprToString e6\n| Thresh (e7,e8,e9,e10) -> \"(\"^exprToString e7^\"<\"^exprToString e8^\"?\"^exprToString e9^\":\"^exprToString e10^\")\"\n| Power (e11) -> \"((\"^exprToString e11^\")^2)\"\n| KellysOp (e1,e2,e3) -> \"(\"^exprToString e1^\">\"^exprToString e2^\"?\"^exprToString e3^\":0.0\"","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e2 -> \"cos(pi*\" ^ ((exprToString e2) ^ \")\")\n  | Average (e3,e4) ->\n      \"((\" ^ ((exprToString e3) ^ (\"+\" ^ ((exprToString e4) ^ \")/2)\")))\n  | Times (e5,e6) -> (exprToString e5) ^ (\"*\" ^ (exprToString e6))\n  | Thresh (e7,e8,e9,e10) ->\n      \"(\" ^\n        ((exprToString e7) ^\n           (\"<\" ^\n              ((exprToString e8) ^\n                 (\"?\" ^\n                    ((exprToString e9) ^ (\":\" ^ ((exprToString e10) ^ \")\")))))))\n  | Power e11 -> \"((\" ^ ((exprToString e11) ^ \")^2)\")\n  | KellysOp (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\">\" ^ ((exprToString e2) ^ (\"?\" ^ ((exprToString e3) ^ \":0.0\")))));;\n","type":"type","out":"Characters 437-456:\n  | KellysOp (e1,e2,e3) -> \"(\"^exprToString e1^\">\"^exprToString e2^\"?\"^exprToString e3^\":0.0\";;\n    ^^^^^^^^^^^^^^^^^^^\nError: The constructor KellysOp expects 4 argument(s),\n       but is applied here to 3 argument(s)\n"},{"in":"let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr* expr;;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n","type":"","out":""},{"in":"let _ = exprToString sampleExpr1","min":"","type":"type","out":"NO ERROR FROM MINIMAL PROGRAM!!!\nCharacters 21-32:\n  let _ = exprToString sampleExpr1;;\n                       ^^^^^^^^^^^\nError: This expression has type expr/3278\n       but an expression was expected of type expr/3049\n"},{"in":"let buildX()                       = VarX","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n","type":"","out":""},{"in":"let buildY()                       = VarY","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr* expr;;\n\nlet buildY () = VarY;;\n","type":"","out":""},{"in":"let buildSine(e)                   = Sine(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n","type":"","out":""},{"in":"let buildCosine(e)                 = Cosine(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n","type":"","out":""},{"in":"let buildAverage(e1,e2)            = Average(e1,e2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n","type":"","out":""},{"in":"let buildTimes(e1,e2)              = Times(e1,e2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr* expr;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n","type":"","out":""},{"in":"let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr* expr;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n","type":"","out":""},{"in":"let pi = 4.0 *. atan 1.0","min":"\nlet pi = 4.0 *. (atan 1.0);;\n","type":"","out":""},{"in":"let rec eval (e,x,y) = \nmatch e with \nVarX -> x\n| VarY -> y\n| Sine (e) -> sin(pi*.eval (e,x,y))\n| Cosine (e) -> cos(pi*. eval (e,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y))/.2.0)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (a,b,a_less,b_less) -> if (eval (a,x,y)<eval(b,x,y)) then eval(a_less,x,y) else eval(b_less,x,y)\n| Power (e) -> eval(e,x,y) *. eval(e,x,y)\n| KellysOp (a,b,a_more) -> if (eval(a,x,y)>eval(b,x,y)) then eval (a_more,x,y) else 0.0","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Power e -> (eval (e, x, y)) *. (eval (e, x, y))\n  | KellysOp (a,b,a_more) ->\n      if (eval (a, x, y)) > (eval (b, x, y))\n      then eval (a_more, x, y)\n      else 0.0;;\n","type":"type","out":"Characters 396-417:\n  | KellysOp (a,b,a_more) -> if (eval(a,x,y)>eval(b,x,y)) then eval (a_more,x,y) else 0.0;;\n    ^^^^^^^^^^^^^^^^^^^^^\nError: The constructor KellysOp expects 4 argument(s),\n       but is applied here to 3 argument(s)\n"},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Power e -> (eval (e, x, y)) *. (eval (e, x, y))\n  | KellysOp (a,b,a_more) ->\n      if (eval (a, x, y)) > (eval (b, x, y))\n      then eval (a_more, x, y)\n      else 0.0;;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.5, (-0.5));;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Power e -> (eval (e, x, y)) *. (eval (e, x, y))\n  | KellysOp (a,b,a_more) ->\n      if (eval (a, x, y)) > (eval (b, x, y))\n      then eval (a_more, x, y)\n      else 0.0;;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.3, 0.3);;\n","type":"","out":""},{"in":"let _ = eval (sampleExpr1,0.5,0.2)","min":"","type":"type","out":"NO ERROR FROM MINIMAL PROGRAM!!!\nCharacters 14-25:\n  let _ = eval (sampleExpr1,0.5,0.2);;\n                ^^^^^^^^^^^\nError: This expression has type expr/3278\n       but an expression was expected of type expr/3049\n"},{"in":"let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Power e -> (eval (e, x, y)) *. (eval (e, x, y))\n  | KellysOp (a,b,a_more) ->\n      if (eval (a, x, y)) > (eval (b, x, y))\n      then eval (a_more, x, y)\n      else 0.0;;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n","type":"","out":""},{"in":"let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n","type":"","out":""},{"in":"let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr2 =\n  buildThresh\n    ((buildX ()), (buildY ()), (buildSine (buildX ())),\n      (buildCosine (buildY ())));;\n","type":"","out":""},{"in":"let rec build (rand, depth) = \nif (depth = 0)\nthen let z = rand (0,1) in \nmatch z with \n0 -> buildX()\n| 1 -> buildY()\nelse\nlet z = rand (2,6) in\nmatch z with \n2 -> buildSine(build (rand, depth-1))\n| 3 -> buildCosine(build (rand, depth-1))\n| 4 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 5 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 6 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let z = rand (0, 1) in match z with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let z = rand (2, 6) in\n     match z with\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n","type":"","out":""},{"in":"let g1 () = (7,1,90)","min":"\nlet g1 () = (7, 1, 90);;\n","type":"","out":""},{"in":"let g2 () = (6,14,33)","min":"\nlet g2 () = (6, 14, 33);;\n","type":"","out":""},{"in":"let g3 () = (5,7,200)","min":"\nlet g3 () = (5, 7, 200);;\n","type":"","out":""},{"in":"let c1 () = (4,33,99)","min":"\nlet c1 () = (4, 33, 99);;\n","type":"","out":""},{"in":"let c2 () = (8,13,99)","min":"\nlet c2 () = (8, 13, 99);;\n","type":"","out":""},{"in":"let c3 () = (5,11,107)","min":"\nlet c3 () = (5, 11, 107);;\n","type":"","out":""},{"in":"let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))","min":"\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n","type":"","out":""},{"in":"let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))","min":"\nlet rec rseq g r n = if n <= 0 then [] else (g r) :: (rseq g r (n - 1));;\n","type":"","out":""},{"in":"let toReal (i,n) = (float_of_int i) /. (float_of_int n)","min":"\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n","type":"","out":""},{"in":"let toIntensity z = int_of_float (127.5 +. (127.5 *. z))","min":"\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n","type":"","out":""},{"in":"let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n","type":"","out":""},{"in":"let emitGrayscale (f,n,name) =\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet z = f (x,y) in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet iz = toIntensity(z) in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n","type":"","out":""},{"in":"let doRandomGray (depth,seed1,seed2) =\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet g = makeRand(seed1,seed2) in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(*XXXXXXXXXXXXXXXXXX*)\nlet n = 150 in\n(*XXXXXXXXXXXXXXXXXX*)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)","min":"","type":"type","out":"Error: This expression has type expr/3278\n       but an expression was expected of type expr/3049\nError: The constructor KellysOp expects 4 argument(s),\n       but is applied here to 3 argument(s)\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 136-137:\n  let _ = print_string (exprToString e) in\n                                     ^\nError: This expression has type expr/3278\n       but an expression was expected of type expr/3049\n"},{"in":"let emitColor (f1,f2,f3,n,name) =\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n","type":"","out":""},{"in":"let doRandomColor (depth,seed1,seed2) =\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet g = makeRand (seed1,seed2) in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(*XXXXXXXXXXXXXXXXXX*)\nlet n = 150 in\n(*XXXXXXXXXXXXXXXXXX*)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)","min":"","type":"type","out":"Error: This expression has type expr/3278\n       but an expression was expected of type expr/3049\nError: The constructor KellysOp expects 4 argument(s),\n       but is applied here to 3 argument(s)\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 216-218:\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n                                                      ^^\nError: This expression has type expr/3278\n       but an expression was expected of type expr/3049\n"},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130 = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n","type":"","out":""},{"in":"let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","min":"\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n","type":"","out":""},{"in":"let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n\nlet drop_paren s =\n  implode\n    (List.filter (fun c  -> not (List.mem c ['('; ' '; ')'])) (explode s));;\n","type":"","out":""},{"in":"let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","min":"\nlet eq_real p (r1,r2) = ((r1 -. r2) < p) || ((r2 -. r1) < p);;\n","type":"","out":""},{"in":"let scoreMsg () = \nFormat.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":16796},"type":"eval"},"cursor":0,"time":1.398315366352611e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) =\n  match l with\n      [] -> d\n    |front::back ->\n        match front with\n            (x,y) ->\n              if (x=k)\n              then y\n              else assoc (d,k,back)\n;; \n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' =  \n            if (List.mem h seen = true) \n            then []@seen\n            else [h]@seen\n          in\n          let rest' = t in \n            helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n;;\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  match f b with\n      (x,y) -> if (y=true) then wwhile (f,x) else x\n;;\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = wwhile ((let g x = let b'=f(x) in (b',b'!=x) in (g)),b);;\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n    | Power    of expr\n    | KellysOp of expr * expr * expr * expr\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = \n  match e with\n      VarX -> \"x\"\n    | VarY -> \"y\"\n    | Sine e1 -> \"sin(pi*\"^exprToString e1^\")\"\n    | Cosine e2 -> \"cos(pi*\"^exprToString e2^\")\"\n    | Average (e3,e4) -> \"((\"^exprToString e3^\"+\"^exprToString e4^\")/2)\"\n    | Times (e5,e6) -> exprToString e5^\"*\"^exprToString e6\n    | Thresh (e7,e8,e9,e10) -> \"(\"^exprToString e7^\"<\"^exprToString e8^\"?\"^exprToString e9^\":\"^exprToString e10^\")\"\n    | Power (e11) -> \"((\"^exprToString e11^\")^2)\"\n    | KellysOp (e1,e2,e3) -> \"(\"^exprToString e1^\">\"^exprToString e2^\"?\"^exprToString e3^\":0.0\"\n;;\n\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\nlet _ = exprToString sampleExpr1 ;;\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = \n  match e with \n      VarX -> x\n    | VarY -> y\n    | Sine (e) -> sin(pi*.eval (e,x,y))\n    | Cosine (e) -> cos(pi*. eval (e,x,y))\n    | Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y))/.2.0)\n    | Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y)\n    | Thresh (a,b,a_less,b_less) -> if (eval (a,x,y)<eval(b,x,y)) then eval(a_less,x,y) else eval(b_less,x,y)\n    | Power (e) -> eval(e,x,y) *. eval(e,x,y)\n    | KellysOp (a,b,a_more) -> if (eval(a,x,y)>eval(b,x,y)) then eval (a_more,x,y) else 0.0\n;;\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr1,0.5,0.2);;\n\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  if (depth = 0)\n  then let z = rand (0,1) in \n      match z with \n          0 -> buildX()\n        | 1 -> buildY()\n  else\n    let z = rand (2,6) in\n      match z with \n          2 -> buildSine(build (rand, depth-1))\n        | 3 -> buildCosine(build (rand, depth-1))\n        | 4 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n        | 5 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n        | 6 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = (7,1,90)\nlet g2 () = (6,14,33)\nlet g3 () = (5,7,200) \n\nlet c1 () = (4,33,99)\nlet c2 () = (8,13,99)\nlet c3 () = (5,11,107)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 fixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec assoc (d,k,l) =\nmatch l with\n[] -> d\n|front::back ->\nmatch front with\n(x,y) ->\nif (x=k)\nthen y\nelse assoc (d,k,back)","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | front::back ->\n      (match front with | (x,y) -> if x = k then y else assoc (d, k, back));;\n","type":"","out":""},{"in":"let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | front::back ->\n      (match front with | (x,y) -> if x = k then y else assoc (d, k, back));;\n\nlet _ =\n  assoc ((-1), \"william\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n","type":"","out":""},{"in":"let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | front::back ->\n      (match front with | (x,y) -> if x = k then y else assoc (d, k, back));;\n\nlet _ = assoc ((-1), \"bob\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n","type":"","out":""},{"in":"let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' =  \nif (List.mem h seen = true) \nthen []@seen\nelse [h]@seen\nin\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))","min":"\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' =\n          if (List.mem h seen) = true then [] @ seen else [h] @ seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n","type":"","out":""},{"in":"let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]","min":"\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' =\n          if (List.mem h seen) = true then [] @ seen else [h] @ seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ = removeDuplicates [1; 6; 2; 4; 12; 2; 13; 6; 9];;\n","type":"","out":""},{"in":"let rec wwhile (f,b) = \nmatch f b with\n(x,y) -> if (y=true) then wwhile (f,x) else x","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n","type":"","out":""},{"in":"let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n","type":"","out":""},{"in":"let fixpoint (f,b) = wwhile ((let g x = let b'=f(x) in (b',b'!=x) in (g)),b)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n","type":"","out":""},{"in":"let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n","type":"","out":""},{"in":"let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1","min":"\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 1)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n\nlet _ = fixpoint (collatz, 1);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 3)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n\nlet _ = fixpoint (collatz, 3);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 48)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n\nlet _ = fixpoint (collatz, 48);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 107)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n\nlet _ = fixpoint (collatz, 107);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 9001)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n\nlet _ = fixpoint (collatz, 9001);;\n","type":"","out":""},{"in":"type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Power    of expr\n| KellysOp of expr * expr * expr","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n","type":"","out":""},{"in":"let rec exprToString e = \nmatch e with\nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine e1 -> \"sin(pi*\"^exprToString e1^\")\"\n| Cosine e2 -> \"cos(pi*\"^exprToString e2^\")\"\n| Average (e3,e4) -> \"((\"^exprToString e3^\"+\"^exprToString e4^\")/2)\"\n| Times (e5,e6) -> exprToString e5^\"*\"^exprToString e6\n| Thresh (e7,e8,e9,e10) -> \"(\"^exprToString e7^\"<\"^exprToString e8^\"?\"^exprToString e9^\":\"^exprToString e10^\")\"\n| Power (e11) -> \"((\"^exprToString e11^\")^2)\"\n| KellysOp (e1,e2,e3) -> \"(\"^exprToString e1^\">\"^exprToString e2^\"?\"^exprToString e3^\":0.0\"","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e2 -> \"cos(pi*\" ^ ((exprToString e2) ^ \")\")\n  | Average (e3,e4) ->\n      \"((\" ^ ((exprToString e3) ^ (\"+\" ^ ((exprToString e4) ^ \")/2)\")))\n  | Times (e5,e6) -> (exprToString e5) ^ (\"*\" ^ (exprToString e6))\n  | Thresh (e7,e8,e9,e10) ->\n      \"(\" ^\n        ((exprToString e7) ^\n           (\"<\" ^\n              ((exprToString e8) ^\n                 (\"?\" ^\n                    ((exprToString e9) ^ (\":\" ^ ((exprToString e10) ^ \")\")))))))\n  | Power e11 -> \"((\" ^ ((exprToString e11) ^ \")^2)\")\n  | KellysOp (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\">\" ^ ((exprToString e2) ^ (\"?\" ^ ((exprToString e3) ^ \":0.0\")))));;\n","type":"","out":""},{"in":"let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n","type":"","out":""},{"in":"let _ = exprToString sampleExpr1","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e2 -> \"cos(pi*\" ^ ((exprToString e2) ^ \")\")\n  | Average (e3,e4) ->\n      \"((\" ^ ((exprToString e3) ^ (\"+\" ^ ((exprToString e4) ^ \")/2)\")))\n  | Times (e5,e6) -> (exprToString e5) ^ (\"*\" ^ (exprToString e6))\n  | Thresh (e7,e8,e9,e10) ->\n      \"(\" ^\n        ((exprToString e7) ^\n           (\"<\" ^\n              ((exprToString e8) ^\n                 (\"?\" ^\n                    ((exprToString e9) ^ (\":\" ^ ((exprToString e10) ^ \")\")))))))\n  | Power e11 -> \"((\" ^ ((exprToString e11) ^ \")^2)\")\n  | KellysOp (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\">\" ^ ((exprToString e2) ^ (\"?\" ^ ((exprToString e3) ^ \":0.0\")))));;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet _ = exprToString sampleExpr1;;\n","type":"","out":""},{"in":"let buildX()                       = VarX","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet buildX () = VarX;;\n","type":"","out":""},{"in":"let buildY()                       = VarY","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet buildY () = VarY;;\n","type":"","out":""},{"in":"let buildSine(e)                   = Sine(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n","type":"","out":""},{"in":"let buildCosine(e)                 = Cosine(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n","type":"","out":""},{"in":"let buildAverage(e1,e2)            = Average(e1,e2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n","type":"","out":""},{"in":"let buildTimes(e1,e2)              = Times(e1,e2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n","type":"","out":""},{"in":"let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n","type":"","out":""},{"in":"let buildPower(e)                  = Power(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet buildPower e = Power e;;\n","type":"","out":""},{"in":"let buildKellysOp(a,b,a_more)      = KellysOp(a,b,a_more)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet buildKellysOp (a,b,a_more) = KellysOp (a, b, a_more);;\n","type":"","out":""},{"in":"let pi = 4.0 *. atan 1.0","min":"\nlet pi = 4.0 *. (atan 1.0);;\n","type":"","out":""},{"in":"let rec eval (e,x,y) = \nmatch e with \nVarX -> x\n| VarY -> y\n| Sine (e) -> sin(pi*.eval (e,x,y))\n| Cosine (e) -> cos(pi*. eval (e,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y))/.2.0)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (a,b,a_less,b_less) -> if (eval (a,x,y)<eval(b,x,y)) then eval(a_less,x,y) else eval(b_less,x,y)\n| Power (e) -> eval(e,x,y) *. eval(e,x,y)\n| KellysOp (a,b,a_more) -> if (eval(a,x,y)>eval(b,x,y)) then eval (a_more,x,y) else 0.0","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Power e -> (eval (e, x, y)) *. (eval (e, x, y))\n  | KellysOp (a,b,a_more) ->\n      if (eval (a, x, y)) > (eval (b, x, y))\n      then eval (a_more, x, y)\n      else 0.0;;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Power e -> (eval (e, x, y)) *. (eval (e, x, y))\n  | KellysOp (a,b,a_more) ->\n      if (eval (a, x, y)) > (eval (b, x, y))\n      then eval (a_more, x, y)\n      else 0.0;;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.5, (-0.5));;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Power e -> (eval (e, x, y)) *. (eval (e, x, y))\n  | KellysOp (a,b,a_more) ->\n      if (eval (a, x, y)) > (eval (b, x, y))\n      then eval (a_more, x, y)\n      else 0.0;;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.3, 0.3);;\n","type":"","out":""},{"in":"let _ = eval (sampleExpr1,0.5,0.2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Power e -> (eval (e, x, y)) *. (eval (e, x, y))\n  | KellysOp (a,b,a_more) ->\n      if (eval (a, x, y)) > (eval (b, x, y))\n      then eval (a_more, x, y)\n      else 0.0;;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet _ = eval (sampleExpr1, 0.5, 0.2);;\n","type":"","out":""},{"in":"let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Power e -> (eval (e, x, y)) *. (eval (e, x, y))\n  | KellysOp (a,b,a_more) ->\n      if (eval (a, x, y)) > (eval (b, x, y))\n      then eval (a_more, x, y)\n      else 0.0;;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n","type":"","out":""},{"in":"let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n","type":"","out":""},{"in":"let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr2 =\n  buildThresh\n    ((buildX ()), (buildY ()), (buildSine (buildX ())),\n      (buildCosine (buildY ())));;\n","type":"","out":""},{"in":"let rec build (rand, depth) = \nif (depth = 0)\nthen let z = rand (0,1) in \nmatch z with \n0 -> buildX()\n| 1 -> buildY()\nelse\nlet z = rand (2,8) in\nmatch z with \n2 -> buildSine(build (rand, depth-1))\n| 3 -> buildCosine(build (rand, depth-1))\n| 4 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 5 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 6 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| 7 -> buildPower(build(rand, depth-1))\n| 8 -> buildKellysOp(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildKellysOp (a,b,a_more) = KellysOp (a, b, a_more);;\n\nlet buildPower e = Power e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let z = rand (0, 1) in match z with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let z = rand (2, 8) in\n     match z with\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7 -> buildPower (build (rand, (depth - 1)))\n     | 8 ->\n         buildKellysOp\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n","type":"","out":""},{"in":"let g1 () = (7,1,90)","min":"\nlet g1 () = (7, 1, 90);;\n","type":"","out":""},{"in":"let g2 () = (6,14,33)","min":"\nlet g2 () = (6, 14, 33);;\n","type":"","out":""},{"in":"let g3 () = (5,7,200)","min":"\nlet g3 () = (5, 7, 200);;\n","type":"","out":""},{"in":"let c1 () = (4,33,99)","min":"\nlet c1 () = (4, 33, 99);;\n","type":"","out":""},{"in":"let c2 () = (8,13,99)","min":"\nlet c2 () = (8, 13, 99);;\n","type":"","out":""},{"in":"let c3 () = (5,11,107)","min":"\nlet c3 () = (5, 11, 107);;\n","type":"","out":""},{"in":"let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))","min":"\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n","type":"","out":""},{"in":"let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))","min":"\nlet rec rseq g r n = if n <= 0 then [] else (g r) :: (rseq g r (n - 1));;\n","type":"","out":""},{"in":"let toReal (i,n) = (float_of_int i) /. (float_of_int n)","min":"\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n","type":"","out":""},{"in":"let toIntensity z = int_of_float (127.5 +. (127.5 *. z))","min":"\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n","type":"","out":""},{"in":"let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n","type":"","out":""},{"in":"let emitGrayscale (f,n,name) =\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet z = f (x,y) in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet iz = toIntensity(z) in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n","type":"","out":""},{"in":"let doRandomGray (depth,seed1,seed2) =\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet g = makeRand(seed1,seed2) in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(*XXXXXXXXXXXXXXXXXX*)\nlet n = 150 in\n(*XXXXXXXXXXXXXXXXXX*)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Power e -> (eval (e, x, y)) *. (eval (e, x, y))\n  | KellysOp (a,b,a_more) ->\n      if (eval (a, x, y)) > (eval (b, x, y))\n      then eval (a_more, x, y)\n      else 0.0;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildKellysOp (a,b,a_more) = KellysOp (a, b, a_more);;\n\nlet buildPower e = Power e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let z = rand (0, 1) in match z with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let z = rand (2, 8) in\n     match z with\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7 -> buildPower (build (rand, (depth - 1)))\n     | 8 ->\n         buildKellysOp\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e2 -> \"cos(pi*\" ^ ((exprToString e2) ^ \")\")\n  | Average (e3,e4) ->\n      \"((\" ^ ((exprToString e3) ^ (\"+\" ^ ((exprToString e4) ^ \")/2)\")))\n  | Times (e5,e6) -> (exprToString e5) ^ (\"*\" ^ (exprToString e6))\n  | Thresh (e7,e8,e9,e10) ->\n      \"(\" ^\n        ((exprToString e7) ^\n           (\"<\" ^\n              ((exprToString e8) ^\n                 (\"?\" ^\n                    ((exprToString e9) ^ (\":\" ^ ((exprToString e10) ^ \")\")))))))\n  | Power e11 -> \"((\" ^ ((exprToString e11) ^ \")^2)\")\n  | KellysOp (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\">\" ^ ((exprToString e2) ^ (\"?\" ^ ((exprToString e3) ^ \":0.0\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n","type":"","out":""},{"in":"let emitColor (f1,f2,f3,n,name) =\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n","type":"","out":""},{"in":"let doRandomColor (depth,seed1,seed2) =\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet g = makeRand (seed1,seed2) in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(*XXXXXXXXXXXXXXXXXX*)\nlet n = 150 in\n(*XXXXXXXXXXXXXXXXXX*)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Power e -> (eval (e, x, y)) *. (eval (e, x, y))\n  | KellysOp (a,b,a_more) ->\n      if (eval (a, x, y)) > (eval (b, x, y))\n      then eval (a_more, x, y)\n      else 0.0;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildKellysOp (a,b,a_more) = KellysOp (a, b, a_more);;\n\nlet buildPower e = Power e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let z = rand (0, 1) in match z with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let z = rand (2, 8) in\n     match z with\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7 -> buildPower (build (rand, (depth - 1)))\n     | 8 ->\n         buildKellysOp\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e2 -> \"cos(pi*\" ^ ((exprToString e2) ^ \")\")\n  | Average (e3,e4) ->\n      \"((\" ^ ((exprToString e3) ^ (\"+\" ^ ((exprToString e4) ^ \")/2)\")))\n  | Times (e5,e6) -> (exprToString e5) ^ (\"*\" ^ (exprToString e6))\n  | Thresh (e7,e8,e9,e10) ->\n      \"(\" ^\n        ((exprToString e7) ^\n           (\"<\" ^\n              ((exprToString e8) ^\n                 (\"?\" ^\n                    ((exprToString e9) ^ (\":\" ^ ((exprToString e10) ^ \")\")))))))\n  | Power e11 -> \"((\" ^ ((exprToString e11) ^ \")^2)\")\n  | KellysOp (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\">\" ^ ((exprToString e2) ^ (\"?\" ^ ((exprToString e3) ^ \":0.0\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130 = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n","type":"","out":""},{"in":"let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","min":"\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n","type":"","out":""},{"in":"let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n\nlet drop_paren s =\n  implode\n    (List.filter (fun c  -> not (List.mem c ['('; ' '; ')'])) (explode s));;\n","type":"","out":""},{"in":"let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","min":"\nlet eq_real p (r1,r2) = ((r1 -. r2) < p) || ((r2 -. r1) < p);;\n","type":"","out":""},{"in":"let scoreMsg () = \nFormat.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":17029},"type":"eval"},"cursor":6472,"time":1.39831555378693e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) =\n  match l with\n      [] -> d\n    |front::back ->\n        match front with\n            (x,y) ->\n              if (x=k)\n              then y\n              else assoc (d,k,back)\n;; \n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' =  \n            if (List.mem h seen = true) \n            then []@seen\n            else [h]@seen\n          in\n          let rest' = t in \n            \t  helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n;;\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  match f b with\n      (x,y) -> if (y=true) then wwhile (f,x) else x\n;;\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = wwhile ((let g x = let b'=f(x) in (b',b'!=x) in (g)),b);;\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n    | Power    of expr\n    | KellysOp of expr * expr * expr \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = \n  match e with\n      VarX -> \"x\"\n    | VarY -> \"y\"\n    | Sine e1 -> \"sin(pi*\"^exprToString e1^\")\"\n    | Cosine e2 -> \"cos(pi*\"^exprToString e2^\")\"\n    | Average (e3,e4) -> \"((\"^exprToString e3^\"+\"^exprToString e4^\")/2)\"\n    | Times (e5,e6) -> exprToString e5^\"*\"^exprToString e6\n    | Thresh (e7,e8,e9,e10) -> \"(\"^exprToString e7^\"<\"^exprToString e8^\"?\"^exprToString e9^\":\"^exprToString e10^\")\"\n    | Power (e11) -> \"((\"^exprToString e11^\")^2)\"\n    | KellysOp (e1,e2,e3) -> \"(\"^exprToString e1^\">\"^exprToString e2^\"?\"^exprToString e3^\":0.0\"\n;;\n\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\nlet _ = exprToString sampleExpr1 ;;\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\nlet buildPower(e)                  = Power(e)\nlet buildKellysOp(a,b,a_more)      = KellysOp(a,b,a_more)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = \n  match e with \n      VarX -> x\n    | VarY -> y\n    | Sine (e) -> sin(pi*.eval (e,x,y))\n    | Cosine (e) -> cos(pi*. eval (e,x,y))\n    | Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y))/.2.0)\n    | Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y)\n    | Thresh (a,b,a_less,b_less) -> if (eval (a,x,y)<eval(b,x,y)) then eval(a_less,x,y) else eval(b_less,x,y)\n    | Power (e) -> eval(e,x,y) *. eval(e,x,y)\n    | KellysOp (a,b,a_more) -> if (eval(a,x,y)>eval(b,x,y)) then eval (a_more,x,y) else 0.0\n;;\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr1,0.5,0.2);;\n\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  if (depth = 0)\n  then let z = rand (0,1) in \n      match z with \n          0 -> buildX()\n        | 1 -> buildY()\n  else\n    let z = rand (2,8) in\n      match z with \n          2 -> buildSine(build (rand, depth-1))\n        | 3 -> buildCosine(build (rand, depth-1))\n        | 4 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n        | 5 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n        | 6 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n        | 7 -> buildPower(build(rand, depth-1))\n        | 8 -> buildKellysOp(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = (7,1,90)\nlet g2 () = (6,14,33)\nlet g3 () = (5,7,200) \n\nlet c1 () = (4,33,99)\nlet c2 () = (8,13,99)\nlet c3 () = (5,11,107)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 \tfixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec assoc (d,k,l) =\nmatch l with\n[] -> d\n|front::back ->\nmatch front with\n(x,y) ->\nif (x=k)\nthen y\nelse assoc (d,k,back)","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | front::back ->\n      (match front with | (x,y) -> if x = k then y else assoc (d, k, back));;\n","type":"","out":""},{"in":"let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | front::back ->\n      (match front with | (x,y) -> if x = k then y else assoc (d, k, back));;\n\nlet _ =\n  assoc ((-1), \"william\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n","type":"","out":""},{"in":"let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | front::back ->\n      (match front with | (x,y) -> if x = k then y else assoc (d, k, back));;\n\nlet _ = assoc ((-1), \"bob\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n","type":"","out":""},{"in":"let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' =  \nif (List.mem h seen = true) \nthen []@seen\nelse [h]@seen\nin\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))","min":"\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' =\n          if (List.mem h seen) = true then [] @ seen else [h] @ seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n","type":"","out":""},{"in":"let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]","min":"\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' =\n          if (List.mem h seen) = true then [] @ seen else [h] @ seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ = removeDuplicates [1; 6; 2; 4; 12; 2; 13; 6; 9];;\n","type":"","out":""},{"in":"let rec wwhile (f,b) = \nmatch f b with\n(x,y) -> if (y=true) then wwhile (f,x) else x","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n","type":"","out":""},{"in":"let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n","type":"","out":""},{"in":"let fixpoint (f,b) = wwhile ((let g x = let b'=f(x) in (b',b'!=x) in (g)),b)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n","type":"","out":""},{"in":"let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n","type":"","out":""},{"in":"let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1","min":"\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 1)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n\nlet _ = fixpoint (collatz, 1);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 3)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n\nlet _ = fixpoint (collatz, 3);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 48)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n\nlet _ = fixpoint (collatz, 48);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 107)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n\nlet _ = fixpoint (collatz, 107);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 9001)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n\nlet _ = fixpoint (collatz, 9001);;\n","type":"","out":""},{"in":"type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Power    of expr\n| KellysOp of expr * expr * expr","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n","type":"","out":""},{"in":"let rec exprToString e = \nmatch e with\nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine e1 -> \"sin(pi*\"^exprToString e1^\")\"\n| Cosine e2 -> \"cos(pi*\"^exprToString e2^\")\"\n| Average (e3,e4) -> \"((\"^exprToString e3^\"+\"^exprToString e4^\")/2)\"\n| Times (e5,e6) -> exprToString e5^\"*\"^exprToString e6\n| Thresh (e7,e8,e9,e10) -> \"(\"^exprToString e7^\"<\"^exprToString e8^\"?\"^exprToString e9^\":\"^exprToString e10^\")\"\n| Power (e11) -> \"((\"^exprToString e11^\")^2)\"\n| KellysOp (e1,e2,e3) -> \"(\"^exprToString e1^\">\"^exprToString e2^\"?\"^exprToString e3^\":0.0\"","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e2 -> \"cos(pi*\" ^ ((exprToString e2) ^ \")\")\n  | Average (e3,e4) ->\n      \"((\" ^ ((exprToString e3) ^ (\"+\" ^ ((exprToString e4) ^ \")/2)\")))\n  | Times (e5,e6) -> (exprToString e5) ^ (\"*\" ^ (exprToString e6))\n  | Thresh (e7,e8,e9,e10) ->\n      \"(\" ^\n        ((exprToString e7) ^\n           (\"<\" ^\n              ((exprToString e8) ^\n                 (\"?\" ^\n                    ((exprToString e9) ^ (\":\" ^ ((exprToString e10) ^ \")\")))))))\n  | Power e11 -> \"((\" ^ ((exprToString e11) ^ \")^2)\")\n  | KellysOp (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\">\" ^ ((exprToString e2) ^ (\"?\" ^ ((exprToString e3) ^ \":0.0\")))));;\n","type":"","out":""},{"in":"let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n","type":"","out":""},{"in":"let _ = exprToString sampleExpr1","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e2 -> \"cos(pi*\" ^ ((exprToString e2) ^ \")\")\n  | Average (e3,e4) ->\n      \"((\" ^ ((exprToString e3) ^ (\"+\" ^ ((exprToString e4) ^ \")/2)\")))\n  | Times (e5,e6) -> (exprToString e5) ^ (\"*\" ^ (exprToString e6))\n  | Thresh (e7,e8,e9,e10) ->\n      \"(\" ^\n        ((exprToString e7) ^\n           (\"<\" ^\n              ((exprToString e8) ^\n                 (\"?\" ^\n                    ((exprToString e9) ^ (\":\" ^ ((exprToString e10) ^ \")\")))))))\n  | Power e11 -> \"((\" ^ ((exprToString e11) ^ \")^2)\")\n  | KellysOp (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\">\" ^ ((exprToString e2) ^ (\"?\" ^ ((exprToString e3) ^ \":0.0\")))));;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet _ = exprToString sampleExpr1;;\n","type":"","out":""},{"in":"let buildX()                       = VarX","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet buildX () = VarX;;\n","type":"","out":""},{"in":"let buildY()                       = VarY","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet buildY () = VarY;;\n","type":"","out":""},{"in":"let buildSine(e)                   = Sine(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n","type":"","out":""},{"in":"let buildCosine(e)                 = Cosine(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n","type":"","out":""},{"in":"let buildAverage(e1,e2)            = Average(e1,e2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n","type":"","out":""},{"in":"let buildTimes(e1,e2)              = Times(e1,e2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n","type":"","out":""},{"in":"let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n","type":"","out":""},{"in":"let buildPower(e)                  = Power(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet buildPower e = Power e;;\n","type":"","out":""},{"in":"let buildKellysOp(a,b,a_more)      = KellysOp(a,b,a_more)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet buildKellysOp (a,b,a_more) = KellysOp (a, b, a_more);;\n","type":"","out":""},{"in":"let pi = 4.0 *. atan 1.0","min":"\nlet pi = 4.0 *. (atan 1.0);;\n","type":"","out":""},{"in":"let rec eval (e,x,y) = \nmatch e with \nVarX -> x\n| VarY -> y\n| Sine (e) -> sin(pi*.eval (e,x,y))\n| Cosine (e) -> cos(pi*. eval (e,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y))/.2.0)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (a,b,a_less,b_less) -> if (eval (a,x,y)<eval(b,x,y)) then eval(a_less,x,y) else eval(b_less,x,y)\n| Power (e) -> eval(e,x,y) *. eval(e,x,y)\n| KellysOp (a,b,a_more) -> if (eval(a,x,y)>eval(b,x,y)) then eval (a_more,x,y) else 0.0","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Power e -> (eval (e, x, y)) *. (eval (e, x, y))\n  | KellysOp (a,b,a_more) ->\n      if (eval (a, x, y)) > (eval (b, x, y))\n      then eval (a_more, x, y)\n      else 0.0;;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Power e -> (eval (e, x, y)) *. (eval (e, x, y))\n  | KellysOp (a,b,a_more) ->\n      if (eval (a, x, y)) > (eval (b, x, y))\n      then eval (a_more, x, y)\n      else 0.0;;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.5, (-0.5));;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Power e -> (eval (e, x, y)) *. (eval (e, x, y))\n  | KellysOp (a,b,a_more) ->\n      if (eval (a, x, y)) > (eval (b, x, y))\n      then eval (a_more, x, y)\n      else 0.0;;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.3, 0.3);;\n","type":"","out":""},{"in":"let _ = eval (sampleExpr1,0.5,0.2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Power e -> (eval (e, x, y)) *. (eval (e, x, y))\n  | KellysOp (a,b,a_more) ->\n      if (eval (a, x, y)) > (eval (b, x, y))\n      then eval (a_more, x, y)\n      else 0.0;;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet _ = eval (sampleExpr1, 0.5, 0.2);;\n","type":"","out":""},{"in":"let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Power e -> (eval (e, x, y)) *. (eval (e, x, y))\n  | KellysOp (a,b,a_more) ->\n      if (eval (a, x, y)) > (eval (b, x, y))\n      then eval (a_more, x, y)\n      else 0.0;;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n","type":"","out":""},{"in":"let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n","type":"","out":""},{"in":"let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr2 =\n  buildThresh\n    ((buildX ()), (buildY ()), (buildSine (buildX ())),\n      (buildCosine (buildY ())));;\n","type":"","out":""},{"in":"let rec build (rand, depth) = \nif (depth = 0)\nthen let z = rand (0,1) in \nmatch z with \n0 -> buildX()\n| 1 -> buildY()\nelse\nlet z = rand (2,8) in\nmatch z with \n2 -> buildSine(build (rand, depth-1))\n| 3 -> buildCosine(build (rand, depth-1))\n| 4 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 5 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 6 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| 7 -> buildPower(build(rand, depth-1))\n| 8 -> buildKellysOp(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildKellysOp (a,b,a_more) = KellysOp (a, b, a_more);;\n\nlet buildPower e = Power e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let z = rand (0, 1) in match z with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let z = rand (2, 8) in\n     match z with\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7 -> buildPower (build (rand, (depth - 1)))\n     | 8 ->\n         buildKellysOp\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n","type":"","out":""},{"in":"let g1 () = (7,1,90)","min":"\nlet g1 () = (7, 1, 90);;\n","type":"","out":""},{"in":"let g2 () = (6,14,33)","min":"\nlet g2 () = (6, 14, 33);;\n","type":"","out":""},{"in":"let g3 () = (5,7,200)","min":"\nlet g3 () = (5, 7, 200);;\n","type":"","out":""},{"in":"let c1 () = (4,33,99)","min":"\nlet c1 () = (4, 33, 99);;\n","type":"","out":""},{"in":"let c2 () = (8,13,99)","min":"\nlet c2 () = (8, 13, 99);;\n","type":"","out":""},{"in":"let c3 () = (5,11,107)","min":"\nlet c3 () = (5, 11, 107);;\n","type":"","out":""},{"in":"let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))","min":"\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n","type":"","out":""},{"in":"let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))","min":"\nlet rec rseq g r n = if n <= 0 then [] else (g r) :: (rseq g r (n - 1));;\n","type":"","out":""},{"in":"let toReal (i,n) = (float_of_int i) /. (float_of_int n)","min":"\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n","type":"","out":""},{"in":"let toIntensity z = int_of_float (127.5 +. (127.5 *. z))","min":"\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n","type":"","out":""},{"in":"let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n","type":"","out":""},{"in":"let emitGrayscale (f,n,name) =\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet z = f (x,y) in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet iz = toIntensity(z) in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n","type":"","out":""},{"in":"let doRandomGray (depth,seed1,seed2) =\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet g = makeRand(seed1,seed2) in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(*XXXXXXXXXXXXXXXXXX*)\nlet n = 150 in\n(*XXXXXXXXXXXXXXXXXX*)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Power e -> (eval (e, x, y)) *. (eval (e, x, y))\n  | KellysOp (a,b,a_more) ->\n      if (eval (a, x, y)) > (eval (b, x, y))\n      then eval (a_more, x, y)\n      else 0.0;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildKellysOp (a,b,a_more) = KellysOp (a, b, a_more);;\n\nlet buildPower e = Power e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let z = rand (0, 1) in match z with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let z = rand (2, 8) in\n     match z with\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7 -> buildPower (build (rand, (depth - 1)))\n     | 8 ->\n         buildKellysOp\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e2 -> \"cos(pi*\" ^ ((exprToString e2) ^ \")\")\n  | Average (e3,e4) ->\n      \"((\" ^ ((exprToString e3) ^ (\"+\" ^ ((exprToString e4) ^ \")/2)\")))\n  | Times (e5,e6) -> (exprToString e5) ^ (\"*\" ^ (exprToString e6))\n  | Thresh (e7,e8,e9,e10) ->\n      \"(\" ^\n        ((exprToString e7) ^\n           (\"<\" ^\n              ((exprToString e8) ^\n                 (\"?\" ^\n                    ((exprToString e9) ^ (\":\" ^ ((exprToString e10) ^ \")\")))))))\n  | Power e11 -> \"((\" ^ ((exprToString e11) ^ \")^2)\")\n  | KellysOp (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\">\" ^ ((exprToString e2) ^ (\"?\" ^ ((exprToString e3) ^ \":0.0\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n","type":"","out":""},{"in":"let _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\")","min":"\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Power e -> (eval (e, x, y)) *. (eval (e, x, y))\n  | KellysOp (a,b,a_more) ->\n      if (eval (a, x, y)) > (eval (b, x, y))\n      then eval (a_more, x, y)\n      else 0.0;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n\nlet _ = emitGrayscale ((eval_fn sampleExpr), 150, \"sample\");;\n","type":"","out":""},{"in":"let emitColor (f1,f2,f3,n,name) =\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n","type":"","out":""},{"in":"let doRandomColor (depth,seed1,seed2) =\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet g = makeRand (seed1,seed2) in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(*XXXXXXXXXXXXXXXXXX*)\nlet n = 150 in\n(*XXXXXXXXXXXXXXXXXX*)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Power e -> (eval (e, x, y)) *. (eval (e, x, y))\n  | KellysOp (a,b,a_more) ->\n      if (eval (a, x, y)) > (eval (b, x, y))\n      then eval (a_more, x, y)\n      else 0.0;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildKellysOp (a,b,a_more) = KellysOp (a, b, a_more);;\n\nlet buildPower e = Power e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let z = rand (0, 1) in match z with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let z = rand (2, 8) in\n     match z with\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7 -> buildPower (build (rand, (depth - 1)))\n     | 8 ->\n         buildKellysOp\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e2 -> \"cos(pi*\" ^ ((exprToString e2) ^ \")\")\n  | Average (e3,e4) ->\n      \"((\" ^ ((exprToString e3) ^ (\"+\" ^ ((exprToString e4) ^ \")/2)\")))\n  | Times (e5,e6) -> (exprToString e5) ^ (\"*\" ^ (exprToString e6))\n  | Thresh (e7,e8,e9,e10) ->\n      \"(\" ^\n        ((exprToString e7) ^\n           (\"<\" ^\n              ((exprToString e8) ^\n                 (\"?\" ^\n                    ((exprToString e9) ^ (\":\" ^ ((exprToString e10) ^ \")\")))))))\n  | Power e11 -> \"((\" ^ ((exprToString e11) ^ \")^2)\")\n  | KellysOp (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\">\" ^ ((exprToString e2) ^ (\"?\" ^ ((exprToString e3) ^ \":0.0\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130 = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n","type":"","out":""},{"in":"let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","min":"\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n","type":"","out":""},{"in":"let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n\nlet drop_paren s =\n  implode\n    (List.filter (fun c  -> not (List.mem c ['('; ' '; ')'])) (explode s));;\n","type":"","out":""},{"in":"let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","min":"\nlet eq_real p (r1,r2) = ((r1 -. r2) < p) || ((r2 -. r1) < p);;\n","type":"","out":""},{"in":"let scoreMsg () = \nFormat.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":16977},"type":"eval"},"cursor":10953,"time":1.398315703497476e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) =\n  match l with\n      [] -> d\n    |front::back ->\n        match front with\n            (x,y) ->\n              if (x=k)\n              then y\n              else assoc (d,k,back)\n;; \n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' =  \n            if (List.mem h seen = true) \n            then []@seen\n            else [h]@seen\n          in\n          let rest' = t in \n            \t  helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n;;\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  match f b with\n      (x,y) -> if (y=true) then wwhile (f,x) else x\n;;\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = wwhile ((let g x = let b'=f(x) in (b',b'!=x) in (g)),b);;\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n    | Power    of expr\n    | KellysOp of expr * expr * expr \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = \n  match e with\n      VarX -> \"x\"\n    | VarY -> \"y\"\n    | Sine e1 -> \"sin(pi*\"^exprToString e1^\")\"\n    | Cosine e2 -> \"cos(pi*\"^exprToString e2^\")\"\n    | Average (e3,e4) -> \"((\"^exprToString e3^\"+\"^exprToString e4^\")/2)\"\n    | Times (e5,e6) -> exprToString e5^\"*\"^exprToString e6\n    | Thresh (e7,e8,e9,e10) -> \"(\"^exprToString e7^\"<\"^exprToString e8^\"?\"^exprToString e9^\":\"^exprToString e10^\")\"\n    | Power (e11) -> \"((\"^exprToString e11^\")^2)\"\n    | KellysOp (e1,e2,e3) -> \"(\"^exprToString e1^\">\"^exprToString e2^\"?\"^exprToString e3^\":0.0\"\n;;\n\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\nlet _ = exprToString sampleExpr1 ;;\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\nlet buildPower(e)                  = Power(e)\nlet buildKellysOp(a,b,a_more)      = KellysOp(a,b,a_more)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = \n  match e with \n      VarX -> x\n    | VarY -> y\n    | Sine (e) -> sin(pi*.eval (e,x,y))\n    | Cosine (e) -> cos(pi*. eval (e,x,y))\n    | Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y))/.2.0)\n    | Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y)\n    | Thresh (a,b,a_less,b_less) -> if (eval (a,x,y)<eval(b,x,y)) then eval(a_less,x,y) else eval(b_less,x,y)\n    | Power (e) -> eval(e,x,y) *. eval(e,x,y)\n    | KellysOp (a,b,a_more) -> if (eval(a,x,y)>eval(b,x,y)) then eval (a_more,x,y) else 0.0\n;;\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr1,0.5,0.2);;\n\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  if (depth = 0)\n  then let z = rand (0,1) in \n      match z with \n          0 -> buildX()\n        | 1 -> buildY()\n  else\n    let z = rand (2,8) in\n      match z with \n          2 -> buildSine(build (rand, depth-1))\n        | 3 -> buildCosine(build (rand, depth-1))\n        | 4 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n        | 5 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n        | 6 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n        | 7 -> buildPower(build(rand, depth-1))\n        | 8 -> buildKellysOp(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = (7,1,90)\nlet g2 () = (6,14,33)\nlet g3 () = (5,7,200) \n\nlet c1 () = (4,33,99)\nlet c2 () = (8,13,99)\nlet c3 () = (5,11,107)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\nlet _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\") ;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 \tfixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec assoc (d,k,l) =\nmatch l with\n[] -> d\n|front::back ->\nmatch front with\n(x,y) ->\nif (x=k)\nthen y\nelse assoc (d,k,back)","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | front::back ->\n      (match front with | (x,y) -> if x = k then y else assoc (d, k, back));;\n","type":"","out":""},{"in":"let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | front::back ->\n      (match front with | (x,y) -> if x = k then y else assoc (d, k, back));;\n\nlet _ =\n  assoc ((-1), \"william\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n","type":"","out":""},{"in":"let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | front::back ->\n      (match front with | (x,y) -> if x = k then y else assoc (d, k, back));;\n\nlet _ = assoc ((-1), \"bob\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n","type":"","out":""},{"in":"let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' =  \nif (List.mem h seen = true) \nthen []@seen\nelse [h]@seen\nin\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))","min":"\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' =\n          if (List.mem h seen) = true then [] @ seen else [h] @ seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n","type":"","out":""},{"in":"let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]","min":"\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' =\n          if (List.mem h seen) = true then [] @ seen else [h] @ seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ = removeDuplicates [1; 6; 2; 4; 12; 2; 13; 6; 9];;\n","type":"","out":""},{"in":"let rec wwhile (f,b) = \nmatch f b with\n(x,y) -> if (y=true) then wwhile (f,x) else x","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n","type":"","out":""},{"in":"let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n","type":"","out":""},{"in":"let fixpoint (f,b) = wwhile ((let g x = let b'=f(x) in (b',b'!=x) in (g)),b)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n","type":"","out":""},{"in":"let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n","type":"","out":""},{"in":"let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1","min":"\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 1)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n\nlet _ = fixpoint (collatz, 1);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 3)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n\nlet _ = fixpoint (collatz, 3);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 48)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n\nlet _ = fixpoint (collatz, 48);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 107)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n\nlet _ = fixpoint (collatz, 107);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 9001)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n\nlet _ = fixpoint (collatz, 9001);;\n","type":"","out":""},{"in":"type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Power    of expr\n| KellysOp of expr * expr * expr","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n","type":"","out":""},{"in":"let rec exprToString e = \nmatch e with\nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine e1 -> \"sin(pi*\"^exprToString e1^\")\"\n| Cosine e2 -> \"cos(pi*\"^exprToString e2^\")\"\n| Average (e3,e4) -> \"((\"^exprToString e3^\"+\"^exprToString e4^\")/2)\"\n| Times (e5,e6) -> exprToString e5^\"*\"^exprToString e6\n| Thresh (e7,e8,e9,e10) -> \"(\"^exprToString e7^\"<\"^exprToString e8^\"?\"^exprToString e9^\":\"^exprToString e10^\")\"\n| Power (e11) -> \"((\"^exprToString e11^\")^2)\"\n| KellysOp (e1,e2,e3) -> \"(\"^exprToString e1^\">\"^exprToString e2^\"?\"^exprToString e3^\":0.0\"","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e2 -> \"cos(pi*\" ^ ((exprToString e2) ^ \")\")\n  | Average (e3,e4) ->\n      \"((\" ^ ((exprToString e3) ^ (\"+\" ^ ((exprToString e4) ^ \")/2)\")))\n  | Times (e5,e6) -> (exprToString e5) ^ (\"*\" ^ (exprToString e6))\n  | Thresh (e7,e8,e9,e10) ->\n      \"(\" ^\n        ((exprToString e7) ^\n           (\"<\" ^\n              ((exprToString e8) ^\n                 (\"?\" ^\n                    ((exprToString e9) ^ (\":\" ^ ((exprToString e10) ^ \")\")))))))\n  | Power e11 -> \"((\" ^ ((exprToString e11) ^ \")^2)\")\n  | KellysOp (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\">\" ^ ((exprToString e2) ^ (\"?\" ^ ((exprToString e3) ^ \":0.0\")))));;\n","type":"","out":""},{"in":"let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n","type":"","out":""},{"in":"let _ = exprToString sampleExpr1","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e2 -> \"cos(pi*\" ^ ((exprToString e2) ^ \")\")\n  | Average (e3,e4) ->\n      \"((\" ^ ((exprToString e3) ^ (\"+\" ^ ((exprToString e4) ^ \")/2)\")))\n  | Times (e5,e6) -> (exprToString e5) ^ (\"*\" ^ (exprToString e6))\n  | Thresh (e7,e8,e9,e10) ->\n      \"(\" ^\n        ((exprToString e7) ^\n           (\"<\" ^\n              ((exprToString e8) ^\n                 (\"?\" ^\n                    ((exprToString e9) ^ (\":\" ^ ((exprToString e10) ^ \")\")))))))\n  | Power e11 -> \"((\" ^ ((exprToString e11) ^ \")^2)\")\n  | KellysOp (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\">\" ^ ((exprToString e2) ^ (\"?\" ^ ((exprToString e3) ^ \":0.0\")))));;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet _ = exprToString sampleExpr1;;\n","type":"","out":""},{"in":"let buildX()                       = VarX","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet buildX () = VarX;;\n","type":"","out":""},{"in":"let buildY()                       = VarY","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet buildY () = VarY;;\n","type":"","out":""},{"in":"let buildSine(e)                   = Sine(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n","type":"","out":""},{"in":"let buildCosine(e)                 = Cosine(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n","type":"","out":""},{"in":"let buildAverage(e1,e2)            = Average(e1,e2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n","type":"","out":""},{"in":"let buildTimes(e1,e2)              = Times(e1,e2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n","type":"","out":""},{"in":"let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n","type":"","out":""},{"in":"let buildPower(e)                  = Power(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet buildPower e = Power e;;\n","type":"","out":""},{"in":"let buildKellysOp(a,b,a_more)      = KellysOp(a,b,a_more)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet buildKellysOp (a,b,a_more) = KellysOp (a, b, a_more);;\n","type":"","out":""},{"in":"let pi = 4.0 *. atan 1.0","min":"\nlet pi = 4.0 *. (atan 1.0);;\n","type":"","out":""},{"in":"let rec eval (e,x,y) = \nmatch e with \nVarX -> x\n| VarY -> y\n| Sine (e) -> sin(pi*.eval (e,x,y))\n| Cosine (e) -> cos(pi*. eval (e,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y))/.2.0)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (a,b,a_less,b_less) -> if (eval (a,x,y)<eval(b,x,y)) then eval(a_less,x,y) else eval(b_less,x,y)\n| Power (e) -> eval(e,x,y) *. eval(e,x,y)\n| KellysOp (a,b,a_more) -> if (eval(a,x,y)>eval(b,x,y)) then eval (a_more,x,y) else 0.0","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Power e -> (eval (e, x, y)) *. (eval (e, x, y))\n  | KellysOp (a,b,a_more) ->\n      if (eval (a, x, y)) > (eval (b, x, y))\n      then eval (a_more, x, y)\n      else 0.0;;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Power e -> (eval (e, x, y)) *. (eval (e, x, y))\n  | KellysOp (a,b,a_more) ->\n      if (eval (a, x, y)) > (eval (b, x, y))\n      then eval (a_more, x, y)\n      else 0.0;;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.5, (-0.5));;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Power e -> (eval (e, x, y)) *. (eval (e, x, y))\n  | KellysOp (a,b,a_more) ->\n      if (eval (a, x, y)) > (eval (b, x, y))\n      then eval (a_more, x, y)\n      else 0.0;;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.3, 0.3);;\n","type":"","out":""},{"in":"let _ = eval (sampleExpr1,0.5,0.2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Power e -> (eval (e, x, y)) *. (eval (e, x, y))\n  | KellysOp (a,b,a_more) ->\n      if (eval (a, x, y)) > (eval (b, x, y))\n      then eval (a_more, x, y)\n      else 0.0;;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet _ = eval (sampleExpr1, 0.5, 0.2);;\n","type":"","out":""},{"in":"let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Power e -> (eval (e, x, y)) *. (eval (e, x, y))\n  | KellysOp (a,b,a_more) ->\n      if (eval (a, x, y)) > (eval (b, x, y))\n      then eval (a_more, x, y)\n      else 0.0;;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n","type":"","out":""},{"in":"let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n","type":"","out":""},{"in":"let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr2 =\n  buildThresh\n    ((buildX ()), (buildY ()), (buildSine (buildX ())),\n      (buildCosine (buildY ())));;\n","type":"","out":""},{"in":"let rec build (rand, depth) = \nif (depth = 0)\nthen let z = rand (0,1) in \nmatch z with \n0 -> buildX()\n| 1 -> buildY()\nelse\nlet z = rand (2,8) in\nmatch z with \n2 -> buildSine(build (rand, depth-1))\n| 3 -> buildCosine(build (rand, depth-1))\n| 4 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 5 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 6 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| 7 -> buildPower(build(rand, depth-1))\n| 8 -> buildKellysOp(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildKellysOp (a,b,a_more) = KellysOp (a, b, a_more);;\n\nlet buildPower e = Power e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let z = rand (0, 1) in match z with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let z = rand (2, 8) in\n     match z with\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7 -> buildPower (build (rand, (depth - 1)))\n     | 8 ->\n         buildKellysOp\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n","type":"","out":""},{"in":"let g1 () = (7,1,90)","min":"\nlet g1 () = (7, 1, 90);;\n","type":"","out":""},{"in":"let g2 () = (6,21,43)","min":"\nlet g2 () = (6, 21, 43);;\n","type":"","out":""},{"in":"let g3 () = (6,54,77)","min":"\nlet g3 () = (6, 54, 77);;\n","type":"","out":""},{"in":"let c1 () = (4,33,99)","min":"\nlet c1 () = (4, 33, 99);;\n","type":"","out":""},{"in":"let c2 () = (8,13,99)","min":"\nlet c2 () = (8, 13, 99);;\n","type":"","out":""},{"in":"let c3 () = (5,11,107)","min":"\nlet c3 () = (5, 11, 107);;\n","type":"","out":""},{"in":"let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))","min":"\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n","type":"","out":""},{"in":"let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))","min":"\nlet rec rseq g r n = if n <= 0 then [] else (g r) :: (rseq g r (n - 1));;\n","type":"","out":""},{"in":"let toReal (i,n) = (float_of_int i) /. (float_of_int n)","min":"\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n","type":"","out":""},{"in":"let toIntensity z = int_of_float (127.5 +. (127.5 *. z))","min":"\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n","type":"","out":""},{"in":"let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n","type":"","out":""},{"in":"let emitGrayscale (f,n,name) =\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet z = f (x,y) in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet iz = toIntensity(z) in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n","type":"","out":""},{"in":"let doRandomGray (depth,seed1,seed2) =\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet g = makeRand(seed1,seed2) in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(*XXXXXXXXXXXXXXXXXX*)\nlet n = 150 in\n(*XXXXXXXXXXXXXXXXXX*)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Power e -> (eval (e, x, y)) *. (eval (e, x, y))\n  | KellysOp (a,b,a_more) ->\n      if (eval (a, x, y)) > (eval (b, x, y))\n      then eval (a_more, x, y)\n      else 0.0;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildKellysOp (a,b,a_more) = KellysOp (a, b, a_more);;\n\nlet buildPower e = Power e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let z = rand (0, 1) in match z with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let z = rand (2, 8) in\n     match z with\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7 -> buildPower (build (rand, (depth - 1)))\n     | 8 ->\n         buildKellysOp\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e2 -> \"cos(pi*\" ^ ((exprToString e2) ^ \")\")\n  | Average (e3,e4) ->\n      \"((\" ^ ((exprToString e3) ^ (\"+\" ^ ((exprToString e4) ^ \")/2)\")))\n  | Times (e5,e6) -> (exprToString e5) ^ (\"*\" ^ (exprToString e6))\n  | Thresh (e7,e8,e9,e10) ->\n      \"(\" ^\n        ((exprToString e7) ^\n           (\"<\" ^\n              ((exprToString e8) ^\n                 (\"?\" ^\n                    ((exprToString e9) ^ (\":\" ^ ((exprToString e10) ^ \")\")))))))\n  | Power e11 -> \"((\" ^ ((exprToString e11) ^ \")^2)\")\n  | KellysOp (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\">\" ^ ((exprToString e2) ^ (\"?\" ^ ((exprToString e3) ^ \":0.0\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n","type":"","out":""},{"in":"let _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\")","min":"\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Power e -> (eval (e, x, y)) *. (eval (e, x, y))\n  | KellysOp (a,b,a_more) ->\n      if (eval (a, x, y)) > (eval (b, x, y))\n      then eval (a_more, x, y)\n      else 0.0;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n\nlet _ = emitGrayscale ((eval_fn sampleExpr), 150, \"sample\");;\n","type":"","out":""},{"in":"let emitColor (f1,f2,f3,n,name) =\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n","type":"","out":""},{"in":"let doRandomColor (depth,seed1,seed2) =\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet g = makeRand (seed1,seed2) in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(*XXXXXXXXXXXXXXXXXX*)\nlet n = 150 in\n(*XXXXXXXXXXXXXXXXXX*)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Power e -> (eval (e, x, y)) *. (eval (e, x, y))\n  | KellysOp (a,b,a_more) ->\n      if (eval (a, x, y)) > (eval (b, x, y))\n      then eval (a_more, x, y)\n      else 0.0;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildKellysOp (a,b,a_more) = KellysOp (a, b, a_more);;\n\nlet buildPower e = Power e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let z = rand (0, 1) in match z with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let z = rand (2, 8) in\n     match z with\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7 -> buildPower (build (rand, (depth - 1)))\n     | 8 ->\n         buildKellysOp\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e2 -> \"cos(pi*\" ^ ((exprToString e2) ^ \")\")\n  | Average (e3,e4) ->\n      \"((\" ^ ((exprToString e3) ^ (\"+\" ^ ((exprToString e4) ^ \")/2)\")))\n  | Times (e5,e6) -> (exprToString e5) ^ (\"*\" ^ (exprToString e6))\n  | Thresh (e7,e8,e9,e10) ->\n      \"(\" ^\n        ((exprToString e7) ^\n           (\"<\" ^\n              ((exprToString e8) ^\n                 (\"?\" ^\n                    ((exprToString e9) ^ (\":\" ^ ((exprToString e10) ^ \")\")))))))\n  | Power e11 -> \"((\" ^ ((exprToString e11) ^ \")^2)\")\n  | KellysOp (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\">\" ^ ((exprToString e2) ^ (\"?\" ^ ((exprToString e3) ^ \":0.0\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130 = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n","type":"","out":""},{"in":"let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","min":"\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n","type":"","out":""},{"in":"let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n\nlet drop_paren s =\n  implode\n    (List.filter (fun c  -> not (List.mem c ['('; ' '; ')'])) (explode s));;\n","type":"","out":""},{"in":"let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","min":"\nlet eq_real p (r1,r2) = ((r1 -. r2) < p) || ((r2 -. r1) < p);;\n","type":"","out":""},{"in":"let scoreMsg () = \nFormat.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":16977},"type":"eval"},"cursor":7740,"time":1.398315885509645e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) =\n  match l with\n      [] -> d\n    |front::back ->\n        match front with\n            (x,y) ->\n              if (x=k)\n              then y\n              else assoc (d,k,back)\n;; \n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' =  \n            if (List.mem h seen = true) \n            then []@seen\n            else [h]@seen\n          in\n          let rest' = t in \n            \t  helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n;;\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  match f b with\n      (x,y) -> if (y=true) then wwhile (f,x) else x\n;;\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = wwhile ((let g x = let b'=f(x) in (b',b'!=x) in (g)),b);;\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n    | Power    of expr\n    | KellysOp of expr * expr * expr \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = \n  match e with\n      VarX -> \"x\"\n    | VarY -> \"y\"\n    | Sine e1 -> \"sin(pi*\"^exprToString e1^\")\"\n    | Cosine e2 -> \"cos(pi*\"^exprToString e2^\")\"\n    | Average (e3,e4) -> \"((\"^exprToString e3^\"+\"^exprToString e4^\")/2)\"\n    | Times (e5,e6) -> exprToString e5^\"*\"^exprToString e6\n    | Thresh (e7,e8,e9,e10) -> \"(\"^exprToString e7^\"<\"^exprToString e8^\"?\"^exprToString e9^\":\"^exprToString e10^\")\"\n    | Power (e11) -> \"((\"^exprToString e11^\")^2)\"\n    | KellysOp (e1,e2,e3) -> \"(\"^exprToString e1^\">\"^exprToString e2^\"?\"^exprToString e3^\":0.0\"\n;;\n\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\nlet _ = exprToString sampleExpr1 ;;\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\nlet buildPower(e)                  = Power(e)\nlet buildKellysOp(a,b,a_more)      = KellysOp(a,b,a_more)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = \n  match e with \n      VarX -> x\n    | VarY -> y\n    | Sine (e) -> sin(pi*.eval (e,x,y))\n    | Cosine (e) -> cos(pi*. eval (e,x,y))\n    | Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y))/.2.0)\n    | Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y)\n    | Thresh (a,b,a_less,b_less) -> if (eval (a,x,y)<eval(b,x,y)) then eval(a_less,x,y) else eval(b_less,x,y)\n    | Power (e) -> eval(e,x,y) *. eval(e,x,y)\n    | KellysOp (a,b,a_more) -> if (eval(a,x,y)>eval(b,x,y)) then eval (a_more,x,y) else 0.0\n;;\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr1,0.5,0.2);;\n\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  if (depth = 0)\n  then let z = rand (0,1) in \n      match z with \n          0 -> buildX()\n        | 1 -> buildY()\n  else\n    let z = rand (2,8) in\n      match z with \n          2 -> buildSine(build (rand, depth-1))\n        | 3 -> buildCosine(build (rand, depth-1))\n        | 4 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n        | 5 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n        | 6 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n        | 7 -> buildPower(build(rand, depth-1))\n        | 8 -> buildKellysOp(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = (7,1,90)\nlet g2 () = (6,21,43)\nlet g3 () = (6,54,77) \n\nlet c1 () = (4,33,99)\nlet c2 () = (8,13,99)\nlet c3 () = (5,11,107)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\nlet _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\") ;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 \tfixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
{"ocaml":[{"in":"let rec assoc (d,k,l) =\nmatch l with\n[] -> d\n|front::back ->\nmatch front with\n(x,y) ->\nif (x=k)\nthen y\nelse assoc (d,k,back)","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | front::back ->\n      (match front with | (x,y) -> if x = k then y else assoc (d, k, back));;\n","type":"","out":""},{"in":"let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | front::back ->\n      (match front with | (x,y) -> if x = k then y else assoc (d, k, back));;\n\nlet _ =\n  assoc ((-1), \"william\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n","type":"","out":""},{"in":"let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])","min":"\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | front::back ->\n      (match front with | (x,y) -> if x = k then y else assoc (d, k, back));;\n\nlet _ = assoc ((-1), \"bob\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n","type":"","out":""},{"in":"let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' =  \nif (List.mem h seen = true) \nthen []@seen\nelse [h]@seen\nin\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))","min":"\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' =\n          if (List.mem h seen) = true then [] @ seen else [h] @ seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n","type":"","out":""},{"in":"let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]","min":"\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' =\n          if (List.mem h seen) = true then [] @ seen else [h] @ seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ = removeDuplicates [1; 6; 2; 4; 12; 2; 13; 6; 9];;\n","type":"","out":""},{"in":"let rec wwhile (f,b) = \nmatch f b with\n(x,y) -> if (y=true) then wwhile (f,x) else x","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n","type":"","out":""},{"in":"let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n","type":"","out":""},{"in":"let fixpoint (f,b) = wwhile ((let g x = let b'=f(x) in (b',b'!=x) in (g)),b)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n","type":"","out":""},{"in":"let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n","type":"","out":""},{"in":"let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1","min":"\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 1)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n\nlet _ = fixpoint (collatz, 1);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 3)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n\nlet _ = fixpoint (collatz, 3);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 48)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n\nlet _ = fixpoint (collatz, 48);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 107)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n\nlet _ = fixpoint (collatz, 107);;\n","type":"","out":""},{"in":"let _ = fixpoint (collatz, 9001)","min":"\nlet rec wwhile (f,b) =\n  match f b with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let b' = f x in (b', (b' != x)) in g), b);;\n\nlet _ = fixpoint (collatz, 9001);;\n","type":"","out":""},{"in":"type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Power    of expr\n| KellysOp of expr * expr * expr","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n","type":"","out":""},{"in":"let rec exprToString e = \nmatch e with\nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine e1 -> \"sin(pi*\"^exprToString e1^\")\"\n| Cosine e2 -> \"cos(pi*\"^exprToString e2^\")\"\n| Average (e3,e4) -> \"((\"^exprToString e3^\"+\"^exprToString e4^\")/2)\"\n| Times (e5,e6) -> exprToString e5^\"*\"^exprToString e6\n| Thresh (e7,e8,e9,e10) -> \"(\"^exprToString e7^\"<\"^exprToString e8^\"?\"^exprToString e9^\":\"^exprToString e10^\")\"\n| Power (e11) -> \"((\"^exprToString e11^\")^2)\"\n| KellysOp (e1,e2,e3) -> \"(\"^exprToString e1^\">\"^exprToString e2^\"?\"^exprToString e3^\":0.0\"","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e2 -> \"cos(pi*\" ^ ((exprToString e2) ^ \")\")\n  | Average (e3,e4) ->\n      \"((\" ^ ((exprToString e3) ^ (\"+\" ^ ((exprToString e4) ^ \")/2)\")))\n  | Times (e5,e6) -> (exprToString e5) ^ (\"*\" ^ (exprToString e6))\n  | Thresh (e7,e8,e9,e10) ->\n      \"(\" ^\n        ((exprToString e7) ^\n           (\"<\" ^\n              ((exprToString e8) ^\n                 (\"?\" ^\n                    ((exprToString e9) ^ (\":\" ^ ((exprToString e10) ^ \")\")))))))\n  | Power e11 -> \"((\" ^ ((exprToString e11) ^ \")^2)\")\n  | KellysOp (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\">\" ^ ((exprToString e2) ^ (\"?\" ^ ((exprToString e3) ^ \":0.0\")))));;\n","type":"","out":""},{"in":"let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n","type":"","out":""},{"in":"let _ = exprToString sampleExpr1","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e2 -> \"cos(pi*\" ^ ((exprToString e2) ^ \")\")\n  | Average (e3,e4) ->\n      \"((\" ^ ((exprToString e3) ^ (\"+\" ^ ((exprToString e4) ^ \")/2)\")))\n  | Times (e5,e6) -> (exprToString e5) ^ (\"*\" ^ (exprToString e6))\n  | Thresh (e7,e8,e9,e10) ->\n      \"(\" ^\n        ((exprToString e7) ^\n           (\"<\" ^\n              ((exprToString e8) ^\n                 (\"?\" ^\n                    ((exprToString e9) ^ (\":\" ^ ((exprToString e10) ^ \")\")))))))\n  | Power e11 -> \"((\" ^ ((exprToString e11) ^ \")^2)\")\n  | KellysOp (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\">\" ^ ((exprToString e2) ^ (\"?\" ^ ((exprToString e3) ^ \":0.0\")))));;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet _ = exprToString sampleExpr1;;\n","type":"","out":""},{"in":"let buildX()                       = VarX","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet buildX () = VarX;;\n","type":"","out":""},{"in":"let buildY()                       = VarY","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet buildY () = VarY;;\n","type":"","out":""},{"in":"let buildSine(e)                   = Sine(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n","type":"","out":""},{"in":"let buildCosine(e)                 = Cosine(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n","type":"","out":""},{"in":"let buildAverage(e1,e2)            = Average(e1,e2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n","type":"","out":""},{"in":"let buildTimes(e1,e2)              = Times(e1,e2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n","type":"","out":""},{"in":"let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n","type":"","out":""},{"in":"let buildPower(e)                  = Power(e)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet buildPower e = Power e;;\n","type":"","out":""},{"in":"let buildKellysOp(a,b,a_more)      = KellysOp(a,b,a_more)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet buildKellysOp (a,b,a_more) = KellysOp (a, b, a_more);;\n","type":"","out":""},{"in":"let pi = 4.0 *. atan 1.0","min":"\nlet pi = 4.0 *. (atan 1.0);;\n","type":"","out":""},{"in":"let rec eval (e,x,y) = \nmatch e with \nVarX -> x\n| VarY -> y\n| Sine (e) -> sin(pi*.eval (e,x,y))\n| Cosine (e) -> cos(pi*. eval (e,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y))/.2.0)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (a,b,a_less,b_less) -> if (eval (a,x,y)<eval(b,x,y)) then eval(a_less,x,y) else eval(b_less,x,y)\n| Power (e) -> eval(e,x,y) *. eval(e,x,y)\n| KellysOp (a,b,a_more) -> if (eval(a,x,y)>eval(b,x,y)) then eval (a_more,x,y) else 0.0","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Power e -> (eval (e, x, y)) *. (eval (e, x, y))\n  | KellysOp (a,b,a_more) ->\n      if (eval (a, x, y)) > (eval (b, x, y))\n      then eval (a_more, x, y)\n      else 0.0;;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Power e -> (eval (e, x, y)) *. (eval (e, x, y))\n  | KellysOp (a,b,a_more) ->\n      if (eval (a, x, y)) > (eval (b, x, y))\n      then eval (a_more, x, y)\n      else 0.0;;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.5, (-0.5));;\n","type":"","out":""},{"in":"let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Power e -> (eval (e, x, y)) *. (eval (e, x, y))\n  | KellysOp (a,b,a_more) ->\n      if (eval (a, x, y)) > (eval (b, x, y))\n      then eval (a_more, x, y)\n      else 0.0;;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.3, 0.3);;\n","type":"","out":""},{"in":"let _ = eval (sampleExpr1,0.5,0.2)","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Power e -> (eval (e, x, y)) *. (eval (e, x, y))\n  | KellysOp (a,b,a_more) ->\n      if (eval (a, x, y)) > (eval (b, x, y))\n      then eval (a_more, x, y)\n      else 0.0;;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet _ = eval (sampleExpr1, 0.5, 0.2);;\n","type":"","out":""},{"in":"let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Power e -> (eval (e, x, y)) *. (eval (e, x, y))\n  | KellysOp (a,b,a_more) ->\n      if (eval (a, x, y)) > (eval (b, x, y))\n      then eval (a_more, x, y)\n      else 0.0;;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n","type":"","out":""},{"in":"let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n","type":"","out":""},{"in":"let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr2 =\n  buildThresh\n    ((buildX ()), (buildY ()), (buildSine (buildX ())),\n      (buildCosine (buildY ())));;\n","type":"","out":""},{"in":"let rec build (rand, depth) = \nif (depth = 0)\nthen let z = rand (0,1) in \nmatch z with \n0 -> buildX()\n| 1 -> buildY()\nelse\nlet z = rand (2,8) in\nmatch z with \n2 -> buildSine(build (rand, depth-1))\n| 3 -> buildCosine(build (rand, depth-1))\n| 4 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 5 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 6 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| 7 -> buildPower(build(rand, depth-1))\n| 8 -> buildKellysOp(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))","min":"\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildKellysOp (a,b,a_more) = KellysOp (a, b, a_more);;\n\nlet buildPower e = Power e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let z = rand (0, 1) in match z with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let z = rand (2, 8) in\n     match z with\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7 -> buildPower (build (rand, (depth - 1)))\n     | 8 ->\n         buildKellysOp\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n","type":"","out":""},{"in":"let g1 () = (7,1,90)","min":"\nlet g1 () = (7, 1, 90);;\n","type":"","out":""},{"in":"let g2 () = (8,13,99)","min":"\nlet g2 () = (8, 13, 99);;\n","type":"","out":""},{"in":"let g3 () = (6,54,77)","min":"\nlet g3 () = (6, 54, 77);;\n","type":"","out":""},{"in":"let c1 () = (4,33,99)","min":"\nlet c1 () = (4, 33, 99);;\n","type":"","out":""},{"in":"let c2 () = (8,13,99)","min":"\nlet c2 () = (8, 13, 99);;\n","type":"","out":""},{"in":"let c3 () = (5,11,107)","min":"\nlet c3 () = (5, 11, 107);;\n","type":"","out":""},{"in":"let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))","min":"\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n","type":"","out":""},{"in":"let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))","min":"\nlet rec rseq g r n = if n <= 0 then [] else (g r) :: (rseq g r (n - 1));;\n","type":"","out":""},{"in":"let toReal (i,n) = (float_of_int i) /. (float_of_int n)","min":"\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n","type":"","out":""},{"in":"let toIntensity z = int_of_float (127.5 +. (127.5 *. z))","min":"\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n","type":"","out":""},{"in":"let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n","type":"","out":""},{"in":"let emitGrayscale (f,n,name) =\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet z = f (x,y) in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet iz = toIntensity(z) in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n","type":"","out":""},{"in":"let doRandomGray (depth,seed1,seed2) =\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet g = makeRand(seed1,seed2) in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(*XXXXXXXXXXXXXXXXXX*)\nlet n = 150 in\n(*XXXXXXXXXXXXXXXXXX*)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Power e -> (eval (e, x, y)) *. (eval (e, x, y))\n  | KellysOp (a,b,a_more) ->\n      if (eval (a, x, y)) > (eval (b, x, y))\n      then eval (a_more, x, y)\n      else 0.0;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildKellysOp (a,b,a_more) = KellysOp (a, b, a_more);;\n\nlet buildPower e = Power e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let z = rand (0, 1) in match z with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let z = rand (2, 8) in\n     match z with\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7 -> buildPower (build (rand, (depth - 1)))\n     | 8 ->\n         buildKellysOp\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e2 -> \"cos(pi*\" ^ ((exprToString e2) ^ \")\")\n  | Average (e3,e4) ->\n      \"((\" ^ ((exprToString e3) ^ (\"+\" ^ ((exprToString e4) ^ \")/2)\")))\n  | Times (e5,e6) -> (exprToString e5) ^ (\"*\" ^ (exprToString e6))\n  | Thresh (e7,e8,e9,e10) ->\n      \"(\" ^\n        ((exprToString e7) ^\n           (\"<\" ^\n              ((exprToString e8) ^\n                 (\"?\" ^\n                    ((exprToString e9) ^ (\":\" ^ ((exprToString e10) ^ \")\")))))))\n  | Power e11 -> \"((\" ^ ((exprToString e11) ^ \")^2)\")\n  | KellysOp (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\">\" ^ ((exprToString e2) ^ (\"?\" ^ ((exprToString e3) ^ \":0.0\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n","type":"","out":""},{"in":"let _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\")","min":"\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Power e -> (eval (e, x, y)) *. (eval (e, x, y))\n  | KellysOp (a,b,a_more) ->\n      if (eval (a, x, y)) > (eval (b, x, y))\n      then eval (a_more, x, y)\n      else 0.0;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n\nlet _ = emitGrayscale ((eval_fn sampleExpr), 150, \"sample\");;\n","type":"","out":""},{"in":"let emitColor (f1,f2,f3,n,name) =\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))","min":"\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n","type":"","out":""},{"in":"let doRandomColor (depth,seed1,seed2) =\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet g = makeRand (seed1,seed2) in\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(*XXXXXXXXXXXXXXXXXX*)\nlet n = 150 in\n(*XXXXXXXXXXXXXXXXXX*)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)","min":"\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Power e -> (eval (e, x, y)) *. (eval (e, x, y))\n  | KellysOp (a,b,a_more) ->\n      if (eval (a, x, y)) > (eval (b, x, y))\n      then eval (a_more, x, y)\n      else 0.0;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildKellysOp (a,b,a_more) = KellysOp (a, b, a_more);;\n\nlet buildPower e = Power e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let z = rand (0, 1) in match z with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let z = rand (2, 8) in\n     match z with\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7 -> buildPower (build (rand, (depth - 1)))\n     | 8 ->\n         buildKellysOp\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e2 -> \"cos(pi*\" ^ ((exprToString e2) ^ \")\")\n  | Average (e3,e4) ->\n      \"((\" ^ ((exprToString e3) ^ (\"+\" ^ ((exprToString e4) ^ \")/2)\")))\n  | Times (e5,e6) -> (exprToString e5) ^ (\"*\" ^ (exprToString e6))\n  | Thresh (e7,e8,e9,e10) ->\n      \"(\" ^\n        ((exprToString e7) ^\n           (\"<\" ^\n              ((exprToString e8) ^\n                 (\"?\" ^\n                    ((exprToString e9) ^ (\":\" ^ ((exprToString e10) ^ \")\")))))))\n  | Power e11 -> \"((\" ^ ((exprToString e11) ^ \")^2)\")\n  | KellysOp (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\">\" ^ ((exprToString e2) ^ (\"?\" ^ ((exprToString e3) ^ \":0.0\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130 = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n","type":"","out":""},{"in":"let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","min":"\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n","type":"","out":""},{"in":"let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n\nlet drop_paren s =\n  implode\n    (List.filter (fun c  -> not (List.mem c ['('; ' '; ')'])) (explode s));;\n","type":"","out":""},{"in":"let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","min":"\nlet eq_real p (r1,r2) = ((r1 -. r2) < p) || ((r2 -. r1) < p);;\n","type":"","out":""},{"in":"let scoreMsg () = \nFormat.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":16977},"type":"eval"},"cursor":7737,"time":1.3983160626673e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec assoc (d,k,l) =\n  match l with\n      [] -> d\n    |front::back ->\n        match front with\n            (x,y) ->\n              if (x=k)\n              then y\n              else assoc (d,k,back)\n;; \n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;    \nlet _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet removeDuplicates l = \n  let rec helper (seen,rest) = \n    match rest with \n        [] -> seen\n      | h::t -> \n          let seen' =  \n            if (List.mem h seen = true) \n            then []@seen\n            else [h]@seen\n          in\n          let rest' = t in \n            \t  helper (seen',rest') \n  in\n    List.rev (helper ([],l))\n;;\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9];;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec wwhile (f,b) = \n  match f b with\n      (x,y) -> if (y=true) then wwhile (f,x) else x\n;;\n\nlet f x = let xx = x*x*x in (xx, xx < 100) in\n  wwhile (f, 2);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet fixpoint (f,b) = wwhile ((let g x = let b'=f(x) in (b',b'!=x) in (g)),b);;\n\n\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);; \n\nlet collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1;;\n\nlet _ = fixpoint (collatz, 1) ;;\nlet _ = fixpoint (collatz, 3) ;;\nlet _ = fixpoint (collatz, 48) ;;\nlet _ = fixpoint (collatz, 107) ;;\nlet _ = fixpoint (collatz, 9001) ;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\ntype expr = \n      VarX\n    | VarY\n    | Sine     of expr\n    | Cosine   of expr\n    | Average  of expr * expr\n    | Times    of expr * expr\n    | Thresh   of expr * expr * expr * expr\t\n    | Power    of expr\n    | KellysOp of expr * expr * expr \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet rec exprToString e = \n  match e with\n      VarX -> \"x\"\n    | VarY -> \"y\"\n    | Sine e1 -> \"sin(pi*\"^exprToString e1^\")\"\n    | Cosine e2 -> \"cos(pi*\"^exprToString e2^\")\"\n    | Average (e3,e4) -> \"((\"^exprToString e3^\"+\"^exprToString e4^\")/2)\"\n    | Times (e5,e6) -> exprToString e5^\"*\"^exprToString e6\n    | Thresh (e7,e8,e9,e10) -> \"(\"^exprToString e7^\"<\"^exprToString e8^\"?\"^exprToString e9^\":\"^exprToString e10^\")\"\n    | Power (e11) -> \"((\"^exprToString e11^\")^2)\"\n    | KellysOp (e1,e2,e3) -> \"(\"^exprToString e1^\">\"^exprToString e2^\"?\"^exprToString e3^\":0.0\"\n;;\n\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))));;\n\nlet _ = exprToString sampleExpr1 ;;\n\n\n(*XXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet buildX()                       = VarX\nlet buildY()                       = VarY\nlet buildSine(e)                   = Sine(e)\nlet buildCosine(e)                 = Cosine(e)\nlet buildAverage(e1,e2)            = Average(e1,e2)\nlet buildTimes(e1,e2)              = Times(e1,e2)\nlet buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)\nlet buildPower(e)                  = Power(e)\nlet buildKellysOp(a,b,a_more)      = KellysOp(a,b,a_more)\n\n\nlet pi = 4.0 *. atan 1.0\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec eval (e,x,y) = \n  match e with \n      VarX -> x\n    | VarY -> y\n    | Sine (e) -> sin(pi*.eval (e,x,y))\n    | Cosine (e) -> cos(pi*. eval (e,x,y))\n    | Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y))/.2.0)\n    | Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y)\n    | Thresh (a,b,a_less,b_less) -> if (eval (a,x,y)<eval(b,x,y)) then eval(a_less,x,y) else eval(b_less,x,y)\n    | Power (e) -> eval(e,x,y) *. eval(e,x,y)\n    | KellysOp (a,b,a_more) -> if (eval(a,x,y)>eval(b,x,y)) then eval (a_more,x,y) else 0.0\n;;\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5);;\nlet _ = eval (Sine(Average(VarX,VarY)),0.3,0.3);;\nlet _ = eval (sampleExpr1,0.5,0.2);;\n\n\n\nlet eval_fn e (x,y) = \n  let rv = eval (e,x,y) in\n    assert (-1.0 <= rv && rv <= 1.0);\n    rv\n\nlet sampleExpr =\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n                                                              buildX()),buildTimes(buildCosine (buildCosine (buildAverage\n                                                                                                               (buildTimes (buildY(),buildY()),buildCosine (buildX())))),\n                                                                                   buildCosine (buildTimes (buildSine (buildCosine\n                                                                                                                         (buildY())),buildAverage (buildSine (buildX()), buildTimes\n                                                                                                                                                                           (buildX(),buildX()))))))),buildY())))\n\nlet sampleExpr2 =\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec build (rand, depth) = \n  if (depth = 0)\n  then let z = rand (0,1) in \n      match z with \n          0 -> buildX()\n        | 1 -> buildY()\n  else\n    let z = rand (2,8) in\n      match z with \n          2 -> buildSine(build (rand, depth-1))\n        | 3 -> buildCosine(build (rand, depth-1))\n        | 4 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n        | 5 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n        | 6 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n        | 7 -> buildPower(build(rand, depth-1))\n        | 8 -> buildKellysOp(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet g1 () = (7,1,90)\nlet g2 () = (8,13,99)\nlet g3 () = (6,54,77) \n\nlet c1 () = (4,33,99)\nlet c2 () = (8,13,99)\nlet c3 () = (5,11,107)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\n*)\n\nlet makeRand (seed1, seed2) = \n  let seed = (Array.of_list [seed1;seed2]) in\n  let s = Random.State.make seed in\n    (fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\n  if n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*X\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec ffor (low,high,f) = \n  if low > high then () else \n    let _ = f low in \n      ffor (low+1,high,f)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet emitGrayscale (f,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_g_\"^name) in\n  let chan = open_out (fname^\".pgm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z = f (x,y) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz = toIntensity(z) in\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz))) in \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet doRandomGray (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand(seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e = build (g,depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitGrayscale (f,n,name)\n\nlet _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\") ;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet emitColor (f1,f2,f3,n,name) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let fname  = (\"art_c_\"^name) in\n  let chan = open_out (fname^\".ppm\") in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let n2p1 = n*2+1 in   \n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ = \n    ffor (-n, n, \n          fun ix ->\n            ffor (-n, n, \n                  fun iy ->\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let x = toReal(ix,n) in\n                    let y = toReal(iy,n) in\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let z1 = f1 (x,y) in\n                    let z2 = f2 (x,y) in\n                    let z3 = f3 (x,y) in\n\n                    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    let iz1 = toIntensity(z1) in\n                    let iz2 = toIntensity(z2) in\n                    let iz3 = toIntensity(z3) in\n\n                      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                      output_char chan (char_of_int iz1);\n                      output_char chan (char_of_int iz2);\n                      output_char chan (char_of_int iz3);\n                 )) in  \n    close_out chan;\n    ignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\n    ignore(Sys.command (\"rm \"^fname^\".ppm\")) \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet doRandomColor (depth,seed1,seed2) =\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let g = makeRand (seed1,seed2) in\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n\n  (*XXXXXXXXXXXXXXXXXX*)\n  let n = 150 in\n  (*XXXXXXXXXXXXXXXXXX*)\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n    emitColor (f1,f2,f3,n,name)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 assoc\n                 (-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 23\n                 \"sample: assoc 1\"\n    );\n    (fun () -> mkTest \n                 assoc\n                 (-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])\n                 (-1)\n                 \"sample: assoc 2\"\n    ); \n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;6;2;4;12;2;13;6;9]\n                 [1;6;2;4;12;13;9]\n                 \"sample: removeDuplicates 2\"\n    );\n    (fun () -> mkTest \n                 removeDuplicates\n                 [1;1;1]\n                 [1]\n                 \"sample: removeDuplicates 2\"\n    );\n\n    (fun () -> mkTest \n                 wwhile \n                 ((fun x -> let xx = x*x*x in (xx, xx < 100)), 2) \n                 512 \n                 \"sample: wwhile 1\"\n    ); \n    (fun () -> mkTest \n                 \tfixpoint\n                 ((fun x -> truncate (1e6 *. cos (1e-6 *. float x))), 0)\n                 739085\n                 \"sample: fixpoint 1\"\n    ); \n\n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr, 150,\"sample\")\n                 ()\n                 \"sample: eval_fn 1: manual\"\n    ); \n    (fun () -> mkTest \n                 emitGrayscale\n                 (eval_fn sampleExpr2, 150,\"sample2\")\n                 ()\n                 \"sample: eval_fn 2: manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g1 ()))\n                 ()\n                 ()\n                 \"sample: gray 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g2 ()))\n                 ()\n                 ()\n                 \"sample: gray 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomGray (g3 ()))\n                 ()\n                 ()\n                 \"sample: gray 3 : manual\"\n    );\n\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c1 ()))\n                 ()\n                 ()\n                 \"sample: color 1 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c2 ()))\n                 ()\n                 ()\n                 \"sample: color 2 : manual\"\n    );\n    (fun () -> mkTest \n                 (fun () -> doRandomColor (c3 ()))\n                 ()\n                 ()\n                 \"sample: color 3 : manual\"\n    )] \n\nlet doTest f = \n  try f () with ex -> \n    Format.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\nlet _ =\n  let report = List.map doTest sampleTests                in\n  let _      = List.iter print130 (report@([scoreMsg()])) in\n  let _      = print130 (\"Compiled\\n\")                    in\n    (!score, !max)\n\n","file":"hw2.ml"}
