{"ocaml":[{"in":"let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n","type":"","out":""},{"in":"let _ = sqsum []","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [];;\n","type":"","out":""},{"in":"let _ = sqsum [1;2;3;4]","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sqsum [(-1); (-2); (-3); (-4)]","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [(-1); (-2); (-3); (-4)];;\n","type":"","out":""},{"in":"let pipe fs = \nlet f a x = (fun y -> x (a y)) in\nlet base = (fun x -> x) in\nList.fold_left f base fs","min":"\nlet pipe fs =\n  let f a x y = x (a y) in let base x = x in List.fold_left f base fs;;\n","type":"","out":""},{"in":"let _ = pipe [] 3","min":"\nlet pipe fs =\n  let f a x y = x (a y) in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n","type":"","out":""},{"in":"let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3","min":"\nlet pipe fs =\n  let f a x y = x (a y) in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n","type":"","out":""},{"in":"let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3","min":"\nlet pipe fs =\n  let f a x y = x (a y) in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n","type":"","out":""},{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base = h in\nlet l = t in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n","type":"","out":""},{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"---\" []","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"---\" [];;\n","type":"","out":""},{"in":"let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"\" [\"a\"; \"b\"; \"c\"; \"d\"; \"e\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"X\" [\"hello\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"X\" [\"hello\"];;\n","type":"","out":""},{"in":"let stringOfList f l = match l with\n| [] -> \"[]\"\n| h::t ->\nlet func a x = a ^ \"; \" ^ (f x) in\nlet base = (f h) in\n\"[\" ^ (List.fold_left func base t) ^ \"]\"","min":"\nlet stringOfList f l =\n  match l with\n  | [] -> \"[]\"\n  | h::t ->\n      let func a x = a ^ (\"; \" ^ (f x)) in\n      let base = f h in \"[\" ^ ((List.fold_left func base t) ^ \"]\");;\n","type":"","out":""},{"in":"let _ = stringOfList string_of_int [1;2;3;4;5;6]","min":"\nlet stringOfList f l =\n  match l with\n  | [] -> \"[]\"\n  | h::t ->\n      let func a x = a ^ (\"; \" ^ (f x)) in\n      let base = f h in \"[\" ^ ((List.fold_left func base t) ^ \"]\");;\n\nlet _ = stringOfList string_of_int [1; 2; 3; 4; 5; 6];;\n","type":"","out":""},{"in":"let _ = stringOfList (fun x -> x) [\"foo\"]","min":"\nlet stringOfList f l =\n  match l with\n  | [] -> \"[]\"\n  | h::t ->\n      let func a x = a ^ (\"; \" ^ (f x)) in\n      let base = f h in \"[\" ^ ((List.fold_left func base t) ^ \"]\");;\n\nlet _ = stringOfList (fun x  -> x) [\"foo\"];;\n","type":"","out":""},{"in":"let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]","min":"\nlet stringOfList f l =\n  match l with\n  | [] -> \"[]\"\n  | h::t ->\n      let func a x = a ^ (\"; \" ^ (f x)) in\n      let base = f h in \"[\" ^ ((List.fold_left func base t) ^ \"]\");;\n\nlet _ =\n  stringOfList (stringOfList string_of_int) [[1; 2; 3]; [4; 5]; [6]; []];;\n","type":"","out":""},{"in":"let rec clone x n = \nlet rec helper acc rep = match rep with\n| rep when rep <= 0 \n-> acc\n| _ \n-> helper ((x)::acc) (rep - 1)\nin\nhelper [] n","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n","type":"","out":""},{"in":"let _ = clone 3 5","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet _ = clone 3 5;;\n","type":"","out":""},{"in":"let _ = clone \"foo\" 2","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet _ = clone \"foo\" 2;;\n","type":"","out":""},{"in":"let _ = clone clone (-3)","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet _ = clone clone (-3);;\n","type":"","out":""},{"in":"let _ = clone clone 4","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet _ = clone clone 4;;\n","type":"","out":""},{"in":"let rec padZero l1 l2 = \nlet (len1, len2) = (List.length(l1), List.length(l2)) in\nif len1 < len2 then\n((List.rev(List.append (List.rev(l1)) (clone 0 (len2-len1)))), l2)\nelse if len2 < len1 then\n(l1, (List.rev(List.append (List.rev(l2)) (clone 0 (len1-len2)))))\nelse\n(l1, l2)","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet rec padZero l1 l2 =\n  let (len1,len2) = ((List.length l1), (List.length l2)) in\n  if len1 < len2\n  then ((List.rev (List.append (List.rev l1) (clone 0 (len2 - len1)))), l2)\n  else\n    if len2 < len1\n    then (l1, (List.rev (List.append (List.rev l2) (clone 0 (len1 - len2)))))\n    else (l1, l2);;\n","type":"","out":""},{"in":"let _ = padZero [9;9] [1;0;0;2]","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet rec padZero l1 l2 =\n  let (len1,len2) = ((List.length l1), (List.length l2)) in\n  if len1 < len2\n  then ((List.rev (List.append (List.rev l1) (clone 0 (len2 - len1)))), l2)\n  else\n    if len2 < len1\n    then (l1, (List.rev (List.append (List.rev l2) (clone 0 (len1 - len2)))))\n    else (l1, l2);;\n\nlet _ = padZero [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = padZero [1;0;0;2] [9;9]","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet rec padZero l1 l2 =\n  let (len1,len2) = ((List.length l1), (List.length l2)) in\n  if len1 < len2\n  then ((List.rev (List.append (List.rev l1) (clone 0 (len2 - len1)))), l2)\n  else\n    if len2 < len1\n    then (l1, (List.rev (List.append (List.rev l2) (clone 0 (len1 - len2)))))\n    else (l1, l2);;\n\nlet _ = padZero [1; 0; 0; 2] [9; 9];;\n","type":"","out":""},{"in":"let _ = padZero [1] [2]","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet rec padZero l1 l2 =\n  let (len1,len2) = ((List.length l1), (List.length l2)) in\n  if len1 < len2\n  then ((List.rev (List.append (List.rev l1) (clone 0 (len2 - len1)))), l2)\n  else\n    if len2 < len1\n    then (l1, (List.rev (List.append (List.rev l2) (clone 0 (len1 - len2)))))\n    else (l1, l2);;\n\nlet _ = padZero [1] [2];;\n","type":"","out":""},{"in":"let rec removeZero l = match l with\n| [] -> []\n| 0::t -> removeZero t\n| h::t -> l","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;1;0;0;2]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet _ = removeZero [0; 0; 0; 1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = removeZero [9;9]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet _ = removeZero [9; 9];;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;0]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet _ = removeZero [0; 0; 0; 0];;\n","type":"","out":""},{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (old_carry, result) = a in\nlet (add1, add2) = x in\nlet sum = add1 + add2 + old_carry in\nlet new_carry = sum/10 in\n(new_carry, ((sum mod 10)::result))\nin\nlet base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (last_carry, res) = List.fold_left f base args in\nlast_carry::res\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet rec padZero l1 l2 =\n  let (len1,len2) = ((List.length l1), (List.length l2)) in\n  if len1 < len2\n  then ((List.rev (List.append (List.rev l1) (clone 0 (len2 - len1)))), l2)\n  else\n    if len2 < len1\n    then (l1, (List.rev (List.append (List.rev l2) (clone 0 (len1 - len2)))))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (old_carry,result) = a in\n      let (add1,add2) = x in\n      let sum = (add1 + add2) + old_carry in\n      let new_carry = sum / 10 in (new_carry, ((sum mod 10) :: result)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (last_carry,res) = List.fold_left f base args in last_carry :: res in\n  removeZero (add (padZero l1 l2));;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9] [1;0;0;2]","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet rec padZero l1 l2 =\n  let (len1,len2) = ((List.length l1), (List.length l2)) in\n  if len1 < len2\n  then ((List.rev (List.append (List.rev l1) (clone 0 (len2 - len1)))), l2)\n  else\n    if len2 < len1\n    then (l1, (List.rev (List.append (List.rev l2) (clone 0 (len1 - len2)))))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (old_carry,result) = a in\n      let (add1,add2) = x in\n      let sum = (add1 + add2) + old_carry in\n      let new_carry = sum / 10 in (new_carry, ((sum mod 10) :: result)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (last_carry,res) = List.fold_left f base args in last_carry :: res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9;9;9] [9;9;9]","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet rec padZero l1 l2 =\n  let (len1,len2) = ((List.length l1), (List.length l2)) in\n  if len1 < len2\n  then ((List.rev (List.append (List.rev l1) (clone 0 (len2 - len1)))), l2)\n  else\n    if len2 < len1\n    then (l1, (List.rev (List.append (List.rev l2) (clone 0 (len1 - len2)))))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (old_carry,result) = a in\n      let (add1,add2) = x in\n      let sum = (add1 + add2) + old_carry in\n      let new_carry = sum / 10 in (new_carry, ((sum mod 10) :: result)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (last_carry,res) = List.fold_left f base args in last_carry :: res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n","type":"","out":""},{"in":"let rec mulByDigit i l =\nlet rec multiply (carry, acc) rem = match rem with\n| [] -> (match carry with \n| 0 -> acc\n| _ -> carry::acc)\n| h::t -> \nlet multi = (i * h) + carry in\nlet digit = (multi mod 10) in\nlet new_carry = (multi/10) \nin\nmultiply (new_carry, (digit::acc)) t\nin\nmultiply (0, []) (List.rev(l))","min":"\nlet rec mulByDigit i l =\n  let rec multiply (carry,acc) rem =\n    match rem with\n    | [] -> (match carry with | 0 -> acc | _ -> carry :: acc)\n    | h::t ->\n        let multi = (i * h) + carry in\n        let digit = multi mod 10 in\n        let new_carry = multi / 10 in multiply (new_carry, (digit :: acc)) t in\n  multiply (0, []) (List.rev l);;\n","type":"","out":""},{"in":"let _ = mulByDigit 1 [0]","min":"\nlet rec mulByDigit i l =\n  let rec multiply (carry,acc) rem =\n    match rem with\n    | [] -> (match carry with | 0 -> acc | _ -> carry :: acc)\n    | h::t ->\n        let multi = (i * h) + carry in\n        let digit = multi mod 10 in\n        let new_carry = multi / 10 in multiply (new_carry, (digit :: acc)) t in\n  multiply (0, []) (List.rev l);;\n\nlet _ = mulByDigit 1 [0];;\n","type":"","out":""},{"in":"let _ = mulByDigit 9 [9;9;9;9]","min":"\nlet rec mulByDigit i l =\n  let rec multiply (carry,acc) rem =\n    match rem with\n    | [] -> (match carry with | 0 -> acc | _ -> carry :: acc)\n    | h::t ->\n        let multi = (i * h) + carry in\n        let digit = multi mod 10 in\n        let new_carry = multi / 10 in multiply (new_carry, (digit :: acc)) t in\n  multiply (0, []) (List.rev l);;\n\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let bigMul l1 l2 =\nlet f a x = let (zeroes, acc) = a in\nlet multiplied = (mulByDigit x l1) @ zeroes in\nlet sum = bigAdd multiplied acc in\nmatch sum with \n| [] -> (0::zeroes, [0])\n| _  -> ((0::zeroes), sum) in\nlet base = ([], [0]) in\nlet args = List.rev(l2) in\nlet (_, res) = List.fold_left f base args in\nres","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet rec padZero l1 l2 =\n  let (len1,len2) = ((List.length l1), (List.length l2)) in\n  if len1 < len2\n  then ((List.rev (List.append (List.rev l1) (clone 0 (len2 - len1)))), l2)\n  else\n    if len2 < len1\n    then (l1, (List.rev (List.append (List.rev l2) (clone 0 (len1 - len2)))))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (old_carry,result) = a in\n      let (add1,add2) = x in\n      let sum = (add1 + add2) + old_carry in\n      let new_carry = sum / 10 in (new_carry, ((sum mod 10) :: result)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (last_carry,res) = List.fold_left f base args in last_carry :: res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec multiply (carry,acc) rem =\n    match rem with\n    | [] -> (match carry with | 0 -> acc | _ -> carry :: acc)\n    | h::t ->\n        let multi = (i * h) + carry in\n        let digit = multi mod 10 in\n        let new_carry = multi / 10 in multiply (new_carry, (digit :: acc)) t in\n  multiply (0, []) (List.rev l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (zeroes,acc) = a in\n    let multiplied = (mulByDigit x l1) @ zeroes in\n    let sum = bigAdd multiplied acc in\n    match sum with | [] -> ((0 :: zeroes), [0]) | _ -> ((0 :: zeroes), sum) in\n  let base = ([], [0]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n","type":"","out":""},{"in":"let _ = bigMul [9;9;9;9] [9;9;9;9]","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet rec padZero l1 l2 =\n  let (len1,len2) = ((List.length l1), (List.length l2)) in\n  if len1 < len2\n  then ((List.rev (List.append (List.rev l1) (clone 0 (len2 - len1)))), l2)\n  else\n    if len2 < len1\n    then (l1, (List.rev (List.append (List.rev l2) (clone 0 (len1 - len2)))))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (old_carry,result) = a in\n      let (add1,add2) = x in\n      let sum = (add1 + add2) + old_carry in\n      let new_carry = sum / 10 in (new_carry, ((sum mod 10) :: result)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (last_carry,res) = List.fold_left f base args in last_carry :: res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec multiply (carry,acc) rem =\n    match rem with\n    | [] -> (match carry with | 0 -> acc | _ -> carry :: acc)\n    | h::t ->\n        let multi = (i * h) + carry in\n        let digit = multi mod 10 in\n        let new_carry = multi / 10 in multiply (new_carry, (digit :: acc)) t in\n  multiply (0, []) (List.rev l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (zeroes,acc) = a in\n    let multiplied = (mulByDigit x l1) @ zeroes in\n    let sum = bigAdd multiplied acc in\n    match sum with | [] -> ((0 :: zeroes), [0]) | _ -> ((0 :: zeroes), sum) in\n  let base = ([], [0]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet rec padZero l1 l2 =\n  let (len1,len2) = ((List.length l1), (List.length l2)) in\n  if len1 < len2\n  then ((List.rev (List.append (List.rev l1) (clone 0 (len2 - len1)))), l2)\n  else\n    if len2 < len1\n    then (l1, (List.rev (List.append (List.rev l2) (clone 0 (len1 - len2)))))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (old_carry,result) = a in\n      let (add1,add2) = x in\n      let sum = (add1 + add2) + old_carry in\n      let new_carry = sum / 10 in (new_carry, ((sum mod 10) :: result)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (last_carry,res) = List.fold_left f base args in last_carry :: res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec multiply (carry,acc) rem =\n    match rem with\n    | [] -> (match carry with | 0 -> acc | _ -> carry :: acc)\n    | h::t ->\n        let multi = (i * h) + carry in\n        let digit = multi mod 10 in\n        let new_carry = multi / 10 in multiply (new_carry, (digit :: acc)) t in\n  multiply (0, []) (List.rev l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (zeroes,acc) = a in\n    let multiplied = (mulByDigit x l1) @ zeroes in\n    let sum = bigAdd multiplied acc in\n    match sum with | [] -> ((0 :: zeroes), [0]) | _ -> ((0 :: zeroes), sum) in\n  let base = ([], [0]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9; 9] [9; 9; 9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigMul [1;0;0;0;0] [1;0;5]","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet rec padZero l1 l2 =\n  let (len1,len2) = ((List.length l1), (List.length l2)) in\n  if len1 < len2\n  then ((List.rev (List.append (List.rev l1) (clone 0 (len2 - len1)))), l2)\n  else\n    if len2 < len1\n    then (l1, (List.rev (List.append (List.rev l2) (clone 0 (len1 - len2)))))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (old_carry,result) = a in\n      let (add1,add2) = x in\n      let sum = (add1 + add2) + old_carry in\n      let new_carry = sum / 10 in (new_carry, ((sum mod 10) :: result)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (last_carry,res) = List.fold_left f base args in last_carry :: res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec multiply (carry,acc) rem =\n    match rem with\n    | [] -> (match carry with | 0 -> acc | _ -> carry :: acc)\n    | h::t ->\n        let multi = (i * h) + carry in\n        let digit = multi mod 10 in\n        let new_carry = multi / 10 in multiply (new_carry, (digit :: acc)) t in\n  multiply (0, []) (List.rev l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (zeroes,acc) = a in\n    let multiplied = (mulByDigit x l1) @ zeroes in\n    let sum = bigAdd multiplied acc in\n    match sum with | [] -> ((0 :: zeroes), [0]) | _ -> ((0 :: zeroes), sum) in\n  let base = ([], [0]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1; 0; 0; 0; 0] [1; 0; 5];;\n","type":"","out":""},{"in":"let _ = bigAdd ((mulByDigit 1 [1]) @ [0]) [0]","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet rec padZero l1 l2 =\n  let (len1,len2) = ((List.length l1), (List.length l2)) in\n  if len1 < len2\n  then ((List.rev (List.append (List.rev l1) (clone 0 (len2 - len1)))), l2)\n  else\n    if len2 < len1\n    then (l1, (List.rev (List.append (List.rev l2) (clone 0 (len1 - len2)))))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (old_carry,result) = a in\n      let (add1,add2) = x in\n      let sum = (add1 + add2) + old_carry in\n      let new_carry = sum / 10 in (new_carry, ((sum mod 10) :: result)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (last_carry,res) = List.fold_left f base args in last_carry :: res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec multiply (carry,acc) rem =\n    match rem with\n    | [] -> (match carry with | 0 -> acc | _ -> carry :: acc)\n    | h::t ->\n        let multi = (i * h) + carry in\n        let digit = multi mod 10 in\n        let new_carry = multi / 10 in multiply (new_carry, (digit :: acc)) t in\n  multiply (0, []) (List.rev l);;\n\nlet _ = bigAdd ((mulByDigit 1 [1]) @ [0]) [0];;\n","type":"","out":""},{"in":"let _ = bigMul [1] [1;0]","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet rec padZero l1 l2 =\n  let (len1,len2) = ((List.length l1), (List.length l2)) in\n  if len1 < len2\n  then ((List.rev (List.append (List.rev l1) (clone 0 (len2 - len1)))), l2)\n  else\n    if len2 < len1\n    then (l1, (List.rev (List.append (List.rev l2) (clone 0 (len1 - len2)))))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (old_carry,result) = a in\n      let (add1,add2) = x in\n      let sum = (add1 + add2) + old_carry in\n      let new_carry = sum / 10 in (new_carry, ((sum mod 10) :: result)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (last_carry,res) = List.fold_left f base args in last_carry :: res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec multiply (carry,acc) rem =\n    match rem with\n    | [] -> (match carry with | 0 -> acc | _ -> carry :: acc)\n    | h::t ->\n        let multi = (i * h) + carry in\n        let digit = multi mod 10 in\n        let new_carry = multi / 10 in multiply (new_carry, (digit :: acc)) t in\n  multiply (0, []) (List.rev l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (zeroes,acc) = a in\n    let multiplied = (mulByDigit x l1) @ zeroes in\n    let sum = bigAdd multiplied acc in\n    match sum with | [] -> ((0 :: zeroes), [0]) | _ -> ((0 :: zeroes), sum) in\n  let base = ([], [0]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1] [1; 0];;\n","type":"","out":""},{"in":"let _ = bigMul [0] []","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet rec padZero l1 l2 =\n  let (len1,len2) = ((List.length l1), (List.length l2)) in\n  if len1 < len2\n  then ((List.rev (List.append (List.rev l1) (clone 0 (len2 - len1)))), l2)\n  else\n    if len2 < len1\n    then (l1, (List.rev (List.append (List.rev l2) (clone 0 (len1 - len2)))))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (old_carry,result) = a in\n      let (add1,add2) = x in\n      let sum = (add1 + add2) + old_carry in\n      let new_carry = sum / 10 in (new_carry, ((sum mod 10) :: result)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (last_carry,res) = List.fold_left f base args in last_carry :: res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec multiply (carry,acc) rem =\n    match rem with\n    | [] -> (match carry with | 0 -> acc | _ -> carry :: acc)\n    | h::t ->\n        let multi = (i * h) + carry in\n        let digit = multi mod 10 in\n        let new_carry = multi / 10 in multiply (new_carry, (digit :: acc)) t in\n  multiply (0, []) (List.rev l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (zeroes,acc) = a in\n    let multiplied = (mulByDigit x l1) @ zeroes in\n    let sum = bigAdd multiplied acc in\n    match sum with | [] -> ((0 :: zeroes), [0]) | _ -> ((0 :: zeroes), sum) in\n  let base = ([], [0]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [0] [];;\n","type":"","out":""},{"in":"let key = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130 = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ ((Printexc.to_string e) ^ \"\\n\"));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n","type":"","out":""},{"in":"let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","min":"\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n","type":"","out":""},{"in":"let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n\nlet drop_paren s =\n  implode\n    (List.filter (fun c  -> not (List.mem c ['('; ' '; ')'])) (explode s));;\n","type":"","out":""},{"in":"let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","min":"\nlet eq_real p (r1,r2) = ((r1 -. r2) < p) || ((r2 -. r1) < p);;\n","type":"","out":""},{"in":"let wrap_curried_2 f (a,b) = f a b","min":"\nlet wrap_curried_2 f (a,b) = f a b;;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":8063},"type":"eval"},"cursor":296,"time":1.398970188445372e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x * x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = (fun y -> x (a y)) in\n  let base = (fun x -> x) in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a^sep^x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = match l with\n  | [] -> \"[]\"\n  | h::t ->\n      let func a x = a ^ \"; \" ^ (f x) in\n      let base = (f h) in\n        \"[\" ^ (List.fold_left func base t) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper acc rep = match rep with\n    | rep when rep <= 0 \n      -> acc\n    | _ \n      -> helper ((x)::acc) (rep - 1)\n  in\n    helper [] n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\nlet _ = clone clone 4;;\n\n\nlet rec padZero l1 l2 = \n  let (len1, len2) = (List.length(l1), List.length(l2)) in\n    if len1 < len2 then\n      ((List.rev(List.append (List.rev(l1)) (clone 0 (len2-len1)))), l2)\n    else if len2 < len1 then\n      (l1, (List.rev(List.append (List.rev(l2)) (clone 0 (len1-len2)))))\n    else\n      (l1, l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \nlet _ = padZero [1] [2]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | 0::t -> removeZero t\n  | h::t -> l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = let (old_carry, result) = a in\n      let (add1, add2) = x in\n      let sum = add1 + add2 + old_carry in\n      let new_carry = sum/10 in\n        (new_carry, ((sum mod 10)::result))\n    in\n    let base = (0, []) in\n    let args = List.rev(List.combine l1 l2) in\n    let (last_carry, res) = List.fold_left f base args in\n      last_carry::res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\n\nlet rec mulByDigit i l =\n  let rec multiply (carry, acc) rem = match rem with\n    | [] -> (match carry with \n              | 0 -> acc\n              | _ -> carry::acc)\n    | h::t -> \n        let multi = (i * h) + carry in\n        let digit = (multi mod 10) in\n        let new_carry = (multi/10) \n        in\n          multiply (new_carry, (digit::acc)) t\n  in\n    multiply (0, []) (List.rev(l))\n\nlet _ = mulByDigit 1 [0]\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 =\n  let f a x = let (zeroes, acc) = a in\n    let multiplied = (mulByDigit x l1) @ zeroes in\n    let sum = bigAdd multiplied acc in\n      match sum with \n        | [] -> (0::zeroes, [0])\n        | _  -> ((0::zeroes), sum) in\n  let base = ([], [0]) in\n  let args = List.rev(l2) in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9]\nlet _ = bigMul [1;0;0;0;0] [1;0;5]\nlet _ = bigAdd ((mulByDigit 1 [1]) @ [0]) [0]\nlet _ = bigMul [1] [1;0]\nlet _ = bigMul [0] []\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n","type":"","out":""},{"in":"let _ = sqsum []","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [];;\n","type":"","out":""},{"in":"let _ = sqsum [1;2;3;4]","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sqsum [(-1); (-2); (-3); (-4)]","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [(-1); (-2); (-3); (-4)];;\n","type":"","out":""},{"in":"let pipe fs = \nlet f a x = (fun y -> x (a y)) in\nlet base = (fun x -> x) in\nList.fold_left f base fs","min":"\nlet pipe fs =\n  let f a x y = x (a y) in let base x = x in List.fold_left f base fs;;\n","type":"","out":""},{"in":"let _ = pipe [] 3","min":"\nlet pipe fs =\n  let f a x y = x (a y) in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n","type":"","out":""},{"in":"let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3","min":"\nlet pipe fs =\n  let f a x y = x (a y) in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n","type":"","out":""},{"in":"let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3","min":"\nlet pipe fs =\n  let f a x y = x (a y) in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n","type":"","out":""},{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base = h in\nlet l = t in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n","type":"","out":""},{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"---\" []","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"---\" [];;\n","type":"","out":""},{"in":"let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"\" [\"a\"; \"b\"; \"c\"; \"d\"; \"e\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"X\" [\"hello\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"X\" [\"hello\"];;\n","type":"","out":""},{"in":"let stringOfList f l = match l with\n| [] -> \"[]\"\n| h::t ->\nlet func a x = a ^ \"; \" ^ (f x) in\nlet base = (f h) in\n\"[\" ^ (List.fold_left func base t) ^ \"]\"","min":"\nlet stringOfList f l =\n  match l with\n  | [] -> \"[]\"\n  | h::t ->\n      let func a x = a ^ (\"; \" ^ (f x)) in\n      let base = f h in \"[\" ^ ((List.fold_left func base t) ^ \"]\");;\n","type":"","out":""},{"in":"let _ = stringOfList string_of_int [1;2;3;4;5;6]","min":"\nlet stringOfList f l =\n  match l with\n  | [] -> \"[]\"\n  | h::t ->\n      let func a x = a ^ (\"; \" ^ (f x)) in\n      let base = f h in \"[\" ^ ((List.fold_left func base t) ^ \"]\");;\n\nlet _ = stringOfList string_of_int [1; 2; 3; 4; 5; 6];;\n","type":"","out":""},{"in":"let _ = stringOfList (fun x -> x) [\"foo\"]","min":"\nlet stringOfList f l =\n  match l with\n  | [] -> \"[]\"\n  | h::t ->\n      let func a x = a ^ (\"; \" ^ (f x)) in\n      let base = f h in \"[\" ^ ((List.fold_left func base t) ^ \"]\");;\n\nlet _ = stringOfList (fun x  -> x) [\"foo\"];;\n","type":"","out":""},{"in":"let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]","min":"\nlet stringOfList f l =\n  match l with\n  | [] -> \"[]\"\n  | h::t ->\n      let func a x = a ^ (\"; \" ^ (f x)) in\n      let base = f h in \"[\" ^ ((List.fold_left func base t) ^ \"]\");;\n\nlet _ =\n  stringOfList (stringOfList string_of_int) [[1; 2; 3]; [4; 5]; [6]; []];;\n","type":"","out":""},{"in":"let rec clone x n = \nlet rec helper acc rep = match rep with\n| rep when rep <= 0 \n-> acc\n| _ \n-> helper ((x)::acc) (rep - 1)\nin\nhelper [] n","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n","type":"","out":""},{"in":"let _ = clone 3 5","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet _ = clone 3 5;;\n","type":"","out":""},{"in":"let _ = clone \"foo\" 2","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet _ = clone \"foo\" 2;;\n","type":"","out":""},{"in":"let _ = clone clone (-3)","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet _ = clone clone (-3);;\n","type":"","out":""},{"in":"let _ = clone clone 4","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet _ = clone clone 4;;\n","type":"","out":""},{"in":"let rec padZero l1 l2 = \nlet (len1, len2) = (List.length(l1), List.length(l2)) in\nif len1 < len2 then\n((List.rev(List.append (List.rev(l1)) (clone 0 (len2-len1)))), l2)\nelse if len2 < len1 then\n(l1, (List.rev(List.append (List.rev(l2)) (clone 0 (len1-len2)))))\nelse\n(l1, l2)","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet rec padZero l1 l2 =\n  let (len1,len2) = ((List.length l1), (List.length l2)) in\n  if len1 < len2\n  then ((List.rev (List.append (List.rev l1) (clone 0 (len2 - len1)))), l2)\n  else\n    if len2 < len1\n    then (l1, (List.rev (List.append (List.rev l2) (clone 0 (len1 - len2)))))\n    else (l1, l2);;\n","type":"","out":""},{"in":"let _ = padZero [9;9] [1;0;0;2]","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet rec padZero l1 l2 =\n  let (len1,len2) = ((List.length l1), (List.length l2)) in\n  if len1 < len2\n  then ((List.rev (List.append (List.rev l1) (clone 0 (len2 - len1)))), l2)\n  else\n    if len2 < len1\n    then (l1, (List.rev (List.append (List.rev l2) (clone 0 (len1 - len2)))))\n    else (l1, l2);;\n\nlet _ = padZero [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = padZero [1;0;0;2] [9;9]","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet rec padZero l1 l2 =\n  let (len1,len2) = ((List.length l1), (List.length l2)) in\n  if len1 < len2\n  then ((List.rev (List.append (List.rev l1) (clone 0 (len2 - len1)))), l2)\n  else\n    if len2 < len1\n    then (l1, (List.rev (List.append (List.rev l2) (clone 0 (len1 - len2)))))\n    else (l1, l2);;\n\nlet _ = padZero [1; 0; 0; 2] [9; 9];;\n","type":"","out":""},{"in":"let _ = padZero [1] [2]","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet rec padZero l1 l2 =\n  let (len1,len2) = ((List.length l1), (List.length l2)) in\n  if len1 < len2\n  then ((List.rev (List.append (List.rev l1) (clone 0 (len2 - len1)))), l2)\n  else\n    if len2 < len1\n    then (l1, (List.rev (List.append (List.rev l2) (clone 0 (len1 - len2)))))\n    else (l1, l2);;\n\nlet _ = padZero [1] [2];;\n","type":"","out":""},{"in":"let rec removeZero l = match l with\n| [] -> []\n| 0::t -> removeZero t\n| h::t -> l","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;1;0;0;2]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet _ = removeZero [0; 0; 0; 1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = removeZero [9;9]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet _ = removeZero [9; 9];;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;0]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet _ = removeZero [0; 0; 0; 0];;\n","type":"","out":""},{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (old_carry, result) = a in\nlet (add1, add2) = x in\nlet sum = add1 + add2 + old_carry in\nlet new_carry = sum/10 in\n(new_carry, ((sum mod 10)::result))\nin\nlet base = (0, []) in\nlet args = List.rev(List.combine (0::l1) (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet rec padZero l1 l2 =\n  let (len1,len2) = ((List.length l1), (List.length l2)) in\n  if len1 < len2\n  then ((List.rev (List.append (List.rev l1) (clone 0 (len2 - len1)))), l2)\n  else\n    if len2 < len1\n    then (l1, (List.rev (List.append (List.rev l2) (clone 0 (len1 - len2)))))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (old_carry,result) = a in\n      let (add1,add2) = x in\n      let sum = (add1 + add2) + old_carry in\n      let new_carry = sum / 10 in (new_carry, ((sum mod 10) :: result)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9] [1;0;0;2]","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet rec padZero l1 l2 =\n  let (len1,len2) = ((List.length l1), (List.length l2)) in\n  if len1 < len2\n  then ((List.rev (List.append (List.rev l1) (clone 0 (len2 - len1)))), l2)\n  else\n    if len2 < len1\n    then (l1, (List.rev (List.append (List.rev l2) (clone 0 (len1 - len2)))))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (old_carry,result) = a in\n      let (add1,add2) = x in\n      let sum = (add1 + add2) + old_carry in\n      let new_carry = sum / 10 in (new_carry, ((sum mod 10) :: result)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9;9;9] [9;9;9]","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet rec padZero l1 l2 =\n  let (len1,len2) = ((List.length l1), (List.length l2)) in\n  if len1 < len2\n  then ((List.rev (List.append (List.rev l1) (clone 0 (len2 - len1)))), l2)\n  else\n    if len2 < len1\n    then (l1, (List.rev (List.append (List.rev l2) (clone 0 (len1 - len2)))))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (old_carry,result) = a in\n      let (add1,add2) = x in\n      let sum = (add1 + add2) + old_carry in\n      let new_carry = sum / 10 in (new_carry, ((sum mod 10) :: result)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n","type":"","out":""},{"in":"let rec mulByDigit i l =\nlet rec multiply acc i = match i with\n| 0 -> acc\n| _ -> multiply (bigAdd acc l) (i-1)\nin\nmultiply [0] i","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet rec padZero l1 l2 =\n  let (len1,len2) = ((List.length l1), (List.length l2)) in\n  if len1 < len2\n  then ((List.rev (List.append (List.rev l1) (clone 0 (len2 - len1)))), l2)\n  else\n    if len2 < len1\n    then (l1, (List.rev (List.append (List.rev l2) (clone 0 (len1 - len2)))))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (old_carry,result) = a in\n      let (add1,add2) = x in\n      let sum = (add1 + add2) + old_carry in\n      let new_carry = sum / 10 in (new_carry, ((sum mod 10) :: result)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec multiply acc i =\n    match i with | 0 -> acc | _ -> multiply (bigAdd acc l) (i - 1) in\n  multiply [0] i;;\n","type":"","out":""},{"in":"let _ = mulByDigit 1 [0]","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet rec padZero l1 l2 =\n  let (len1,len2) = ((List.length l1), (List.length l2)) in\n  if len1 < len2\n  then ((List.rev (List.append (List.rev l1) (clone 0 (len2 - len1)))), l2)\n  else\n    if len2 < len1\n    then (l1, (List.rev (List.append (List.rev l2) (clone 0 (len1 - len2)))))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (old_carry,result) = a in\n      let (add1,add2) = x in\n      let sum = (add1 + add2) + old_carry in\n      let new_carry = sum / 10 in (new_carry, ((sum mod 10) :: result)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec multiply acc i =\n    match i with | 0 -> acc | _ -> multiply (bigAdd acc l) (i - 1) in\n  multiply [0] i;;\n\nlet _ = mulByDigit 1 [0];;\n","type":"","out":""},{"in":"let _ = mulByDigit 9 [9;9;9;9]","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet rec padZero l1 l2 =\n  let (len1,len2) = ((List.length l1), (List.length l2)) in\n  if len1 < len2\n  then ((List.rev (List.append (List.rev l1) (clone 0 (len2 - len1)))), l2)\n  else\n    if len2 < len1\n    then (l1, (List.rev (List.append (List.rev l2) (clone 0 (len1 - len2)))))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (old_carry,result) = a in\n      let (add1,add2) = x in\n      let sum = (add1 + add2) + old_carry in\n      let new_carry = sum / 10 in (new_carry, ((sum mod 10) :: result)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec multiply acc i =\n    match i with | 0 -> acc | _ -> multiply (bigAdd acc l) (i - 1) in\n  multiply [0] i;;\n\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let bigMul l1 l2 =\nlet f a x = let (zeroes, acc) = a in\nlet multiplied = (mulByDigit x l1) @ zeroes in\nlet sum = bigAdd multiplied acc in\nmatch sum with \n| [] -> (0::zeroes, [0])\n| _  -> ((0::zeroes), sum) in\nlet base = ([], [0]) in\nlet args = List.rev(l2) in\nlet (_, res) = List.fold_left f base args in\nres","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet rec padZero l1 l2 =\n  let (len1,len2) = ((List.length l1), (List.length l2)) in\n  if len1 < len2\n  then ((List.rev (List.append (List.rev l1) (clone 0 (len2 - len1)))), l2)\n  else\n    if len2 < len1\n    then (l1, (List.rev (List.append (List.rev l2) (clone 0 (len1 - len2)))))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (old_carry,result) = a in\n      let (add1,add2) = x in\n      let sum = (add1 + add2) + old_carry in\n      let new_carry = sum / 10 in (new_carry, ((sum mod 10) :: result)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec multiply acc i =\n    match i with | 0 -> acc | _ -> multiply (bigAdd acc l) (i - 1) in\n  multiply [0] i;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (zeroes,acc) = a in\n    let multiplied = (mulByDigit x l1) @ zeroes in\n    let sum = bigAdd multiplied acc in\n    match sum with | [] -> ((0 :: zeroes), [0]) | _ -> ((0 :: zeroes), sum) in\n  let base = ([], [0]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n","type":"","out":""},{"in":"let _ = bigMul [9;9;9;9] [9;9;9;9]","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet rec padZero l1 l2 =\n  let (len1,len2) = ((List.length l1), (List.length l2)) in\n  if len1 < len2\n  then ((List.rev (List.append (List.rev l1) (clone 0 (len2 - len1)))), l2)\n  else\n    if len2 < len1\n    then (l1, (List.rev (List.append (List.rev l2) (clone 0 (len1 - len2)))))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (old_carry,result) = a in\n      let (add1,add2) = x in\n      let sum = (add1 + add2) + old_carry in\n      let new_carry = sum / 10 in (new_carry, ((sum mod 10) :: result)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec multiply acc i =\n    match i with | 0 -> acc | _ -> multiply (bigAdd acc l) (i - 1) in\n  multiply [0] i;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (zeroes,acc) = a in\n    let multiplied = (mulByDigit x l1) @ zeroes in\n    let sum = bigAdd multiplied acc in\n    match sum with | [] -> ((0 :: zeroes), [0]) | _ -> ((0 :: zeroes), sum) in\n  let base = ([], [0]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet rec padZero l1 l2 =\n  let (len1,len2) = ((List.length l1), (List.length l2)) in\n  if len1 < len2\n  then ((List.rev (List.append (List.rev l1) (clone 0 (len2 - len1)))), l2)\n  else\n    if len2 < len1\n    then (l1, (List.rev (List.append (List.rev l2) (clone 0 (len1 - len2)))))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (old_carry,result) = a in\n      let (add1,add2) = x in\n      let sum = (add1 + add2) + old_carry in\n      let new_carry = sum / 10 in (new_carry, ((sum mod 10) :: result)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec multiply acc i =\n    match i with | 0 -> acc | _ -> multiply (bigAdd acc l) (i - 1) in\n  multiply [0] i;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (zeroes,acc) = a in\n    let multiplied = (mulByDigit x l1) @ zeroes in\n    let sum = bigAdd multiplied acc in\n    match sum with | [] -> ((0 :: zeroes), [0]) | _ -> ((0 :: zeroes), sum) in\n  let base = ([], [0]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9; 9] [9; 9; 9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigMul [1;0;0;0;0] [1;0;5]","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet rec padZero l1 l2 =\n  let (len1,len2) = ((List.length l1), (List.length l2)) in\n  if len1 < len2\n  then ((List.rev (List.append (List.rev l1) (clone 0 (len2 - len1)))), l2)\n  else\n    if len2 < len1\n    then (l1, (List.rev (List.append (List.rev l2) (clone 0 (len1 - len2)))))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (old_carry,result) = a in\n      let (add1,add2) = x in\n      let sum = (add1 + add2) + old_carry in\n      let new_carry = sum / 10 in (new_carry, ((sum mod 10) :: result)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec multiply acc i =\n    match i with | 0 -> acc | _ -> multiply (bigAdd acc l) (i - 1) in\n  multiply [0] i;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (zeroes,acc) = a in\n    let multiplied = (mulByDigit x l1) @ zeroes in\n    let sum = bigAdd multiplied acc in\n    match sum with | [] -> ((0 :: zeroes), [0]) | _ -> ((0 :: zeroes), sum) in\n  let base = ([], [0]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1; 0; 0; 0; 0] [1; 0; 5];;\n","type":"","out":""},{"in":"let _ = bigAdd ((mulByDigit 1 [1]) @ [0]) [0]","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet rec padZero l1 l2 =\n  let (len1,len2) = ((List.length l1), (List.length l2)) in\n  if len1 < len2\n  then ((List.rev (List.append (List.rev l1) (clone 0 (len2 - len1)))), l2)\n  else\n    if len2 < len1\n    then (l1, (List.rev (List.append (List.rev l2) (clone 0 (len1 - len2)))))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (old_carry,result) = a in\n      let (add1,add2) = x in\n      let sum = (add1 + add2) + old_carry in\n      let new_carry = sum / 10 in (new_carry, ((sum mod 10) :: result)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec multiply acc i =\n    match i with | 0 -> acc | _ -> multiply (bigAdd acc l) (i - 1) in\n  multiply [0] i;;\n\nlet _ = bigAdd ((mulByDigit 1 [1]) @ [0]) [0];;\n","type":"","out":""},{"in":"let _ = bigMul [1] [1;0]","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet rec padZero l1 l2 =\n  let (len1,len2) = ((List.length l1), (List.length l2)) in\n  if len1 < len2\n  then ((List.rev (List.append (List.rev l1) (clone 0 (len2 - len1)))), l2)\n  else\n    if len2 < len1\n    then (l1, (List.rev (List.append (List.rev l2) (clone 0 (len1 - len2)))))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (old_carry,result) = a in\n      let (add1,add2) = x in\n      let sum = (add1 + add2) + old_carry in\n      let new_carry = sum / 10 in (new_carry, ((sum mod 10) :: result)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec multiply acc i =\n    match i with | 0 -> acc | _ -> multiply (bigAdd acc l) (i - 1) in\n  multiply [0] i;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (zeroes,acc) = a in\n    let multiplied = (mulByDigit x l1) @ zeroes in\n    let sum = bigAdd multiplied acc in\n    match sum with | [] -> ((0 :: zeroes), [0]) | _ -> ((0 :: zeroes), sum) in\n  let base = ([], [0]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1] [1; 0];;\n","type":"","out":""},{"in":"let _ = bigMul [0] []","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet rec padZero l1 l2 =\n  let (len1,len2) = ((List.length l1), (List.length l2)) in\n  if len1 < len2\n  then ((List.rev (List.append (List.rev l1) (clone 0 (len2 - len1)))), l2)\n  else\n    if len2 < len1\n    then (l1, (List.rev (List.append (List.rev l2) (clone 0 (len1 - len2)))))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (old_carry,result) = a in\n      let (add1,add2) = x in\n      let sum = (add1 + add2) + old_carry in\n      let new_carry = sum / 10 in (new_carry, ((sum mod 10) :: result)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec multiply acc i =\n    match i with | 0 -> acc | _ -> multiply (bigAdd acc l) (i - 1) in\n  multiply [0] i;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (zeroes,acc) = a in\n    let multiplied = (mulByDigit x l1) @ zeroes in\n    let sum = bigAdd multiplied acc in\n    match sum with | [] -> ((0 :: zeroes), [0]) | _ -> ((0 :: zeroes), sum) in\n  let base = ([], [0]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [0] [];;\n","type":"","out":""},{"in":"let _ = List.length([])","min":"\nlet _ = List.length [];;\n","type":"","out":""},{"in":"let key = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130 = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ ((Printexc.to_string e) ^ \"\\n\"));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n","type":"","out":""},{"in":"let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","min":"\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n","type":"","out":""},{"in":"let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n\nlet drop_paren s =\n  implode\n    (List.filter (fun c  -> not (List.mem c ['('; ' '; ')'])) (explode s));;\n","type":"","out":""},{"in":"let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","min":"\nlet eq_real p (r1,r2) = ((r1 -. r2) < p) || ((r2 -. r1) < p);;\n","type":"","out":""},{"in":"let wrap_curried_2 f (a,b) = f a b","min":"\nlet wrap_curried_2 f (a,b) = f a b;;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":7899},"type":"eval"},"cursor":0,"time":1.398996474806526e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x * x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = (fun y -> x (a y)) in\n  let base = (fun x -> x) in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a^sep^x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = match l with\n  | [] -> \"[]\"\n  | h::t ->\n      let func a x = a ^ \"; \" ^ (f x) in\n      let base = (f h) in\n        \"[\" ^ (List.fold_left func base t) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper acc rep = match rep with\n    | rep when rep <= 0 \n      -> acc\n    | _ \n      -> helper ((x)::acc) (rep - 1)\n  in\n    helper [] n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\nlet _ = clone clone 4;;\n\n\nlet rec padZero l1 l2 = \n  let (len1, len2) = (List.length(l1), List.length(l2)) in\n    if len1 < len2 then\n      ((List.rev(List.append (List.rev(l1)) (clone 0 (len2-len1)))), l2)\n    else if len2 < len1 then\n      (l1, (List.rev(List.append (List.rev(l2)) (clone 0 (len1-len2)))))\n    else\n      (l1, l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \nlet _ = padZero [1] [2]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | 0::t -> removeZero t\n  | h::t -> l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = let (old_carry, result) = a in\n      let (add1, add2) = x in\n      let sum = add1 + add2 + old_carry in\n      let new_carry = sum/10 in\n        (new_carry, ((sum mod 10)::result))\n    in\n    let base = (0, []) in\n    let args = List.rev(List.combine (0::l1) (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\n\nlet rec mulByDigit i l =\n  let rec multiply acc i = match i with\n    | 0 -> acc\n    | _ -> multiply (bigAdd acc l) (i-1)\n  in\n    multiply [0] i\n\nlet _ = mulByDigit 1 [0]\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 =\n  let f a x = let (zeroes, acc) = a in\n    let multiplied = (mulByDigit x l1) @ zeroes in\n    let sum = bigAdd multiplied acc in\n      match sum with \n        | [] -> (0::zeroes, [0])\n        | _  -> ((0::zeroes), sum) in\n  let base = ([], [0]) in\n  let args = List.rev(l2) in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9]\nlet _ = bigMul [1;0;0;0;0] [1;0;5]\nlet _ = bigAdd ((mulByDigit 1 [1]) @ [0]) [0]\nlet _ = bigMul [1] [1;0]\nlet _ = bigMul [0] []\n\nlet _ = List.length([])\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[],"event":{"region":{"start":0,"stop":0},"type":"eval"},"cursor":0,"time":1.398996484060568e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x * x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = (fun y -> x (a y)) in\n  let base = (fun x -> x) in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a^sep^x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = match l with\n  | [] -> \"[]\"\n  | h::t ->\n      let func a x = a ^ \"; \" ^ (f x) in\n      let base = (f h) in\n        \"[\" ^ (List.fold_left func base t) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper acc rep = match rep with\n    | rep when rep <= 0 \n      -> acc\n    | _ \n      -> helper ((x)::acc) (rep - 1)\n  in\n    helper [] n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\nlet _ = clone clone 4;;\n\n\nlet rec padZero l1 l2 = \n  let (len1, len2) = (List.length(l1), List.length(l2)) in\n    if len1 < len2 then\n      ((List.rev(List.append (List.rev(l1)) (clone 0 (len2-len1)))), l2)\n    else if len2 < len1 then\n      (l1, (List.rev(List.append (List.rev(l2)) (clone 0 (len1-len2)))))\n    else\n      (l1, l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \nlet _ = padZero [1] [2]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | 0::t -> removeZero t\n  | h::t -> l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = let (old_carry, result) = a in\n      let (add1, add2) = x in\n      let sum = add1 + add2 + old_carry in\n      let new_carry = sum/10 in\n        (new_carry, ((sum mod 10)::result))\n    in\n    let base = (0, []) in\n    let args = List.rev(List.combine (0::l1) (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\n\nlet rec mulByDigit i l =\n  let rec multiply acc i = match i with\n    | 0 -> acc\n    | _ -> multiply (bigAdd acc l) (i-1)\n  in\n    multiply [0] i\n\nlet _ = mulByDigit 1 [0]\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 =\n  let f a x = let (zeroes, acc) = a in\n    let multiplied = (mulByDigit x l1) @ zeroes in\n    let sum = bigAdd multiplied acc in\n      match sum with \n        | [] -> (0::zeroes, [0])\n        | _  -> ((0::zeroes), sum) in\n  let base = ([], [0]) in\n  let args = List.rev(l2) in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9]\nlet _ = bigMul [1;0;0;0;0] [1;0;5]\nlet _ = bigAdd ((mulByDigit 1 [1]) @ [0]) [0]\nlet _ = bigMul [1] [1;0]\nlet _ = bigMul [0] []\n\nlet _ = List.length([])\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n","type":"","out":""},{"in":"let _ = sqsum []","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [];;\n","type":"","out":""},{"in":"let _ = sqsum [1;2;3;4]","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sqsum [(-1); (-2); (-3); (-4)]","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [(-1); (-2); (-3); (-4)];;\n","type":"","out":""},{"in":"let pipe fs = \nlet f a x = (fun y -> x (a y)) in\nlet base = (fun x -> x) in\nList.fold_left f base fs","min":"\nlet pipe fs =\n  let f a x y = x (a y) in let base x = x in List.fold_left f base fs;;\n","type":"","out":""},{"in":"let _ = pipe [] 3","min":"\nlet pipe fs =\n  let f a x y = x (a y) in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n","type":"","out":""},{"in":"let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3","min":"\nlet pipe fs =\n  let f a x y = x (a y) in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n","type":"","out":""},{"in":"let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3","min":"\nlet pipe fs =\n  let f a x y = x (a y) in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n","type":"","out":""},{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base = h in\nlet l = t in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n","type":"","out":""},{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"---\" []","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"---\" [];;\n","type":"","out":""},{"in":"let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"\" [\"a\"; \"b\"; \"c\"; \"d\"; \"e\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"X\" [\"hello\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"X\" [\"hello\"];;\n","type":"","out":""},{"in":"let stringOfList f l = match l with\n| [] -> \"[]\"\n| h::t ->\nlet func a x = a ^ \"; \" ^ (f x) in\nlet base = (f h) in\n\"[\" ^ (List.fold_left func base t) ^ \"]\"","min":"\nlet stringOfList f l =\n  match l with\n  | [] -> \"[]\"\n  | h::t ->\n      let func a x = a ^ (\"; \" ^ (f x)) in\n      let base = f h in \"[\" ^ ((List.fold_left func base t) ^ \"]\");;\n","type":"","out":""},{"in":"let _ = stringOfList string_of_int [1;2;3;4;5;6]","min":"\nlet stringOfList f l =\n  match l with\n  | [] -> \"[]\"\n  | h::t ->\n      let func a x = a ^ (\"; \" ^ (f x)) in\n      let base = f h in \"[\" ^ ((List.fold_left func base t) ^ \"]\");;\n\nlet _ = stringOfList string_of_int [1; 2; 3; 4; 5; 6];;\n","type":"","out":""},{"in":"let _ = stringOfList (fun x -> x) [\"foo\"]","min":"\nlet stringOfList f l =\n  match l with\n  | [] -> \"[]\"\n  | h::t ->\n      let func a x = a ^ (\"; \" ^ (f x)) in\n      let base = f h in \"[\" ^ ((List.fold_left func base t) ^ \"]\");;\n\nlet _ = stringOfList (fun x  -> x) [\"foo\"];;\n","type":"","out":""},{"in":"let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]","min":"\nlet stringOfList f l =\n  match l with\n  | [] -> \"[]\"\n  | h::t ->\n      let func a x = a ^ (\"; \" ^ (f x)) in\n      let base = f h in \"[\" ^ ((List.fold_left func base t) ^ \"]\");;\n\nlet _ =\n  stringOfList (stringOfList string_of_int) [[1; 2; 3]; [4; 5]; [6]; []];;\n","type":"","out":""},{"in":"let rec clone x n = \nlet rec helper acc rep = match rep with\n| rep when rep <= 0 \n-> acc\n| _ \n-> helper ((x)::acc) (rep - 1)\nin\nhelper [] n","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n","type":"","out":""},{"in":"let _ = clone 3 5","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet _ = clone 3 5;;\n","type":"","out":""},{"in":"let _ = clone \"foo\" 2","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet _ = clone \"foo\" 2;;\n","type":"","out":""},{"in":"let _ = clone clone (-3)","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet _ = clone clone (-3);;\n","type":"","out":""},{"in":"let _ = clone clone 4","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet _ = clone clone 4;;\n","type":"","out":""},{"in":"let rec padZero l1 l2 = \nlet (len1, len2) = (List.length(l1), List.length(l2)) in\nif len1 < len2 then\n((List.rev(List.append (List.rev(l1)) (clone 0 (len2-len1)))), l2)\nelse if len2 < len1 then\n(l1, (List.rev(List.append (List.rev(l2)) (clone 0 (len1-len2)))))\nelse\n(l1, l2)","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet rec padZero l1 l2 =\n  let (len1,len2) = ((List.length l1), (List.length l2)) in\n  if len1 < len2\n  then ((List.rev (List.append (List.rev l1) (clone 0 (len2 - len1)))), l2)\n  else\n    if len2 < len1\n    then (l1, (List.rev (List.append (List.rev l2) (clone 0 (len1 - len2)))))\n    else (l1, l2);;\n","type":"","out":""},{"in":"let _ = padZero [9;9] [1;0;0;2]","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet rec padZero l1 l2 =\n  let (len1,len2) = ((List.length l1), (List.length l2)) in\n  if len1 < len2\n  then ((List.rev (List.append (List.rev l1) (clone 0 (len2 - len1)))), l2)\n  else\n    if len2 < len1\n    then (l1, (List.rev (List.append (List.rev l2) (clone 0 (len1 - len2)))))\n    else (l1, l2);;\n\nlet _ = padZero [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = padZero [1;0;0;2] [9;9]","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet rec padZero l1 l2 =\n  let (len1,len2) = ((List.length l1), (List.length l2)) in\n  if len1 < len2\n  then ((List.rev (List.append (List.rev l1) (clone 0 (len2 - len1)))), l2)\n  else\n    if len2 < len1\n    then (l1, (List.rev (List.append (List.rev l2) (clone 0 (len1 - len2)))))\n    else (l1, l2);;\n\nlet _ = padZero [1; 0; 0; 2] [9; 9];;\n","type":"","out":""},{"in":"let _ = padZero [1] [2]","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet rec padZero l1 l2 =\n  let (len1,len2) = ((List.length l1), (List.length l2)) in\n  if len1 < len2\n  then ((List.rev (List.append (List.rev l1) (clone 0 (len2 - len1)))), l2)\n  else\n    if len2 < len1\n    then (l1, (List.rev (List.append (List.rev l2) (clone 0 (len1 - len2)))))\n    else (l1, l2);;\n\nlet _ = padZero [1] [2];;\n","type":"","out":""},{"in":"let rec removeZero l = match l with\n| [] -> []\n| 0::t -> removeZero t\n| h::t -> l","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;1;0;0;2]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet _ = removeZero [0; 0; 0; 1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = removeZero [9;9]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet _ = removeZero [9; 9];;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;0]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet _ = removeZero [0; 0; 0; 0];;\n","type":"","out":""},{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (old_carry, result) = a in\nlet (add1, add2) = x in\nlet sum = add1 + add2 + old_carry in\nlet new_carry = sum/10 in\n(new_carry, ((sum mod 10)::result))\nin\nlet base = (0, []) in\nlet args = List.rev(List.combine (0::l1) (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet rec padZero l1 l2 =\n  let (len1,len2) = ((List.length l1), (List.length l2)) in\n  if len1 < len2\n  then ((List.rev (List.append (List.rev l1) (clone 0 (len2 - len1)))), l2)\n  else\n    if len2 < len1\n    then (l1, (List.rev (List.append (List.rev l2) (clone 0 (len1 - len2)))))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (old_carry,result) = a in\n      let (add1,add2) = x in\n      let sum = (add1 + add2) + old_carry in\n      let new_carry = sum / 10 in (new_carry, ((sum mod 10) :: result)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9] [1;0;0;2]","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet rec padZero l1 l2 =\n  let (len1,len2) = ((List.length l1), (List.length l2)) in\n  if len1 < len2\n  then ((List.rev (List.append (List.rev l1) (clone 0 (len2 - len1)))), l2)\n  else\n    if len2 < len1\n    then (l1, (List.rev (List.append (List.rev l2) (clone 0 (len1 - len2)))))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (old_carry,result) = a in\n      let (add1,add2) = x in\n      let sum = (add1 + add2) + old_carry in\n      let new_carry = sum / 10 in (new_carry, ((sum mod 10) :: result)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9;9;9] [9;9;9]","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet rec padZero l1 l2 =\n  let (len1,len2) = ((List.length l1), (List.length l2)) in\n  if len1 < len2\n  then ((List.rev (List.append (List.rev l1) (clone 0 (len2 - len1)))), l2)\n  else\n    if len2 < len1\n    then (l1, (List.rev (List.append (List.rev l2) (clone 0 (len1 - len2)))))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (old_carry,result) = a in\n      let (add1,add2) = x in\n      let sum = (add1 + add2) + old_carry in\n      let new_carry = sum / 10 in (new_carry, ((sum mod 10) :: result)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n","type":"","out":""},{"in":"let rec mulByDigit i l =\nlet rec multiply acc i = match i with\n| 0 -> acc\n| _ -> multiply (bigAdd acc l) (i-1)\nin\nmultiply [0] i","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet rec padZero l1 l2 =\n  let (len1,len2) = ((List.length l1), (List.length l2)) in\n  if len1 < len2\n  then ((List.rev (List.append (List.rev l1) (clone 0 (len2 - len1)))), l2)\n  else\n    if len2 < len1\n    then (l1, (List.rev (List.append (List.rev l2) (clone 0 (len1 - len2)))))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (old_carry,result) = a in\n      let (add1,add2) = x in\n      let sum = (add1 + add2) + old_carry in\n      let new_carry = sum / 10 in (new_carry, ((sum mod 10) :: result)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec multiply acc i =\n    match i with | 0 -> acc | _ -> multiply (bigAdd acc l) (i - 1) in\n  multiply [0] i;;\n","type":"","out":""},{"in":"let _ = mulByDigit 1 [0]","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet rec padZero l1 l2 =\n  let (len1,len2) = ((List.length l1), (List.length l2)) in\n  if len1 < len2\n  then ((List.rev (List.append (List.rev l1) (clone 0 (len2 - len1)))), l2)\n  else\n    if len2 < len1\n    then (l1, (List.rev (List.append (List.rev l2) (clone 0 (len1 - len2)))))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (old_carry,result) = a in\n      let (add1,add2) = x in\n      let sum = (add1 + add2) + old_carry in\n      let new_carry = sum / 10 in (new_carry, ((sum mod 10) :: result)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec multiply acc i =\n    match i with | 0 -> acc | _ -> multiply (bigAdd acc l) (i - 1) in\n  multiply [0] i;;\n\nlet _ = mulByDigit 1 [0];;\n","type":"","out":""},{"in":"let _ = mulByDigit 9 [9;9;9;9]","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet rec padZero l1 l2 =\n  let (len1,len2) = ((List.length l1), (List.length l2)) in\n  if len1 < len2\n  then ((List.rev (List.append (List.rev l1) (clone 0 (len2 - len1)))), l2)\n  else\n    if len2 < len1\n    then (l1, (List.rev (List.append (List.rev l2) (clone 0 (len1 - len2)))))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (old_carry,result) = a in\n      let (add1,add2) = x in\n      let sum = (add1 + add2) + old_carry in\n      let new_carry = sum / 10 in (new_carry, ((sum mod 10) :: result)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec multiply acc i =\n    match i with | 0 -> acc | _ -> multiply (bigAdd acc l) (i - 1) in\n  multiply [0] i;;\n\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let bigMul l1 l2 =\nlet f a x = let (zeroes, acc) = a in\nlet multiplied = (mulByDigit x l1) @ zeroes in\nlet sum = bigAdd multiplied acc in\nmatch sum with \n| [] -> (0::zeroes, [0])\n| _  -> ((0::zeroes), sum) in\nlet base = ([], [0]) in\nlet args = List.rev(l2) in\nlet (_, res) = List.fold_left f base args in\nres","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet rec padZero l1 l2 =\n  let (len1,len2) = ((List.length l1), (List.length l2)) in\n  if len1 < len2\n  then ((List.rev (List.append (List.rev l1) (clone 0 (len2 - len1)))), l2)\n  else\n    if len2 < len1\n    then (l1, (List.rev (List.append (List.rev l2) (clone 0 (len1 - len2)))))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (old_carry,result) = a in\n      let (add1,add2) = x in\n      let sum = (add1 + add2) + old_carry in\n      let new_carry = sum / 10 in (new_carry, ((sum mod 10) :: result)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec multiply acc i =\n    match i with | 0 -> acc | _ -> multiply (bigAdd acc l) (i - 1) in\n  multiply [0] i;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (zeroes,acc) = a in\n    let multiplied = (mulByDigit x l1) @ zeroes in\n    let sum = bigAdd multiplied acc in\n    match sum with | [] -> ((0 :: zeroes), [0]) | _ -> ((0 :: zeroes), sum) in\n  let base = ([], [0]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n","type":"","out":""},{"in":"let _ = bigMul [9;9;9;9] [9;9;9;9]","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet rec padZero l1 l2 =\n  let (len1,len2) = ((List.length l1), (List.length l2)) in\n  if len1 < len2\n  then ((List.rev (List.append (List.rev l1) (clone 0 (len2 - len1)))), l2)\n  else\n    if len2 < len1\n    then (l1, (List.rev (List.append (List.rev l2) (clone 0 (len1 - len2)))))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (old_carry,result) = a in\n      let (add1,add2) = x in\n      let sum = (add1 + add2) + old_carry in\n      let new_carry = sum / 10 in (new_carry, ((sum mod 10) :: result)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec multiply acc i =\n    match i with | 0 -> acc | _ -> multiply (bigAdd acc l) (i - 1) in\n  multiply [0] i;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (zeroes,acc) = a in\n    let multiplied = (mulByDigit x l1) @ zeroes in\n    let sum = bigAdd multiplied acc in\n    match sum with | [] -> ((0 :: zeroes), [0]) | _ -> ((0 :: zeroes), sum) in\n  let base = ([], [0]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet rec padZero l1 l2 =\n  let (len1,len2) = ((List.length l1), (List.length l2)) in\n  if len1 < len2\n  then ((List.rev (List.append (List.rev l1) (clone 0 (len2 - len1)))), l2)\n  else\n    if len2 < len1\n    then (l1, (List.rev (List.append (List.rev l2) (clone 0 (len1 - len2)))))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (old_carry,result) = a in\n      let (add1,add2) = x in\n      let sum = (add1 + add2) + old_carry in\n      let new_carry = sum / 10 in (new_carry, ((sum mod 10) :: result)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec multiply acc i =\n    match i with | 0 -> acc | _ -> multiply (bigAdd acc l) (i - 1) in\n  multiply [0] i;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (zeroes,acc) = a in\n    let multiplied = (mulByDigit x l1) @ zeroes in\n    let sum = bigAdd multiplied acc in\n    match sum with | [] -> ((0 :: zeroes), [0]) | _ -> ((0 :: zeroes), sum) in\n  let base = ([], [0]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9; 9] [9; 9; 9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigMul [1;0;0;0;0] [1;0;5]","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet rec padZero l1 l2 =\n  let (len1,len2) = ((List.length l1), (List.length l2)) in\n  if len1 < len2\n  then ((List.rev (List.append (List.rev l1) (clone 0 (len2 - len1)))), l2)\n  else\n    if len2 < len1\n    then (l1, (List.rev (List.append (List.rev l2) (clone 0 (len1 - len2)))))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (old_carry,result) = a in\n      let (add1,add2) = x in\n      let sum = (add1 + add2) + old_carry in\n      let new_carry = sum / 10 in (new_carry, ((sum mod 10) :: result)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec multiply acc i =\n    match i with | 0 -> acc | _ -> multiply (bigAdd acc l) (i - 1) in\n  multiply [0] i;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (zeroes,acc) = a in\n    let multiplied = (mulByDigit x l1) @ zeroes in\n    let sum = bigAdd multiplied acc in\n    match sum with | [] -> ((0 :: zeroes), [0]) | _ -> ((0 :: zeroes), sum) in\n  let base = ([], [0]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1; 0; 0; 0; 0] [1; 0; 5];;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":3762},"type":"eval"},"cursor":3762,"time":1.399004171730063e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x * x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = (fun y -> x (a y)) in\n  let base = (fun x -> x) in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a^sep^x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = match l with\n  | [] -> \"[]\"\n  | h::t ->\n      let func a x = a ^ \"; \" ^ (f x) in\n      let base = (f h) in\n        \"[\" ^ (List.fold_left func base t) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper acc rep = match rep with\n    | rep when rep <= 0 \n      -> acc\n    | _ \n      -> helper ((x)::acc) (rep - 1)\n  in\n    helper [] n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\nlet _ = clone clone 4;;\n\n\nlet rec padZero l1 l2 = \n  let (len1, len2) = (List.length(l1), List.length(l2)) in\n    if len1 < len2 then\n      ((List.rev(List.append (List.rev(l1)) (clone 0 (len2-len1)))), l2)\n    else if len2 < len1 then\n      (l1, (List.rev(List.append (List.rev(l2)) (clone 0 (len1-len2)))))\n    else\n      (l1, l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \nlet _ = padZero [1] [2]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | 0::t -> removeZero t\n  | h::t -> l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = let (old_carry, result) = a in\n      let (add1, add2) = x in\n      let sum = add1 + add2 + old_carry in\n      let new_carry = sum/10 in\n        (new_carry, ((sum mod 10)::result))\n    in\n    let base = (0, []) in\n    let args = List.rev(List.combine (0::l1) (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\n\nlet rec mulByDigit i l =\n  let rec multiply acc i = match i with\n    | 0 -> acc\n    | _ -> multiply (bigAdd acc l) (i-1)\n  in\n    multiply [0] i\n\nlet _ = mulByDigit 1 [0]\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 =\n  let f a x = let (zeroes, acc) = a in\n    let multiplied = (mulByDigit x l1) @ zeroes in\n    let sum = bigAdd multiplied acc in\n      match sum with \n        | [] -> (0::zeroes, [0])\n        | _  -> ((0::zeroes), sum) in\n  let base = ([], [0]) in\n  let args = List.rev(l2) in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9]\nlet _ = bigMul [1;0;0;0;0] [1;0;5]\nlet _ = bigAdd ((mulByDigit 1 [1]) @ [0]) [0]\nlet _ = bigMul [1] [1;0]\nlet _ = bigMul [0] []\n\nlet _ = List.length([])\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n","type":"","out":""},{"in":"let _ = sqsum []","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [];;\n","type":"","out":""},{"in":"let _ = sqsum [1;2;3;4]","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sqsum [(-1); (-2); (-3); (-4)]","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [(-1); (-2); (-3); (-4)];;\n","type":"","out":""},{"in":"let pipe fs = \nlet f a x = (fun y -> x (a y)) in\nlet base = (fun x -> x) in\nList.fold_left f base fs","min":"\nlet pipe fs =\n  let f a x y = x (a y) in let base x = x in List.fold_left f base fs;;\n","type":"","out":""},{"in":"let _ = pipe [] 3","min":"\nlet pipe fs =\n  let f a x y = x (a y) in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n","type":"","out":""},{"in":"let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3","min":"\nlet pipe fs =\n  let f a x y = x (a y) in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n","type":"","out":""},{"in":"let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3","min":"\nlet pipe fs =\n  let f a x y = x (a y) in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n","type":"","out":""},{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base = h in\nlet l = t in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n","type":"","out":""},{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"---\" []","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"---\" [];;\n","type":"","out":""},{"in":"let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"\" [\"a\"; \"b\"; \"c\"; \"d\"; \"e\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"X\" [\"hello\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"X\" [\"hello\"];;\n","type":"","out":""},{"in":"let stringOfList f l = match l with\n| [] -> \"[]\"\n| h::t ->\nlet func a x = a ^ \"; \" ^ (f x) in\nlet base = (f h) in\n\"[\" ^ (List.fold_left func base t) ^ \"]\"","min":"\nlet stringOfList f l =\n  match l with\n  | [] -> \"[]\"\n  | h::t ->\n      let func a x = a ^ (\"; \" ^ (f x)) in\n      let base = f h in \"[\" ^ ((List.fold_left func base t) ^ \"]\");;\n","type":"","out":""},{"in":"let _ = stringOfList string_of_int [1;2;3;4;5;6]","min":"\nlet stringOfList f l =\n  match l with\n  | [] -> \"[]\"\n  | h::t ->\n      let func a x = a ^ (\"; \" ^ (f x)) in\n      let base = f h in \"[\" ^ ((List.fold_left func base t) ^ \"]\");;\n\nlet _ = stringOfList string_of_int [1; 2; 3; 4; 5; 6];;\n","type":"","out":""},{"in":"let _ = stringOfList (fun x -> x) [\"foo\"]","min":"\nlet stringOfList f l =\n  match l with\n  | [] -> \"[]\"\n  | h::t ->\n      let func a x = a ^ (\"; \" ^ (f x)) in\n      let base = f h in \"[\" ^ ((List.fold_left func base t) ^ \"]\");;\n\nlet _ = stringOfList (fun x  -> x) [\"foo\"];;\n","type":"","out":""},{"in":"let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]","min":"\nlet stringOfList f l =\n  match l with\n  | [] -> \"[]\"\n  | h::t ->\n      let func a x = a ^ (\"; \" ^ (f x)) in\n      let base = f h in \"[\" ^ ((List.fold_left func base t) ^ \"]\");;\n\nlet _ =\n  stringOfList (stringOfList string_of_int) [[1; 2; 3]; [4; 5]; [6]; []];;\n","type":"","out":""},{"in":"let rec clone x n = \nlet rec helper acc rep = match rep with\n| rep when rep <= 0 \n-> acc\n| _ \n-> helper ((x)::acc) (rep - 1)\nin\nhelper [] n","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n","type":"","out":""},{"in":"let _ = clone 3 5","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet _ = clone 3 5;;\n","type":"","out":""},{"in":"let _ = clone \"foo\" 2","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet _ = clone \"foo\" 2;;\n","type":"","out":""},{"in":"let _ = clone clone (-3)","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet _ = clone clone (-3);;\n","type":"","out":""},{"in":"let _ = clone clone 4","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet _ = clone clone 4;;\n","type":"","out":""},{"in":"let rec padZero l1 l2 = \nlet (len1, len2) = (List.length(l1), List.length(l2)) in\nif len1 < len2 then\n((List.rev(List.append (List.rev(l1)) (clone 0 (len2-len1)))), l2)\nelse if len2 < len1 then\n(l1, (List.rev(List.append (List.rev(l2)) (clone 0 (len1-len2)))))\nelse\n(l1, l2)","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet rec padZero l1 l2 =\n  let (len1,len2) = ((List.length l1), (List.length l2)) in\n  if len1 < len2\n  then ((List.rev (List.append (List.rev l1) (clone 0 (len2 - len1)))), l2)\n  else\n    if len2 < len1\n    then (l1, (List.rev (List.append (List.rev l2) (clone 0 (len1 - len2)))))\n    else (l1, l2);;\n","type":"","out":""},{"in":"let _ = padZero [9;9] [1;0;0;2]","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet rec padZero l1 l2 =\n  let (len1,len2) = ((List.length l1), (List.length l2)) in\n  if len1 < len2\n  then ((List.rev (List.append (List.rev l1) (clone 0 (len2 - len1)))), l2)\n  else\n    if len2 < len1\n    then (l1, (List.rev (List.append (List.rev l2) (clone 0 (len1 - len2)))))\n    else (l1, l2);;\n\nlet _ = padZero [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = padZero [1;0;0;2] [9;9]","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet rec padZero l1 l2 =\n  let (len1,len2) = ((List.length l1), (List.length l2)) in\n  if len1 < len2\n  then ((List.rev (List.append (List.rev l1) (clone 0 (len2 - len1)))), l2)\n  else\n    if len2 < len1\n    then (l1, (List.rev (List.append (List.rev l2) (clone 0 (len1 - len2)))))\n    else (l1, l2);;\n\nlet _ = padZero [1; 0; 0; 2] [9; 9];;\n","type":"","out":""},{"in":"let _ = padZero [1] [2]","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet rec padZero l1 l2 =\n  let (len1,len2) = ((List.length l1), (List.length l2)) in\n  if len1 < len2\n  then ((List.rev (List.append (List.rev l1) (clone 0 (len2 - len1)))), l2)\n  else\n    if len2 < len1\n    then (l1, (List.rev (List.append (List.rev l2) (clone 0 (len1 - len2)))))\n    else (l1, l2);;\n\nlet _ = padZero [1] [2];;\n","type":"","out":""},{"in":"let rec removeZero l = match l with\n| [] -> []\n| 0::t -> removeZero t\n| h::t -> l","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;1;0;0;2]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet _ = removeZero [0; 0; 0; 1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = removeZero [9;9]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet _ = removeZero [9; 9];;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;0]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet _ = removeZero [0; 0; 0; 0];;\n","type":"","out":""},{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (old_carry, result) = a in\nlet (add1, add2) = x in\nlet sum = add1 + add2 + old_carry in\nlet new_carry = sum/10 in\n(new_carry, ((sum mod 10)::result))\nin\nlet base = (0, []) in\nlet args = List.rev(List.combine (0::l1) (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet rec padZero l1 l2 =\n  let (len1,len2) = ((List.length l1), (List.length l2)) in\n  if len1 < len2\n  then ((List.rev (List.append (List.rev l1) (clone 0 (len2 - len1)))), l2)\n  else\n    if len2 < len1\n    then (l1, (List.rev (List.append (List.rev l2) (clone 0 (len1 - len2)))))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (old_carry,result) = a in\n      let (add1,add2) = x in\n      let sum = (add1 + add2) + old_carry in\n      let new_carry = sum / 10 in (new_carry, ((sum mod 10) :: result)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9] [1;0;0;2]","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet rec padZero l1 l2 =\n  let (len1,len2) = ((List.length l1), (List.length l2)) in\n  if len1 < len2\n  then ((List.rev (List.append (List.rev l1) (clone 0 (len2 - len1)))), l2)\n  else\n    if len2 < len1\n    then (l1, (List.rev (List.append (List.rev l2) (clone 0 (len1 - len2)))))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (old_carry,result) = a in\n      let (add1,add2) = x in\n      let sum = (add1 + add2) + old_carry in\n      let new_carry = sum / 10 in (new_carry, ((sum mod 10) :: result)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9;9;9] [9;9;9]","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet rec padZero l1 l2 =\n  let (len1,len2) = ((List.length l1), (List.length l2)) in\n  if len1 < len2\n  then ((List.rev (List.append (List.rev l1) (clone 0 (len2 - len1)))), l2)\n  else\n    if len2 < len1\n    then (l1, (List.rev (List.append (List.rev l2) (clone 0 (len1 - len2)))))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (old_carry,result) = a in\n      let (add1,add2) = x in\n      let sum = (add1 + add2) + old_carry in\n      let new_carry = sum / 10 in (new_carry, ((sum mod 10) :: result)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n","type":"","out":""},{"in":"let rec mulByDigit i l =\nlet rec multiply acc i = match i with\n| 0 -> acc\n| _ -> multiply (bigAdd acc l) (i-1)\nin\nmultiply [0] i","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet rec padZero l1 l2 =\n  let (len1,len2) = ((List.length l1), (List.length l2)) in\n  if len1 < len2\n  then ((List.rev (List.append (List.rev l1) (clone 0 (len2 - len1)))), l2)\n  else\n    if len2 < len1\n    then (l1, (List.rev (List.append (List.rev l2) (clone 0 (len1 - len2)))))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (old_carry,result) = a in\n      let (add1,add2) = x in\n      let sum = (add1 + add2) + old_carry in\n      let new_carry = sum / 10 in (new_carry, ((sum mod 10) :: result)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec multiply acc i =\n    match i with | 0 -> acc | _ -> multiply (bigAdd acc l) (i - 1) in\n  multiply [0] i;;\n","type":"","out":""},{"in":"let _ = mulByDigit 1 [0]","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet rec padZero l1 l2 =\n  let (len1,len2) = ((List.length l1), (List.length l2)) in\n  if len1 < len2\n  then ((List.rev (List.append (List.rev l1) (clone 0 (len2 - len1)))), l2)\n  else\n    if len2 < len1\n    then (l1, (List.rev (List.append (List.rev l2) (clone 0 (len1 - len2)))))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (old_carry,result) = a in\n      let (add1,add2) = x in\n      let sum = (add1 + add2) + old_carry in\n      let new_carry = sum / 10 in (new_carry, ((sum mod 10) :: result)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec multiply acc i =\n    match i with | 0 -> acc | _ -> multiply (bigAdd acc l) (i - 1) in\n  multiply [0] i;;\n\nlet _ = mulByDigit 1 [0];;\n","type":"","out":""},{"in":"let _ = mulByDigit 9 [9;9;9;9]","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet rec padZero l1 l2 =\n  let (len1,len2) = ((List.length l1), (List.length l2)) in\n  if len1 < len2\n  then ((List.rev (List.append (List.rev l1) (clone 0 (len2 - len1)))), l2)\n  else\n    if len2 < len1\n    then (l1, (List.rev (List.append (List.rev l2) (clone 0 (len1 - len2)))))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (old_carry,result) = a in\n      let (add1,add2) = x in\n      let sum = (add1 + add2) + old_carry in\n      let new_carry = sum / 10 in (new_carry, ((sum mod 10) :: result)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec multiply acc i =\n    match i with | 0 -> acc | _ -> multiply (bigAdd acc l) (i - 1) in\n  multiply [0] i;;\n\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let bigMul l1 l2 =\nlet f a x = let (zeroes, acc) = a in\nlet multiplied = (mulByDigit x l1) @ zeroes in\nlet sum = bigAdd multiplied acc in\nmatch sum with \n| [] -> (0::zeroes, [0])\n| _  -> ((0::zeroes), sum) in\nlet base = ([], [0]) in\nlet args = List.rev(l2) in\nlet (_, res) = List.fold_left f base args in\nres","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet rec padZero l1 l2 =\n  let (len1,len2) = ((List.length l1), (List.length l2)) in\n  if len1 < len2\n  then ((List.rev (List.append (List.rev l1) (clone 0 (len2 - len1)))), l2)\n  else\n    if len2 < len1\n    then (l1, (List.rev (List.append (List.rev l2) (clone 0 (len1 - len2)))))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (old_carry,result) = a in\n      let (add1,add2) = x in\n      let sum = (add1 + add2) + old_carry in\n      let new_carry = sum / 10 in (new_carry, ((sum mod 10) :: result)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec multiply acc i =\n    match i with | 0 -> acc | _ -> multiply (bigAdd acc l) (i - 1) in\n  multiply [0] i;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (zeroes,acc) = a in\n    let multiplied = (mulByDigit x l1) @ zeroes in\n    let sum = bigAdd multiplied acc in\n    match sum with | [] -> ((0 :: zeroes), [0]) | _ -> ((0 :: zeroes), sum) in\n  let base = ([], [0]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n","type":"","out":""},{"in":"let _ = bigMul [9;9;9;9] [9;9;9;9]","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet rec padZero l1 l2 =\n  let (len1,len2) = ((List.length l1), (List.length l2)) in\n  if len1 < len2\n  then ((List.rev (List.append (List.rev l1) (clone 0 (len2 - len1)))), l2)\n  else\n    if len2 < len1\n    then (l1, (List.rev (List.append (List.rev l2) (clone 0 (len1 - len2)))))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (old_carry,result) = a in\n      let (add1,add2) = x in\n      let sum = (add1 + add2) + old_carry in\n      let new_carry = sum / 10 in (new_carry, ((sum mod 10) :: result)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec multiply acc i =\n    match i with | 0 -> acc | _ -> multiply (bigAdd acc l) (i - 1) in\n  multiply [0] i;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (zeroes,acc) = a in\n    let multiplied = (mulByDigit x l1) @ zeroes in\n    let sum = bigAdd multiplied acc in\n    match sum with | [] -> ((0 :: zeroes), [0]) | _ -> ((0 :: zeroes), sum) in\n  let base = ([], [0]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet rec padZero l1 l2 =\n  let (len1,len2) = ((List.length l1), (List.length l2)) in\n  if len1 < len2\n  then ((List.rev (List.append (List.rev l1) (clone 0 (len2 - len1)))), l2)\n  else\n    if len2 < len1\n    then (l1, (List.rev (List.append (List.rev l2) (clone 0 (len1 - len2)))))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (old_carry,result) = a in\n      let (add1,add2) = x in\n      let sum = (add1 + add2) + old_carry in\n      let new_carry = sum / 10 in (new_carry, ((sum mod 10) :: result)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec multiply acc i =\n    match i with | 0 -> acc | _ -> multiply (bigAdd acc l) (i - 1) in\n  multiply [0] i;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (zeroes,acc) = a in\n    let multiplied = (mulByDigit x l1) @ zeroes in\n    let sum = bigAdd multiplied acc in\n    match sum with | [] -> ((0 :: zeroes), [0]) | _ -> ((0 :: zeroes), sum) in\n  let base = ([], [0]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9; 9] [9; 9; 9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigMul [1;0;0;0;0] [1;0;5]","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet rec padZero l1 l2 =\n  let (len1,len2) = ((List.length l1), (List.length l2)) in\n  if len1 < len2\n  then ((List.rev (List.append (List.rev l1) (clone 0 (len2 - len1)))), l2)\n  else\n    if len2 < len1\n    then (l1, (List.rev (List.append (List.rev l2) (clone 0 (len1 - len2)))))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (old_carry,result) = a in\n      let (add1,add2) = x in\n      let sum = (add1 + add2) + old_carry in\n      let new_carry = sum / 10 in (new_carry, ((sum mod 10) :: result)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec multiply acc i =\n    match i with | 0 -> acc | _ -> multiply (bigAdd acc l) (i - 1) in\n  multiply [0] i;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (zeroes,acc) = a in\n    let multiplied = (mulByDigit x l1) @ zeroes in\n    let sum = bigAdd multiplied acc in\n    match sum with | [] -> ((0 :: zeroes), [0]) | _ -> ((0 :: zeroes), sum) in\n  let base = ([], [0]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1; 0; 0; 0; 0] [1; 0; 5];;\n","type":"","out":""},{"in":"let _ = bigAdd ((mulByDigit 1 [1]) @ [0]) [0]","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet rec padZero l1 l2 =\n  let (len1,len2) = ((List.length l1), (List.length l2)) in\n  if len1 < len2\n  then ((List.rev (List.append (List.rev l1) (clone 0 (len2 - len1)))), l2)\n  else\n    if len2 < len1\n    then (l1, (List.rev (List.append (List.rev l2) (clone 0 (len1 - len2)))))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (old_carry,result) = a in\n      let (add1,add2) = x in\n      let sum = (add1 + add2) + old_carry in\n      let new_carry = sum / 10 in (new_carry, ((sum mod 10) :: result)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec multiply acc i =\n    match i with | 0 -> acc | _ -> multiply (bigAdd acc l) (i - 1) in\n  multiply [0] i;;\n\nlet _ = bigAdd ((mulByDigit 1 [1]) @ [0]) [0];;\n","type":"","out":""},{"in":"let _ = bigMul [1] [1;0]","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet rec padZero l1 l2 =\n  let (len1,len2) = ((List.length l1), (List.length l2)) in\n  if len1 < len2\n  then ((List.rev (List.append (List.rev l1) (clone 0 (len2 - len1)))), l2)\n  else\n    if len2 < len1\n    then (l1, (List.rev (List.append (List.rev l2) (clone 0 (len1 - len2)))))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (old_carry,result) = a in\n      let (add1,add2) = x in\n      let sum = (add1 + add2) + old_carry in\n      let new_carry = sum / 10 in (new_carry, ((sum mod 10) :: result)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec multiply acc i =\n    match i with | 0 -> acc | _ -> multiply (bigAdd acc l) (i - 1) in\n  multiply [0] i;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (zeroes,acc) = a in\n    let multiplied = (mulByDigit x l1) @ zeroes in\n    let sum = bigAdd multiplied acc in\n    match sum with | [] -> ((0 :: zeroes), [0]) | _ -> ((0 :: zeroes), sum) in\n  let base = ([], [0]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1] [1; 0];;\n","type":"","out":""},{"in":"let _ = bigMul [0] []","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet rec padZero l1 l2 =\n  let (len1,len2) = ((List.length l1), (List.length l2)) in\n  if len1 < len2\n  then ((List.rev (List.append (List.rev l1) (clone 0 (len2 - len1)))), l2)\n  else\n    if len2 < len1\n    then (l1, (List.rev (List.append (List.rev l2) (clone 0 (len1 - len2)))))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (old_carry,result) = a in\n      let (add1,add2) = x in\n      let sum = (add1 + add2) + old_carry in\n      let new_carry = sum / 10 in (new_carry, ((sum mod 10) :: result)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec multiply acc i =\n    match i with | 0 -> acc | _ -> multiply (bigAdd acc l) (i - 1) in\n  multiply [0] i;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (zeroes,acc) = a in\n    let multiplied = (mulByDigit x l1) @ zeroes in\n    let sum = bigAdd multiplied acc in\n    match sum with | [] -> ((0 :: zeroes), [0]) | _ -> ((0 :: zeroes), sum) in\n  let base = ([], [0]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [0] [];;\n","type":"","out":""},{"in":"let _ = List.length([])","min":"\nlet _ = List.length [];;\n","type":"","out":""},{"in":"let key = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130 = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ ((Printexc.to_string e) ^ \"\\n\"));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n","type":"","out":""},{"in":"let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","min":"\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n","type":"","out":""},{"in":"let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n\nlet drop_paren s =\n  implode\n    (List.filter (fun c  -> not (List.mem c ['('; ' '; ')'])) (explode s));;\n","type":"","out":""},{"in":"let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","min":"\nlet eq_real p (r1,r2) = ((r1 -. r2) < p) || ((r2 -. r1) < p);;\n","type":"","out":""},{"in":"let wrap_curried_2 f (a,b) = f a b","min":"\nlet wrap_curried_2 f (a,b) = f a b;;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":7899},"type":"eval"},"cursor":3762,"time":1.39900417906313e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x * x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = (fun y -> x (a y)) in\n  let base = (fun x -> x) in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a^sep^x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = match l with\n  | [] -> \"[]\"\n  | h::t ->\n      let func a x = a ^ \"; \" ^ (f x) in\n      let base = (f h) in\n        \"[\" ^ (List.fold_left func base t) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper acc rep = match rep with\n    | rep when rep <= 0 \n      -> acc\n    | _ \n      -> helper ((x)::acc) (rep - 1)\n  in\n    helper [] n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\nlet _ = clone clone 4;;\n\n\nlet rec padZero l1 l2 = \n  let (len1, len2) = (List.length(l1), List.length(l2)) in\n    if len1 < len2 then\n      ((List.rev(List.append (List.rev(l1)) (clone 0 (len2-len1)))), l2)\n    else if len2 < len1 then\n      (l1, (List.rev(List.append (List.rev(l2)) (clone 0 (len1-len2)))))\n    else\n      (l1, l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \nlet _ = padZero [1] [2]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | 0::t -> removeZero t\n  | h::t -> l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = let (old_carry, result) = a in\n      let (add1, add2) = x in\n      let sum = add1 + add2 + old_carry in\n      let new_carry = sum/10 in\n        (new_carry, ((sum mod 10)::result))\n    in\n    let base = (0, []) in\n    let args = List.rev(List.combine (0::l1) (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\n\nlet rec mulByDigit i l =\n  let rec multiply acc i = match i with\n    | 0 -> acc\n    | _ -> multiply (bigAdd acc l) (i-1)\n  in\n    multiply [0] i\n\nlet _ = mulByDigit 1 [0]\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 =\n  let f a x = let (zeroes, acc) = a in\n    let multiplied = (mulByDigit x l1) @ zeroes in\n    let sum = bigAdd multiplied acc in\n      match sum with \n        | [] -> (0::zeroes, [0])\n        | _  -> ((0::zeroes), sum) in\n  let base = ([], [0]) in\n  let args = List.rev(l2) in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9]\nlet _ = bigMul [1;0;0;0;0] [1;0;5]\nlet _ = bigAdd ((mulByDigit 1 [1]) @ [0]) [0]\nlet _ = bigMul [1] [1;0]\nlet _ = bigMul [0] []\n\nlet _ = List.length([])\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n","type":"","out":""},{"in":"let _ = sqsum []","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [];;\n","type":"","out":""},{"in":"let _ = sqsum [1;2;3;4]","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sqsum [(-1); (-2); (-3); (-4)]","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [(-1); (-2); (-3); (-4)];;\n","type":"","out":""},{"in":"let pipe fs = \nlet f a x = (fun y -> x (a y)) in\nlet base = (fun x -> x) in\nList.fold_left f base fs","min":"\nlet pipe fs =\n  let f a x y = x (a y) in let base x = x in List.fold_left f base fs;;\n","type":"","out":""},{"in":"let _ = pipe [] 3","min":"\nlet pipe fs =\n  let f a x y = x (a y) in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n","type":"","out":""},{"in":"let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3","min":"\nlet pipe fs =\n  let f a x y = x (a y) in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n","type":"","out":""},{"in":"let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3","min":"\nlet pipe fs =\n  let f a x y = x (a y) in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n","type":"","out":""},{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base = h in\nlet l = t in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n","type":"","out":""},{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"---\" []","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"---\" [];;\n","type":"","out":""},{"in":"let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"\" [\"a\"; \"b\"; \"c\"; \"d\"; \"e\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"X\" [\"hello\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"X\" [\"hello\"];;\n","type":"","out":""},{"in":"let stringOfList f l = match l with\n| [] -> \"[]\"\n| h::t ->\nlet func a x = a ^ \"; \" ^ (f x) in\nlet base = (f h) in\n\"[\" ^ (List.fold_left func base t) ^ \"]\"","min":"\nlet stringOfList f l =\n  match l with\n  | [] -> \"[]\"\n  | h::t ->\n      let func a x = a ^ (\"; \" ^ (f x)) in\n      let base = f h in \"[\" ^ ((List.fold_left func base t) ^ \"]\");;\n","type":"","out":""},{"in":"let _ = stringOfList string_of_int [1;2;3;4;5;6]","min":"\nlet stringOfList f l =\n  match l with\n  | [] -> \"[]\"\n  | h::t ->\n      let func a x = a ^ (\"; \" ^ (f x)) in\n      let base = f h in \"[\" ^ ((List.fold_left func base t) ^ \"]\");;\n\nlet _ = stringOfList string_of_int [1; 2; 3; 4; 5; 6];;\n","type":"","out":""},{"in":"let _ = stringOfList (fun x -> x) [\"foo\"]","min":"\nlet stringOfList f l =\n  match l with\n  | [] -> \"[]\"\n  | h::t ->\n      let func a x = a ^ (\"; \" ^ (f x)) in\n      let base = f h in \"[\" ^ ((List.fold_left func base t) ^ \"]\");;\n\nlet _ = stringOfList (fun x  -> x) [\"foo\"];;\n","type":"","out":""},{"in":"let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]","min":"\nlet stringOfList f l =\n  match l with\n  | [] -> \"[]\"\n  | h::t ->\n      let func a x = a ^ (\"; \" ^ (f x)) in\n      let base = f h in \"[\" ^ ((List.fold_left func base t) ^ \"]\");;\n\nlet _ =\n  stringOfList (stringOfList string_of_int) [[1; 2; 3]; [4; 5]; [6]; []];;\n","type":"","out":""},{"in":"let rec clone x n = \nlet rec helper acc rep = match rep with\n| rep when rep <= 0 \n-> acc\n| _ \n-> helper ((x)::acc) (rep - 1)\nin\nhelper [] n","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n","type":"","out":""},{"in":"let _ = clone 3 5","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet _ = clone 3 5;;\n","type":"","out":""},{"in":"let _ = clone \"foo\" 2","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet _ = clone \"foo\" 2;;\n","type":"","out":""},{"in":"let _ = clone clone (-3)","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet _ = clone clone (-3);;\n","type":"","out":""},{"in":"let _ = clone clone 4","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet _ = clone clone 4;;\n","type":"","out":""},{"in":"let _ = clone [1;2;3] 2","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet _ = clone [1; 2; 3] 2;;\n","type":"","out":""},{"in":"let rec padZero l1 l2 = \nlet (len1, len2) = (List.length(l1), List.length(l2)) in\nif len1 < len2 then\n((List.rev(List.append (List.rev(l1)) (clone 0 (len2-len1)))), l2)\nelse if len2 < len1 then\n(l1, (List.rev(List.append (List.rev(l2)) (clone 0 (len1-len2)))))\nelse\n(l1, l2)","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet rec padZero l1 l2 =\n  let (len1,len2) = ((List.length l1), (List.length l2)) in\n  if len1 < len2\n  then ((List.rev (List.append (List.rev l1) (clone 0 (len2 - len1)))), l2)\n  else\n    if len2 < len1\n    then (l1, (List.rev (List.append (List.rev l2) (clone 0 (len1 - len2)))))\n    else (l1, l2);;\n","type":"","out":""},{"in":"let _ = padZero [9;9] [1;0;0;2]","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet rec padZero l1 l2 =\n  let (len1,len2) = ((List.length l1), (List.length l2)) in\n  if len1 < len2\n  then ((List.rev (List.append (List.rev l1) (clone 0 (len2 - len1)))), l2)\n  else\n    if len2 < len1\n    then (l1, (List.rev (List.append (List.rev l2) (clone 0 (len1 - len2)))))\n    else (l1, l2);;\n\nlet _ = padZero [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = padZero [1;0;0;2] [9;9]","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet rec padZero l1 l2 =\n  let (len1,len2) = ((List.length l1), (List.length l2)) in\n  if len1 < len2\n  then ((List.rev (List.append (List.rev l1) (clone 0 (len2 - len1)))), l2)\n  else\n    if len2 < len1\n    then (l1, (List.rev (List.append (List.rev l2) (clone 0 (len1 - len2)))))\n    else (l1, l2);;\n\nlet _ = padZero [1; 0; 0; 2] [9; 9];;\n","type":"","out":""},{"in":"let _ = padZero [1] [2]","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet rec padZero l1 l2 =\n  let (len1,len2) = ((List.length l1), (List.length l2)) in\n  if len1 < len2\n  then ((List.rev (List.append (List.rev l1) (clone 0 (len2 - len1)))), l2)\n  else\n    if len2 < len1\n    then (l1, (List.rev (List.append (List.rev l2) (clone 0 (len1 - len2)))))\n    else (l1, l2);;\n\nlet _ = padZero [1] [2];;\n","type":"","out":""},{"in":"let rec removeZero l = match l with\n| [] -> []\n| 0::t -> removeZero t\n| h::t -> l","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;1;0;0;2]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet _ = removeZero [0; 0; 0; 1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = removeZero [9;9]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet _ = removeZero [9; 9];;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;0]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet _ = removeZero [0; 0; 0; 0];;\n","type":"","out":""},{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (old_carry, result) = a in\nlet (add1, add2) = x in\nlet sum = add1 + add2 + old_carry in\nlet new_carry = sum/10 in\n(new_carry, ((sum mod 10)::result))\nin\nlet base = (0, []) in\nlet args = List.rev(List.combine (0::l1) (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet rec padZero l1 l2 =\n  let (len1,len2) = ((List.length l1), (List.length l2)) in\n  if len1 < len2\n  then ((List.rev (List.append (List.rev l1) (clone 0 (len2 - len1)))), l2)\n  else\n    if len2 < len1\n    then (l1, (List.rev (List.append (List.rev l2) (clone 0 (len1 - len2)))))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (old_carry,result) = a in\n      let (add1,add2) = x in\n      let sum = (add1 + add2) + old_carry in\n      let new_carry = sum / 10 in (new_carry, ((sum mod 10) :: result)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9] [1;0;0;2]","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet rec padZero l1 l2 =\n  let (len1,len2) = ((List.length l1), (List.length l2)) in\n  if len1 < len2\n  then ((List.rev (List.append (List.rev l1) (clone 0 (len2 - len1)))), l2)\n  else\n    if len2 < len1\n    then (l1, (List.rev (List.append (List.rev l2) (clone 0 (len1 - len2)))))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (old_carry,result) = a in\n      let (add1,add2) = x in\n      let sum = (add1 + add2) + old_carry in\n      let new_carry = sum / 10 in (new_carry, ((sum mod 10) :: result)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9;9;9] [9;9;9]","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet rec padZero l1 l2 =\n  let (len1,len2) = ((List.length l1), (List.length l2)) in\n  if len1 < len2\n  then ((List.rev (List.append (List.rev l1) (clone 0 (len2 - len1)))), l2)\n  else\n    if len2 < len1\n    then (l1, (List.rev (List.append (List.rev l2) (clone 0 (len1 - len2)))))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (old_carry,result) = a in\n      let (add1,add2) = x in\n      let sum = (add1 + add2) + old_carry in\n      let new_carry = sum / 10 in (new_carry, ((sum mod 10) :: result)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n","type":"","out":""},{"in":"let rec mulByDigit i l =\nlet rec multiply acc i = match i with\n| 0 -> acc\n| _ -> multiply (bigAdd acc l) (i-1)\nin\nmultiply [0] i","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet rec padZero l1 l2 =\n  let (len1,len2) = ((List.length l1), (List.length l2)) in\n  if len1 < len2\n  then ((List.rev (List.append (List.rev l1) (clone 0 (len2 - len1)))), l2)\n  else\n    if len2 < len1\n    then (l1, (List.rev (List.append (List.rev l2) (clone 0 (len1 - len2)))))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (old_carry,result) = a in\n      let (add1,add2) = x in\n      let sum = (add1 + add2) + old_carry in\n      let new_carry = sum / 10 in (new_carry, ((sum mod 10) :: result)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec multiply acc i =\n    match i with | 0 -> acc | _ -> multiply (bigAdd acc l) (i - 1) in\n  multiply [0] i;;\n","type":"","out":""},{"in":"let _ = mulByDigit 1 [1;0]","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet rec padZero l1 l2 =\n  let (len1,len2) = ((List.length l1), (List.length l2)) in\n  if len1 < len2\n  then ((List.rev (List.append (List.rev l1) (clone 0 (len2 - len1)))), l2)\n  else\n    if len2 < len1\n    then (l1, (List.rev (List.append (List.rev l2) (clone 0 (len1 - len2)))))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (old_carry,result) = a in\n      let (add1,add2) = x in\n      let sum = (add1 + add2) + old_carry in\n      let new_carry = sum / 10 in (new_carry, ((sum mod 10) :: result)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec multiply acc i =\n    match i with | 0 -> acc | _ -> multiply (bigAdd acc l) (i - 1) in\n  multiply [0] i;;\n\nlet _ = mulByDigit 1 [1; 0];;\n","type":"","out":""},{"in":"let _ = mulByDigit 9 [9;9;9;9]","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet rec padZero l1 l2 =\n  let (len1,len2) = ((List.length l1), (List.length l2)) in\n  if len1 < len2\n  then ((List.rev (List.append (List.rev l1) (clone 0 (len2 - len1)))), l2)\n  else\n    if len2 < len1\n    then (l1, (List.rev (List.append (List.rev l2) (clone 0 (len1 - len2)))))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (old_carry,result) = a in\n      let (add1,add2) = x in\n      let sum = (add1 + add2) + old_carry in\n      let new_carry = sum / 10 in (new_carry, ((sum mod 10) :: result)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec multiply acc i =\n    match i with | 0 -> acc | _ -> multiply (bigAdd acc l) (i - 1) in\n  multiply [0] i;;\n\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let bigMul l1 l2 =\nlet f a x = let (zeroes, acc) = a in\nlet (number, multiplier) = x in\nlet multiplied = (mulByDigit multiplier number) @ zeroes in\nlet sum = bigAdd multiplied acc in\nmatch sum with \n| [] -> (0::zeroes, [0])\n| _  -> ((0::zeroes), sum) in\nlet base = ([], [0]) in\nlet args = let (len1, len2) = ((List.length l1), (List.length l2)) in\nif len1 > len2 then\nList.rev(List.combine (clone l1 len2) l2)\nelse \nList.rev(List.combine (clone l2 len1) l1)\nin\nlet (_, res) = List.fold_left f base args in\nres","min":"\nlet rec padZero l1 l2 =\n  let (len1,len2) = ((List.length l1), (List.length l2)) in\n  if len1 < len2\n  then ((List.rev (List.append (List.rev l1) (clone 0 (len2 - len1)))), l2)\n  else\n    if len2 < len1\n    then (l1, (List.rev (List.append (List.rev l2) (clone 0 (len1 - len2)))))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (old_carry,result) = a in\n      let (add1,add2) = x in\n      let sum = (add1 + add2) + old_carry in\n      let new_carry = sum / 10 in (new_carry, ((sum mod 10) :: result)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet rec mulByDigit i l =\n  let rec multiply acc i =\n    match i with | 0 -> acc | _ -> multiply (bigAdd acc l) (i - 1) in\n  multiply [0] i;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (zeroes,acc) = a in\n    let (number,multiplier) = x in\n    let multiplied = (mulByDigit multiplier number) @ zeroes in\n    let sum = bigAdd multiplied acc in\n    match sum with | [] -> ((0 :: zeroes), [0]) | _ -> ((0 :: zeroes), sum) in\n  let base = ([], [0]) in\n  let args =\n    let (len1,len2) = ((List.length l1), (List.length l2)) in\n    if len1 > len2\n    then List.rev (List.combine (clone l1 len2) l2)\n    else List.rev (List.combine (clone l2 len1) l1) in\n  let (_,res) = List.fold_left f base args in res;;\n","type":"","out":""},{"in":"let _ = bigMul [9;9;9;9] [9;9;9;9]","min":"\nlet rec padZero l1 l2 =\n  let (len1,len2) = ((List.length l1), (List.length l2)) in\n  if len1 < len2\n  then ((List.rev (List.append (List.rev l1) (clone 0 (len2 - len1)))), l2)\n  else\n    if len2 < len1\n    then (l1, (List.rev (List.append (List.rev l2) (clone 0 (len1 - len2)))))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (old_carry,result) = a in\n      let (add1,add2) = x in\n      let sum = (add1 + add2) + old_carry in\n      let new_carry = sum / 10 in (new_carry, ((sum mod 10) :: result)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet rec mulByDigit i l =\n  let rec multiply acc i =\n    match i with | 0 -> acc | _ -> multiply (bigAdd acc l) (i - 1) in\n  multiply [0] i;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (zeroes,acc) = a in\n    let (number,multiplier) = x in\n    let multiplied = (mulByDigit multiplier number) @ zeroes in\n    let sum = bigAdd multiplied acc in\n    match sum with | [] -> ((0 :: zeroes), [0]) | _ -> ((0 :: zeroes), sum) in\n  let base = ([], [0]) in\n  let args =\n    let (len1,len2) = ((List.length l1), (List.length l2)) in\n    if len1 > len2\n    then List.rev (List.combine (clone l1 len2) l2)\n    else List.rev (List.combine (clone l2 len1) l1) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]","min":"\nlet rec padZero l1 l2 =\n  let (len1,len2) = ((List.length l1), (List.length l2)) in\n  if len1 < len2\n  then ((List.rev (List.append (List.rev l1) (clone 0 (len2 - len1)))), l2)\n  else\n    if len2 < len1\n    then (l1, (List.rev (List.append (List.rev l2) (clone 0 (len1 - len2)))))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (old_carry,result) = a in\n      let (add1,add2) = x in\n      let sum = (add1 + add2) + old_carry in\n      let new_carry = sum / 10 in (new_carry, ((sum mod 10) :: result)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet rec mulByDigit i l =\n  let rec multiply acc i =\n    match i with | 0 -> acc | _ -> multiply (bigAdd acc l) (i - 1) in\n  multiply [0] i;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (zeroes,acc) = a in\n    let (number,multiplier) = x in\n    let multiplied = (mulByDigit multiplier number) @ zeroes in\n    let sum = bigAdd multiplied acc in\n    match sum with | [] -> ((0 :: zeroes), [0]) | _ -> ((0 :: zeroes), sum) in\n  let base = ([], [0]) in\n  let args =\n    let (len1,len2) = ((List.length l1), (List.length l2)) in\n    if len1 > len2\n    then List.rev (List.combine (clone l1 len2) l2)\n    else List.rev (List.combine (clone l2 len1) l1) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9; 9] [9; 9; 9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigMul [1;0;0;0;0] [1;0;5]","min":"\nlet rec padZero l1 l2 =\n  let (len1,len2) = ((List.length l1), (List.length l2)) in\n  if len1 < len2\n  then ((List.rev (List.append (List.rev l1) (clone 0 (len2 - len1)))), l2)\n  else\n    if len2 < len1\n    then (l1, (List.rev (List.append (List.rev l2) (clone 0 (len1 - len2)))))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (old_carry,result) = a in\n      let (add1,add2) = x in\n      let sum = (add1 + add2) + old_carry in\n      let new_carry = sum / 10 in (new_carry, ((sum mod 10) :: result)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet rec mulByDigit i l =\n  let rec multiply acc i =\n    match i with | 0 -> acc | _ -> multiply (bigAdd acc l) (i - 1) in\n  multiply [0] i;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (zeroes,acc) = a in\n    let (number,multiplier) = x in\n    let multiplied = (mulByDigit multiplier number) @ zeroes in\n    let sum = bigAdd multiplied acc in\n    match sum with | [] -> ((0 :: zeroes), [0]) | _ -> ((0 :: zeroes), sum) in\n  let base = ([], [0]) in\n  let args =\n    let (len1,len2) = ((List.length l1), (List.length l2)) in\n    if len1 > len2\n    then List.rev (List.combine (clone l1 len2) l2)\n    else List.rev (List.combine (clone l2 len1) l1) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1; 0; 0; 0; 0] [1; 0; 5];;\n","type":"","out":""},{"in":"let _ = bigAdd ((mulByDigit 1 [1]) @ [0]) [0]","min":"\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet rec padZero l1 l2 =\n  let (len1,len2) = ((List.length l1), (List.length l2)) in\n  if len1 < len2\n  then ((List.rev (List.append (List.rev l1) (clone 0 (len2 - len1)))), l2)\n  else\n    if len2 < len1\n    then (l1, (List.rev (List.append (List.rev l2) (clone 0 (len1 - len2)))))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (old_carry,result) = a in\n      let (add1,add2) = x in\n      let sum = (add1 + add2) + old_carry in\n      let new_carry = sum / 10 in (new_carry, ((sum mod 10) :: result)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec multiply acc i =\n    match i with | 0 -> acc | _ -> multiply (bigAdd acc l) (i - 1) in\n  multiply [0] i;;\n\nlet _ = bigAdd ((mulByDigit 1 [1]) @ [0]) [0];;\n","type":"","out":""},{"in":"let _ = bigMul [1] [1;0]","min":"\nlet rec padZero l1 l2 =\n  let (len1,len2) = ((List.length l1), (List.length l2)) in\n  if len1 < len2\n  then ((List.rev (List.append (List.rev l1) (clone 0 (len2 - len1)))), l2)\n  else\n    if len2 < len1\n    then (l1, (List.rev (List.append (List.rev l2) (clone 0 (len1 - len2)))))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (old_carry,result) = a in\n      let (add1,add2) = x in\n      let sum = (add1 + add2) + old_carry in\n      let new_carry = sum / 10 in (new_carry, ((sum mod 10) :: result)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet rec mulByDigit i l =\n  let rec multiply acc i =\n    match i with | 0 -> acc | _ -> multiply (bigAdd acc l) (i - 1) in\n  multiply [0] i;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (zeroes,acc) = a in\n    let (number,multiplier) = x in\n    let multiplied = (mulByDigit multiplier number) @ zeroes in\n    let sum = bigAdd multiplied acc in\n    match sum with | [] -> ((0 :: zeroes), [0]) | _ -> ((0 :: zeroes), sum) in\n  let base = ([], [0]) in\n  let args =\n    let (len1,len2) = ((List.length l1), (List.length l2)) in\n    if len1 > len2\n    then List.rev (List.combine (clone l1 len2) l2)\n    else List.rev (List.combine (clone l2 len1) l1) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1] [1; 0];;\n","type":"","out":""},{"in":"let _ = bigMul [1;0] [1]","min":"\nlet rec padZero l1 l2 =\n  let (len1,len2) = ((List.length l1), (List.length l2)) in\n  if len1 < len2\n  then ((List.rev (List.append (List.rev l1) (clone 0 (len2 - len1)))), l2)\n  else\n    if len2 < len1\n    then (l1, (List.rev (List.append (List.rev l2) (clone 0 (len1 - len2)))))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (old_carry,result) = a in\n      let (add1,add2) = x in\n      let sum = (add1 + add2) + old_carry in\n      let new_carry = sum / 10 in (new_carry, ((sum mod 10) :: result)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet rec mulByDigit i l =\n  let rec multiply acc i =\n    match i with | 0 -> acc | _ -> multiply (bigAdd acc l) (i - 1) in\n  multiply [0] i;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (zeroes,acc) = a in\n    let (number,multiplier) = x in\n    let multiplied = (mulByDigit multiplier number) @ zeroes in\n    let sum = bigAdd multiplied acc in\n    match sum with | [] -> ((0 :: zeroes), [0]) | _ -> ((0 :: zeroes), sum) in\n  let base = ([], [0]) in\n  let args =\n    let (len1,len2) = ((List.length l1), (List.length l2)) in\n    if len1 > len2\n    then List.rev (List.combine (clone l1 len2) l2)\n    else List.rev (List.combine (clone l2 len1) l1) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1; 0] [1];;\n","type":"","out":""},{"in":"let _ = bigMul [0] []","min":"\nlet rec padZero l1 l2 =\n  let (len1,len2) = ((List.length l1), (List.length l2)) in\n  if len1 < len2\n  then ((List.rev (List.append (List.rev l1) (clone 0 (len2 - len1)))), l2)\n  else\n    if len2 < len1\n    then (l1, (List.rev (List.append (List.rev l2) (clone 0 (len1 - len2)))))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (old_carry,result) = a in\n      let (add1,add2) = x in\n      let sum = (add1 + add2) + old_carry in\n      let new_carry = sum / 10 in (new_carry, ((sum mod 10) :: result)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet rec mulByDigit i l =\n  let rec multiply acc i =\n    match i with | 0 -> acc | _ -> multiply (bigAdd acc l) (i - 1) in\n  multiply [0] i;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (zeroes,acc) = a in\n    let (number,multiplier) = x in\n    let multiplied = (mulByDigit multiplier number) @ zeroes in\n    let sum = bigAdd multiplied acc in\n    match sum with | [] -> ((0 :: zeroes), [0]) | _ -> ((0 :: zeroes), sum) in\n  let base = ([], [0]) in\n  let args =\n    let (len1,len2) = ((List.length l1), (List.length l2)) in\n    if len1 > len2\n    then List.rev (List.combine (clone l1 len2) l2)\n    else List.rev (List.combine (clone l2 len1) l1) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [0] [];;\n","type":"","out":""},{"in":"let _ = bigMul [] [0]","min":"\nlet rec padZero l1 l2 =\n  let (len1,len2) = ((List.length l1), (List.length l2)) in\n  if len1 < len2\n  then ((List.rev (List.append (List.rev l1) (clone 0 (len2 - len1)))), l2)\n  else\n    if len2 < len1\n    then (l1, (List.rev (List.append (List.rev l2) (clone 0 (len1 - len2)))))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (old_carry,result) = a in\n      let (add1,add2) = x in\n      let sum = (add1 + add2) + old_carry in\n      let new_carry = sum / 10 in (new_carry, ((sum mod 10) :: result)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n =\n  let rec helper acc rep =\n    match rep with\n    | rep when rep <= 0 -> acc\n    | _ -> helper (x :: acc) (rep - 1) in\n  helper [] n;;\n\nlet rec mulByDigit i l =\n  let rec multiply acc i =\n    match i with | 0 -> acc | _ -> multiply (bigAdd acc l) (i - 1) in\n  multiply [0] i;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (zeroes,acc) = a in\n    let (number,multiplier) = x in\n    let multiplied = (mulByDigit multiplier number) @ zeroes in\n    let sum = bigAdd multiplied acc in\n    match sum with | [] -> ((0 :: zeroes), [0]) | _ -> ((0 :: zeroes), sum) in\n  let base = ([], [0]) in\n  let args =\n    let (len1,len2) = ((List.length l1), (List.length l2)) in\n    if len1 > len2\n    then List.rev (List.combine (clone l1 len2) l2)\n    else List.rev (List.combine (clone l2 len1) l1) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [] [0];;\n","type":"","out":""},{"in":"let _ = List.length([])","min":"\nlet _ = List.length [];;\n","type":"","out":""},{"in":"let key = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130 = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ ((Printexc.to_string e) ^ \"\\n\"));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n","type":"","out":""},{"in":"let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","min":"\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n","type":"","out":""},{"in":"let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n\nlet drop_paren s =\n  implode\n    (List.filter (fun c  -> not (List.mem c ['('; ' '; ')'])) (explode s));;\n","type":"","out":""},{"in":"let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","min":"\nlet eq_real p (r1,r2) = ((r1 -. r2) < p) || ((r2 -. r1) < p);;\n","type":"","out":""},{"in":"let wrap_curried_2 f (a,b) = f a b","min":"\nlet wrap_curried_2 f (a,b) = f a b;;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":8173},"type":"eval"},"cursor":0,"time":1.399069170613505e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x * x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = (fun y -> x (a y)) in\n  let base = (fun x -> x) in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a^sep^x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = match l with\n  | [] -> \"[]\"\n  | h::t ->\n      let func a x = a ^ \"; \" ^ (f x) in\n      let base = (f h) in\n        \"[\" ^ (List.fold_left func base t) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper acc rep = match rep with\n    | rep when rep <= 0 \n      -> acc\n    | _ \n      -> helper ((x)::acc) (rep - 1)\n  in\n    helper [] n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\nlet _ = clone clone 4;;\nlet _ = clone [1;2;3] 2\n\n\nlet rec padZero l1 l2 = \n  let (len1, len2) = (List.length(l1), List.length(l2)) in\n    if len1 < len2 then\n      ((List.rev(List.append (List.rev(l1)) (clone 0 (len2-len1)))), l2)\n    else if len2 < len1 then\n      (l1, (List.rev(List.append (List.rev(l2)) (clone 0 (len1-len2)))))\n    else\n      (l1, l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \nlet _ = padZero [1] [2]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | 0::t -> removeZero t\n  | h::t -> l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = let (old_carry, result) = a in\n      let (add1, add2) = x in\n      let sum = add1 + add2 + old_carry in\n      let new_carry = sum/10 in\n        (new_carry, ((sum mod 10)::result))\n    in\n    let base = (0, []) in\n    let args = List.rev(List.combine (0::l1) (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\n\nlet rec mulByDigit i l =\n  let rec multiply acc i = match i with\n    | 0 -> acc\n    | _ -> multiply (bigAdd acc l) (i-1)\n  in\n    multiply [0] i\n\nlet _ = mulByDigit 1 [1;0]\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 =\n  let f a x = let (zeroes, acc) = a in\n    let (number, multiplier) = x in\n    let multiplied = (mulByDigit multiplier number) @ zeroes in\n    let sum = bigAdd multiplied acc in\n      match sum with \n        | [] -> (0::zeroes, [0])\n        | _  -> ((0::zeroes), sum) in\n  let base = ([], [0]) in\n  let args = let (len1, len2) = ((List.length l1), (List.length l2)) in\n      if len1 > len2 then\n        List.rev(List.combine (clone l1 len2) l2)\n      else \n        List.rev(List.combine (clone l2 len1) l1)\n  in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9]\nlet _ = bigMul [1;0;0;0;0] [1;0;5]\nlet _ = bigAdd ((mulByDigit 1 [1]) @ [0]) [0]\nlet _ = bigMul [1] [1;0]\nlet _ = bigMul [1;0] [1]\nlet _ = bigMul [0] []\nlet _ = bigMul [] [0]\n\nlet _ = List.length([])\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[],"event":{"region":{"start":0,"stop":0},"type":"eval"},"cursor":0,"time":1.399069177625002e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + (x * x) in\n  let base = 0 in\n    List.fold_left f base xs\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = (fun y -> x (a y)) in\n  let base = (fun x -> x) in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\nlet _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a^sep^x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = match l with\n  | [] -> \"[]\"\n  | h::t ->\n      let func a x = a ^ \"; \" ^ (f x) in\n      let base = (f h) in\n        \"[\" ^ (List.fold_left func base t) ^ \"]\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  let rec helper acc rep = match rep with\n    | rep when rep <= 0 \n      -> acc\n    | _ \n      -> helper ((x)::acc) (rep - 1)\n  in\n    helper [] n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\nlet _ = clone clone 4;;\nlet _ = clone [1;2;3] 2\n\n\nlet rec padZero l1 l2 = \n  let (len1, len2) = (List.length(l1), List.length(l2)) in\n    if len1 < len2 then\n      ((List.rev(List.append (List.rev(l1)) (clone 0 (len2-len1)))), l2)\n    else if len2 < len1 then\n      (l1, (List.rev(List.append (List.rev(l2)) (clone 0 (len1-len2)))))\n    else\n      (l1, l2)\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \nlet _ = padZero [1] [2]\n\n\nlet rec removeZero l = match l with\n  | [] -> []\n  | 0::t -> removeZero t\n  | h::t -> l\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = let (old_carry, result) = a in\n      let (add1, add2) = x in\n      let sum = add1 + add2 + old_carry in\n      let new_carry = sum/10 in\n        (new_carry, ((sum mod 10)::result))\n    in\n    let base = (0, []) in\n    let args = List.rev(List.combine (0::l1) (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];;\n\nlet rec mulByDigit i l =\n  let rec multiply acc i = match i with\n    | 0 -> acc\n    | _ -> multiply (bigAdd acc l) (i-1)\n  in\n    multiply [0] i\n\nlet _ = mulByDigit 1 [1;0]\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 =\n  let f a x = let (zeroes, acc) = a in\n    let (number, multiplier) = x in\n    let multiplied = (mulByDigit multiplier number) @ zeroes in\n    let sum = bigAdd multiplied acc in\n      match sum with \n        | [] -> (0::zeroes, [0])\n        | _  -> ((0::zeroes), sum) in\n  let base = ([], [0]) in\n  let args = let (len1, len2) = ((List.length l1), (List.length l2)) in\n      if len1 > len2 then\n        List.rev(List.combine (clone l1 len2) l2)\n      else \n        List.rev(List.combine (clone l2 len1) l1)\n  in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9]\nlet _ = bigMul [1;0;0;0;0] [1;0;5]\nlet _ = bigAdd ((mulByDigit 1 [1]) @ [0]) [0]\nlet _ = bigMul [1] [1;0]\nlet _ = bigMul [1;0] [1]\nlet _ = bigMul [0] []\nlet _ = bigMul [] [0]\n\nlet _ = List.length([])\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
